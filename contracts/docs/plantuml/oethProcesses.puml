@startuml

skinparam tabSize 2
hide footbox

title "Origin ETH processes"

actor "Anyone" as sender
actor "Block\nBuilder\n(MEV)" as mev
actor "Registrator\n(Relayer)" as reg <<Origin>>
actor "Strategist\n(2/8 Safe)" as strategist <<Origin>>
actor "Governor\n(Timelock)" as gov <<Origin>>
actor "Treasury" as treasury <<Origin>>
participant "API" as api <<P2P>>

box "Execution Chain"
participant "Harvester" as harv <<Origin>>
participant "Vault" as vault <<Origin>>
participant "Native\nStaking\nStrategy" as nativeStrat <<Origin>>
participant "Compounding\nStaking\nStrategy" as compStrat <<Origin>>
participant "SSV Network" as ssvNet <<SSV>>
participant "Token" as ssv <<SSV>>
participant "WETH" as weth <<Wrapped ETH>>
participant "Beacon\nOracle" as bo <<Origin>>
participant "Beacon\nDeposit\nContract" as dep <<System>>
participant "Beacon\nConsolidation\nRequests" as consol <<System>>
participant "Beacon\nWithdrawal\nRequests" as withdraw <<System>>
participant "Beacon\nBlock\nRoots" as roots <<System>>
end box

box "Beacon chain"
participant "Validator" as val <<Beacon>>
end box


group Consolidate validators

reg -> nativeStrat: requestConsolidation(\nsourcePubKeys,\ntargetPubKey,\ntargetStakingStrategy)
activate nativeStrat

loop for each sourcePubKey
    nativeStrat -> consol : sourcePubKey, targetPubKey
    activate consol
    return
    note over nativeStrat: Store source validator state as exiting
end

nativeStrat -> compStrat : requestConsolidation(\nlastSourcePubKeyHash,\ntargetPubKeyHash)
activate compStrat
note over compStrat: pause the strategy
return

note over nativeStrat
store count of consolidated validators
store target starting strategy
pause the strategy
end note

return

... wait 1-10 days for consolidation to be processed on the Beacon Chain ...

reg -> val : getBlockV2(slot)
note left : any slot after the last\nconsolidation request\nwas processed
activate val
return beacon block

reg -> val : getStateV2(slot)
note left : any slot after the last\nconsolidation request\nwas processed
activate val
return beacon state

reg -> reg : generateValidatorPubKeyProof(\nlastValidatorIndex,\nbeacon block,\nbeacon state)
reg -> reg : generateValidatorBalanceProof(\nlastValidatorIndex,\nbeacon block,\nbeacon state)

reg -> compStrat : verifyConsolidation(parentBlockTimestamp,\nlastValidatorIndex,\nvalidatorPubKeyProof,\nbalancesLeaf,\nvalidatorBalanceProof)
activate compStrat

compStrat -> roots : get(parentBlockTimestamp)
note left
timestamp of the block after the block we want to map.
This is because the timestamp will get the parent block root.
end note
activate roots
return parent block root

note over compStrat
verify last validator pubkey to block root
verify last validator balance to block root
assert last validator balance is zero
end note

compStrat -> nativeStrat : confirmConsolidation()
activate nativeStrat
note over nativeStrat
reduce active validators by consolidated validators
reset consolidation state
unpause the strategy
end note
return consolidated validators count
note over compStrat
increase last verified balance by consolidated validators count * 32 ETH
reset consolidation state
unpause the strategy
end note

compStrat -> compStrat : snapBalances()
note left : store WETH and ETH balances
return

end group

group Governor initializes the Staking Strategy

gov -> compStrat : initialize()
activate compStrat
compStrat -> ssv : approve(\nSSV Network,\namount)
activate ssv
note right : Staking Strategy approves\nSSV Network to spend\nSSV tokens
return
return

gov -> ssv : transfer(\nfrom\nto\namount)
activate ssv
note right : transfer SSV tokens\nfrom Governor\nto Staking Strategy
return

end group

group Registrator creates a new SSV validator

reg -> api: POST\neth/staking/ssv/request/create\nuuid,\nvalidatorsCount,\ntype,\nwithdrawalAddress,\nfeeRecipientAddress,\nssvOwnerAddress,\noperationPeriodInDays,\namountPerValidator,\nwithdrawalCredentialsType
activate api
note right
withdrawalAddress is Staking Strategy
feeRecipientAddress is Staking Strategy
ssvOwnerAddress is Staking Strategy
type is with-encrypt-key
ecdhPublicKey public key for encrypting the validator keys
operationPeriodInDays is 0 if not the first validator in the cluster
amountPerValidator 1 ETH in Gwei to limit front-run deposits
withdrawalCredentialsType 0x02 for compounding validators
end note
api -> api: private key
note right : generate a validator private key
api -> api: split(key)
note right : splits validator key into multiple KeyShares
return

reg -> api: GET\neth/staking/ssv/request/status/uuid
activate api
return status,\npubkey\nvalidatorRegistration,\nshareData
note right : validatorRegistration contains the operatorIds and cluster details

reg -> compStrat : registerSsvValidator(\npublicKey,\noperatorIds,\nsharesData,\nssvAmount,\ncluster)
activate compStrat
note right
cluster data:
The number of validators in the cluster
The index of network fees related to this cluster
The last index calculated for the cluster
Flag indicating whether the cluster is active
The SSV balance of the cluster
end note
compStrat -> ssvNet : registerValidator(\npublicKey,\noperatorIds,\nsharesData,\nssvAmount,\ncluster)
activate ssvNet
ssvNet -> ssv : transferFrom(\nfrom\nto\namount)
activate ssv
note right: for the first validator\ntransfer SSV tokens\nfrom NodeDelegator\nto SSV Network
return
return
return

end group

... 20 minutes ...

group Deposit to a new SSV validator

reg -> api: GET\neth/staking/ssv/request/deposit-data/uuid
activate api
return status,\ndepositData
note right : depositData contains the signature and deposit root

reg -> compStrat : stakeEth(\npubkey,\nsignature,\ndeposit root,\namountGwei)
activate compStrat
compStrat -> weth : withdraw(amountGwei * 1 Gwei)
activate weth
note right : WETH burned for ETH
return ETH

compStrat -> dep : deposit(\npubkey,\nwithdrawal_credentials,\nsignature,\ndeposit root)
activate dep
note left
ETH from Staking Strategy is sent to Beacon Deposit.
Withdrawal credential is the Staking Strategy
end note
return

note over compStrat
store deposit pubKeyHash, amountGwei, blockNumber and depositRoot
end note

return

... Beacon chain slot created for the block ...

note over val : Pending deposit added\nBeaconBlock.state.PendingDeposits[index]

... 13 minutes to many days depending on the deposit queue ...

note over val
Validator registered in
BeaconBlock.state.validators[validatorIndex]
Validator balance created in
BeaconBlock.state.balances[balanceIndex]
end note

... four validators are activated each epoch from the Validator Queue (1-10 days) ...

note over val
Validator pending activation
Will activate when another 31 ETH is deposited
end note

end group

group Deposit more to existing validator

reg -> api: POST\neth/staking/direct/increment-request/create\nuuid\npubkeys,amountPerValidator,withdrawalAddress
activate api
note right: amountPerValidator is in Gwei
return 

reg -> api: GET\neth/staking/eth/staking/increment-request/status/uuid
activate api
return status,\ndepositData
note right : depositData contains the signature and deposit root

reg -> compStrat : stakeEth(\npubkey,\nsignature,\ndeposit root,\namountGwei)
activate compStrat
compStrat -> weth : withdraw(\namountGwei * 1 Gwei)
activate weth
note right : WETH burned for ETH
return ETH

compStrat -> dep : deposit(\npubkey,\nwithdrawal_credentials,\nsignature,\ndeposit root)
activate dep
note left
ETH from Staking Strategy is sent to Beacon Deposit.
Withdrawal credential is the Staking Strategy
end note
return

note over compStrat
store deposit pubKeyHash, amountGwei, blockNumber and depositRoot
end note
return

... Beacon chain slot created for the block ...

note over val : Pending deposit added\nBeaconBlock.state.PendingDeposits[index]

... 13 minutes to many days depending on the deposit queue ...

note over val: Validator balance updated\nBeaconBlock.state.balances[balanceIndex]

... end of the epoch ...

note over val: Validator activated if >= 32 ETH

end group

group Verify validator deposit

sender -> val : getBlockV2(slot)
note left : slot the deposit was\ncreated on the execution layer
activate val
return beacon block

sender -> val : getStateV2(slot)
note left : slot the deposit was\ncreated on the execution layer
activate val
return beacon state

sender -> sender : generateSlotProof(\nslot,\nbeacon block)
sender -> sender : generateBlockProof(\nblock number,\nbeacon block,\nbeacon state)

' map block number to slot in Beacon Oracle
sender -> bo : verifySlot(\nnextBlockTimestamp,\nblockNumber,\nslot,\nslot proof,\nblock proof)
activate bo
bo -> roots : get(timestamp)
note left
timestamp of the block after the block we want to map.
This is because the timestamp will get the parent block root.
end note
activate roots
return parent block root
note over bo
verify slot proof to block root
verify block number proof to block root
store map of block to slot
end note
return

sender -> val : getBlockV2(slot)
note left : slot after the deposit was processed
activate val
return beacon block

sender -> val : getStateV2(slot)
note left : slot after the deposit was processed
activate val
return beacon state

sender -> sender : generateValidatorPubKeyProof(\nvalidator index,\nbeacon block,\nbeacon state)
sender -> sender : generateFirstPendingDepositSlotProof(\nbeacon block,\nbeacon state)

sender -> compStrat : verifyDeposit(\ndepositDataRoot,\nparentBlockTimestamp,\nmappedBlockNumber,\nvalidatorIndex,\nfirstPendingDepositSlot,\nvalidatorPubKeyProof,\nfirstPendingDepositSlotProof)
activate compStrat

note over compStrat : deposit needs to be before\nor at the mapped block number

compStrat -> bo : slotToBlock(\nmappedBlockNumber)
note left : map the block number to a slot
activate bo
return slot

note over compStrat : Check the mapped slot is\nbefore the first pending deposit slot

compStrat -> roots : get(timestamp)
note left
timestamp of the block after the block we want to verify.
This is because the timestamp will get the parent block root.
end note
activate roots
return parent block root

note over compStrat
verify the pub key hash saved with the deposit is for the validator index
verify the slot of the first pending deposit is after the deposit was processed
remove the deposit
add validator to active validators if not already
end note

end group

group Update balances

sender -> compStrat : snapBalances()
activate compStrat
compStrat -> roots : get(block timestamp)
activate roots
return parent block root
note over compStrat
store WETH and ETH balances
against the parent block root
store timestamp of snap
end note
return

sender -> val : getBlockV2(slot)
note left : slot of the first pending deposit\nwhen the balance snap was taken
activate val
return beacon block

sender -> val : getStateV2(slot)
note left : slot of the first pending deposit\nwhen the balance snap was taken
activate val
return beacon state

sender -> sender : generateSlotProof(\nfirst pending deposit slot,\nbeacon block)
sender -> sender : generateBlockProof(\nfirst pending deposit block number,\nbeacon block,\nbeacon state)

' map block number to slot in Beacon Oracle
sender -> bo : verifySlot(\nnextBlockTimestamp,\nblockNumber,\nslot,\nslot proof,\nblock proof)
note left : verify slot to block number\nof the first pending deposit\nwhen the balance snap was taken
activate bo
bo -> roots : get(timestamp)
note left
timestamp of the block after the block we want to map.
This is because the timestamp will get the parent block root.
end note
activate roots
return parent block root
note over bo
verify slot proof to block root
verify block number proof to block root
store map of block to slot
end note
return

sender -> val : getBlockV2(slot)
note left : slot before snapBalances was taken
activate val
return beacon block

sender -> val : getStateV2(slot)
note left : slot before snapBalances was taken
activate val
return beacon state

sender -> sender : generateFirstPendingDepositProof(\nbeacon block,\nbeacon state)
note left : proof against beacon block root
sender -> sender : generateValidatorBalanceContainerProof(\nbeacon block,\nbeacon state)
note left : proof against beacon block root
loop active validator indexes
sender -> sender : generateValidatorBalanceProof(\nvalidator index,\nbeacon block,\nbeacon state)
note left: proof against root of\nbeaconBlock.state.balances
end

sender -> compStrat : verifyBalances(\nblockRoot,\nfirstPendingDepositSlot,\nfirstPendingDepositSlotProof,\nbalancesContainerRoot,\nvalidatorContainerProof,\nvalidatorBalanceLeaves[],\validatorBalanceProofs[])
activate compStrat

note over compStrat
    verify the first pending deposit slot proof against the block root
end note

compStrat -> bo : slotToBlock(firstPendingDepositSlot)
activate bo
return block number of the first pending deposit

loop strategy deposits
note over compStrat
Check the first pending deposit block number
is before the block number of the deposit.
add to total deposits
end note
end

note over compStrat
    verify balances container proof against the snapped block root
end note

loop active validator indexes
    note over compStrat
        verify validator balance proof against the balances container root using the validator index
        decode the validator balance from the balance leaf
        total validator balances
    end note
    alt if balance is zero
        note over compStrat
            remove from active validators
        end note
    end
end
note over compStrat
    store strategy balance =
        ETH balance from snap +
        WETH balance from snap +
        total deposits +
        total validator balances
end note

return

end group

group Registrator deposits more SSV to SSV cluster

strategist -> ssv : transfer(\nto\namount)
activate ssv
note right : transfer SSV tokens\nfrom Treasury\nto Staking Strategy
return

group SSV ClusterScanner
reg -> ssvNet : getPastEvents(filter)
activate ssvNet
note right : get all events where the ownerAddress\nis the Staking Strategy
return events

reg -> reg : getCluster(events):\n cluster
note right
cluster data:
  validatorCount
  networkFeeIndex
  index
  active
  balance
end note
end group

strategist -> compStrat : depositSSV(\noperatorIds,\namount,\ncluster)
activate compStrat
compStrat -> ssvNet : deposit(\nclusterOwner,\noperatorIds,\namount,\ncluster)
activate ssvNet
note right
clusterOwner is Staking Strategy
operatorIds are the SSV Operators
amount of SSV tokens
end note
ssvNet -> ssv : transferFrom(\nfrom\nto\namount)
activate ssv
note right: transfer SSV tokens\nfrom Staking Strategy\nto SSV Network
return
return
return
end group

group Consensus Rewards

note over val
attesting to blocks
participating in sync committees
end note
val -> val : ETH

... swept every 8-10 days ...

note over val : partial withdraw of excess ETH\nfrom validator to the Staking Strategy
val -> compStrat : ETH

note over compStrat : Staking Strategy's\nWETH balance does not change

end group

group Registrator full or partial withdraw from validator

reg -> compStrat : validatorWithdrawal(\npublicKey\namount)
activate compStrat
compStrat -> withdraw : publicKey, amount
activate withdraw
return
return

... wait until withdrawal request have been processed.\nmin four epochs (~25 min), currently 1 day but can take a number of days depending on the number of validators in the exit queue ...

note over val
If the remaining balance is less than
32 ETH, the validator is exited
end note
 
val -> compStrat : ETH
note left : transfer withdrawn ETH\nfrom validator\nto Staking Strategy

strategist -> vault : withdrawFromStrategy(\nstrategy,\nasset,\namount)
activate vault
vault -> compStrat : withdraw(\nasset,\namount)
activate compStrat
compStrat -> weth : deposit(amount)
activate weth
note left : convert all ETH to WETH
return
compStrat -> weth : transfer(\nvault,\namount)
activate weth
note left : transfer WETH\nfrom Staking Strategy\nto OETH Vault
return
return
return


reg -> compStrat : snapBalance()
activate compStrat
return

reg -> compStrat : verifyBalances(\nblockRoot,\nfirstPendingDepositSlot,\nfirstPendingDepositSlotProof,\nbalancesContainerRoot,\nvalidatorContainerProof,\nvalidatorBalanceLeaves[],\validatorBalanceProofs[])
activate compStrat
note over compStrat
if validator balance is zero,
remove validator from active validators
and store as exited
end note
return

reg -> compStrat : removeSsvValidator(\npublicKey,\noperatorIds,\ncluster)
activate compStrat
compStrat -> ssvNet : removeValidator(\npublicKey\noperatorIds,\ncluster)
activate ssvNet
note right : stop paying SSV to Operators\n and reduce required SSV collateral
return
return

... wait for the validator to be swept on the Beacon chain\ncurrent time is every 8.5 days ...


end group

group Consensus Rewards

note over val
Consensus layer rewards are
compounded to the validator's balance.
end note

end group

group Execution Rewards

mev -> compStrat : ETH
note right : MEV rewards

sender -> compStrat : ETH
note right : tx priority fees

note over compStrat : Staking Strategy's WETH balance\ndoes not change from either

end group

group Harvester collects ETH rewards

sender -> harv : harvestAndTransfer(\nstrategy)
activate harv
harv -> compStrat : collectRewardTokens()
activate compStrat

compStrat -> weth : deposit(\nexecution rewards)
activate weth
note left : convert ETH rewards to WETH
return

compStrat -> weth : transfer(\nHarvester,\nrewards)
activate weth
note left : transfer rewards as WETH\nfrom Staking Strategy\nto Harvester
return

return

harv -> weth : transfer(\nVault,\nETH rewards)
activate weth
note left : transfer WETH rewards\nfrom Harvester\nto Vault
return

return

end group

' group Strategist pauses Staking Strategy

' strategist -> compStrat : pause()
' activate compStrat
' return

' end group

' group Strategist unpauses Staking Strategy

' strategist -> compStrat : manuallyFixAccounting(0, 0, 0)
' activate compStrat
' note right : params _validatorsDelta, _consensusRewardsDelta\nand _ethToVaultAmount all set to zero
' compStrat -> compStrat
' note right : unpause
' return

' end group

@enduml