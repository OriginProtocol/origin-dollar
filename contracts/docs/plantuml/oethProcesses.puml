@startuml

skinparam tabSize 2
hide footbox

title "Origin ETH processes"

actor "Anyone" as sender
actor "Block\nBuilder\n(MEV)" as mev
actor "Registrator\n(Relayer)" as reg <<Origin>>
actor "Strategist\n(2/8 Safe)" as strategist <<Origin>>
actor "Admin\n(5/8 Safe)" as admin <<Origin>>
actor "Governor\n(Timelock)" as gov <<Origin>>
actor "Treasury" as treasury <<Origin>>
participant "API" as api <<P2P>>

box "Execution Chain"
participant "Vault" as vault <<Origin>>
participant "Consolidation\nController" as consolCtrl <<Origin>>
participant "Native\nStaking\nStrategy" as nativeStrat <<Origin>>
participant "Compounding\nStaking\nStrategy" as compStrat <<Origin>>
participant "SSV Network" as ssvNet <<SSV>>
participant "Token" as ssv <<SSV>>
participant "WETH" as weth <<Wrapped ETH>>
participant "BeaconProofs" as proofs <<Origin>>
participant "Beacon\nDeposit\nContract" as dep <<System>>
participant "Beacon\nConsolidation\nRequests" as consol <<System>>
participant "Beacon\nWithdrawal\nRequests" as withdraw <<System>>
participant "Beacon\nBlock\nRoots" as roots <<System>>
end box

box "Beacon chain"
participant "Validator" as val <<Beacon>>
end box

group Registrator creates a new SSV validator

reg -> api: POST\neth/staking/ssv/request/create\nuuid,\nvalidatorsCount,\ntype,\nwithdrawalAddress,\nfeeRecipientAddress,\nssvOwnerAddress,\noperationPeriodInDays,\namountPerValidator,\nwithdrawalCredentialsType
activate api
note right
withdrawalAddress is Staking Strategy
feeRecipientAddress is Staking Strategy
ssvOwnerAddress is Staking Strategy
type is with-encrypt-key
ecdhPublicKey public key for encrypting the validator keys
operationPeriodInDays is 0 if not the first validator in the cluster
amountPerValidator 32 ETH in Gwei to limit front-run deposits
withdrawalCredentialsType 0x02 for compounding validators
end note
api -> api: private key
note right : generate a validator private key
api -> api: split(key)
note right : splits validator key into multiple KeyShares
return

reg -> api: GET\neth/staking/ssv/request/status/uuid
activate api
return status,\npubkey\nvalidatorRegistration,\nshareData
note right : validatorRegistration contains the operatorIds and cluster details

reg -> compStrat : registerSsvValidator(\npublicKey,\noperatorIds,\nsharesData,\nssvAmount,\ncluster)
activate compStrat
note right
cluster data:
The number of validators in the cluster
The index of network fees related to this cluster
The last index calculated for the cluster
Flag indicating whether the cluster is active
The SSV balance of the cluster
end note
compStrat -> ssvNet : registerValidator(\npublicKey,\noperatorIds,\nsharesData,\nssvAmount,\ncluster)
activate ssvNet
ssvNet -> ssv : transferFrom(\nfrom\nto\namount)
activate ssv
note right: for the first validator\ntransfer SSV tokens\nfrom NodeDelegator\nto SSV Network
return
return
return

end group

... 20 minutes ...

group Deposit to a new SSV validator

reg -> api: GET\neth/staking/ssv/request/deposit-data/uuid
activate api
return status,\ndepositData
note right : depositData contains the signature and deposit root

reg -> compStrat : stakeEth(\npubkey,\nsignature,\ndeposit root,\namountGwei)
activate compStrat
compStrat -> weth : withdraw(amountGwei * 1 Gwei)
activate weth
note right : WETH burned for ETH
return ETH

compStrat -> dep : deposit(\npubkey,\nwithdrawal_credentials,\nsignature,\ndeposit root)
activate dep
note left
32 ETH from Staking Strategy is sent to Beacon Deposit.
Withdrawal credential is the Staking Strategy.
end note
return

note over compStrat
Calculate deposit slot from block timestamp.
Store deposit pubKeyHash, amountGwei, slot and depositRoot.
end note

return

... Beacon chain slot created for the block ...

note over val : Pending deposit added\nBeaconBlock.state.PendingDeposits[index]

... 13 minutes to many days depending on the deposit queue ...

note over val
Validator registered in
BeaconBlock.state.validators[validatorIndex]
Validator balance created in
BeaconBlock.state.balances[balanceIndex]
end note

... four validators are activated each epoch from the Validator Queue (1-10 days) ...

note over val
Validator pending activation
Will activate when another 31 ETH is deposited
end note

end group

group Deposit more to existing validator

reg -> api: POST\neth/staking/direct/increment-request/create\nuuid\npubkeys,amountPerValidator,withdrawalAddress
activate api
note right: amountPerValidator is in Gwei
return 

reg -> api: GET\neth/staking/eth/staking/increment-request/status/uuid
activate api
return status,\ndepositData
note right : depositData contains the signature and deposit root

reg -> compStrat : stakeEth(\npubkey,\nsignature,\ndeposit root,\namountGwei)
activate compStrat
compStrat -> weth : withdraw(\namountGwei * 1 Gwei)
activate weth
note right : WETH burned for ETH
return ETH

compStrat -> dep : deposit(\npubkey,\nwithdrawal_credentials,\nsignature,\ndeposit root)
activate dep
note left
ETH from Staking Strategy is sent to Beacon Deposit.
Withdrawal credential is the Staking Strategy.
end note
return

note over compStrat
Calculate deposit slot from block timestamp.
Store deposit pubKeyHash, amountGwei, slot and depositRoot.
end note
return

... Beacon chain slot created for the block ...

note over val : Pending deposit added\nBeaconBlock.state.PendingDeposits[index]

... 13 minutes to many days depending on the deposit queue ...

note over val: Validator balance updated\nBeaconBlock.state.balances[balanceIndex]

... Start of the epoch ...

note over val: Validator activated if >= 32 ETH

end group

group Verify validator

sender -> val : getBlockV2(slot)
note left : Any slot after the\nvalidator was processed
activate val
return beacon block

sender -> val : getStateV2(slot)
note left : Any slot after the\nvalidator was processed
activate val
return beacon state

sender -> sender : generateValidatorPubKeyProof(\nvalidator index,\nbeacon block,\nbeacon state)

sender -> compStrat : verifyValidator(\nnextBlockTimestamp,\nvalidatorIndex,\npubKeyHash,\nvalidatorPubKeyProof)
activate compStrat

note over compStrat : check the validator is STAKED 

compStrat -> roots : get(nextBlockTimestamp)
note left
Timestamp of any block after the block we want to verify.
This is because the timestamp will get the parent block root.
end note
activate roots
return parent block root

compStrat -> proofs : verifyValidatorPubkey(\n beacon block root,\n pubKeyHash,\n validatorPubKeyProof,\n validatorIndex,\n withdrawalAddress,\n validatorType)
activate proofs
note over proofs
Index BeaconBlock.state.validators[validatorIndex].pubkey
Verify merkle proof of pubKeyHash, strategy address
and validatorType against the beacon block root.
end note
return

note over compStrat
Add the validator to the active validators.
end note

end group

group Verify validator deposit

sender -> val : getBlockV2(deposit processed slot)
note left : Any slot after the deposit was\nprocessed on the beacon chain
activate val
return deposit beacon block

sender -> val : getStateV2(deposit processed slot)
note left : Any slot after the deposit was\nprocessed on the beacon chain
activate val
return deposit beacon state

sender -> val : getBlockV2(first pending validator created slot)
note left : Any slot after the validator of\nthe first pending deposit was created
activate val
return validator beacon block

sender -> val : getStateV2(first pending validator created slot)
note left :Any slot after the validator of\nthe first pending deposit was created
activate val
return validator beacon state

sender -> sender : generateFirstPendingDepositProof(\n deposit beacon block,\n deposit beacon state)
sender -> sender : generateVerifyValidatorWithdrawableProof(\n validator beacon block,\n validator beacon state)
sender -> sender : generateVerifyValidatorWithdrawableProof(\n deposit beacon block,\n deposit beacon state)

sender -> compStrat : verifyDeposit(\n depositID,\n depositProcessedSlot,\n firstDepositValidatorCreatedSlot,\n firstPendingDeposit,\n strategyValidatorData)
activate compStrat
note right
FirstPendingDepositProofData:
  slot
  validatorIndex
  pubKeyHash
  pendingDepositPubKeyProof
  withdrawableEpochProof
  validatorPubKeyProof

StrategyValidatorProofData:
  withdrawableEpoch
  withdrawableEpochProof
end note

note over compStrat
Calculate next block timestamp from the depositProcessedSlot.
end note

compStrat -> roots : get(nextBlockTimestamp)
note left
Timestamp of block after the depositProcessedSlot.
This is because the timestamp will get the parent block root.
end note
activate roots
return beacon block root of the depositProcessedSlot

compStrat -> proofs : verifyFirstPendingDeposit(\n beacon block root,\n firstPendingDepositSlot,\n pubKeyHash,\n firstPendingDepositSlotProof)
activate proofs
alt if empty pending deposit proof
    note over proofs
    verify the first pending deposit is empty
      BeaconBlock.state.PendingDeposits[0]
    end note
else if first pending deposit proof
    note over proofs
    Verify the pubKeyHash of the first pending deposit
      BeaconBlock.state.PendingDeposits[0].pubkey
    Verify the slot of the first pending deposit to
    the third witness of the pubKeyProof
    end note
end
return

alt if pending deposits

    note over compStrat
    Calculate next block timestamp from the firstDepositValidatorCreatedSlot.
    end note
    compStrat -> roots : get(nextBlockTimestamp)
    note left
    Timestamp of block after the firstDepositValidatorCreatedSlot.
    This is because the timestamp will get the parent block root.
    end note
    activate roots
    return beacon block root of the firstDepositValidatorCreatedSlot

    compStrat -> proofs : verifyValidatorWithdrawable(\n beacon block root,\n firstPendingDeposit.validatorIndex,\n firstPendingDeposit.pubKeyHash,\n farFuture,\n firstPendingDeposit.withdrawableEpochProof,\n firstPendingDeposit.validatorPubKeyProof)
    activate proofs

    note over proofs
    Verify the validator's withdrawable epoch to the beacon block root.
      BeaconBlock.state.validators[validatorIndex].withdrawableEpoch
    Verify the validator's public key to the third witness of the withdrawableEpochProof
    end note
    return
end


compStrat -> proofs : verifyValidatorWithdrawable(\n beacon block root,\n strategyValidator.validatorIndex,\n strategyValidator.withdrawableEpoch,\n strategyValidator.withdrawableEpochProof)
activate proofs

note over proofs
Verify the validator's withdrawable epoch to the beacon block root.
    BeaconBlock.state.validators[validatorIndex].withdrawableEpoch
end note
return

alt if strategy validator is exiting
    note over compStrat
    Store the withdrawable epoch on the deposit
    Store the validator as EXITING
    end note
else if strategy validator not exiting
    note over compStrat
    Check stored deposit slot is before the depositProcessedSlot.
    Remove deposit from storage.
    end note
end

return

end group

group Update balances

sender -> compStrat : snapBalances()
activate compStrat
compStrat -> roots : get(block timestamp)
activate roots
return parent block root
note over compStrat
Store ETH balance against the parent block root.
Store block timestamp of snap.
end note
return

sender -> val : getBlockV2(slot)
note left : slot before\nsnapBalances
activate val
return beacon block

sender -> val : getStateV2(slot)
note left : slot before\nsnapBalances
activate val
return beacon state

sender -> sender : generateFirstPendingDepositProof(\n beacon block,\n beacon state)
note right : proof against beacon block root
sender -> sender : generateValidatorBalanceContainerProof(\n beacon block,\n beacon state)
note right : proof against beacon block root
loop active validator indexes
sender -> sender : generateValidatorBalanceProof(\n validator index,\n beacon block,\n beacon state)
note right: proof against root of\nbeaconBlock.state.balances
end

sender -> compStrat : verifyBalances(\n blockRoot,\n firstPendingDepositSlot,\n firstPendingDepositSlotProof,\n balancesContainerRoot,\n validatorContainerProof,\n validatorBalanceLeaves[],\n validatorBalanceProofs[])
activate compStrat

alt if any deposits
    compStrat -> proofs : verifyFirstPendingDepositSlot(\n beacon block root,\n firstPendingDepositSlot,\n firstPendingDepositSlotProof)
    activate proofs
    note over proofs
    Encode slot to little endian padded to 32 bytes.
    Index BeaconBlock.state.PendingDeposits[0].slot
    Verify merkle proof of slot against the beacon block root.
    end note
    return

    loop strategy deposits
    note over compStrat
    Check the first pending deposit slot is before the stored deposit slot.
    Add deposit amount to total deposits.
    end note
    end
end

alt if active validators
    compStrat -> proofs : verifyBalancesContainer(\n beacon block root,\n balancesContainerRoot,\n balancesContainerProof)
    activate proofs
    note over proofs
    Index BeaconBlock.state.balances
    Verify merkle proof of balance container root against the beacon block root.
    end note
    return

    loop active validator indexes

        compStrat -> proofs : verifyValidatorBalance(\n beacon block root,\n balancesContainerRoot,\n balanceProof,\n validatorIndex)
        activate proofs
        note over proofs
        Index is validatorIndex / 4 as there are four balances per leaf.
        Verify validator balance against the balances container root.
        Decode the validator balance from the balance leaf.
        end note
        return balance

        alt if balance is zero
            note over compStrat
                Remove from active validators.
            end note
        end

        note over compStrat
            Add balance to total
        end note
    end
end

note over compStrat
    store strategy balance =
        ETH balance from snap +
        WETH balance +
        total deposits +
        total validator balances
end note

return

end group

group Registrator deposits more SSV to SSV cluster

group SSV ClusterScanner
strategist -> ssvNet : getPastEvents(filter)
activate ssvNet
note right : get all events where the ownerAddress\nis the Staking Strategy
return events

strategist -> strategist : getCluster(events):\n cluster
note right
cluster data:
  validatorCount
  networkFeeIndex
  index
  active
  balance
end note
end group

strategist -> ssvNet : deposit(\nclusterOwner,\noperatorIds,\namount,\ncluster)
activate ssvNet
note right
clusterOwner is Staking Strategy
operatorIds are the SSV Operators
amount of SSV tokens
end note
ssvNet -> ssv : transferFrom(\nfrom\nto\namount)
activate ssv
note right: transfer SSV tokens\nfrom Staking Strategy\nto SSV Network
return
return
end group

group Consensus Rewards

note over val
attesting to blocks
participating in sync committees
end note
val -> val : ETH

... swept every 8-10 days ...

note over val : partial withdraw of excess ETH\nfrom validator to the Staking Strategy
val -> compStrat : ETH

note over compStrat : Staking Strategy's\nWETH balance does not change

end group

group Registrator full or partial withdraw from validator

reg -> compStrat : validatorWithdrawal(\npublicKey\namount)
activate compStrat
note right: zero amount means full withdraw
compStrat -> withdraw : publicKey, amount
activate withdraw
return
return

... wait until withdrawal request have been processed.\nmin four epochs (~25 min), currently many days but can take a number of days depending on the number of validators in the exit queue ...
 
val -> compStrat : ETH
note left : transfer withdrawn ETH\nfrom validator\nto Staking Strategy

strategist -> vault : withdrawFromStrategy(\nstrategy,\nasset,\namount)
activate vault
vault -> compStrat : withdraw(\nasset,\namount)
activate compStrat
compStrat -> weth : deposit(amount)
activate weth
note left : convert all ETH to WETH
return
compStrat -> weth : transfer(\nvault,\namount)
activate weth
note left : transfer WETH\nfrom Staking Strategy\nto OETH Vault
return
return
return


reg -> compStrat : snapBalance()
activate compStrat
return

reg -> compStrat : verifyBalances(\nblockRoot,\nfirstPendingDepositSlot,\nfirstPendingDepositSlotProof,\nbalancesContainerRoot,\nvalidatorContainerProof,\nvalidatorBalanceLeaves[],\validatorBalanceProofs[])
activate compStrat
note over compStrat
if validator balance is zero,
remove validator from active validators
and store as exited
end note
return

reg -> compStrat : removeSsvValidator(\npublicKey,\noperatorIds,\ncluster)
activate compStrat
compStrat -> ssvNet : removeValidator(\npublicKey\noperatorIds,\ncluster)
activate ssvNet
note right : stop paying SSV to Operators\n and reduce required SSV collateral
return
return

... wait for the validator to be swept on the Beacon chain\ncurrent time is every 9.5 days ...

end group


group Admin requests consolidation
admin -> consolCtrl: requestConsolidation(\nsourceStrategy,\nsourcePubKeys,\ntargetPubKey)
activate consolCtrl


consolCtrl -> compStrat : validators(targetPubKeyHash)
activate compStrat
return state

note over consolCtrl
Check target is active.
Check target has no pending deposits.
end note
consolCtrl -> compStrat : depositListLength()
activate compStrat
return number of pending deposits
loop for each pending deposit
consolCtrl -> compStrat : depositList(i)
activate compStrat
return depositHash
consolCtrl -> compStrat : deposits(depositHash)
activate compStrat
return validator pub key hash
end

note over consolCtrl
store count of consolidated validators
store source starting strategy
store timestamp of request
store target pub key hash
end note

consolCtrl -> nativeStrat : requestConsolidation(\n  sourcePubKeys,\n  targetPubKey)
activate nativeStrat

loop for each sourcePubKey
    note over nativeStrat: Check source validator is active
    note over nativeStrat: Store source validator as EXITING
    nativeStrat -> consol : sourcePubKey, targetPubKey
    activate consol
    return
end
return

consolCtrl -> compStrat : snapBalances()
activate compStrat
compStrat -> roots : get(block timestamp)
activate roots
return parent block root
note over compStrat
Store ETH balance against the parent block root
Store block timestamp of snap
end note
return

return
end group

group Anyone verify balance at the start of the consolidation

note over sender
Optional to update compounding staking strategy balance
for the last time until the consolidation has been processed.
end note

sender -> val : getBeaconState(slot)
note left: slot of the request
return beacon state

sender -> sender : generatePendingDepositProofs(\n  beacon state)
sender -> sender : generateBalanceProofs(\n  beacon state)

sender -> consolCtrl : verifyBalances(\n  balances proofs,\n  pending deposit proofs)
activate consolCtrl
consolCtrl -> compStrat : verifyBalances(\n  balances proofs,\n  pending deposit proofs)
activate compStrat
return
return

end group

group Admin fails validator consolidations

admin -> consolCtrl : failConsolidation(\n  sourcePubKeys)
activate consolCtrl

note over consolCtrl
Reduce consolidation count.
Reset consolidation state if count is zero.
end note

consolCtrl -> nativeStrat : failConsolidation(\n  sourcePubKeys)
activate nativeStrat

loop for each source validator
    note over nativeStrat: Restore state to STAKED
end

return

return

end group

... wait 1-10 days for consolidation to be processed on the Beacon Chain ...

group Admin confirms consolidation

sender -> compStrat : snapBalances()
activate compStrat
compStrat -> roots : get(block timestamp)
activate roots
return parent block root
note over compStrat
Store ETH balance against the parent block root
Store block timestamp of snap
end note
return

admin -> val : getBeaconState(slot)
note left : the slot balances were snapped
activate val
return beacon state

admin -> admin : generatePendingDepositProofs(\n  beacon state)
admin -> admin : generateBalanceProofs(\n  beacon state)

admin -> consolCtrl : verifyConsolidation(\n  balances proofs,\n  pending deposit proofs)
activate consolCtrl

note over consolCtrl
reset consolidation state
end note

consolCtrl -> compStrat : verifyBalances(\n  balances proofs,\n  pending deposit proofs)
activate compStrat
note over compStrat
Increase the strategy balance
end note
return

consolCtrl -> nativeStrat : confirmConsolidation(\n  consolidation count)
activate nativeStrat
note over nativeStrat
Decrease the strategy balance
end note
return
return
end group

@enduml