{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/governance/Governable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Base for contracts that are managed by the Origin Protocol's Governor.\n * @dev Copy of the openzeppelin Ownable.sol contract with nomenclature change\n *      from owner to governor and renounce methods removed. Does not use\n *      Context.sol like Ownable.sol does for simplification.\n * @author Origin Protocol Inc\n */\nabstract contract Governable {\n    // Storage position of the owner and pendingOwner of the contract\n    // keccak256(\"OUSD.governor\");\n    bytes32 private constant governorPosition =\n        0x7bea13895fa79d2831e0a9e28edede30099005a50d652d8957cf8a607ee6ca4a;\n\n    // keccak256(\"OUSD.pending.governor\");\n    bytes32 private constant pendingGovernorPosition =\n        0x44c4d30b2eaad5130ad70c3ba6972730566f3e6359ab83e800d905c61b1c51db;\n\n    // keccak256(\"OUSD.reentry.status\");\n    bytes32 private constant reentryStatusPosition =\n        0x53bf423e48ed90e97d02ab0ebab13b2a235a6bfbe9c321847d5c175333ac4535;\n\n    // See OpenZeppelin ReentrancyGuard implementation\n    uint256 constant _NOT_ENTERED = 1;\n    uint256 constant _ENTERED = 2;\n\n    event PendingGovernorshipTransfer(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    event GovernorshipTransferred(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    /**\n     * @notice Returns the address of the current Governor.\n     */\n    function governor() public view returns (address) {\n        return _governor();\n    }\n\n    /**\n     * @dev Returns the address of the current Governor.\n     */\n    function _governor() internal view returns (address governorOut) {\n        bytes32 position = governorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            governorOut := sload(position)\n        }\n    }\n\n    /**\n     * @dev Returns the address of the pending Governor.\n     */\n    function _pendingGovernor()\n        internal\n        view\n        returns (address pendingGovernor)\n    {\n        bytes32 position = pendingGovernorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            pendingGovernor := sload(position)\n        }\n    }\n\n    /**\n     * @dev Throws if called by any account other than the Governor.\n     */\n    modifier onlyGovernor() {\n        require(isGovernor(), \"Caller is not the Governor\");\n        _;\n    }\n\n    /**\n     * @notice Returns true if the caller is the current Governor.\n     */\n    function isGovernor() public view returns (bool) {\n        return msg.sender == _governor();\n    }\n\n    function _setGovernor(address newGovernor) internal {\n        emit GovernorshipTransferred(_governor(), newGovernor);\n\n        bytes32 position = governorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, newGovernor)\n        }\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        bytes32 position = reentryStatusPosition;\n        uint256 _reentry_status;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _reentry_status := sload(position)\n        }\n\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_reentry_status != _ENTERED, \"Reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, _ENTERED)\n        }\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, _NOT_ENTERED)\n        }\n    }\n\n    function _setPendingGovernor(address newGovernor) internal {\n        bytes32 position = pendingGovernorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, newGovernor)\n        }\n    }\n\n    /**\n     * @notice Transfers Governance of the contract to a new account (`newGovernor`).\n     * Can only be called by the current Governor. Must be claimed for this to complete\n     * @param _newGovernor Address of the new Governor\n     */\n    function transferGovernance(address _newGovernor) external onlyGovernor {\n        _setPendingGovernor(_newGovernor);\n        emit PendingGovernorshipTransfer(_governor(), _newGovernor);\n    }\n\n    /**\n     * @notice Claim Governance of the contract to a new account (`newGovernor`).\n     * Can only be called by the new Governor.\n     */\n    function claimGovernance() external {\n        require(\n            msg.sender == _pendingGovernor(),\n            \"Only the pending Governor can complete the claim\"\n        );\n        _changeGovernor(msg.sender);\n    }\n\n    /**\n     * @dev Change Governance of the contract to a new account (`newGovernor`).\n     * @param _newGovernor Address of the new Governor\n     */\n    function _changeGovernor(address _newGovernor) internal {\n        require(_newGovernor != address(0), \"New Governor is address(0)\");\n        _setGovernor(_newGovernor);\n    }\n}\n"
    },
    "contracts/interfaces/poolBooster/IPoolBoostCentralRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPoolBoostCentralRegistry {\n    /**\n     * @dev all the supported pool booster types are listed here. It is possible\n     *      to have multiple versions of the factory that supports the same type of\n     *      pool booster. Factories are immutable and this can happen when a factory\n     *      or related pool booster required code update.\n     *      e.g. \"PoolBoosterSwapxDouble\" & \"PoolBoosterSwapxDouble_v2\"\n     */\n    enum PoolBoosterType {\n        // Supports bribing 2 contracts per pool. Appropriate for Ichi vault concentrated\n        // liquidity pools where (which is expected in most/all cases) both pool gauges\n        // require bribing.\n        SwapXDoubleBooster,\n        // Supports bribing a single contract per pool. Appropriate for Classic Stable &\n        // Classic Volatile pools and Ichi vaults where only 1 side (1 of the 2 gauges)\n        // needs bribing\n        SwapXSingleBooster,\n        // Supports bribing a single contract per pool. Appropriate for Metropolis pools\n        MetropolisBooster\n    }\n\n    struct PoolBoosterEntry {\n        address boosterAddress;\n        address ammPoolAddress;\n        PoolBoosterType boosterType;\n    }\n\n    event PoolBoosterCreated(\n        address poolBoosterAddress,\n        address ammPoolAddress,\n        PoolBoosterType poolBoosterType,\n        address factoryAddress\n    );\n    event PoolBoosterRemoved(address poolBoosterAddress);\n\n    function emitPoolBoosterCreated(\n        address _poolBoosterAddress,\n        address _ammPoolAddress,\n        PoolBoosterType _boosterType\n    ) external;\n\n    function emitPoolBoosterRemoved(address _poolBoosterAddress) external;\n}\n"
    },
    "contracts/interfaces/poolBooster/IPoolBooster.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPoolBooster {\n    event BribeExecuted(uint256 amount);\n\n    /// @notice Execute the bribe action\n    function bribe() external;\n}\n"
    },
    "contracts/interfaces/poolBooster/ISwapXAlgebraBribe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBribe {\n    /// @notice Notify a bribe amount\n    /// @dev    Rewards are saved into NEXT EPOCH mapping.\n    function notifyRewardAmount(address _rewardsToken, uint256 reward) external;\n}\n"
    },
    "contracts/poolBooster/AbstractPoolBoosterFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Governable } from \"../governance/Governable.sol\";\nimport { IPoolBooster } from \"../interfaces/poolBooster/IPoolBooster.sol\";\nimport { IPoolBoostCentralRegistry } from \"../interfaces/poolBooster/IPoolBoostCentralRegistry.sol\";\n\n/**\n * @title Abstract Pool booster factory\n * @author Origin Protocol Inc\n */\ncontract AbstractPoolBoosterFactory is Governable {\n    struct PoolBoosterEntry {\n        address boosterAddress;\n        address ammPoolAddress;\n        IPoolBoostCentralRegistry.PoolBoosterType boosterType;\n    }\n\n    // @notice address of Origin Sonic\n    address public immutable oSonic;\n    // @notice Central registry contract\n    IPoolBoostCentralRegistry public immutable centralRegistry;\n\n    // @notice list of all the pool boosters created by this factory\n    PoolBoosterEntry[] public poolBoosters;\n    // @notice mapping of AMM pool to pool booster\n    mapping(address => PoolBoosterEntry) public poolBoosterFromPool;\n\n    // @param address _oSonic address of the OSonic token\n    // @param address _governor address governor\n    // @param address _centralRegistry address of the central registry\n    constructor(\n        address _oSonic,\n        address _governor,\n        address _centralRegistry\n    ) {\n        require(_oSonic != address(0), \"Invalid oSonic address\");\n        require(_governor != address(0), \"Invalid governor address\");\n        require(\n            _centralRegistry != address(0),\n            \"Invalid central registry address\"\n        );\n\n        oSonic = _oSonic;\n        centralRegistry = IPoolBoostCentralRegistry(_centralRegistry);\n        _setGovernor(_governor);\n    }\n\n    /**\n     * @notice Goes over all the pool boosters created by this factory and\n     *         calls bribe() on them.\n     * @param _exclusionList A list of pool booster addresses to skip when\n     *        calling this function.\n     */\n    function bribeAll(address[] memory _exclusionList) external {\n        uint256 lengthI = poolBoosters.length;\n        for (uint256 i = 0; i < lengthI; i++) {\n            address poolBoosterAddress = poolBoosters[i].boosterAddress;\n            bool skipBribeCall = false;\n            uint256 lengthJ = _exclusionList.length;\n            for (uint256 j = 0; j < lengthJ; j++) {\n                // pool booster in exclusion list\n                if (_exclusionList[j] == poolBoosterAddress) {\n                    skipBribeCall = true;\n                    break;\n                }\n            }\n\n            if (!skipBribeCall) {\n                IPoolBooster(poolBoosterAddress).bribe();\n            }\n        }\n    }\n\n    /**\n     * @notice Removes the pool booster from the internal list of pool boosters.\n     * @dev This action does not destroy the pool booster contract nor does it\n     *      stop the yield delegation to it.\n     * @param _poolBoosterAddress address of the pool booster\n     */\n    function removePoolBooster(address _poolBoosterAddress)\n        external\n        onlyGovernor\n    {\n        uint256 boostersLen = poolBoosters.length;\n        for (uint256 i = 0; i < boostersLen; ++i) {\n            if (poolBoosters[i].boosterAddress == _poolBoosterAddress) {\n                // erase mapping\n                delete poolBoosterFromPool[poolBoosters[i].ammPoolAddress];\n\n                // overwrite current pool booster with the last entry in the list\n                poolBoosters[i] = poolBoosters[boostersLen - 1];\n                // drop the last entry\n                poolBoosters.pop();\n\n                centralRegistry.emitPoolBoosterRemoved(_poolBoosterAddress);\n                break;\n            }\n        }\n    }\n\n    function _storePoolBoosterEntry(\n        address _poolBoosterAddress,\n        address _ammPoolAddress,\n        IPoolBoostCentralRegistry.PoolBoosterType _boosterType\n    ) internal {\n        PoolBoosterEntry memory entry = PoolBoosterEntry(\n            _poolBoosterAddress,\n            _ammPoolAddress,\n            _boosterType\n        );\n\n        poolBoosters.push(entry);\n        poolBoosterFromPool[_ammPoolAddress] = entry;\n\n        // emit the events of the pool booster created\n        centralRegistry.emitPoolBoosterCreated(\n            _poolBoosterAddress,\n            _ammPoolAddress,\n            _boosterType\n        );\n    }\n\n    function _deployContract(bytes memory _bytecode, uint256 _salt)\n        internal\n        returns (address _address)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _address := create2(\n                0,\n                add(_bytecode, 0x20),\n                mload(_bytecode),\n                _salt\n            )\n        }\n\n        require(\n            _address.code.length > 0 && _address != address(0),\n            \"Failed creating a pool booster\"\n        );\n    }\n\n    // pre-compute the address of the deployed contract that will be\n    // created when create2 is called\n    function _computeAddress(bytes memory _bytecode, uint256 _salt)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                _salt,\n                keccak256(_bytecode)\n            )\n        );\n\n        // cast last 20 bytes of hash to address\n        return address(uint160(uint256(hash)));\n    }\n\n    function poolBoosterLength() external view returns (uint256) {\n        return poolBoosters.length;\n    }\n}\n"
    },
    "contracts/poolBooster/PoolBoostCentralRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Governable } from \"../governance/Governable.sol\";\nimport { IPoolBoostCentralRegistry } from \"../interfaces/poolBooster/IPoolBoostCentralRegistry.sol\";\n\n/**\n * @title Contract that holds all governance approved pool booster Factory\n *        implementation deployments\n * @author Origin Protocol Inc\n */\ncontract PoolBoostCentralRegistry is Governable, IPoolBoostCentralRegistry {\n    event FactoryApproved(address factoryAddress);\n    event FactoryRemoved(address factoryAddress);\n\n    // @notice List of approved factories\n    address[] public factories;\n\n    modifier onlyApprovedFactories() {\n        require(isApprovedFactory(msg.sender), \"Not an approved factory\");\n        _;\n    }\n\n    constructor() {\n        // set the governor of the implementation contract to zero address\n        _setGovernor(address(0));\n    }\n\n    /**\n     * @notice Adds a factory address to the approved factory addresses\n     * @param _factoryAddress address of the factory\n     */\n    function approveFactory(address _factoryAddress) external onlyGovernor {\n        require(_factoryAddress != address(0), \"Invalid address\");\n        require(\n            !isApprovedFactory(_factoryAddress),\n            \"Factory already approved\"\n        );\n\n        factories.push(_factoryAddress);\n        emit FactoryApproved(_factoryAddress);\n    }\n\n    /**\n     * @notice Removes the factory from approved factory addresses\n     * @param _factoryAddress address of the factory\n     */\n    function removeFactory(address _factoryAddress) external onlyGovernor {\n        require(_factoryAddress != address(0), \"Invalid address\");\n\n        uint256 length = factories.length;\n        bool factoryRemoved = false;\n        for (uint256 i = 0; i < length; i++) {\n            if (factories[i] != _factoryAddress) {\n                continue;\n            }\n\n            factories[i] = factories[length - 1];\n            factories.pop();\n            emit FactoryRemoved(_factoryAddress);\n            factoryRemoved = true;\n            break;\n        }\n        require(factoryRemoved, \"Not an approved factory\");\n\n        emit FactoryRemoved(_factoryAddress);\n    }\n\n    /**\n     * @notice Emits a pool booster created event\n     * @dev    This has been created as a convenience method for the monitoring to have\n     *         an index of all of the created pool boosters by only listening to the\n     *         events of this contract.\n     * @param _poolBoosterAddress address of the pool booster created\n     * @param _ammPoolAddress address of the AMM pool forwarding yield to the pool booster\n     * @param _boosterType PoolBoosterType the type of the pool booster\n     */\n    function emitPoolBoosterCreated(\n        address _poolBoosterAddress,\n        address _ammPoolAddress,\n        PoolBoosterType _boosterType\n    ) external onlyApprovedFactories {\n        emit PoolBoosterCreated(\n            _poolBoosterAddress,\n            _ammPoolAddress,\n            _boosterType,\n            msg.sender // address of the factory\n        );\n    }\n\n    /**\n     * @notice Emits a pool booster removed event\n     * @dev    This has been created as a convenience method for the monitoring to have\n     *         an index of all of the removed pool boosters by only listening to the\n     *         events of this contract.\n     * @param _poolBoosterAddress address of the pool booster to be removed\n     */\n    function emitPoolBoosterRemoved(address _poolBoosterAddress)\n        external\n        onlyApprovedFactories\n    {\n        emit PoolBoosterRemoved(_poolBoosterAddress);\n    }\n\n    /**\n     * @notice Returns true if the factory is approved\n     * @param _factoryAddress address of the factory\n     */\n    function isApprovedFactory(address _factoryAddress)\n        public\n        view\n        returns (bool)\n    {\n        uint256 length = factories.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (factories[i] == _factoryAddress) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice Returns all supported factories\n     */\n    function getAllFactories() external view returns (address[] memory) {\n        return factories;\n    }\n}\n"
    },
    "contracts/poolBooster/PoolBoosterFactoryMetropolis.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { PoolBoosterMetropolis } from \"./PoolBoosterMetropolis.sol\";\nimport { AbstractPoolBoosterFactory, IPoolBoostCentralRegistry } from \"./AbstractPoolBoosterFactory.sol\";\n\n/**\n * @title Pool booster factory for creating Metropolis pool boosters.\n * @author Origin Protocol Inc\n */\ncontract PoolBoosterFactoryMetropolis is AbstractPoolBoosterFactory {\n    uint256 public constant version = 1;\n    address public immutable rewardFactory;\n    address public immutable voter;\n\n    // @param address _oSonic address of the OSonic token\n    // @param address _governor address governor\n    // @param address _centralRegistry address of the central registry\n    // @param address _rewardFactory address of the Metropolis reward factory\n    // @param address _voter address of the Metropolis voter\n    constructor(\n        address _oSonic,\n        address _governor,\n        address _centralRegistry,\n        address _rewardFactory,\n        address _voter\n    ) AbstractPoolBoosterFactory(_oSonic, _governor, _centralRegistry) {\n        rewardFactory = _rewardFactory;\n        voter = _voter;\n    }\n\n    /**\n     * @dev Create a Pool Booster for Metropolis pool.\n     * @param _ammPoolAddress address of the AMM pool where the yield originates from\n     * @param _salt A unique number that affects the address of the pool booster created. Note: this number\n     *        should match the one from `computePoolBoosterAddress` in order for the final deployed address\n     *        and pre-computed address to match\n     */\n    function createPoolBoosterMetropolis(address _ammPoolAddress, uint256 _salt)\n        external\n        onlyGovernor\n    {\n        require(\n            _ammPoolAddress != address(0),\n            \"Invalid ammPoolAddress address\"\n        );\n        require(_salt > 0, \"Invalid salt\");\n\n        address poolBoosterAddress = _deployContract(\n            abi.encodePacked(\n                type(PoolBoosterMetropolis).creationCode,\n                abi.encode(oSonic, rewardFactory, _ammPoolAddress, voter)\n            ),\n            _salt\n        );\n\n        _storePoolBoosterEntry(\n            poolBoosterAddress,\n            _ammPoolAddress,\n            IPoolBoostCentralRegistry.PoolBoosterType.MetropolisBooster\n        );\n    }\n\n    /**\n     * @dev Create a Pool Booster for Metropolis pool.\n     * @param _ammPoolAddress address of the AMM pool where the yield originates from\n     * @param _salt A unique number that affects the address of the pool booster created. Note: this number\n     *        should match the one from `createPoolBoosterMetropolis` in order for the final deployed address\n     *        and pre-computed address to match\n     */\n    function computePoolBoosterAddress(address _ammPoolAddress, uint256 _salt)\n        external\n        view\n        returns (address)\n    {\n        require(\n            _ammPoolAddress != address(0),\n            \"Invalid ammPoolAddress address\"\n        );\n        require(_salt > 0, \"Invalid salt\");\n\n        return\n            _computeAddress(\n                abi.encodePacked(\n                    type(PoolBoosterMetropolis).creationCode,\n                    abi.encode(oSonic, rewardFactory, _ammPoolAddress, voter)\n                ),\n                _salt\n            );\n    }\n}\n"
    },
    "contracts/poolBooster/PoolBoosterFactorySwapxDouble.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { PoolBoosterSwapxDouble } from \"./PoolBoosterSwapxDouble.sol\";\nimport { AbstractPoolBoosterFactory, IPoolBoostCentralRegistry } from \"./AbstractPoolBoosterFactory.sol\";\n\n/**\n * @title Pool booster factory for creating Swapx Ichi pool boosters where both of the\n *        gauges need incentivizing.\n * @author Origin Protocol Inc\n */\ncontract PoolBoosterFactorySwapxDouble is AbstractPoolBoosterFactory {\n    uint256 public constant version = 1;\n\n    // @param address _oSonic address of the OSonic token\n    // @param address _governor address governor\n    // @param address _centralRegistry address of the central registry\n    constructor(\n        address _oSonic,\n        address _governor,\n        address _centralRegistry\n    ) AbstractPoolBoosterFactory(_oSonic, _governor, _centralRegistry) {}\n\n    /**\n     * @dev Create a Pool Booster for SwapX Ichi vault based pool where 2 Bribe contracts need to be\n     *      bribed\n     * @param _bribeAddressOS address of the Bribes.sol(Bribe) contract for the OS token side\n     * @param _bribeAddressOther address of the Bribes.sol(Bribe) contract for the other token in the pool\n     * @param _ammPoolAddress address of the AMM pool where the yield originates from\n     * @param _split 1e18 denominated split between OS and Other bribe. E.g. 0.4e17 means 40% to OS\n     *        bribe contract and 60% to other bribe contract\n     * @param _salt A unique number that affects the address of the pool booster created. Note: this number\n     *        should match the one from `computePoolBoosterAddress` in order for the final deployed address\n     *        and pre-computed address to match\n     */\n    function createPoolBoosterSwapxDouble(\n        address _bribeAddressOS,\n        address _bribeAddressOther,\n        address _ammPoolAddress,\n        uint256 _split,\n        uint256 _salt\n    ) external onlyGovernor {\n        require(\n            _ammPoolAddress != address(0),\n            \"Invalid ammPoolAddress address\"\n        );\n        require(_salt > 0, \"Invalid salt\");\n\n        address poolBoosterAddress = _deployContract(\n            abi.encodePacked(\n                type(PoolBoosterSwapxDouble).creationCode,\n                abi.encode(_bribeAddressOS, _bribeAddressOther, oSonic, _split)\n            ),\n            _salt\n        );\n\n        _storePoolBoosterEntry(\n            poolBoosterAddress,\n            _ammPoolAddress,\n            IPoolBoostCentralRegistry.PoolBoosterType.SwapXDoubleBooster\n        );\n    }\n\n    /**\n     * @dev Compute the address of the pool booster to be deployed.\n     * @param _bribeAddressOS address of the Bribes.sol(Bribe) contract for the OS token side\n     * @param _bribeAddressOther address of the Bribes.sol(Bribe) contract for the other token in the pool\n     * @param _ammPoolAddress address of the AMM pool where the yield originates from\n     * @param _split 1e18 denominated split between OS and Other bribe. E.g. 0.4e17 means 40% to OS\n     *        bribe contract and 60% to other bribe contract\n     * @param _salt A unique number that affects the address of the pool booster created. Note: this number\n     *        should match the one from `createPoolBoosterSwapxDouble` in order for the final deployed address\n     *        and pre-computed address to match\n     */\n    function computePoolBoosterAddress(\n        address _bribeAddressOS,\n        address _bribeAddressOther,\n        address _ammPoolAddress,\n        uint256 _split,\n        uint256 _salt\n    ) external view returns (address) {\n        require(\n            _ammPoolAddress != address(0),\n            \"Invalid ammPoolAddress address\"\n        );\n        require(_salt > 0, \"Invalid salt\");\n\n        return\n            _computeAddress(\n                abi.encodePacked(\n                    type(PoolBoosterSwapxDouble).creationCode,\n                    abi.encode(\n                        _bribeAddressOS,\n                        _bribeAddressOther,\n                        oSonic,\n                        _split\n                    )\n                ),\n                _salt\n            );\n    }\n}\n"
    },
    "contracts/poolBooster/PoolBoosterFactorySwapxSingle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { PoolBoosterSwapxSingle } from \"./PoolBoosterSwapxSingle.sol\";\nimport { AbstractPoolBoosterFactory, IPoolBoostCentralRegistry } from \"./AbstractPoolBoosterFactory.sol\";\n\n/**\n * @title Pool booster factory for creating Swapx Single pool boosters - where a single\n *        gauge is created for a pool. this is appropriate for Classic Stable & Classic\n *        Volatile SwapX pools.\n * @author Origin Protocol Inc\n */\ncontract PoolBoosterFactorySwapxSingle is AbstractPoolBoosterFactory {\n    uint256 public constant version = 1;\n\n    // @param address _oSonic address of the OSonic token\n    // @param address _governor address governor\n    // @param address _centralRegistry address of the central registry\n    constructor(\n        address _oSonic,\n        address _governor,\n        address _centralRegistry\n    ) AbstractPoolBoosterFactory(_oSonic, _governor, _centralRegistry) {}\n\n    /**\n     * @dev Create a Pool Booster for SwapX classic volatile or classic stable pools where\n     *      a single Bribe contract is incentivized.\n     * @param _bribeAddress address of the Bribes.sol contract\n     * @param _ammPoolAddress address of the AMM pool where the yield originates from\n     * @param _salt A unique number that affects the address of the pool booster created. Note: this number\n     *        should match the one from `computePoolBoosterAddress` in order for the final deployed address\n     *        and pre-computed address to match\n     */\n    function createPoolBoosterSwapxSingle(\n        address _bribeAddress,\n        address _ammPoolAddress,\n        uint256 _salt\n    ) external onlyGovernor {\n        require(\n            _ammPoolAddress != address(0),\n            \"Invalid ammPoolAddress address\"\n        );\n        require(_salt > 0, \"Invalid salt\");\n\n        address poolBoosterAddress = _deployContract(\n            abi.encodePacked(\n                type(PoolBoosterSwapxSingle).creationCode,\n                abi.encode(_bribeAddress, oSonic)\n            ),\n            _salt\n        );\n\n        _storePoolBoosterEntry(\n            poolBoosterAddress,\n            _ammPoolAddress,\n            IPoolBoostCentralRegistry.PoolBoosterType.SwapXSingleBooster\n        );\n    }\n\n    /**\n     * @dev Create a Pool Booster for SwapX classic volatile or classic stable pools where\n     *      a single Bribe contract is incentivized.\n     * @param _bribeAddress address of the Bribes.sol contract\n     * @param _ammPoolAddress address of the AMM pool where the yield originates from\n     * @param _salt A unique number that affects the address of the pool booster created. Note: this number\n     *        should match the one from `createPoolBoosterSwapxSingle` in order for the final deployed address\n     *        and pre-computed address to match\n     */\n    function computePoolBoosterAddress(\n        address _bribeAddress,\n        address _ammPoolAddress,\n        uint256 _salt\n    ) external view returns (address) {\n        require(\n            _ammPoolAddress != address(0),\n            \"Invalid ammPoolAddress address\"\n        );\n        require(_salt > 0, \"Invalid salt\");\n\n        return\n            _computeAddress(\n                abi.encodePacked(\n                    type(PoolBoosterSwapxSingle).creationCode,\n                    abi.encode(_bribeAddress, oSonic)\n                ),\n                _salt\n            );\n    }\n}\n"
    },
    "contracts/poolBooster/PoolBoosterMetropolis.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IPoolBooster } from \"../interfaces/poolBooster/IPoolBooster.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Pool booster for Metropolis pools\n * @author Origin Protocol Inc\n */\ncontract PoolBoosterMetropolis is IPoolBooster {\n    // @notice address of the OS token\n    IERC20 public immutable osToken;\n    // @notice address of the pool\n    address public immutable pool;\n    // @notice if balance under this amount the bribe action is skipped\n    uint256 public constant MIN_BRIBE_AMOUNT = 1e10;\n\n    IRewarderFactory public immutable rewardFactory;\n\n    IVoter public immutable voter;\n\n    constructor(\n        address _osToken,\n        address _rewardFactory,\n        address _pool,\n        address _voter\n    ) {\n        require(_pool != address(0), \"Invalid pool address\");\n        pool = _pool;\n        // Abstract factory already validates this is not a zero address\n        osToken = IERC20(_osToken);\n\n        rewardFactory = IRewarderFactory(_rewardFactory);\n\n        voter = IVoter(_voter);\n    }\n\n    function bribe() external override {\n        uint256 balance = osToken.balanceOf(address(this));\n        // balance too small, do no bribes\n        (, uint256 minBribeAmount) = rewardFactory.getWhitelistedTokenInfo(\n            address(osToken)\n        );\n        if (balance < MIN_BRIBE_AMOUNT || balance < minBribeAmount) {\n            return;\n        }\n\n        uint256 id = voter.getCurrentVotingPeriod() + 1;\n\n        // Deploy a rewarder\n        IRewarder rewarder = IRewarder(\n            rewardFactory.createBribeRewarder(address(osToken), pool)\n        );\n\n        // Approve the rewarder to spend the balance\n        osToken.approve(address(rewarder), balance);\n\n        // Fund and bribe the rewarder\n        rewarder.fundAndBribe(id, id, balance);\n\n        emit BribeExecuted(balance);\n    }\n}\n\ninterface IRewarderFactory {\n    function createBribeRewarder(address token, address pool)\n        external\n        returns (address rewarder);\n\n    function getWhitelistedTokenInfo(address token)\n        external\n        view\n        returns (bool isWhitelisted, uint256 minBribeAmount);\n}\n\ninterface IRewarder {\n    function fundAndBribe(\n        uint256 startId,\n        uint256 lastId,\n        uint256 amountPerPeriod\n    ) external payable;\n}\n\ninterface IVoter {\n    function getCurrentVotingPeriod() external view returns (uint256);\n}\n"
    },
    "contracts/poolBooster/PoolBoosterSwapxDouble.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IBribe } from \"../interfaces/poolBooster/ISwapXAlgebraBribe.sol\";\nimport { IPoolBooster } from \"../interfaces/poolBooster/IPoolBooster.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\n/**\n * @title Pool booster for SwapX concentrated liquidity where 2 gauges are created for\n *        every pool. Ichi vaults currently have such setup.\n * @author Origin Protocol Inc\n */\ncontract PoolBoosterSwapxDouble is IPoolBooster {\n    using StableMath for uint256;\n\n    // @notice address of the Bribes.sol(Bribe) contract for the OS token side\n    IBribe public immutable bribeContractOS;\n    // @notice address of the  Bribes.sol(Bribe) contract for the other token in the pool\n    IBribe public immutable bribeContractOther;\n    // @notice address of the OS token\n    IERC20 public immutable osToken;\n    // @notice 1e18 denominated split between OS and Other bribe. E.g. 0.4e17 means 40% to OS\n    //         bribe contract and 60% to other bribe contract\n    uint256 public immutable split;\n\n    // @notice if balance under this amount the bribe action is skipped\n    uint256 public constant MIN_BRIBE_AMOUNT = 1e10;\n\n    constructor(\n        address _bribeContractOS,\n        address _bribeContractOther,\n        address _osToken,\n        uint256 _split\n    ) {\n        require(\n            _bribeContractOS != address(0),\n            \"Invalid bribeContractOS address\"\n        );\n        require(\n            _bribeContractOther != address(0),\n            \"Invalid bribeContractOther address\"\n        );\n        // expect it to be between 1% & 99%\n        require(_split > 1e16 && _split < 99e16, \"Unexpected split amount\");\n\n        bribeContractOS = IBribe(_bribeContractOS);\n        bribeContractOther = IBribe(_bribeContractOther);\n        // Abstract factory already validates this is not a zero address\n        osToken = IERC20(_osToken);\n        split = _split;\n    }\n\n    function bribe() external override {\n        uint256 balance = osToken.balanceOf(address(this));\n        // balance too small, do no bribes\n        if (balance < MIN_BRIBE_AMOUNT) {\n            return;\n        }\n\n        uint256 osBribeAmount = balance.mulTruncate(split);\n        uint256 otherBribeAmount = balance - osBribeAmount;\n\n        osToken.approve(address(bribeContractOS), osBribeAmount);\n        osToken.approve(address(bribeContractOther), otherBribeAmount);\n\n        bribeContractOS.notifyRewardAmount(address(osToken), osBribeAmount);\n        bribeContractOther.notifyRewardAmount(\n            address(osToken),\n            otherBribeAmount\n        );\n\n        emit BribeExecuted(balance);\n    }\n}\n"
    },
    "contracts/poolBooster/PoolBoosterSwapxSingle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IBribe } from \"../interfaces/poolBooster/ISwapXAlgebraBribe.sol\";\nimport { IPoolBooster } from \"../interfaces/poolBooster/IPoolBooster.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Pool booster for SwapX for Classic Stable Pools and Classic Volatile Pools\n * @author Origin Protocol Inc\n */\ncontract PoolBoosterSwapxSingle is IPoolBooster {\n    // @notice address of the Bribes.sol(Bribe) contract\n    IBribe public immutable bribeContract;\n    // @notice address of the OS token\n    IERC20 public immutable osToken;\n    // @notice if balance under this amount the bribe action is skipped\n    uint256 public constant MIN_BRIBE_AMOUNT = 1e10;\n\n    constructor(address _bribeContract, address _osToken) {\n        require(_bribeContract != address(0), \"Invalid bribeContract address\");\n        bribeContract = IBribe(_bribeContract);\n        // Abstract factory already validates this is not a zero address\n        osToken = IERC20(_osToken);\n    }\n\n    function bribe() external override {\n        uint256 balance = osToken.balanceOf(address(this));\n        // balance too small, do no bribes\n        if (balance < MIN_BRIBE_AMOUNT) {\n            return;\n        }\n\n        osToken.approve(address(bribeContract), balance);\n\n        bribeContract.notifyRewardAmount(address(osToken), balance);\n        emit BribeExecuted(balance);\n    }\n}\n"
    },
    "contracts/utils/StableMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n// Based on StableMath from Stability Labs Pty. Ltd.\n// https://github.com/mstable/mStable-contracts/blob/master/contracts/shared/StableMath.sol\n\nlibrary StableMath {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Scaling unit for use in specific calculations,\n     * where 1 * 10**18, or 1e18 represents a unit '1'\n     */\n    uint256 private constant FULL_SCALE = 1e18;\n\n    /***************************************\n                    Helpers\n    ****************************************/\n\n    /**\n     * @dev Adjust the scale of an integer\n     * @param to Decimals to scale to\n     * @param from Decimals to scale from\n     */\n    function scaleBy(\n        uint256 x,\n        uint256 to,\n        uint256 from\n    ) internal pure returns (uint256) {\n        if (to > from) {\n            x = x.mul(10**(to - from));\n        } else if (to < from) {\n            // slither-disable-next-line divide-before-multiply\n            x = x.div(10**(from - to));\n        }\n        return x;\n    }\n\n    /***************************************\n               Precise Arithmetic\n    ****************************************/\n\n    /**\n     * @dev Multiplies two precise units, and then truncates by the full scale\n     * @param x Left hand input to multiplication\n     * @param y Right hand input to multiplication\n     * @return Result after multiplying the two inputs and then dividing by the shared\n     *         scale unit\n     */\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulTruncateScale(x, y, FULL_SCALE);\n    }\n\n    /**\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\n     * @param x Left hand input to multiplication\n     * @param y Right hand input to multiplication\n     * @param scale Scale unit\n     * @return Result after multiplying the two inputs and then dividing by the shared\n     *         scale unit\n     */\n    function mulTruncateScale(\n        uint256 x,\n        uint256 y,\n        uint256 scale\n    ) internal pure returns (uint256) {\n        // e.g. assume scale = fullScale\n        // z = 10e18 * 9e17 = 9e36\n        uint256 z = x.mul(y);\n        // return 9e36 / 1e18 = 9e18\n        return z.div(scale);\n    }\n\n    /**\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\n     * @param x Left hand input to multiplication\n     * @param y Right hand input to multiplication\n     * @return Result after multiplying the two inputs and then dividing by the shared\n     *          scale unit, rounded up to the closest base unit.\n     */\n    function mulTruncateCeil(uint256 x, uint256 y)\n        internal\n        pure\n        returns (uint256)\n    {\n        // e.g. 8e17 * 17268172638 = 138145381104e17\n        uint256 scaled = x.mul(y);\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\n        uint256 ceil = scaled.add(FULL_SCALE.sub(1));\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\n        return ceil.div(FULL_SCALE);\n    }\n\n    /**\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\n     * @param x Left hand input to division\n     * @param y Right hand input to division\n     * @return Result after multiplying the left operand by the scale, and\n     *         executing the division on the right hand input.\n     */\n    function divPrecisely(uint256 x, uint256 y)\n        internal\n        pure\n        returns (uint256)\n    {\n        // e.g. 8e18 * 1e18 = 8e36\n        uint256 z = x.mul(FULL_SCALE);\n        // e.g. 8e36 / 10e18 = 8e17\n        return z.div(y);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}