{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouterClient {\n  error UnsupportedDestinationChain(uint64 destChainSelector);\n  error InsufficientFeeTokenAmount();\n  error InvalidMsgValue();\n\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\n  /// @param chainSelector The chain to check.\n  /// @return supported is true if it is supported, false if not.\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\n\n  /// @notice Gets a list of all supported tokens which can be sent or received\n  /// to/from a given chain id.\n  /// @param chainSelector The chainSelector.\n  /// @return tokens The addresses of all tokens that are supported.\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\n\n  /// @param destinationChainSelector The destination chainSelector\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return fee returns execution fee for the message\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function getFee(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage memory message\n  ) external view returns (uint256 fee);\n\n  /// @notice Request a message to be sent to the destination chain\n  /// @param destinationChainSelector The destination chain ID\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return messageId The message ID\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\n  /// the overpayment with no refund.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\n    bytes data; // Data payload\n    EVMTokenAmount[] tokenAmounts; // Token transfers\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\n  }\n\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit;\n  }\n\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/buyback/AbstractBuyback.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Strategizable } from \"../governance/Strategizable.sol\";\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ICVXLocker } from \"../interfaces/ICVXLocker.sol\";\nimport { ISwapper } from \"../interfaces/ISwapper.sol\";\n\nimport { Initializable } from \"../utils/Initializable.sol\";\n\nabstract contract AbstractBuyback is Initializable, Strategizable {\n    using SafeERC20 for IERC20;\n\n    event SwapRouterUpdated(address indexed _address);\n\n    event RewardsSourceUpdated(address indexed _address);\n    event TreasuryManagerUpdated(address indexed _address);\n    event CVXShareBpsUpdated(uint256 bps);\n\n    // Emitted whenever OUSD/OETH is swapped for OGN/CVX or any other token\n    event OTokenBuyback(\n        address indexed oToken,\n        address indexed swappedFor,\n        uint256 swapAmountIn,\n        uint256 amountOut\n    );\n\n    // Address of 1-inch Swap Router\n    address public swapRouter;\n\n    // slither-disable-next-line constable-states\n    address private __deprecated_ousd;\n    // slither-disable-next-line constable-states\n    address private __deprecated_ogv;\n    // slither-disable-next-line constable-states\n    address private __deprecated_usdt;\n    // slither-disable-next-line constable-states\n    address private __deprecated_weth9;\n\n    // Address that receives OGN after swaps\n    address public rewardsSource;\n\n    // Address that receives all other tokens after swaps\n    address public treasuryManager;\n\n    // slither-disable-next-line constable-states\n    uint256 private __deprecated_treasuryBps;\n\n    address public immutable oToken;\n    address public immutable ogn;\n    address public immutable cvx;\n    address public immutable cvxLocker;\n\n    // Amount of `oToken` balance to use for OGN buyback\n    uint256 public balanceForOGN;\n\n    // Amount of `oToken` balance to use for CVX buyback\n    uint256 public balanceForCVX;\n\n    // Percentage of `oToken` balance to be used for CVX\n    uint256 public cvxShareBps; // 10000 = 100%\n\n    constructor(\n        address _oToken,\n        address _ogn,\n        address _cvx,\n        address _cvxLocker\n    ) {\n        // Make sure nobody owns the implementation contract\n        _setGovernor(address(0));\n\n        oToken = _oToken;\n        ogn = _ogn;\n        cvx = _cvx;\n        cvxLocker = _cvxLocker;\n    }\n\n    /**\n     * @param _swapRouter Address of Uniswap V3 Router\n     * @param _strategistAddr Address of Strategist multi-sig wallet\n     * @param _treasuryManagerAddr Address that receives the treasury's share of OUSD\n     * @param _rewardsSource Address of RewardsSource contract\n     * @param _cvxShareBps Percentage of balance to use for CVX\n     */\n    function initialize(\n        address _swapRouter,\n        address _strategistAddr,\n        address _treasuryManagerAddr,\n        address _rewardsSource,\n        uint256 _cvxShareBps\n    ) external onlyGovernor initializer {\n        _setStrategistAddr(_strategistAddr);\n\n        _setSwapRouter(_swapRouter);\n        _setRewardsSource(_rewardsSource);\n\n        _setTreasuryManager(_treasuryManagerAddr);\n\n        _setCVXShareBps(_cvxShareBps);\n    }\n\n    /**\n     * @dev Set address of Uniswap Universal Router for performing liquidation\n     * of platform fee tokens. Setting to 0x0 will pause swaps.\n     *\n     * @param _router Address of the Uniswap Universal router\n     */\n    function setSwapRouter(address _router) external onlyGovernor {\n        _setSwapRouter(_router);\n    }\n\n    function _setSwapRouter(address _router) internal {\n        address oldRouter = swapRouter;\n        swapRouter = _router;\n\n        if (oldRouter != address(0)) {\n            // Remove allowance of old router, if any\n\n            if (IERC20(ogn).allowance(address(this), oldRouter) != 0) {\n                // slither-disable-next-line unused-return\n                IERC20(ogn).safeApprove(oldRouter, 0);\n            }\n\n            if (IERC20(cvx).allowance(address(this), oldRouter) != 0) {\n                // slither-disable-next-line unused-return\n                IERC20(cvx).safeApprove(oldRouter, 0);\n            }\n        }\n\n        emit SwapRouterUpdated(_router);\n    }\n\n    /**\n     * @dev Sets the address that receives the OGN buyback rewards\n     * @param _address Address\n     */\n    function setRewardsSource(address _address) external onlyGovernor {\n        _setRewardsSource(_address);\n    }\n\n    function _setRewardsSource(address _address) internal {\n        require(_address != address(0), \"Address not set\");\n        rewardsSource = _address;\n        emit RewardsSourceUpdated(_address);\n    }\n\n    /**\n     * @dev Sets the address that can receive and manage the funds for Treasury\n     * @param _address Address\n     */\n    function setTreasuryManager(address _address) external onlyGovernor {\n        _setTreasuryManager(_address);\n    }\n\n    function _setTreasuryManager(address _address) internal {\n        require(_address != address(0), \"Address not set\");\n        treasuryManager = _address;\n        emit TreasuryManagerUpdated(_address);\n    }\n\n    /**\n     * @dev Sets the percentage of oToken to use for Flywheel tokens\n     * @param _bps BPS, 10000 to 100%\n     */\n    function setCVXShareBps(uint256 _bps) external onlyGovernor {\n        _setCVXShareBps(_bps);\n    }\n\n    function _setCVXShareBps(uint256 _bps) internal {\n        require(_bps <= 10000, \"Invalid bps value\");\n        cvxShareBps = _bps;\n        emit CVXShareBpsUpdated(_bps);\n    }\n\n    /**\n     * @dev Computes the split of oToken balance that can be\n     *      used for OGN and CVX buybacks.\n     */\n    function _updateBuybackSplits()\n        internal\n        returns (uint256 _balanceForOGN, uint256 _balanceForCVX)\n    {\n        _balanceForOGN = balanceForOGN;\n        _balanceForCVX = balanceForCVX;\n\n        uint256 totalBalance = IERC20(oToken).balanceOf(address(this));\n        uint256 unsplitBalance = totalBalance - _balanceForOGN - _balanceForCVX;\n\n        // Check if all balance is accounted for\n        if (unsplitBalance != 0) {\n            // If not, split unaccounted balance based on `cvxShareBps`\n            uint256 addToCVX = (unsplitBalance * cvxShareBps) / 10000;\n            _balanceForCVX = _balanceForCVX + addToCVX;\n            _balanceForOGN = _balanceForOGN + unsplitBalance - addToCVX;\n\n            // Update storage\n            balanceForOGN = _balanceForOGN;\n            balanceForCVX = _balanceForCVX;\n        }\n    }\n\n    function updateBuybackSplits() external onlyGovernor {\n        // slither-disable-next-line unused-return\n        _updateBuybackSplits();\n    }\n\n    function _swapToken(\n        address tokenOut,\n        uint256 oTokenAmount,\n        uint256 minAmountOut,\n        bytes calldata swapData\n    ) internal returns (uint256 amountOut) {\n        require(oTokenAmount > 0, \"Invalid Swap Amount\");\n        require(swapRouter != address(0), \"Swap Router not set\");\n        require(minAmountOut > 0, \"Invalid minAmount\");\n\n        // Transfer OToken to Swapper for swapping\n        // slither-disable-next-line unchecked-transfer unused-return\n        IERC20(oToken).transfer(swapRouter, oTokenAmount);\n\n        // Swap\n        amountOut = ISwapper(swapRouter).swap(\n            oToken,\n            tokenOut,\n            oTokenAmount,\n            minAmountOut,\n            swapData\n        );\n\n        require(amountOut >= minAmountOut, \"Higher Slippage\");\n\n        emit OTokenBuyback(oToken, tokenOut, oTokenAmount, amountOut);\n    }\n\n    /**\n     * @dev Swaps `oTokenAmount` to OGN\n     * @param oTokenAmount Amount of OUSD/OETH to swap\n     * @param minOGN Minimum OGN to receive for oTokenAmount\n     * @param swapData 1inch Swap Data\n     */\n    function swapForOGN(\n        uint256 oTokenAmount,\n        uint256 minOGN,\n        bytes calldata swapData\n    ) external onlyGovernorOrStrategist nonReentrant {\n        (uint256 _amountForOGN, ) = _updateBuybackSplits();\n        require(_amountForOGN >= oTokenAmount, \"Balance underflow\");\n        require(rewardsSource != address(0), \"RewardsSource contract not set\");\n\n        unchecked {\n            // Subtract the amount to swap from net balance\n            balanceForOGN = _amountForOGN - oTokenAmount;\n        }\n\n        uint256 ognReceived = _swapToken(ogn, oTokenAmount, minOGN, swapData);\n\n        // Transfer OGN received to RewardsSource contract\n        // slither-disable-next-line unchecked-transfer unused-return\n        IERC20(ogn).transfer(rewardsSource, ognReceived);\n    }\n\n    /**\n     * @dev Swaps `oTokenAmount` to CVX\n     * @param oTokenAmount Amount of OUSD/OETH to swap\n     * @param minCVX Minimum CVX to receive for oTokenAmount\n     * @param swapData 1inch Swap Data\n     */\n    function swapForCVX(\n        uint256 oTokenAmount,\n        uint256 minCVX,\n        bytes calldata swapData\n    ) external onlyGovernorOrStrategist nonReentrant {\n        (, uint256 _amountForCVX) = _updateBuybackSplits();\n        require(_amountForCVX >= oTokenAmount, \"Balance underflow\");\n\n        unchecked {\n            // Subtract the amount to swap from net balance\n            balanceForCVX = _amountForCVX - oTokenAmount;\n        }\n\n        uint256 cvxReceived = _swapToken(cvx, oTokenAmount, minCVX, swapData);\n\n        // Lock all CVX\n        _lockAllCVX(cvxReceived);\n    }\n\n    /**\n     * @dev Locks all CVX held by the contract on behalf of the Treasury Manager\n     */\n    function lockAllCVX() external onlyGovernorOrStrategist {\n        _lockAllCVX(IERC20(cvx).balanceOf(address(this)));\n    }\n\n    function _lockAllCVX(uint256 cvxAmount) internal {\n        require(\n            treasuryManager != address(0),\n            \"Treasury manager address not set\"\n        );\n\n        // Lock all available CVX on behalf of `treasuryManager`\n        ICVXLocker(cvxLocker).lock(treasuryManager, cvxAmount, 0);\n    }\n\n    /**\n     * @dev Approve CVX Locker to move CVX held by this contract\n     */\n    function safeApproveAllTokens() external onlyGovernorOrStrategist {\n        IERC20(cvx).safeApprove(cvxLocker, type(uint256).max);\n    }\n\n    /**\n     * @notice Owner function to withdraw a specific amount of a token\n     * @param token token to be transferered\n     * @param amount amount of the token to be transferred\n     */\n    function transferToken(address token, uint256 amount)\n        external\n        onlyGovernor\n        nonReentrant\n    {\n        IERC20(token).safeTransfer(_governor(), amount);\n    }\n}\n"
    },
    "contracts/buyback/OETHBuyback.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { AbstractBuyback } from \"./AbstractBuyback.sol\";\n\ncontract OETHBuyback is AbstractBuyback {\n    constructor(\n        address _oToken,\n        address _ogn,\n        address _cvx,\n        address _cvxLocker\n    ) AbstractBuyback(_oToken, _ogn, _cvx, _cvxLocker) {}\n}\n"
    },
    "contracts/buyback/OUSDBuyback.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { AbstractBuyback } from \"./AbstractBuyback.sol\";\n\ncontract OUSDBuyback is AbstractBuyback {\n    constructor(\n        address _oToken,\n        address _ogn,\n        address _cvx,\n        address _cvxLocker\n    ) AbstractBuyback(_oToken, _ogn, _cvx, _cvxLocker) {}\n}\n"
    },
    "contracts/compensation/CompensationClaims.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\n\n/**\n * @title Compensation Claims\n * @author Origin Protocol Inc\n * @dev Airdrop for ERC20 tokens.\n *\n *   Provides a coin airdrop with a verification period in which everyone\n *   can check that all claims are correct before any actual funds are moved\n *   to the contract.\n *\n *      - Users can claim funds during the claim period.\n *\n *      - The adjuster can set the amount of each user's claim,\n *         but only when unlocked, and not during the claim period.\n *\n *      - The governor can unlock and lock the adjuster, outside the claim period.\n *      - The governor can start the claim period, if it's not started.\n *      - The governor can collect any remaining funds after the claim period is over.\n *\n *  Intended use sequence:\n *\n *   1. Governor unlocks the adjuster\n *   2. Adjuster uploads claims\n *   3. Governor locks the adjuster\n *   4. Everyone verifies that the claim amounts and totals are correct\n *   5. Payout funds are moved to the contract\n *   6. The claim period starts\n *   7. Users claim funds\n *   8. The claim period ends\n *   9. Governor can collect any remaing funds\n *\n */\ncontract CompensationClaims is Governable {\n    address public adjuster;\n    address public token;\n    uint256 public end;\n    uint256 public totalClaims;\n    mapping(address => uint256) claims;\n    bool public isAdjusterLocked;\n\n    using SafeMath for uint256;\n\n    event Claim(address indexed recipient, uint256 amount);\n    event ClaimSet(address indexed recipient, uint256 amount);\n    event Start(uint256 end);\n    event Lock();\n    event Unlock();\n    event Collect(address indexed coin, uint256 amount);\n\n    constructor(address _token, address _adjuster) onlyGovernor {\n        token = _token;\n        adjuster = _adjuster;\n        isAdjusterLocked = true;\n    }\n\n    function balanceOf(address _account) external view returns (uint256) {\n        return claims[_account];\n    }\n\n    function decimals() external view returns (uint8) {\n        return IERC20Decimals(token).decimals();\n    }\n\n    /* -- User -- */\n\n    function claim(address _recipient) external onlyInClaimPeriod nonReentrant {\n        uint256 amount = claims[_recipient];\n        require(amount > 0, \"Amount must be greater than 0\");\n        claims[_recipient] = 0;\n        totalClaims = totalClaims.sub(amount);\n        SafeERC20.safeTransfer(IERC20(token), _recipient, amount);\n        emit Claim(_recipient, amount);\n    }\n\n    /* -- Adjustor -- */\n\n    function setClaims(\n        address[] calldata _addresses,\n        uint256[] calldata _amounts\n    ) external notInClaimPeriod onlyUnlockedAdjuster {\n        require(\n            _addresses.length == _amounts.length,\n            \"Addresses and amounts must match\"\n        );\n        uint256 len = _addresses.length;\n        for (uint256 i = 0; i < len; i++) {\n            address recipient = _addresses[i];\n            uint256 newAmount = _amounts[i];\n            uint256 oldAmount = claims[recipient];\n            claims[recipient] = newAmount;\n            totalClaims = totalClaims.add(newAmount).sub(oldAmount);\n            emit ClaimSet(recipient, newAmount);\n        }\n    }\n\n    /* -- Governor -- */\n\n    function lockAdjuster() external onlyGovernor notInClaimPeriod {\n        _lockAdjuster();\n    }\n\n    function _lockAdjuster() internal {\n        isAdjusterLocked = true;\n        emit Lock();\n    }\n\n    function unlockAdjuster() external onlyGovernor notInClaimPeriod {\n        isAdjusterLocked = false;\n        emit Unlock();\n    }\n\n    function start(uint256 _seconds)\n        external\n        onlyGovernor\n        notInClaimPeriod\n        nonReentrant\n    {\n        require(totalClaims > 0, \"No claims\");\n        uint256 funding = IERC20(token).balanceOf(address(this));\n        require(funding >= totalClaims, \"Insufficient funds for all claims\");\n        _lockAdjuster();\n        end = block.timestamp.add(_seconds);\n        require(end.sub(block.timestamp) < 31622400, \"Duration too long\"); // 31622400 = 366*24*60*60\n        emit Start(end);\n    }\n\n    function collect(address _coin)\n        external\n        onlyGovernor\n        notInClaimPeriod\n        nonReentrant\n    {\n        uint256 amount = IERC20(_coin).balanceOf(address(this));\n        SafeERC20.safeTransfer(IERC20(_coin), address(governor()), amount);\n        emit Collect(_coin, amount);\n    }\n\n    /* -- modifiers -- */\n\n    modifier onlyInClaimPeriod() {\n        require(block.timestamp <= end, \"Should be in claim period\");\n        _;\n    }\n\n    modifier notInClaimPeriod() {\n        require(block.timestamp > end, \"Should not be in claim period\");\n        _;\n    }\n\n    modifier onlyUnlockedAdjuster() {\n        require(isAdjusterLocked == false, \"Adjuster must be unlocked\");\n        require(msg.sender == adjuster, \"Must be adjuster\");\n        _;\n    }\n}\n\ninterface IERC20Decimals {\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/echidna/Debugger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary Debugger {\n    event Debug(string debugString);\n    event Debug(string description, string data);\n    event Debug(string prefix, string description, string data);\n    event Debug(string description, bytes32 data);\n    event Debug(string prefix, string description, bytes32 data);\n    event Debug(string description, uint256 data);\n    event Debug(string prefix, string description, uint256 data);\n    event Debug(string description, int256 data);\n    event Debug(string prefix, string description, int256 data);\n    event Debug(string description, address data);\n    event Debug(string prefix, string description, address data);\n    event Debug(string description, bool data);\n    event Debug(string prefix, string description, bool data);\n\n    function log(string memory debugString) internal {\n        emit Debug(debugString);\n    }\n\n    function log(string memory description, string memory data) internal {\n        emit Debug(description, data);\n    }\n\n    function log(\n        string memory prefix,\n        string memory description,\n        string memory data\n    ) internal {\n        emit Debug(prefix, description, data);\n    }\n\n    function log(string memory description, bytes32 data) internal {\n        emit Debug(description, data);\n    }\n\n    function log(\n        string memory prefix,\n        string memory description,\n        bytes32 data\n    ) internal {\n        emit Debug(prefix, description, data);\n    }\n\n    function log(string memory description, uint256 data) internal {\n        emit Debug(description, data);\n    }\n\n    function log(\n        string memory prefix,\n        string memory description,\n        uint256 data\n    ) internal {\n        emit Debug(prefix, description, data);\n    }\n\n    function log(string memory description, int256 data) internal {\n        emit Debug(description, data);\n    }\n\n    function log(\n        string memory prefix,\n        string memory description,\n        int256 data\n    ) internal {\n        emit Debug(prefix, description, data);\n    }\n\n    function log(string memory description, address data) internal {\n        emit Debug(description, data);\n    }\n\n    function log(\n        string memory prefix,\n        string memory description,\n        address data\n    ) internal {\n        emit Debug(prefix, description, data);\n    }\n\n    function log(string memory description, bool data) internal {\n        emit Debug(description, data);\n    }\n\n    function log(\n        string memory prefix,\n        string memory description,\n        bool data\n    ) internal {\n        emit Debug(prefix, description, data);\n    }\n}\n"
    },
    "contracts/echidna/Echidna.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./EchidnaTestApproval.sol\";\n\n/**\n * @title Echidna test contract for OUSD\n * @notice Target contract to be tested, containing all mixins\n * @author Rappie\n */\ncontract Echidna is EchidnaTestApproval {\n\n}\n"
    },
    "contracts/echidna/EchidnaConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Top-level mixin for configuring the desired fuzzing setup\n * @author Rappie\n */\ncontract EchidnaConfig {\n    address internal constant ADDRESS_VAULT = address(0x10000);\n    address internal constant ADDRESS_OUTSIDER_USER = address(0x20000);\n\n    address internal constant ADDRESS_USER0 = address(0x30000);\n    address internal constant ADDRESS_USER1 = address(0x40000);\n\n    // Will be set in EchidnaSetup constructor\n    address internal ADDRESS_OUTSIDER_CONTRACT;\n    address internal ADDRESS_CONTRACT0;\n    address internal ADDRESS_CONTRACT1;\n\n    // Toggle known issues\n    //\n    // This can be used to skip tests that are known to fail. This is useful\n    // when debugging a specific issue, but should be disabled when running\n    // the full test suite.\n    //\n    //   True => skip tests that are known to fail\n    //   False => run all tests\n    //\n    bool internal constant TOGGLE_KNOWN_ISSUES = false;\n\n    // Toggle known issues within limits\n    //\n    // Same as TOGGLE_KNOWN_ISSUES, but also skip tests that are known to fail\n    // within limits set by the variables below.\n    //\n    bool internal constant TOGGLE_KNOWN_ISSUES_WITHIN_LIMITS = true;\n\n    // Starting balance\n    //\n    // Gives OUSD a non-zero starting supply, which can be useful to ignore\n    // certain edge cases.\n    //\n    // The starting balance is given to outsider accounts that are not used as\n    // accounts while fuzzing.\n    //\n    bool internal constant TOGGLE_STARTING_BALANCE = true;\n    uint256 internal constant STARTING_BALANCE = 1_000_000e18;\n\n    // Change supply\n    //\n    // Set a limit to the amount of change per rebase, which can be useful to\n    // ignore certain edge cases.\n    //\n    //  True => limit the amount of change to a percentage of total supply\n    //  False => no limit\n    //\n    bool internal constant TOGGLE_CHANGESUPPLY_LIMIT = true;\n    uint256 internal constant CHANGESUPPLY_DIVISOR = 10; // 10% of total supply\n\n    // Mint limit\n    //\n    // Set a limit the the amount minted per mint, which can be useful to\n    // ignore certain edge cases.\n    //\n    //  True => limit the amount of minted tokens\n    //  False => no limit\n    //\n    bool internal constant TOGGLE_MINT_LIMIT = true;\n    uint256 internal constant MINT_MODULO = 1_000_000_000_000e18;\n\n    // Known rounding errors\n    uint256 internal constant TRANSFER_ROUNDING_ERROR = 1e18 - 1;\n    uint256 internal constant OPT_IN_ROUNDING_ERROR = 1e18 - 1;\n    uint256 internal constant MINT_ROUNDING_ERROR = 1e18 - 1;\n\n    /**\n     * @notice Modifier to skip tests that are known to fail\n     * @dev see TOGGLE_KNOWN_ISSUES for more information\n     */\n    modifier hasKnownIssue() {\n        if (TOGGLE_KNOWN_ISSUES) return;\n        _;\n    }\n\n    /**\n     * @notice Modifier to skip tests that are known to fail within limits\n     * @dev see TOGGLE_KNOWN_ISSUES_WITHIN_LIMITS for more information\n     */\n    modifier hasKnownIssueWithinLimits() {\n        if (TOGGLE_KNOWN_ISSUES_WITHIN_LIMITS) return;\n        _;\n    }\n\n    /**\n     * @notice Translate an account ID to an address\n     * @param accountId The ID of the account\n     * @return account The address of the account\n     */\n    function getAccount(uint8 accountId)\n        internal\n        view\n        returns (address account)\n    {\n        accountId = accountId / 64;\n        if (accountId == 0) return account = ADDRESS_USER0;\n        if (accountId == 1) return account = ADDRESS_USER1;\n        if (accountId == 2) return account = ADDRESS_CONTRACT0;\n        if (accountId == 3) return account = ADDRESS_CONTRACT1;\n        require(false, \"Unknown account ID\");\n    }\n}\n"
    },
    "contracts/echidna/EchidnaDebug.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"./EchidnaHelper.sol\";\nimport \"./Debugger.sol\";\n\nimport \"../token/OUSD.sol\";\n\n/**\n * @title Room for random debugging functions\n * @author Rappie\n */\ncontract EchidnaDebug is EchidnaHelper {\n    function debugOUSD() public pure {\n        // assert(ousd.balanceOf(ADDRESS_USER0) == 1000);\n        // assert(ousd.rebaseState(ADDRESS_USER0) != OUSD.RebaseOptions.OptIn);\n        // assert(Address.isContract(ADDRESS_CONTRACT0));\n        // Debugger.log(\"nonRebasingSupply\", ousd.nonRebasingSupply());\n        // assert(false);\n    }\n}\n"
    },
    "contracts/echidna/EchidnaHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./EchidnaSetup.sol\";\nimport \"./Debugger.sol\";\n\n/**\n * @title Mixin containing helper functions\n * @author Rappie\n */\ncontract EchidnaHelper is EchidnaSetup {\n    /**\n     * @notice Mint tokens to an account\n     * @param toAcc Account to mint to\n     * @param amount Amount to mint\n     * @return Amount minted (in case of capped mint with modulo)\n     */\n    function mint(uint8 toAcc, uint256 amount) public returns (uint256) {\n        address to = getAccount(toAcc);\n\n        if (TOGGLE_MINT_LIMIT) {\n            amount = amount % MINT_MODULO;\n        }\n\n        hevm.prank(ADDRESS_VAULT);\n        ousd.mint(to, amount);\n\n        return amount;\n    }\n\n    /**\n     * @notice Burn tokens from an account\n     * @param fromAcc Account to burn from\n     * @param amount Amount to burn\n     */\n    function burn(uint8 fromAcc, uint256 amount) public {\n        address from = getAccount(fromAcc);\n        hevm.prank(ADDRESS_VAULT);\n        ousd.burn(from, amount);\n    }\n\n    /**\n     * @notice Change the total supply of OUSD (rebase)\n     * @param amount New total supply\n     */\n    function changeSupply(uint256 amount) public {\n        if (TOGGLE_CHANGESUPPLY_LIMIT) {\n            amount =\n                ousd.totalSupply() +\n                (amount % (ousd.totalSupply() / CHANGESUPPLY_DIVISOR));\n        }\n\n        hevm.prank(ADDRESS_VAULT);\n        ousd.changeSupply(amount);\n    }\n\n    /**\n     * @notice Transfer tokens between accounts\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function transfer(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n        hevm.prank(from);\n        // slither-disable-next-line unchecked-transfer\n        ousd.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfer approved tokens between accounts\n     * @param authorizedAcc Account that is authorized to transfer\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function transferFrom(\n        uint8 authorizedAcc,\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address authorized = getAccount(authorizedAcc);\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n        hevm.prank(authorized);\n        // slither-disable-next-line unchecked-transfer\n        ousd.transferFrom(from, to, amount);\n    }\n\n    /**\n     * @notice Opt in to rebasing\n     * @param targetAcc Account to opt in\n     */\n    function optIn(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n        hevm.prank(target);\n        ousd.rebaseOptIn();\n    }\n\n    /**\n     * @notice Opt out of rebasing\n     * @param targetAcc Account to opt out\n     */\n    function optOut(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n        hevm.prank(target);\n        ousd.rebaseOptOut();\n    }\n\n    /**\n     * @notice Approve an account to spend OUSD\n     * @param ownerAcc Account that owns the OUSD\n     * @param spenderAcc Account that is approved to spend the OUSD\n     * @param amount Amount to approve\n     */\n    function approve(\n        uint8 ownerAcc,\n        uint8 spenderAcc,\n        uint256 amount\n    ) public {\n        address owner = getAccount(ownerAcc);\n        address spender = getAccount(spenderAcc);\n        hevm.prank(owner);\n        // slither-disable-next-line unused-return\n        ousd.approve(spender, amount);\n    }\n\n    /**\n     * @notice Increase the allowance of an account to spend OUSD\n     * @param ownerAcc Account that owns the OUSD\n     * @param spenderAcc Account that is approved to spend the OUSD\n     * @param amount Amount to increase the allowance by\n     */\n    function increaseAllowance(\n        uint8 ownerAcc,\n        uint8 spenderAcc,\n        uint256 amount\n    ) public {\n        address owner = getAccount(ownerAcc);\n        address spender = getAccount(spenderAcc);\n        hevm.prank(owner);\n        // slither-disable-next-line unused-return\n        ousd.increaseAllowance(spender, amount);\n    }\n\n    /**\n     * @notice Decrease the allowance of an account to spend OUSD\n     * @param ownerAcc Account that owns the OUSD\n     * @param spenderAcc Account that is approved to spend the OUSD\n     * @param amount Amount to decrease the allowance by\n     */\n    function decreaseAllowance(\n        uint8 ownerAcc,\n        uint8 spenderAcc,\n        uint256 amount\n    ) public {\n        address owner = getAccount(ownerAcc);\n        address spender = getAccount(spenderAcc);\n        hevm.prank(owner);\n        // slither-disable-next-line unused-return\n        ousd.decreaseAllowance(spender, amount);\n    }\n\n    /**\n     * @notice Get the sum of all OUSD balances\n     * @return total Total balance\n     */\n    function getTotalBalance() public view returns (uint256 total) {\n        total += ousd.balanceOf(ADDRESS_VAULT);\n        total += ousd.balanceOf(ADDRESS_OUTSIDER_USER);\n        total += ousd.balanceOf(ADDRESS_OUTSIDER_CONTRACT);\n        total += ousd.balanceOf(ADDRESS_USER0);\n        total += ousd.balanceOf(ADDRESS_USER1);\n        total += ousd.balanceOf(ADDRESS_CONTRACT0);\n        total += ousd.balanceOf(ADDRESS_CONTRACT1);\n    }\n\n    /**\n     * @notice Get the sum of all non-rebasing OUSD balances\n     * @return total Total balance\n     */\n    function getTotalNonRebasingBalance() public returns (uint256 total) {\n        total += ousd._isNonRebasingAccountEchidna(ADDRESS_VAULT)\n            ? ousd.balanceOf(ADDRESS_VAULT)\n            : 0;\n        total += ousd._isNonRebasingAccountEchidna(ADDRESS_OUTSIDER_USER)\n            ? ousd.balanceOf(ADDRESS_OUTSIDER_USER)\n            : 0;\n        total += ousd._isNonRebasingAccountEchidna(ADDRESS_OUTSIDER_CONTRACT)\n            ? ousd.balanceOf(ADDRESS_OUTSIDER_CONTRACT)\n            : 0;\n        total += ousd._isNonRebasingAccountEchidna(ADDRESS_USER0)\n            ? ousd.balanceOf(ADDRESS_USER0)\n            : 0;\n        total += ousd._isNonRebasingAccountEchidna(ADDRESS_USER1)\n            ? ousd.balanceOf(ADDRESS_USER1)\n            : 0;\n        total += ousd._isNonRebasingAccountEchidna(ADDRESS_CONTRACT0)\n            ? ousd.balanceOf(ADDRESS_CONTRACT0)\n            : 0;\n        total += ousd._isNonRebasingAccountEchidna(ADDRESS_CONTRACT1)\n            ? ousd.balanceOf(ADDRESS_CONTRACT1)\n            : 0;\n    }\n}\n"
    },
    "contracts/echidna/EchidnaSetup.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IHevm.sol\";\nimport \"./EchidnaConfig.sol\";\nimport \"./OUSDEchidna.sol\";\n\ncontract Dummy {}\n\n/**\n * @title Mixin for setup and deployment\n * @author Rappie\n */\ncontract EchidnaSetup is EchidnaConfig {\n    IHevm hevm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    OUSDEchidna ousd = new OUSDEchidna();\n\n    /**\n     * @notice Deploy the OUSD contract and set up initial state\n     */\n    constructor() {\n        ousd.initialize(\"Origin Dollar\", \"OUSD\", ADDRESS_VAULT, 1e18);\n\n        // Deploy dummny contracts as users\n        Dummy outsider = new Dummy();\n        ADDRESS_OUTSIDER_CONTRACT = address(outsider);\n        Dummy dummy0 = new Dummy();\n        ADDRESS_CONTRACT0 = address(dummy0);\n        Dummy dummy1 = new Dummy();\n        ADDRESS_CONTRACT1 = address(dummy1);\n\n        // Start out with a reasonable amount of OUSD\n        if (TOGGLE_STARTING_BALANCE) {\n            // Rebasing tokens\n            hevm.prank(ADDRESS_VAULT);\n            ousd.mint(ADDRESS_OUTSIDER_USER, STARTING_BALANCE / 2);\n\n            // Non-rebasing tokens\n            hevm.prank(ADDRESS_VAULT);\n            ousd.mint(ADDRESS_OUTSIDER_CONTRACT, STARTING_BALANCE / 2);\n        }\n    }\n}\n"
    },
    "contracts/echidna/EchidnaTestAccounting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./EchidnaDebug.sol\";\nimport \"./EchidnaTestSupply.sol\";\n\n/**\n * @title Mixin for testing accounting functions\n * @author Rappie\n */\ncontract EchidnaTestAccounting is EchidnaTestSupply {\n    /**\n     * @notice After opting in, balance should not increase. (Ok to lose rounding funds doing this)\n     * @param targetAcc Account to opt in\n     */\n    function testOptInBalance(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        optIn(targetAcc);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        assert(balanceAfter <= balanceBefore);\n    }\n\n    /**\n     * @notice After opting out, balance should remain the same\n     * @param targetAcc Account to opt out\n     */\n    function testOptOutBalance(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        optOut(targetAcc);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        assert(balanceAfter == balanceBefore);\n    }\n\n    /**\n     * @notice Account balance should remain the same after opting in minus rounding error\n     * @param targetAcc Account to opt in\n     */\n    function testOptInBalanceRounding(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        optIn(targetAcc);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        int256 delta = int256(balanceAfter) - int256(balanceBefore);\n        Debugger.log(\"delta\", delta);\n\n        // slither-disable-next-line tautology\n        assert(-1 * delta >= 0);\n        assert(-1 * delta <= int256(OPT_IN_ROUNDING_ERROR));\n    }\n\n    /**\n     * @notice After opting in, total supply should remain the same\n     * @param targetAcc Account to opt in\n     */\n    function testOptInTotalSupply(uint8 targetAcc) public {\n        uint256 totalSupplyBefore = ousd.totalSupply();\n        optIn(targetAcc);\n        uint256 totalSupplyAfter = ousd.totalSupply();\n\n        assert(totalSupplyAfter == totalSupplyBefore);\n    }\n\n    /**\n     * @notice After opting out, total supply should remain the same\n     * @param targetAcc Account to opt out\n     */\n    function testOptOutTotalSupply(uint8 targetAcc) public {\n        uint256 totalSupplyBefore = ousd.totalSupply();\n        optOut(targetAcc);\n        uint256 totalSupplyAfter = ousd.totalSupply();\n\n        assert(totalSupplyAfter == totalSupplyBefore);\n    }\n\n    /**\n     * @notice Account balance should remain the same when a smart contract auto converts\n     * @param targetAcc Account to auto convert\n     */\n    function testAutoConvertBalance(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        // slither-disable-next-line unused-return\n        ousd._isNonRebasingAccountEchidna(target);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        assert(balanceAfter == balanceBefore);\n    }\n\n    /**\n     * @notice The `balanceOf` function should never revert\n     * @param targetAcc Account to check balance of\n     */\n    function testBalanceOfShouldNotRevert(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        // slither-disable-next-line unused-return\n        try ousd.balanceOf(target) {\n            assert(true);\n        } catch {\n            assert(false);\n        }\n    }\n}\n"
    },
    "contracts/echidna/EchidnaTestApproval.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./EchidnaTestMintBurn.sol\";\nimport \"./Debugger.sol\";\n\n/**\n * @title Mixin for testing approval related functions\n * @author Rappie\n */\ncontract EchidnaTestApproval is EchidnaTestMintBurn {\n    /**\n     * @notice Performing `transferFrom` with an amount inside the allowance should not revert\n     * @param authorizedAcc The account that is authorized to transfer\n     * @param fromAcc The account that is transferring\n     * @param toAcc The account that is receiving\n     * @param amount The amount to transfer\n     */\n    function testTransferFromShouldNotRevert(\n        uint8 authorizedAcc,\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address authorized = getAccount(authorizedAcc);\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(amount <= ousd.balanceOf(from));\n        require(amount <= ousd.allowance(from, authorized));\n\n        hevm.prank(authorized);\n        // slither-disable-next-line unchecked-transfer\n        try ousd.transferFrom(from, to, amount) {\n            // pass\n        } catch {\n            assert(false);\n        }\n    }\n\n    /**\n     * @notice Performing `transferFrom` with an amount outside the allowance should revert\n     * @param authorizedAcc The account that is authorized to transfer\n     * @param fromAcc The account that is transferring\n     * @param toAcc The account that is receiving\n     * @param amount The amount to transfer\n     */\n    function testTransferFromShouldRevert(\n        uint8 authorizedAcc,\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address authorized = getAccount(authorizedAcc);\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(amount > 0);\n        require(\n            !(amount <= ousd.balanceOf(from) &&\n                amount <= ousd.allowance(from, authorized))\n        );\n\n        hevm.prank(authorized);\n        // slither-disable-next-line unchecked-transfer\n        try ousd.transferFrom(from, to, amount) {\n            assert(false);\n        } catch {\n            // pass\n        }\n    }\n\n    /**\n     * @notice Approving an amount should update the allowance and overwrite any previous allowance\n     * @param ownerAcc The account that is approving\n     * @param spenderAcc The account that is being approved\n     * @param amount The amount to approve\n     */\n    function testApprove(\n        uint8 ownerAcc,\n        uint8 spenderAcc,\n        uint256 amount\n    ) public {\n        address owner = getAccount(ownerAcc);\n        address spender = getAccount(spenderAcc);\n\n        approve(ownerAcc, spenderAcc, amount);\n        uint256 allowanceAfter1 = ousd.allowance(owner, spender);\n\n        assert(allowanceAfter1 == amount);\n\n        approve(ownerAcc, spenderAcc, amount / 2);\n        uint256 allowanceAfter2 = ousd.allowance(owner, spender);\n\n        assert(allowanceAfter2 == amount / 2);\n    }\n\n    /**\n     * @notice Increasing the allowance should raise it by the amount provided\n     * @param ownerAcc The account that is approving\n     * @param spenderAcc The account that is being approved\n     * @param amount The amount to approve\n     */\n    function testIncreaseAllowance(\n        uint8 ownerAcc,\n        uint8 spenderAcc,\n        uint256 amount\n    ) public {\n        address owner = getAccount(ownerAcc);\n        address spender = getAccount(spenderAcc);\n\n        uint256 allowanceBefore = ousd.allowance(owner, spender);\n        increaseAllowance(ownerAcc, spenderAcc, amount);\n        uint256 allowanceAfter = ousd.allowance(owner, spender);\n\n        assert(allowanceAfter == allowanceBefore + amount);\n    }\n\n    /**\n     * @notice Decreasing the allowance should lower it by the amount provided\n     * @param ownerAcc The account that is approving\n     * @param spenderAcc The account that is being approved\n     * @param amount The amount to approve\n     */\n    function testDecreaseAllowance(\n        uint8 ownerAcc,\n        uint8 spenderAcc,\n        uint256 amount\n    ) public {\n        address owner = getAccount(ownerAcc);\n        address spender = getAccount(spenderAcc);\n\n        uint256 allowanceBefore = ousd.allowance(owner, spender);\n        decreaseAllowance(ownerAcc, spenderAcc, amount);\n        uint256 allowanceAfter = ousd.allowance(owner, spender);\n\n        assert(allowanceAfter == allowanceBefore - amount);\n    }\n}\n"
    },
    "contracts/echidna/EchidnaTestMintBurn.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./EchidnaDebug.sol\";\nimport \"./EchidnaTestAccounting.sol\";\n\n/**\n * @title Mixin for testing Mint and Burn functions\n * @author Rappie\n */\ncontract EchidnaTestMintBurn is EchidnaTestAccounting {\n    /**\n     * @notice Minting 0 tokens should not affect account balance\n     * @param targetAcc Account to mint to\n     */\n    function testMintZeroBalance(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        mint(targetAcc, 0);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        assert(balanceAfter == balanceBefore);\n    }\n\n    /**\n     * @notice Burning 0 tokens should not affect account balance\n     * @param targetAcc Account to burn from\n     */\n    function testBurnZeroBalance(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        burn(targetAcc, 0);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        assert(balanceAfter == balanceBefore);\n    }\n\n    /**\n     * @notice Minting tokens must increase the account balance by at least amount\n     * @param targetAcc Account to mint to\n     * @param amount Amount to mint\n     * @custom:error testMintBalance(uint8,uint256): failed!\n     *   Call sequence:\n     *       changeSupply(1)\n     *       testMintBalance(0,1)\n     *   Event sequence:\n     *       Debug(balanceBefore, 0)\n     *       Debug(balanceAfter, 0)\n     */\n    function testMintBalance(uint8 targetAcc, uint256 amount)\n        public\n        hasKnownIssue\n        hasKnownIssueWithinLimits\n    {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        uint256 amountMinted = mint(targetAcc, amount);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        Debugger.log(\"amountMinted\", amountMinted);\n        Debugger.log(\"balanceBefore\", balanceBefore);\n        Debugger.log(\"balanceAfter\", balanceAfter);\n\n        assert(balanceAfter >= balanceBefore + amountMinted);\n    }\n\n    /**\n     * @notice Burning tokens must decrease the account balance by at least amount\n     * @param targetAcc Account to burn from\n     * @param amount Amount to burn\n     * @custom:error testBurnBalance(uint8,uint256): failed!\n     *   Call sequence:\n     *       changeSupply(1)\n     *       mint(0,3)\n     *       testBurnBalance(0,1)\n     *   Event sequence:\n     *       Debug(balanceBefore, 2)\n     *       Debug(balanceAfter, 2)\n     */\n    function testBurnBalance(uint8 targetAcc, uint256 amount)\n        public\n        hasKnownIssue\n        hasKnownIssueWithinLimits\n    {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        burn(targetAcc, amount);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        Debugger.log(\"balanceBefore\", balanceBefore);\n        Debugger.log(\"balanceAfter\", balanceAfter);\n\n        assert(balanceAfter <= balanceBefore - amount);\n    }\n\n    /**\n     * @notice Minting tokens should not increase the account balance by less than rounding error above amount\n     * @param targetAcc Account to mint to\n     * @param amount Amount to mint\n     */\n    function testMintBalanceRounding(uint8 targetAcc, uint256 amount) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        uint256 amountMinted = mint(targetAcc, amount);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        int256 delta = int256(balanceAfter) - int256(balanceBefore);\n\n        // delta == amount, if no error\n        // delta < amount,  if too little is minted\n        // delta > amount,  if too much is minted\n        int256 error = int256(amountMinted) - delta;\n\n        assert(error >= 0);\n        assert(error <= int256(MINT_ROUNDING_ERROR));\n    }\n\n    /**\n     * @notice A burn of an account balance must result in a zero balance\n     * @param targetAcc Account to burn from\n     */\n    function testBurnAllBalanceToZero(uint8 targetAcc) public hasKnownIssue {\n        address target = getAccount(targetAcc);\n\n        burn(targetAcc, ousd.balanceOf(target));\n        assert(ousd.balanceOf(target) == 0);\n    }\n\n    /**\n     * @notice You should always be able to burn an account's balance\n     * @param targetAcc Account to burn from\n     */\n    function testBurnAllBalanceShouldNotRevert(uint8 targetAcc)\n        public\n        hasKnownIssue\n    {\n        address target = getAccount(targetAcc);\n        uint256 balance = ousd.balanceOf(target);\n\n        hevm.prank(ADDRESS_VAULT);\n        try ousd.burn(target, balance) {\n            assert(true);\n        } catch {\n            assert(false);\n        }\n    }\n}\n"
    },
    "contracts/echidna/EchidnaTestSupply.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./EchidnaDebug.sol\";\nimport \"./EchidnaTestTransfer.sol\";\n\nimport { StableMath } from \"../utils/StableMath.sol\";\n\n/**\n * @title Mixin for testing supply related functions\n * @author Rappie\n */\ncontract EchidnaTestSupply is EchidnaTestTransfer {\n    using StableMath for uint256;\n\n    uint256 prevRebasingCreditsPerToken = type(uint256).max;\n\n    /**\n     * @notice After a `changeSupply`, the total supply should exactly\n     * match the target total supply. (This is needed to ensure successive\n     * rebases are correct).\n     * @param supply New total supply\n     * @custom:error testChangeSupply(uint256): failed!\n     *   Call sequence:\n     *       testChangeSupply(1044505275072865171609)\n     *   Event sequence:\n     *       TotalSupplyUpdatedHighres(1044505275072865171610, 1000000000000000000000000, 957391048054055578595)\n     */\n    function testChangeSupply(uint256 supply)\n        public\n        hasKnownIssue\n        hasKnownIssueWithinLimits\n    {\n        hevm.prank(ADDRESS_VAULT);\n        ousd.changeSupply(supply);\n\n        assert(ousd.totalSupply() == supply);\n    }\n\n    /**\n     * @notice The total supply must not be less than the sum of account balances.\n     * (The difference will go into future rebases)\n     * @custom:error testTotalSupplyLessThanTotalBalance(): failed!\n     *   Call sequence:\n     *     mint(0,1)\n     *     changeSupply(1)\n     *     optOut(64)\n     *     transfer(0,64,1)\n     *     testTotalSupplyLessThanTotalBalance()\n     *   Event sequence:\n     *     Debug(totalSupply, 1000000000000000001000001)\n     *     Debug(totalBalance, 1000000000000000001000002)\n     */\n    function testTotalSupplyLessThanTotalBalance()\n        public\n        hasKnownIssue\n        hasKnownIssueWithinLimits\n    {\n        uint256 totalSupply = ousd.totalSupply();\n        uint256 totalBalance = getTotalBalance();\n\n        Debugger.log(\"totalSupply\", totalSupply);\n        Debugger.log(\"totalBalance\", totalBalance);\n\n        assert(totalSupply >= totalBalance);\n    }\n\n    /**\n     * @notice Non-rebasing supply should not be larger than total supply\n     * @custom:error testNonRebasingSupplyVsTotalSupply(): failed!\n     *   Call sequence:\n     *     mint(0,2)\n     *     changeSupply(3)\n     *     burn(0,1)\n     *     optOut(0)\n     *     testNonRebasingSupplyVsTotalSupply()\n     */\n    function testNonRebasingSupplyVsTotalSupply() public hasKnownIssue {\n        uint256 nonRebasingSupply = ousd.nonRebasingSupply();\n        uint256 totalSupply = ousd.totalSupply();\n\n        assert(nonRebasingSupply <= totalSupply);\n    }\n\n    /**\n     * @notice Global `rebasingCreditsPerToken` should never increase\n     * @custom:error testRebasingCreditsPerTokenNotIncreased(): failed!\n     *   Call sequence:\n     *     testRebasingCreditsPerTokenNotIncreased()\n     *     changeSupply(1)\n     *     testRebasingCreditsPerTokenNotIncreased()\n     */\n    function testRebasingCreditsPerTokenNotIncreased() public hasKnownIssue {\n        uint256 curRebasingCreditsPerToken = ousd\n            .rebasingCreditsPerTokenHighres();\n\n        Debugger.log(\n            \"prevRebasingCreditsPerToken\",\n            prevRebasingCreditsPerToken\n        );\n        Debugger.log(\"curRebasingCreditsPerToken\", curRebasingCreditsPerToken);\n\n        assert(curRebasingCreditsPerToken <= prevRebasingCreditsPerToken);\n\n        prevRebasingCreditsPerToken = curRebasingCreditsPerToken;\n    }\n\n    /**\n     * @notice The rebasing credits per token ratio must greater than zero\n     */\n    function testRebasingCreditsPerTokenAboveZero() public {\n        assert(ousd.rebasingCreditsPerTokenHighres() > 0);\n    }\n\n    /**\n     * @notice The sum of all non-rebasing balances should not be larger than\n     * non-rebasing supply\n     * @custom:error testTotalNonRebasingSupplyLessThanTotalBalance(): failed!\n     *   Call sequence\n     *     mint(0,2)\n     *     changeSupply(1)\n     *     optOut(0)\n     *     burn(0,1)\n     *     testTotalNonRebasingSupplyLessThanTotalBalance()\n     *   Event sequence:\n     *     Debug(totalNonRebasingSupply, 500000000000000000000001)\n     *     Debug(totalNonRebasingBalance, 500000000000000000000002)\n     */\n    function testTotalNonRebasingSupplyLessThanTotalBalance()\n        public\n        hasKnownIssue\n        hasKnownIssueWithinLimits\n    {\n        uint256 totalNonRebasingSupply = ousd.nonRebasingSupply();\n        uint256 totalNonRebasingBalance = getTotalNonRebasingBalance();\n\n        Debugger.log(\"totalNonRebasingSupply\", totalNonRebasingSupply);\n        Debugger.log(\"totalNonRebasingBalance\", totalNonRebasingBalance);\n\n        assert(totalNonRebasingSupply >= totalNonRebasingBalance);\n    }\n\n    /**\n     * @notice An accounts credits / credits per token should not be larger it's balance\n     * @param targetAcc The account to check\n     */\n    function testCreditsPerTokenVsBalance(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        (uint256 credits, uint256 creditsPerToken, ) = ousd\n            .creditsBalanceOfHighres(target);\n        uint256 expectedBalance = credits.divPrecisely(creditsPerToken);\n\n        uint256 balance = ousd.balanceOf(target);\n\n        Debugger.log(\"credits\", credits);\n        Debugger.log(\"creditsPerToken\", creditsPerToken);\n        Debugger.log(\"expectedBalance\", expectedBalance);\n        Debugger.log(\"balance\", balance);\n\n        assert(expectedBalance == balance);\n    }\n}\n"
    },
    "contracts/echidna/EchidnaTestTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./EchidnaDebug.sol\";\nimport \"./Debugger.sol\";\n\n/**\n * @title Mixin for testing transfer related functions\n * @author Rappie\n */\ncontract EchidnaTestTransfer is EchidnaDebug {\n    /**\n     * @notice The receiving account's balance after a transfer must not increase by\n     * less than the amount transferred\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     * @custom:error testTransferBalanceReceivedLess(uint8,uint8,uint256): failed!\n     *   Call sequence:\n     *     changeSupply(1)\n     *     mint(64,2)\n     *     testTransferBalanceReceivedLess(64,0,1)\n     *   Event sequence:\n     *     Debug(totalSupply, 1000000000000000000500002)\n     *     Debug(toBalBefore, 0)\n     *     Debug(toBalAfter, 0)\n     */\n    function testTransferBalanceReceivedLess(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public hasKnownIssue hasKnownIssueWithinLimits {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(from != to);\n\n        uint256 toBalBefore = ousd.balanceOf(to);\n        transfer(fromAcc, toAcc, amount);\n        uint256 toBalAfter = ousd.balanceOf(to);\n\n        Debugger.log(\"totalSupply\", ousd.totalSupply());\n        Debugger.log(\"toBalBefore\", toBalBefore);\n        Debugger.log(\"toBalAfter\", toBalAfter);\n\n        assert(toBalAfter >= toBalBefore + amount);\n    }\n\n    /**\n     * @notice The receiving account's balance after a transfer must not\n     * increase by more than the amount transferred\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function testTransferBalanceReceivedMore(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(from != to);\n\n        uint256 toBalBefore = ousd.balanceOf(to);\n        transfer(fromAcc, toAcc, amount);\n        uint256 toBalAfter = ousd.balanceOf(to);\n\n        Debugger.log(\"totalSupply\", ousd.totalSupply());\n        Debugger.log(\"toBalBefore\", toBalBefore);\n        Debugger.log(\"toBalAfter\", toBalAfter);\n\n        assert(toBalAfter <= toBalBefore + amount);\n    }\n\n    /**\n     * @notice The sending account's balance after a transfer must not\n     * decrease by less than the amount transferred\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     * @custom:error testTransferBalanceSentLess(uint8,uint8,uint256): failed!\n     *   Call sequence:\n     *     mint(0,1)\n     *     changeSupply(1)\n     *     testTransferBalanceSentLess(0,64,1)\n     *   Event sequence:\n     *     Debug(totalSupply, 1000000000000000000500001)\n     *     Debug(fromBalBefore, 1)\n     *     Debug(fromBalAfter, 1)\n     */\n    function testTransferBalanceSentLess(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public hasKnownIssue hasKnownIssueWithinLimits {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(from != to);\n\n        uint256 fromBalBefore = ousd.balanceOf(from);\n        transfer(fromAcc, toAcc, amount);\n        uint256 fromBalAfter = ousd.balanceOf(from);\n\n        Debugger.log(\"totalSupply\", ousd.totalSupply());\n        Debugger.log(\"fromBalBefore\", fromBalBefore);\n        Debugger.log(\"fromBalAfter\", fromBalAfter);\n\n        assert(fromBalAfter <= fromBalBefore - amount);\n    }\n\n    /**\n     * @notice The sending account's balance after a transfer must not\n     * decrease by more than the amount transferred\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function testTransferBalanceSentMore(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(from != to);\n\n        uint256 fromBalBefore = ousd.balanceOf(from);\n        transfer(fromAcc, toAcc, amount);\n        uint256 fromBalAfter = ousd.balanceOf(from);\n\n        Debugger.log(\"totalSupply\", ousd.totalSupply());\n        Debugger.log(\"fromBalBefore\", fromBalBefore);\n        Debugger.log(\"fromBalAfter\", fromBalAfter);\n\n        assert(fromBalAfter >= fromBalBefore - amount);\n    }\n\n    /**\n     * @notice The receiving account's balance after a transfer must not\n     * increase by less than the amount transferred (minus rounding error)\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function testTransferBalanceReceivedLessRounding(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(from != to);\n\n        uint256 toBalBefore = ousd.balanceOf(to);\n        transfer(fromAcc, toAcc, amount);\n        uint256 toBalAfter = ousd.balanceOf(to);\n\n        int256 toDelta = int256(toBalAfter) - int256(toBalBefore);\n\n        // delta == amount, if no error\n        // delta < amount,  if too little is sent\n        // delta > amount,  if too much is sent\n        int256 error = int256(amount) - toDelta;\n\n        Debugger.log(\"totalSupply\", ousd.totalSupply());\n        Debugger.log(\"toBalBefore\", toBalBefore);\n        Debugger.log(\"toBalAfter\", toBalAfter);\n        Debugger.log(\"toDelta\", toDelta);\n        Debugger.log(\"error\", error);\n\n        assert(error >= 0);\n        assert(error <= int256(TRANSFER_ROUNDING_ERROR));\n    }\n\n    /**\n     * @notice The sending account's balance after a transfer must\n     * not decrease by less than the amount transferred (minus rounding error)\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function testTransferBalanceSentLessRounding(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(from != to);\n\n        uint256 fromBalBefore = ousd.balanceOf(from);\n        transfer(fromAcc, toAcc, amount);\n        uint256 fromBalAfter = ousd.balanceOf(from);\n\n        int256 fromDelta = int256(fromBalAfter) - int256(fromBalBefore);\n\n        // delta == -amount, if no error\n        // delta < -amount,  if too much is sent\n        // delta > -amount,  if too little is sent\n        int256 error = int256(amount) + fromDelta;\n\n        Debugger.log(\"totalSupply\", ousd.totalSupply());\n        Debugger.log(\"fromBalBefore\", fromBalBefore);\n        Debugger.log(\"fromBalAfter\", fromBalAfter);\n        Debugger.log(\"fromDelta\", fromDelta);\n        Debugger.log(\"error\", error);\n\n        assert(error >= 0);\n        assert(error <= int256(TRANSFER_ROUNDING_ERROR));\n    }\n\n    /**\n     * @notice An account should always be able to successfully transfer\n     * an amount within its balance.\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     * @custom:error testTransferWithinBalanceDoesNotRevert(uint8,uint8,uint8): failed!\n     *   Call sequence:\n     *       mint(0,1)\n     *       changeSupply(3)\n     *       optOut(0)\n     *       testTransferWithinBalanceDoesNotRevert(0,128,2)\n     *       optIn(0)\n     *       testTransferWithinBalanceDoesNotRevert(128,0,1)\n     *   Event sequence:\n     *       error Revert Panic(17): SafeMath over-/under-flows\n     */\n    function testTransferWithinBalanceDoesNotRevert(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public hasKnownIssue {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(amount > 0);\n        amount = amount % ousd.balanceOf(from);\n\n        Debugger.log(\"Total supply\", ousd.totalSupply());\n\n        hevm.prank(from);\n        // slither-disable-next-line unchecked-transfer\n        try ousd.transfer(to, amount) {\n            assert(true);\n        } catch {\n            assert(false);\n        }\n    }\n\n    /**\n     * @notice An account should never be able to successfully transfer\n     * an amount greater than their balance.\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function testTransferExceedingBalanceReverts(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        amount = ousd.balanceOf(from) + 1 + amount;\n\n        hevm.prank(from);\n        // slither-disable-next-line unchecked-transfer\n        try ousd.transfer(to, amount) {\n            assert(false);\n        } catch {\n            assert(true);\n        }\n    }\n\n    /**\n     * @notice A transfer to the same account should not change that account's balance\n     * @param targetAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function testTransferSelf(uint8 targetAcc, uint256 amount) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        transfer(targetAcc, targetAcc, amount);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        assert(balanceBefore == balanceAfter);\n    }\n\n    /**\n     * @notice Transfers to the zero account revert\n     * @param fromAcc Account to transfer from\n     * @param amount Amount to transfer\n     */\n    function testTransferToZeroAddress(uint8 fromAcc, uint256 amount) public {\n        address from = getAccount(fromAcc);\n\n        hevm.prank(from);\n        // slither-disable-next-line unchecked-transfer\n        try ousd.transfer(address(0), amount) {\n            assert(false);\n        } catch {\n            assert(true);\n        }\n    }\n}\n"
    },
    "contracts/echidna/IHevm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// https://github.com/ethereum/hevm/blob/main/doc/src/controlling-the-unit-testing-environment.md#cheat-codes\n\ninterface IHevm {\n    function warp(uint256 x) external;\n\n    function roll(uint256 x) external;\n\n    function store(\n        address c,\n        bytes32 loc,\n        bytes32 val\n    ) external;\n\n    function load(address c, bytes32 loc) external returns (bytes32 val);\n\n    function sign(uint256 sk, bytes32 digest)\n        external\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        );\n\n    function addr(uint256 sk) external returns (address addr);\n\n    function ffi(string[] calldata) external returns (bytes memory);\n\n    function prank(address sender) external;\n}\n"
    },
    "contracts/echidna/OUSDEchidna.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../token/OUSD.sol\";\n\ncontract OUSDEchidna is OUSD {\n    constructor() OUSD() {}\n\n    function _isNonRebasingAccountEchidna(address _account)\n        public\n        returns (bool)\n    {\n        return _isNonRebasingAccount(_account);\n    }\n}\n"
    },
    "contracts/flipper/Flipper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../governance/Governable.sol\";\nimport \"../token/OUSD.sol\";\nimport \"../interfaces/Tether.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Contract to exchange usdt, usdc, dai from and to ousd.\n//   - 1 to 1. No slippage\n//   - Optimized for low gas usage\n//   - No guarantee of availability\n\ncontract Flipper is Governable {\n    using SafeERC20 for IERC20;\n\n    uint256 constant MAXIMUM_PER_TRADE = (25000 * 1e18);\n\n    // Settable coin addresses allow easy testing and use of mock currencies.\n    IERC20 immutable dai;\n    OUSD immutable ousd;\n    IERC20 immutable usdc;\n    Tether immutable usdt;\n\n    // ---------------------\n    // Dev constructor\n    // ---------------------\n    constructor(\n        address _dai,\n        address _ousd,\n        address _usdc,\n        address _usdt\n    ) {\n        require(address(_dai) != address(0));\n        require(address(_ousd) != address(0));\n        require(address(_usdc) != address(0));\n        require(address(_usdt) != address(0));\n        dai = IERC20(_dai);\n        ousd = OUSD(_ousd);\n        usdc = IERC20(_usdc);\n        usdt = Tether(_usdt);\n    }\n\n    // -----------------\n    // Trading functions\n    // -----------------\n\n    /// @notice Purchase OUSD with Dai\n    /// @param amount Amount of OUSD to purchase, in 18 fixed decimals.\n    function buyOusdWithDai(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        require(\n            dai.transferFrom(msg.sender, address(this), amount),\n            \"DAI transfer failed\"\n        );\n        require(ousd.transfer(msg.sender, amount), \"OUSD transfer failed\");\n    }\n\n    /// @notice Sell OUSD for Dai\n    /// @param amount Amount of OUSD to sell, in 18 fixed decimals.\n    function sellOusdForDai(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        require(dai.transfer(msg.sender, amount), \"DAI transfer failed\");\n        require(\n            ousd.transferFrom(msg.sender, address(this), amount),\n            \"OUSD transfer failed\"\n        );\n    }\n\n    /// @notice Purchase OUSD with USDC\n    /// @param amount Amount of OUSD to purchase, in 18 fixed decimals.\n    function buyOusdWithUsdc(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        // Potential rounding error is an intentional trade off\n        require(\n            usdc.transferFrom(msg.sender, address(this), amount / 1e12),\n            \"USDC transfer failed\"\n        );\n        require(ousd.transfer(msg.sender, amount), \"OUSD transfer failed\");\n    }\n\n    /// @notice Sell OUSD for USDC\n    /// @param amount Amount of OUSD to sell, in 18 fixed decimals.\n    function sellOusdForUsdc(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        require(\n            usdc.transfer(msg.sender, amount / 1e12),\n            \"USDC transfer failed\"\n        );\n        require(\n            ousd.transferFrom(msg.sender, address(this), amount),\n            \"OUSD transfer failed\"\n        );\n    }\n\n    /// @notice Purchase OUSD with USDT\n    /// @param amount Amount of OUSD to purchase, in 18 fixed decimals.\n    function buyOusdWithUsdt(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        // Potential rounding error is an intentional trade off\n        // USDT does not return a boolean and reverts,\n        // so no need for a require.\n        usdt.transferFrom(msg.sender, address(this), amount / 1e12);\n        require(ousd.transfer(msg.sender, amount), \"OUSD transfer failed\");\n    }\n\n    /// @notice Sell OUSD for USDT\n    /// @param amount Amount of OUSD to sell, in 18 fixed decimals.\n    function sellOusdForUsdt(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        // USDT does not return a boolean and reverts,\n        // so no need for a require.\n        usdt.transfer(msg.sender, amount / 1e12);\n        require(\n            ousd.transferFrom(msg.sender, address(this), amount),\n            \"OUSD transfer failed\"\n        );\n    }\n\n    // --------------------\n    // Governance functions\n    // --------------------\n\n    /// @dev Opting into yield reduces the gas cost per transfer by about 4K, since\n    /// ousd needs to do less accounting and one less storage write.\n    function rebaseOptIn() external onlyGovernor nonReentrant {\n        ousd.rebaseOptIn();\n    }\n\n    /// @notice Owner function to withdraw a specific amount of a token\n    function withdraw(address token, uint256 amount)\n        external\n        onlyGovernor\n        nonReentrant\n    {\n        IERC20(token).safeTransfer(_governor(), amount);\n    }\n\n    /// @notice Owner function to withdraw all tradable tokens\n    /// @dev Contract will not perform any swaps until liquidity is provided\n    /// again by transferring assets to the contract.\n    function withdrawAll() external onlyGovernor nonReentrant {\n        IERC20(dai).safeTransfer(_governor(), dai.balanceOf(address(this)));\n        IERC20(ousd).safeTransfer(_governor(), ousd.balanceOf(address(this)));\n        IERC20(address(usdt)).safeTransfer(\n            _governor(),\n            usdt.balanceOf(address(this))\n        );\n        IERC20(usdc).safeTransfer(_governor(), usdc.balanceOf(address(this)));\n    }\n}\n"
    },
    "contracts/governance/Governable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Base for contracts that are managed by the Origin Protocol's Governor.\n * @dev Copy of the openzeppelin Ownable.sol contract with nomenclature change\n *      from owner to governor and renounce methods removed. Does not use\n *      Context.sol like Ownable.sol does for simplification.\n * @author Origin Protocol Inc\n */\ncontract Governable {\n    // Storage position of the owner and pendingOwner of the contract\n    // keccak256(\"OUSD.governor\");\n    bytes32 private constant governorPosition =\n        0x7bea13895fa79d2831e0a9e28edede30099005a50d652d8957cf8a607ee6ca4a;\n\n    // keccak256(\"OUSD.pending.governor\");\n    bytes32 private constant pendingGovernorPosition =\n        0x44c4d30b2eaad5130ad70c3ba6972730566f3e6359ab83e800d905c61b1c51db;\n\n    // keccak256(\"OUSD.reentry.status\");\n    bytes32 private constant reentryStatusPosition =\n        0x53bf423e48ed90e97d02ab0ebab13b2a235a6bfbe9c321847d5c175333ac4535;\n\n    // See OpenZeppelin ReentrancyGuard implementation\n    uint256 constant _NOT_ENTERED = 1;\n    uint256 constant _ENTERED = 2;\n\n    event PendingGovernorshipTransfer(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    event GovernorshipTransferred(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial Governor.\n     */\n    constructor() {\n        _setGovernor(msg.sender);\n        emit GovernorshipTransferred(address(0), _governor());\n    }\n\n    /**\n     * @notice Returns the address of the current Governor.\n     */\n    function governor() public view returns (address) {\n        return _governor();\n    }\n\n    /**\n     * @dev Returns the address of the current Governor.\n     */\n    function _governor() internal view returns (address governorOut) {\n        bytes32 position = governorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            governorOut := sload(position)\n        }\n    }\n\n    /**\n     * @dev Returns the address of the pending Governor.\n     */\n    function _pendingGovernor()\n        internal\n        view\n        returns (address pendingGovernor)\n    {\n        bytes32 position = pendingGovernorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            pendingGovernor := sload(position)\n        }\n    }\n\n    /**\n     * @dev Throws if called by any account other than the Governor.\n     */\n    modifier onlyGovernor() {\n        require(isGovernor(), \"Caller is not the Governor\");\n        _;\n    }\n\n    /**\n     * @notice Returns true if the caller is the current Governor.\n     */\n    function isGovernor() public view returns (bool) {\n        return msg.sender == _governor();\n    }\n\n    function _setGovernor(address newGovernor) internal {\n        bytes32 position = governorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, newGovernor)\n        }\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        bytes32 position = reentryStatusPosition;\n        uint256 _reentry_status;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _reentry_status := sload(position)\n        }\n\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_reentry_status != _ENTERED, \"Reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, _ENTERED)\n        }\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, _NOT_ENTERED)\n        }\n    }\n\n    function _setPendingGovernor(address newGovernor) internal {\n        bytes32 position = pendingGovernorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, newGovernor)\n        }\n    }\n\n    /**\n     * @notice Transfers Governance of the contract to a new account (`newGovernor`).\n     * Can only be called by the current Governor. Must be claimed for this to complete\n     * @param _newGovernor Address of the new Governor\n     */\n    function transferGovernance(address _newGovernor) external onlyGovernor {\n        _setPendingGovernor(_newGovernor);\n        emit PendingGovernorshipTransfer(_governor(), _newGovernor);\n    }\n\n    /**\n     * @notice Claim Governance of the contract to a new account (`newGovernor`).\n     * Can only be called by the new Governor.\n     */\n    function claimGovernance() external {\n        require(\n            msg.sender == _pendingGovernor(),\n            \"Only the pending Governor can complete the claim\"\n        );\n        _changeGovernor(msg.sender);\n    }\n\n    /**\n     * @dev Change Governance of the contract to a new account (`newGovernor`).\n     * @param _newGovernor Address of the new Governor\n     */\n    function _changeGovernor(address _newGovernor) internal {\n        require(_newGovernor != address(0), \"New Governor is address(0)\");\n        emit GovernorshipTransferred(_governor(), _newGovernor);\n        _setGovernor(_newGovernor);\n    }\n}\n"
    },
    "contracts/governance/Governor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./../timelock/Timelock.sol\";\n\n// Modeled off of Compound's Governor Alpha\n//    https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorAlpha.sol\ncontract Governor is Timelock {\n    // @notice The total number of proposals\n    uint256 public proposalCount;\n\n    struct Proposal {\n        // @notice Unique id for looking up a proposal\n        uint256 id;\n        // @notice Creator of the proposal\n        address proposer;\n        // @notice The timestamp that the proposal will be available for\n        // execution, set once the vote succeeds\n        uint256 eta;\n        // @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        // @notice The ordered list of function signatures to be called\n        string[] signatures;\n        // @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        // @notice Flag marking whether the proposal has been executed\n        bool executed;\n    }\n\n    // @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n\n    // @notice An event emitted when a new proposal is created\n    event ProposalCreated(\n        uint256 id,\n        address proposer,\n        address[] targets,\n        string[] signatures,\n        bytes[] calldatas,\n        string description\n    );\n\n    // @notice An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint256 id, uint256 eta);\n\n    // @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint256 id);\n\n    // @notice An event emitted when a proposal has been cancelled\n    event ProposalCancelled(uint256 id);\n\n    uint256 public constant MAX_OPERATIONS = 32;\n\n    // @notice Possible states that a proposal may be in\n    enum ProposalState {\n        Pending,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    constructor(address admin_, uint256 delay_) Timelock(admin_, delay_) {}\n\n    /**\n     * @notice Propose Governance call(s)\n     * @param targets Ordered list of targeted addresses\n     * @param signatures Orderd list of function signatures to be called\n     * @param calldatas Orderded list of calldata to be passed with each call\n     * @param description Description of the governance\n     * @return uint256 id of the proposal\n     */\n    function propose(\n        address[] memory targets,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256) {\n        // Allow anyone to propose for now, since only admin can queue the\n        // transaction it should be harmless, you just need to pay the gas\n        require(\n            targets.length == signatures.length &&\n                targets.length == calldatas.length,\n            \"Governor::propose: proposal function information arity mismatch\"\n        );\n        require(targets.length != 0, \"Governor::propose: must provide actions\");\n        require(\n            targets.length <= MAX_OPERATIONS,\n            \"Governor::propose: too many actions\"\n        );\n\n        proposalCount++;\n        Proposal memory newProposal = Proposal({\n            id: proposalCount,\n            proposer: msg.sender,\n            eta: 0,\n            targets: targets,\n            signatures: signatures,\n            calldatas: calldatas,\n            executed: false\n        });\n\n        proposals[newProposal.id] = newProposal;\n\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            signatures,\n            calldatas,\n            description\n        );\n        return newProposal.id;\n    }\n\n    /**\n     * @notice Queue a proposal for execution\n     * @param proposalId id of the proposal to queue\n     */\n    function queue(uint256 proposalId) public onlyAdmin {\n        require(\n            state(proposalId) == ProposalState.Pending,\n            \"Governor::queue: proposal can only be queued if it is pending\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        proposal.eta = block.timestamp + delay;\n\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            _queueOrRevert(\n                proposal.targets[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalQueued(proposal.id, proposal.eta);\n    }\n\n    /**\n     * @notice Get the state of a proposal\n     * @param proposalId id of the proposal\n     * @return ProposalState\n     */\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(\n            proposalCount >= proposalId && proposalId > 0,\n            \"Governor::state: invalid proposal id\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Pending;\n        } else if (block.timestamp >= proposal.eta + GRACE_PERIOD) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    function _queueOrRevert(\n        address target,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            !queuedTransactions[\n                keccak256(abi.encode(target, signature, keccak256(data), eta))\n            ],\n            \"Governor::_queueOrRevert: proposal action already queued at eta\"\n        );\n        require(\n            queuedTransactions[queueTransaction(target, signature, data, eta)],\n            \"Governor::_queueOrRevert: failed to queue transaction\"\n        );\n    }\n\n    /**\n     * @notice Execute a proposal.\n     * @param proposalId id of the proposal\n     */\n    function execute(uint256 proposalId) public {\n        require(\n            state(proposalId) == ProposalState.Queued,\n            \"Governor::execute: proposal can only be executed if it is queued\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            executeTransaction(\n                proposal.targets[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Cancel a proposal.\n     * @param proposalId id of the proposal\n     */\n    function cancel(uint256 proposalId) public onlyAdmin {\n        ProposalState proposalState = state(proposalId);\n\n        require(\n            proposalState == ProposalState.Queued ||\n                proposalState == ProposalState.Pending,\n            \"Governor::execute: proposal can only be cancelled if it is queued or pending\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        proposal.eta = 1; // To mark the proposal as `Expired`\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            cancelTransaction(\n                proposal.targets[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalCancelled(proposalId);\n    }\n\n    /**\n     * @notice Get the actions that a proposal will take.\n     * @param proposalId id of the proposal\n     */\n    function getActions(uint256 proposalId)\n        public\n        view\n        returns (\n            address[] memory targets,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.signatures, p.calldatas);\n    }\n}\n"
    },
    "contracts/governance/InitializableGovernable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD InitializableGovernable Contract\n * @author Origin Protocol Inc\n */\nimport { Initializable } from \"../utils/Initializable.sol\";\n\nimport { Governable } from \"./Governable.sol\";\n\ncontract InitializableGovernable is Governable, Initializable {\n    function _initialize(address _newGovernor) internal {\n        _changeGovernor(_newGovernor);\n    }\n}\n"
    },
    "contracts/governance/Strategizable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Governable } from \"./Governable.sol\";\n\ncontract Strategizable is Governable {\n    event StrategistUpdated(address _address);\n\n    // Address of strategist\n    address public strategistAddr;\n\n    // For future use\n    uint256[50] private __gap;\n\n    /**\n     * @dev Verifies that the caller is either Governor or Strategist.\n     */\n    modifier onlyGovernorOrStrategist() {\n        require(\n            msg.sender == strategistAddr || isGovernor(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Set address of Strategist\n     * @param _address Address of Strategist\n     */\n    function setStrategistAddr(address _address) external onlyGovernor {\n        _setStrategistAddr(_address);\n    }\n\n    /**\n     * @dev Set address of Strategist\n     * @param _address Address of Strategist\n     */\n    function _setStrategistAddr(address _address) internal {\n        strategistAddr = _address;\n        emit StrategistUpdated(_address);\n    }\n}\n"
    },
    "contracts/harvest/AbstractHarvester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\nimport { IUniswapV2Router } from \"../interfaces/uniswap/IUniswapV2Router02.sol\";\nimport { IUniswapV3Router } from \"../interfaces/uniswap/IUniswapV3Router.sol\";\nimport { IBalancerVault } from \"../interfaces/balancer/IBalancerVault.sol\";\nimport { ICurvePool } from \"../strategies/ICurvePool.sol\";\nimport \"../utils/Helpers.sol\";\n\nabstract contract AbstractHarvester is Governable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using StableMath for uint256;\n\n    enum SwapPlatform {\n        UniswapV2Compatible,\n        UniswapV3,\n        Balancer,\n        Curve\n    }\n\n    event SupportedStrategyUpdate(address strategyAddress, bool isSupported);\n    event RewardTokenConfigUpdated(\n        address tokenAddress,\n        uint16 allowedSlippageBps,\n        uint16 harvestRewardBps,\n        SwapPlatform swapPlatform,\n        address swapPlatformAddr,\n        bytes swapData,\n        uint256 liquidationLimit,\n        bool doSwapRewardToken\n    );\n    event RewardTokenSwapped(\n        address indexed rewardToken,\n        address indexed swappedInto,\n        SwapPlatform swapPlatform,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    event RewardProceedsTransferred(\n        address indexed token,\n        address farmer,\n        uint256 protcolYield,\n        uint256 farmerFee\n    );\n    event RewardProceedsAddressChanged(address newProceedsAddress);\n\n    error EmptyAddress();\n    error InvalidSlippageBps();\n    error InvalidHarvestRewardBps();\n\n    error InvalidSwapPlatform(SwapPlatform swapPlatform);\n\n    error InvalidUniswapV2PathLength();\n    error InvalidTokenInSwapPath(address token);\n    error EmptyBalancerPoolId();\n    error InvalidCurvePoolAssetIndex(address token);\n\n    error UnsupportedStrategy(address strategyAddress);\n\n    error SlippageError(uint256 actualBalance, uint256 minExpected);\n    error BalanceMismatchAfterSwap(uint256 actualBalance, uint256 minExpected);\n\n    // Configuration properties for harvesting logic of reward tokens\n    struct RewardTokenConfig {\n        // Max allowed slippage when swapping reward token for a stablecoin denominated in basis points.\n        uint16 allowedSlippageBps;\n        // Reward when calling a harvest function denominated in basis points.\n        uint16 harvestRewardBps;\n        // Address of compatible exchange protocol (Uniswap V2/V3, SushiSwap, Balancer and Curve).\n        address swapPlatformAddr;\n        /* When true the reward token is being swapped. In a need of (temporarily) disabling the swapping of\n         * a reward token this needs to be set to false.\n         */\n        bool doSwapRewardToken;\n        // Platform to use for Swapping\n        SwapPlatform swapPlatform;\n        /* How much token can be sold per one harvest call. If the balance of rewards tokens\n         * exceeds that limit multiple harvest calls are required to harvest all of the tokens.\n         * Set it to MAX_INT to effectively disable the limit.\n         */\n        uint256 liquidationLimit;\n    }\n\n    mapping(address => RewardTokenConfig) public rewardTokenConfigs;\n    mapping(address => bool) public supportedStrategies;\n\n    address public immutable vaultAddress;\n\n    /**\n     * Address receiving rewards proceeds. Initially the Vault contract later will possibly\n     * be replaced by another contract that eases out rewards distribution.\n     **/\n    address public rewardProceedsAddress;\n\n    /**\n     * All tokens are swapped to this token before it gets transferred\n     * to the `rewardProceedsAddress`. USDT for OUSD and WETH for OETH.\n     **/\n    address public immutable baseTokenAddress;\n    // Cached decimals for `baseTokenAddress`\n    uint256 public immutable baseTokenDecimals;\n\n    // Uniswap V2 path for reward tokens using Uniswap V2 Router\n    mapping(address => address[]) public uniswapV2Path;\n    // Uniswap V3 path for reward tokens using Uniswap V3 Router\n    mapping(address => bytes) public uniswapV3Path;\n    // Pool ID to use for reward tokens on Balancer\n    mapping(address => bytes32) public balancerPoolId;\n\n    struct CurvePoolIndices {\n        // Casted into uint128 and stored in a struct to save gas\n        uint128 rewardTokenIndex;\n        uint128 baseTokenIndex;\n    }\n    // Packed indices of assets on the Curve pool\n    mapping(address => CurvePoolIndices) public curvePoolIndices;\n\n    constructor(address _vaultAddress, address _baseTokenAddress) {\n        require(_vaultAddress != address(0));\n        require(_baseTokenAddress != address(0));\n\n        vaultAddress = _vaultAddress;\n        baseTokenAddress = _baseTokenAddress;\n\n        // Cache decimals as well\n        baseTokenDecimals = Helpers.getDecimals(_baseTokenAddress);\n    }\n\n    /***************************************\n                 Configuration\n    ****************************************/\n\n    /**\n     * Set the Address receiving rewards proceeds.\n     * @param _rewardProceedsAddress Address of the reward token\n     */\n    function setRewardProceedsAddress(address _rewardProceedsAddress)\n        external\n        onlyGovernor\n    {\n        if (_rewardProceedsAddress == address(0)) {\n            revert EmptyAddress();\n        }\n\n        rewardProceedsAddress = _rewardProceedsAddress;\n        emit RewardProceedsAddressChanged(_rewardProceedsAddress);\n    }\n\n    /**\n     * @dev Add/update a reward token configuration that holds harvesting config variables\n     * @param _tokenAddress Address of the reward token\n     * @param tokenConfig.allowedSlippageBps uint16 maximum allowed slippage denominated in basis points.\n     *          Example: 300 == 3% slippage\n     * @param tokenConfig.harvestRewardBps uint16 amount of reward tokens the caller of the function is rewarded.\n     *          Example: 100 == 1%\n     * @param tokenConfig.swapPlatformAddr Address Address of a UniswapV2 compatible contract to perform\n     *          the exchange from reward tokens to stablecoin (currently hard-coded to USDT)\n     * @param tokenConfig.liquidationLimit uint256 Maximum amount of token to be sold per one swap function call.\n     *          When value is 0 there is no limit.\n     * @param tokenConfig.doSwapRewardToken bool Disables swapping of the token when set to true,\n     *          does not cause it to revert though.\n     * @param tokenConfig.swapPlatform SwapPlatform to use for Swapping\n     * @param swapData Additional data required for swapping\n     */\n    function setRewardTokenConfig(\n        address _tokenAddress,\n        RewardTokenConfig calldata tokenConfig,\n        bytes calldata swapData\n    ) external onlyGovernor {\n        if (tokenConfig.allowedSlippageBps > 1000) {\n            revert InvalidSlippageBps();\n        }\n\n        if (tokenConfig.harvestRewardBps > 1000) {\n            revert InvalidHarvestRewardBps();\n        }\n\n        address newRouterAddress = tokenConfig.swapPlatformAddr;\n        if (newRouterAddress == address(0)) {\n            // Swap router address should be non zero address\n            revert EmptyAddress();\n        }\n\n        address oldRouterAddress = rewardTokenConfigs[_tokenAddress]\n            .swapPlatformAddr;\n        rewardTokenConfigs[_tokenAddress] = tokenConfig;\n\n        // Revert if feed does not exist\n        // slither-disable-next-line unused-return\n        IOracle(IVault(vaultAddress).priceProvider()).price(_tokenAddress);\n\n        IERC20 token = IERC20(_tokenAddress);\n        // if changing token swap provider cancel existing allowance\n        if (\n            /* oldRouterAddress == address(0) when there is no pre-existing\n             * configuration for said rewards token\n             */\n            oldRouterAddress != address(0) &&\n            oldRouterAddress != newRouterAddress\n        ) {\n            token.safeApprove(oldRouterAddress, 0);\n        }\n\n        // Give SwapRouter infinite approval when needed\n        if (oldRouterAddress != newRouterAddress) {\n            token.safeApprove(newRouterAddress, 0);\n            token.safeApprove(newRouterAddress, type(uint256).max);\n        }\n\n        SwapPlatform _platform = tokenConfig.swapPlatform;\n        if (_platform == SwapPlatform.UniswapV2Compatible) {\n            uniswapV2Path[_tokenAddress] = _decodeUniswapV2Path(\n                swapData,\n                _tokenAddress\n            );\n        } else if (_platform == SwapPlatform.UniswapV3) {\n            uniswapV3Path[_tokenAddress] = _decodeUniswapV3Path(\n                swapData,\n                _tokenAddress\n            );\n        } else if (_platform == SwapPlatform.Balancer) {\n            balancerPoolId[_tokenAddress] = _decodeBalancerPoolId(\n                swapData,\n                newRouterAddress,\n                _tokenAddress\n            );\n        } else if (_platform == SwapPlatform.Curve) {\n            curvePoolIndices[_tokenAddress] = _decodeCurvePoolIndices(\n                swapData,\n                newRouterAddress,\n                _tokenAddress\n            );\n        } else {\n            // Note: This code is unreachable since Solidity reverts when\n            // the value is outside the range of defined values of the enum\n            // (even if it's under the max length of the base type)\n            revert InvalidSwapPlatform(_platform);\n        }\n\n        emit RewardTokenConfigUpdated(\n            _tokenAddress,\n            tokenConfig.allowedSlippageBps,\n            tokenConfig.harvestRewardBps,\n            _platform,\n            newRouterAddress,\n            swapData,\n            tokenConfig.liquidationLimit,\n            tokenConfig.doSwapRewardToken\n        );\n    }\n\n    /**\n     * @dev Decodes the data passed into Uniswap V2 path and validates\n     *      it to make sure the path is for `token` to `baseToken`\n     *\n     * @param data Ecnoded data passed to the `setRewardTokenConfig`\n     * @param token The address of the reward token\n     * @return path The validated Uniswap V2 path\n     */\n    function _decodeUniswapV2Path(bytes calldata data, address token)\n        internal\n        view\n        returns (address[] memory path)\n    {\n        (path) = abi.decode(data, (address[]));\n        uint256 len = path.length;\n\n        if (len < 2) {\n            // Path should have at least two tokens\n            revert InvalidUniswapV2PathLength();\n        }\n\n        // Do some validation\n        if (path[0] != token) {\n            revert InvalidTokenInSwapPath(path[0]);\n        }\n\n        if (path[len - 1] != baseTokenAddress) {\n            revert InvalidTokenInSwapPath(path[len - 1]);\n        }\n    }\n\n    /**\n     * @dev Decodes the data passed into Uniswap V3 path and validates\n     *      it to make sure the path is for `token` to `baseToken`\n     *\n     * @param data Ecnoded data passed to the `setRewardTokenConfig`\n     * @param token The address of the reward token\n     * @return path The validated Uniswap V3 path\n     */\n    function _decodeUniswapV3Path(bytes calldata data, address token)\n        internal\n        view\n        returns (bytes calldata path)\n    {\n        path = data;\n\n        address decodedAddress = address(uint160(bytes20(data[0:20])));\n\n        if (decodedAddress != token) {\n            // Invalid Reward Token in swap path\n            revert InvalidTokenInSwapPath(decodedAddress);\n        }\n\n        decodedAddress = address(uint160(bytes20(data[path.length - 20:])));\n        if (decodedAddress != baseTokenAddress) {\n            // Invalid Base Token in swap path\n            revert InvalidTokenInSwapPath(decodedAddress);\n        }\n    }\n\n    /**\n     * @dev Decodes the data passed to Balancer Pool ID\n     *\n     * @param data Ecnoded data passed to the `setRewardTokenConfig`\n     * @return poolId The pool ID\n     */\n    function _decodeBalancerPoolId(\n        bytes calldata data,\n        address balancerVault,\n        address token\n    ) internal view returns (bytes32 poolId) {\n        (poolId) = abi.decode(data, (bytes32));\n\n        if (poolId == bytes32(0)) {\n            revert EmptyBalancerPoolId();\n        }\n\n        IBalancerVault bVault = IBalancerVault(balancerVault);\n\n        // Note: this reverts if token is not a pool asset\n        // slither-disable-next-line unused-return\n        bVault.getPoolTokenInfo(poolId, token);\n\n        // slither-disable-next-line unused-return\n        bVault.getPoolTokenInfo(poolId, baseTokenAddress);\n    }\n\n    /**\n     * @dev Decodes the data passed to get the pool indices and\n     *      checks it against the Curve Pool to make sure it's\n     *      not misconfigured. The indices are packed into a single\n     *      uint256 for gas savings\n     *\n     * @param data Ecnoded data passed to the `setRewardTokenConfig`\n     * @param poolAddress Curve pool address\n     * @param token The address of the reward token\n     * @return indices Packed pool asset indices\n     */\n    function _decodeCurvePoolIndices(\n        bytes calldata data,\n        address poolAddress,\n        address token\n    ) internal view returns (CurvePoolIndices memory indices) {\n        indices = abi.decode(data, (CurvePoolIndices));\n\n        ICurvePool pool = ICurvePool(poolAddress);\n        if (token != pool.coins(indices.rewardTokenIndex)) {\n            revert InvalidCurvePoolAssetIndex(token);\n        }\n        if (baseTokenAddress != pool.coins(indices.baseTokenIndex)) {\n            revert InvalidCurvePoolAssetIndex(baseTokenAddress);\n        }\n    }\n\n    /**\n     * @dev Flags a strategy as supported or not supported one\n     * @param _strategyAddress Address of the strategy\n     * @param _isSupported Bool marking strategy as supported or not supported\n     */\n    function setSupportedStrategy(address _strategyAddress, bool _isSupported)\n        external\n        onlyGovernor\n    {\n        supportedStrategies[_strategyAddress] = _isSupported;\n        emit SupportedStrategyUpdate(_strategyAddress, _isSupported);\n    }\n\n    /***************************************\n                    Rewards\n    ****************************************/\n\n    /**\n     * @dev Transfer token to governor. Intended for recovering tokens stuck in\n     *      contract, i.e. mistaken sends.\n     * @param _asset Address for the asset\n     * @param _amount Amount of the asset to transfer\n     */\n    function transferToken(address _asset, uint256 _amount)\n        external\n        onlyGovernor\n    {\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /**\n     * @dev Collect reward tokens from a specific strategy and swap them for\n     *      base token on the configured swap platform. Can be called by anyone.\n     *      Rewards incentivizing the caller are sent to the caller of this function.\n     * @param _strategyAddr Address of the strategy to collect rewards from\n     */\n    function harvestAndSwap(address _strategyAddr) external nonReentrant {\n        // Remember _harvest function checks for the validity of _strategyAddr\n        _harvestAndSwap(_strategyAddr, msg.sender);\n    }\n\n    /**\n     * @dev Collect reward tokens from a specific strategy and swap them for\n     *      base token on the configured swap platform. Can be called by anyone\n     * @param _strategyAddr Address of the strategy to collect rewards from\n     * @param _rewardTo Address where to send a share of harvest rewards to as an incentive\n     *      for executing this function\n     */\n    function harvestAndSwap(address _strategyAddr, address _rewardTo)\n        external\n        nonReentrant\n    {\n        // Remember _harvest function checks for the validity of _strategyAddr\n        _harvestAndSwap(_strategyAddr, _rewardTo);\n    }\n\n    /**\n     * @dev Collect reward tokens from a specific strategy and swap them for\n     *      base token on the configured swap platform\n     * @param _strategyAddr Address of the strategy to collect rewards from\n     * @param _rewardTo Address where to send a share of harvest rewards to as an incentive\n     *      for executing this function\n     */\n    function _harvestAndSwap(address _strategyAddr, address _rewardTo)\n        internal\n    {\n        _harvest(_strategyAddr);\n        IStrategy strategy = IStrategy(_strategyAddr);\n        address[] memory rewardTokens = strategy.getRewardTokenAddresses();\n        IOracle priceProvider = IOracle(IVault(vaultAddress).priceProvider());\n        uint256 len = rewardTokens.length;\n        for (uint256 i = 0; i < len; ++i) {\n            _swap(rewardTokens[i], _rewardTo, priceProvider);\n        }\n    }\n\n    /**\n     * @dev Collect reward tokens from a specific strategy and swap them for\n     *      base token on the configured swap platform\n     * @param _strategyAddr Address of the strategy to collect rewards from.\n     */\n    function _harvest(address _strategyAddr) internal virtual {\n        if (!supportedStrategies[_strategyAddr]) {\n            revert UnsupportedStrategy(_strategyAddr);\n        }\n\n        IStrategy strategy = IStrategy(_strategyAddr);\n        strategy.collectRewardTokens();\n    }\n\n    /**\n     * @dev Swap a reward token for the base token on the configured\n     *      swap platform. The token must have a registered price feed\n     *      with the price provider\n     * @param _swapToken Address of the token to swap\n     * @param _rewardTo Address where to send the share of harvest rewards to\n     * @param _priceProvider Oracle to get prices of the swap token\n     */\n    function _swap(\n        address _swapToken,\n        address _rewardTo,\n        IOracle _priceProvider\n    ) internal virtual {\n        uint256 balance = IERC20(_swapToken).balanceOf(address(this));\n\n        // No need to swap if the reward token is the base token. eg USDT or WETH.\n        // There is also no limit on the transfer. Everything in the harvester will be transferred\n        // to the Dripper regardless of the liquidationLimit config.\n        if (_swapToken == baseTokenAddress) {\n            IERC20(_swapToken).safeTransfer(rewardProceedsAddress, balance);\n            // currently not paying the farmer any rewards as there is no swap\n            emit RewardProceedsTransferred(\n                baseTokenAddress,\n                address(0),\n                balance,\n                0\n            );\n            return;\n        }\n\n        RewardTokenConfig memory tokenConfig = rewardTokenConfigs[_swapToken];\n\n        /* This will trigger a return when reward token configuration has not yet been set\n         * or we have temporarily disabled swapping of specific reward token via setting\n         * doSwapRewardToken to false.\n         */\n        if (!tokenConfig.doSwapRewardToken) {\n            return;\n        }\n\n        if (balance == 0) {\n            return;\n        }\n\n        if (tokenConfig.liquidationLimit > 0) {\n            balance = Math.min(balance, tokenConfig.liquidationLimit);\n        }\n\n        // This'll revert if there is no price feed\n        uint256 oraclePrice = _priceProvider.price(_swapToken);\n\n        // Oracle price is 1e18\n        uint256 minExpected = (balance *\n            (1e4 - tokenConfig.allowedSlippageBps) * // max allowed slippage\n            oraclePrice).scaleBy(\n                baseTokenDecimals,\n                Helpers.getDecimals(_swapToken)\n            ) /\n            1e4 / // fix the max slippage decimal position\n            1e18; // and oracle price decimals position\n\n        // Do the swap\n        uint256 amountReceived = _doSwap(\n            tokenConfig.swapPlatform,\n            tokenConfig.swapPlatformAddr,\n            _swapToken,\n            balance,\n            minExpected\n        );\n\n        if (amountReceived < minExpected) {\n            revert SlippageError(amountReceived, minExpected);\n        }\n\n        emit RewardTokenSwapped(\n            _swapToken,\n            baseTokenAddress,\n            tokenConfig.swapPlatform,\n            balance,\n            amountReceived\n        );\n\n        IERC20 baseToken = IERC20(baseTokenAddress);\n        uint256 baseTokenBalance = baseToken.balanceOf(address(this));\n        if (baseTokenBalance < amountReceived) {\n            // Note: It's possible to bypass this check by transferring `baseToken`\n            // directly to Harvester before calling the `harvestAndSwap`. However,\n            // there's no incentive for an attacker to do that. Doing a balance diff\n            // will increase the gas cost significantly\n            revert BalanceMismatchAfterSwap(baseTokenBalance, amountReceived);\n        }\n\n        // Farmer only gets fee from the base amount they helped farm,\n        // They do not get anything from anything that already was there\n        // on the Harvester\n        uint256 farmerFee = amountReceived.mulTruncateScale(\n            tokenConfig.harvestRewardBps,\n            1e4\n        );\n        uint256 protocolYield = baseTokenBalance - farmerFee;\n\n        baseToken.safeTransfer(rewardProceedsAddress, protocolYield);\n        baseToken.safeTransfer(_rewardTo, farmerFee);\n        emit RewardProceedsTransferred(\n            baseTokenAddress,\n            _rewardTo,\n            protocolYield,\n            farmerFee\n        );\n    }\n\n    function _doSwap(\n        SwapPlatform swapPlatform,\n        address routerAddress,\n        address rewardTokenAddress,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        if (swapPlatform == SwapPlatform.UniswapV2Compatible) {\n            return\n                _swapWithUniswapV2(\n                    routerAddress,\n                    rewardTokenAddress,\n                    amountIn,\n                    minAmountOut\n                );\n        } else if (swapPlatform == SwapPlatform.UniswapV3) {\n            return\n                _swapWithUniswapV3(\n                    routerAddress,\n                    rewardTokenAddress,\n                    amountIn,\n                    minAmountOut\n                );\n        } else if (swapPlatform == SwapPlatform.Balancer) {\n            return\n                _swapWithBalancer(\n                    routerAddress,\n                    rewardTokenAddress,\n                    amountIn,\n                    minAmountOut\n                );\n        } else if (swapPlatform == SwapPlatform.Curve) {\n            return\n                _swapWithCurve(\n                    routerAddress,\n                    rewardTokenAddress,\n                    amountIn,\n                    minAmountOut\n                );\n        } else {\n            // Should never be invoked since we catch invalid values\n            // in the `setRewardTokenConfig` function before it's set\n            revert InvalidSwapPlatform(swapPlatform);\n        }\n    }\n\n    /**\n     * @dev Swaps the token to `baseToken` with Uniswap V2\n     *\n     * @param routerAddress Uniswap V2 Router address\n     * @param swapToken Address of the tokenIn\n     * @param amountIn Amount of `swapToken` to swap\n     * @param minAmountOut Minimum expected amount of `baseToken`\n     *\n     * @return amountOut Amount of `baseToken` received after the swap\n     */\n    function _swapWithUniswapV2(\n        address routerAddress,\n        address swapToken,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        address[] memory path = uniswapV2Path[swapToken];\n\n        uint256[] memory amounts = IUniswapV2Router(routerAddress)\n            .swapExactTokensForTokens(\n                amountIn,\n                minAmountOut,\n                path,\n                address(this),\n                block.timestamp\n            );\n\n        amountOut = amounts[amounts.length - 1];\n    }\n\n    /**\n     * @dev Swaps the token to `baseToken` with Uniswap V3\n     *\n     * @param routerAddress Uniswap V3 Router address\n     * @param swapToken Address of the tokenIn\n     * @param amountIn Amount of `swapToken` to swap\n     * @param minAmountOut Minimum expected amount of `baseToken`\n     *\n     * @return amountOut Amount of `baseToken` received after the swap\n     */\n    function _swapWithUniswapV3(\n        address routerAddress,\n        address swapToken,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        bytes memory path = uniswapV3Path[swapToken];\n\n        IUniswapV3Router.ExactInputParams memory params = IUniswapV3Router\n            .ExactInputParams({\n                path: path,\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountIn: amountIn,\n                amountOutMinimum: minAmountOut\n            });\n        amountOut = IUniswapV3Router(routerAddress).exactInput(params);\n    }\n\n    /**\n     * @dev Swaps the token to `baseToken` on Balancer\n     *\n     * @param balancerVaultAddress BalancerVaultAddress\n     * @param swapToken Address of the tokenIn\n     * @param amountIn Amount of `swapToken` to swap\n     * @param minAmountOut Minimum expected amount of `baseToken`\n     *\n     * @return amountOut Amount of `baseToken` received after the swap\n     */\n    function _swapWithBalancer(\n        address balancerVaultAddress,\n        address swapToken,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        bytes32 poolId = balancerPoolId[swapToken];\n\n        IBalancerVault.SingleSwap memory singleSwap = IBalancerVault\n            .SingleSwap({\n                poolId: poolId,\n                kind: IBalancerVault.SwapKind.GIVEN_IN,\n                assetIn: swapToken,\n                assetOut: baseTokenAddress,\n                amount: amountIn,\n                userData: hex\"\"\n            });\n\n        IBalancerVault.FundManagement memory fundMgmt = IBalancerVault\n            .FundManagement({\n                sender: address(this),\n                fromInternalBalance: false,\n                recipient: payable(address(this)),\n                toInternalBalance: false\n            });\n\n        amountOut = IBalancerVault(balancerVaultAddress).swap(\n            singleSwap,\n            fundMgmt,\n            minAmountOut,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Swaps the token to `baseToken` on Curve\n     *\n     * @param poolAddress Curve Pool Address\n     * @param swapToken Address of the tokenIn\n     * @param amountIn Amount of `swapToken` to swap\n     * @param minAmountOut Minimum expected amount of `baseToken`\n     *\n     * @return amountOut Amount of `baseToken` received after the swap\n     */\n    function _swapWithCurve(\n        address poolAddress,\n        address swapToken,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        CurvePoolIndices memory indices = curvePoolIndices[swapToken];\n\n        // Note: Not all CurvePools return the `amountOut`, make sure\n        // to use only pool that do. Otherwise the swap would revert\n        // always\n        amountOut = ICurvePool(poolAddress).exchange(\n            uint256(indices.rewardTokenIndex),\n            uint256(indices.baseTokenIndex),\n            amountIn,\n            minAmountOut\n        );\n    }\n}\n"
    },
    "contracts/harvest/Dripper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\n/**\n * @title OUSD Dripper\n *\n * The dripper contract smooths out the yield from point-in-time yield events\n * and spreads the yield out over a configurable time period. This ensures a\n * continuous per block yield to makes users happy as their next rebase\n * amount is always moving up. Also, this makes historical day to day yields\n * smooth, rather than going from a near zero day, to a large APY day, then\n * back to a near zero day again.\n *\n *\n * Design notes\n * - USDT has a smaller resolution than the number of seconds\n * in a week, which can make per block payouts have a rounding error. However\n * the total effect is not large - cents per day, and this money is\n * not lost, just distributed in the future. While we could use a higher\n * decimal precision for the drip perBlock, we chose simpler code.\n * - By calculating the changing drip rates on collects only, harvests and yield\n * events don't have to call anything on this contract or pay any extra gas.\n * Collect() is already be paying for a single write, since it has to reset\n * the lastCollect time.\n * - By having a collectAndRebase method, and having our external systems call\n * that, the OUSD vault does not need any changes, not even to know the address\n * of the dripper.\n * - A rejected design was to retro-calculate the drip rate on each collect,\n * based on the balance at the time of the collect. While this would have\n * required less state, and would also have made the contract respond more quickly\n * to new income, it would break the predictability that is this contract's entire\n * purpose. If we did this, the amount of fundsAvailable() would make sharp increases\n * when funds were deposited.\n * - When the dripper recalculates the rate, it targets spending the balance over\n * the duration. This means that every time that collect is called, if no\n * new funds have been deposited the duration is being pushed back and the\n * rate decreases. This is expected, and ends up following a smoother but\n * longer curve the more collect() is called without incoming yield.\n *\n */\n\ncontract Dripper is Governable {\n    using SafeERC20 for IERC20;\n\n    struct Drip {\n        uint64 lastCollect; // overflows 262 billion years after the sun dies\n        uint192 perBlock; // drip rate per block\n    }\n\n    address immutable vault; // OUSD vault\n    address immutable token; // token to drip out\n    uint256 public dripDuration; // in seconds\n    Drip public drip; // active drip parameters\n\n    constructor(address _vault, address _token) {\n        vault = _vault;\n        token = _token;\n    }\n\n    /// @notice How much funds have dripped out already and are currently\n    //   available to be sent to the vault.\n    /// @return The amount that would be sent if a collect was called\n    function availableFunds() external view returns (uint256) {\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        return _availableFunds(balance, drip);\n    }\n\n    /// @notice Collect all dripped funds and send to vault.\n    ///  Recalculate new drip rate.\n    function collect() external {\n        _collect();\n    }\n\n    /// @notice Collect all dripped funds, send to vault, recalculate new drip\n    ///  rate, and rebase OUSD.\n    function collectAndRebase() external {\n        _collect();\n        IVault(vault).rebase();\n    }\n\n    /// @dev Change the drip duration. Governor only.\n    /// @param _durationSeconds the number of seconds to drip out the entire\n    ///  balance over if no collects were called during that time.\n    function setDripDuration(uint256 _durationSeconds) external onlyGovernor {\n        require(_durationSeconds > 0, \"duration must be non-zero\");\n        dripDuration = _durationSeconds;\n        _collect(); // duration change take immediate effect\n    }\n\n    /// @dev Transfer out ERC20 tokens held by the contract. Governor only.\n    /// @param _asset ERC20 token address\n    /// @param _amount amount to transfer\n    function transferToken(address _asset, uint256 _amount)\n        external\n        onlyGovernor\n    {\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /// @dev Calculate available funds by taking the lower of either the\n    ///  currently dripped out funds or the balance available.\n    ///  Uses passed in parameters to calculate with for gas savings.\n    /// @param _balance current balance in contract\n    /// @param _drip current drip parameters\n    function _availableFunds(uint256 _balance, Drip memory _drip)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 elapsed = block.timestamp - _drip.lastCollect;\n        uint256 allowed = (elapsed * _drip.perBlock);\n        return (allowed > _balance) ? _balance : allowed;\n    }\n\n    /// @dev Sends the currently dripped funds to be vault, and sets\n    ///  the new drip rate based on the new balance.\n    function _collect() internal {\n        // Calculate send\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        uint256 amountToSend = _availableFunds(balance, drip);\n        uint256 remaining = balance - amountToSend;\n        // Calculate new drip perBlock\n        //   Gas savings by setting entire struct at one time\n        drip = Drip({\n            perBlock: uint192(remaining / dripDuration),\n            lastCollect: uint64(block.timestamp)\n        });\n        // Send funds\n        IERC20(token).safeTransfer(vault, amountToSend);\n    }\n}\n"
    },
    "contracts/harvest/Harvester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { AbstractHarvester } from \"./AbstractHarvester.sol\";\n\ncontract Harvester is AbstractHarvester {\n    constructor(address _vault, address _usdtAddress)\n        AbstractHarvester(_vault, _usdtAddress)\n    {}\n}\n"
    },
    "contracts/harvest/OETHDripper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Dripper } from \"./Dripper.sol\";\n\n/**\n * @title OETH Dripper Contract\n * @author Origin Protocol Inc\n */\ncontract OETHDripper is Dripper {\n    constructor(address _vault, address _token) Dripper(_vault, _token) {}\n}\n"
    },
    "contracts/harvest/OETHHarvester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { AbstractHarvester } from \"./AbstractHarvester.sol\";\n\ncontract OETHHarvester is AbstractHarvester {\n    constructor(address _vault, address _wethAddress)\n        AbstractHarvester(_vault, _wethAddress)\n    {}\n}\n"
    },
    "contracts/interfaces/aerodrome/ICLGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface ICLGauge {\n    /// @notice Returns the claimable rewards for a given account and tokenId\n    /// @dev Throws if account is not the position owner\n    /// @dev pool.updateRewardsGrowthGlobal() needs to be called first, to return the correct claimable rewards\n    /// @param account The address of the user\n    /// @param tokenId The tokenId of the position\n    /// @return The amount of claimable reward\n    function earned(address account, uint256 tokenId)\n        external\n        view\n        returns (uint256);\n\n    /// @notice Retrieve rewards for all tokens owned by an account\n    /// @dev Throws if not called by the voter\n    /// @param account The account of the user\n    function getReward(address account) external;\n\n    /// @notice Retrieve rewards for a tokenId\n    /// @dev Throws if not called by the position owner\n    /// @param tokenId The tokenId of the position\n    function getReward(uint256 tokenId) external;\n\n    /// @notice Notifies gauge of gauge rewards.\n    /// @param amount Amount of gauge rewards (emissions) to notify. Must be greater than 604_800.\n    function notifyRewardAmount(uint256 amount) external;\n\n    /// @dev Notifies gauge of gauge rewards without distributing its fees.\n    ///      Assumes gauge reward tokens is 18 decimals.\n    ///      If not 18 decimals, rewardRate may have rounding issues.\n    /// @param amount Amount of gauge rewards (emissions) to notify. Must be greater than 604_800.\n    function notifyRewardWithoutClaim(uint256 amount) external;\n\n    /// @notice Used to deposit a CL position into the gauge\n    /// @notice Allows the user to receive emissions instead of fees\n    /// @param tokenId The tokenId of the position\n    function deposit(uint256 tokenId) external;\n\n    /// @notice Used to withdraw a CL position from the gauge\n    /// @notice Allows the user to receive fees instead of emissions\n    /// @notice Outstanding emissions will be collected on withdrawal\n    /// @param tokenId The tokenId of the position\n    function withdraw(uint256 tokenId) external;\n\n    // /// @notice Fetch all tokenIds staked by a given account\n    // /// @param depositor The address of the user\n    // /// @return The tokenIds of the staked positions\n    // function stakedValues(address depositor) external view returns (uint256[] memory);\n\n    // /// @notice Fetch a staked tokenId by index\n    // /// @param depositor The address of the user\n    // /// @param index The index of the staked tokenId\n    // /// @return The tokenId of the staked position\n    // function stakedByIndex(address depositor, uint256 index) external view returns (uint256);\n\n    // /// @notice Check whether a position is staked in the gauge by a certain user\n    // /// @param depositor The address of the user\n    // /// @param tokenId The tokenId of the position\n    // /// @return Whether the position is staked in the gauge\n    // function stakedContains(address depositor, uint256 tokenId) external view returns (bool);\n\n    // /// @notice The amount of positions staked in the gauge by a certain user\n    // /// @param depositor The address of the user\n    // /// @return The amount of positions staked in the gauge\n    // function stakedLength(address depositor) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/aerodrome/ICLPool.sol": {
      "content": "pragma solidity >=0.5.0;\n\n/// @title The interface for a CL Pool\n/// @notice A CL pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface ICLPool {\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            bool unlocked\n        );\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The gauge corresponding to this pool\n    /// @return The gauge contract address\n    function gauge() external view returns (address);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    /// @dev This value includes staked liquidity\n    function liquidity() external view returns (uint128);\n}\n"
    },
    "contracts/interfaces/aerodrome/INonfungiblePositionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Non-fungible token for positions\n/// @notice Wraps CL positions in a non-fungible token interface which allows for them to be transferred\n/// and authorized.\n// slither-disable-start erc20-interface\ninterface INonfungiblePositionManager {\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) external returns (address);\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    /// @notice Returns the position information associated with a given token ID.\n    /// @dev Throws if the token ID is not valid.\n    /// @param tokenId The ID of the token that represents the position\n    /// @return nonce The nonce for permits\n    /// @return operator The address that is approved for spending\n    /// @return token0 The address of the token0 for a specific pool\n    /// @return token1 The address of the token1 for a specific pool\n    /// @return tickSpacing The tick spacing associated with the pool\n    /// @return tickLower The lower end of the tick range for the position\n    /// @return tickUpper The higher end of the tick range for the position\n    /// @return liquidity The liquidity of the position\n    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\n    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\n    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\n    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            int24 tickSpacing,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    struct MintParams {\n        address token0;\n        address token1;\n        int24 tickSpacing;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n        uint160 sqrtPriceX96;\n    }\n\n    /// @notice Creates a new position wrapped in a NFT\n    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\n    /// a method does not exist, i.e. the pool is assumed to be initialized.\n    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\n    /// @return tokenId The ID of the token that represents the minted position\n    /// @return liquidity The amount of liquidity for this position\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function mint(MintParams calldata params)\n        external\n        payable\n        returns (\n            uint256 tokenId,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\n    /// @param params tokenId The ID of the token for which liquidity is being increased,\n    /// amount0Desired The desired amount of token0 to be spent,\n    /// amount1Desired The desired amount of token1 to be spent,\n    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\n    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return liquidity The new liquidity amount as a result of the increase\n    /// @return amount0 The amount of token0 to acheive resulting liquidity\n    /// @return amount1 The amount of token1 to acheive resulting liquidity\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Decreases the amount of liquidity in a position and accounts it to the position\n    /// @param params tokenId The ID of the token for which liquidity is being decreased,\n    /// amount The amount by which liquidity will be decreased,\n    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\n    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return amount0 The amount of token0 accounted to the position's tokens owed\n    /// @return amount1 The amount of token1 accounted to the position's tokens owed\n    /// @dev The use of this function can cause a loss to users of the NonfungiblePositionManager\n    /// @dev for tokens that have very high decimals.\n    /// @dev The amount of tokens necessary for the loss is: 3.4028237e+38.\n    /// @dev This is equivalent to 1e20 value with 18 decimals.\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\n    /// @notice Used to update staked positions before deposit and withdraw\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\n    /// recipient The account that should receive the tokens,\n    /// amount0Max The maximum amount of token0 to collect,\n    /// amount1Max The maximum amount of token1 to collect\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(CollectParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\n    /// must be collected first.\n    /// @param tokenId The ID of the token that is being burned\n    function burn(uint256 tokenId) external payable;\n\n    /// @notice Sets a new Token Descriptor\n    /// @param _tokenDescriptor Address of the new Token Descriptor to be chosen\n    function setTokenDescriptor(address _tokenDescriptor) external;\n\n    /// @notice Sets a new Owner address\n    /// @param _owner Address of the new Owner to be chosen\n    function setOwner(address _owner) external;\n}\n// slither-disable-end erc20-interface\n"
    },
    "contracts/interfaces/aerodrome/IQuoterV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title QuoterV2 Interface\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps.\n/// @notice For each pool also tells you the number of initialized ticks crossed and the sqrt price of the\n///         pool after the swap.\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\ninterface IQuoterV2 {\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool tick spacing\n    /// @param amountIn The amount of the first token to swap\n    /// @return amountOut The amount of the last token that would be received\n    /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\n    /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for\n    ///         each pool in the path\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactInput(bytes memory path, uint256 amountIn)\n        external\n        returns (\n            uint256 amountOut,\n            uint160[] memory sqrtPriceX96AfterList,\n            uint32[] memory initializedTicksCrossedList,\n            uint256 gasEstimate\n        );\n\n    struct QuoteExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        int24 tickSpacing;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n    /// @param params The params for the quote, encoded as `QuoteExactInputSingleParams`\n    /// tokenIn The token being swapped in\n    /// tokenOut The token being swapped out\n    /// tickSpacing The tick spacing of the token pool to consider for the pair\n    /// amountIn The desired input amount\n    /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountOut The amount of `tokenOut` that would be received\n    /// @return sqrtPriceX96After The sqrt price of the pool after the swap\n    /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactInputSingle(QuoteExactInputSingleParams memory params)\n        external\n        returns (\n            uint256 amountOut,\n            uint160 sqrtPriceX96After,\n            uint32 initializedTicksCrossed,\n            uint256 gasEstimate\n        );\n\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool tick spacing.\n    ///        Path must be provided in reverse order\n    /// @param amountOut The amount of the last token to receive\n    /// @return amountIn The amount of first token required to be paid\n    /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\n    /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for\n    ///         each pool in the path\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactOutput(bytes memory path, uint256 amountOut)\n        external\n        returns (\n            uint256 amountIn,\n            uint160[] memory sqrtPriceX96AfterList,\n            uint32[] memory initializedTicksCrossedList,\n            uint256 gasEstimate\n        );\n\n    struct QuoteExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amount;\n        int24 tickSpacing;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\n    /// @param params The params for the quote, encoded as `QuoteExactOutputSingleParams`\n    /// tokenIn The token being swapped in\n    /// tokenOut The token being swapped out\n    /// tickSpacing The tick spacing of the token pool to consider for the pair\n    /// amountOut The desired output amount\n    /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\n    /// @return sqrtPriceX96After The sqrt price of the pool after the swap\n    /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactOutputSingle(QuoteExactOutputSingleParams memory params)\n        external\n        returns (\n            uint256 amountIn,\n            uint160 sqrtPriceX96After,\n            uint32 initializedTicksCrossed,\n            uint256 gasEstimate\n        );\n}\n"
    },
    "contracts/interfaces/aerodrome/ISugarHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\npragma abicoder v2;\n\nimport { INonfungiblePositionManager } from \"./INonfungiblePositionManager.sol\";\n\ninterface ISugarHelper {\n    struct PopulatedTick {\n        int24 tick;\n        uint160 sqrtRatioX96;\n        int128 liquidityNet;\n        uint128 liquidityGross;\n    }\n\n    ///\n    /// Wrappers for LiquidityAmounts\n    ///\n\n    function getAmountsForLiquidity(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) external pure returns (uint256 amount0, uint256 amount1);\n\n    function getLiquidityForAmounts(\n        uint256 amount0,\n        uint256 amount1,\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96\n    ) external pure returns (uint256 liquidity);\n\n    /// @notice Computes the amount of token0 for a given amount of token1 and price range\n    /// @param amount1 Amount of token1 to estimate liquidity\n    /// @param pool Address of the pool to be used\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param tickLow Lower tick boundary\n    /// @param tickLow Upper tick boundary\n    /// @dev   If the given pool address is not the zero address, will fetch `sqrtRatioX96` from pool\n    /// @return amount0 Estimated amount of token0\n    function estimateAmount0(\n        uint256 amount1,\n        address pool,\n        uint160 sqrtRatioX96,\n        int24 tickLow,\n        int24 tickHigh\n    ) external view returns (uint256 amount0);\n\n    /// @notice Computes the amount of token1 for a given amount of token0 and price range\n    /// @param amount0 Amount of token0 to estimate liquidity\n    /// @param pool Address of the pool to be used\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param tickLow Lower tick boundary\n    /// @param tickLow Upper tick boundary\n    /// @dev   If the given pool address is not the zero address, will fetch `sqrtRatioX96` from pool\n    /// @return amount1 Estimated amount of token1\n    function estimateAmount1(\n        uint256 amount0,\n        address pool,\n        uint160 sqrtRatioX96,\n        int24 tickLow,\n        int24 tickHigh\n    ) external view returns (uint256 amount1);\n\n    ///\n    /// Wrappers for PositionValue\n    ///\n\n    function principal(\n        INonfungiblePositionManager positionManager,\n        uint256 tokenId,\n        uint160 sqrtRatioX96\n    ) external view returns (uint256 amount0, uint256 amount1);\n\n    function fees(INonfungiblePositionManager positionManager, uint256 tokenId)\n        external\n        view\n        returns (uint256 amount0, uint256 amount1);\n\n    ///\n    /// Wrappers for TickMath\n    ///\n\n    function getSqrtRatioAtTick(int24 tick)\n        external\n        pure\n        returns (uint160 sqrtRatioX96);\n\n    function getTickAtSqrtRatio(uint160 sqrtRatioX96)\n        external\n        pure\n        returns (int24 tick);\n\n    /// @notice Fetches Tick Data for all populated Ticks in given bitmaps\n    /// @param pool Address of the pool from which to fetch data\n    /// @param startTick Tick from which the first bitmap will be fetched\n    /// @dev   The number of bitmaps fetched by this function should always be `MAX_BITMAPS`,\n    ///        unless there are less than `MAX_BITMAPS` left to iterate through\n    /// @return populatedTicks Array of all Populated Ticks in the provided bitmaps\n    function getPopulatedTicks(address pool, int24 startTick)\n        external\n        view\n        returns (PopulatedTick[] memory populatedTicks);\n}\n"
    },
    "contracts/interfaces/aerodrome/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via CL\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        int24 tickSpacing;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        int24 tickSpacing;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params)\n        external\n        payable\n        returns (uint256 amountIn);\n}\n"
    },
    "contracts/interfaces/balancer/IBalancerVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"../../utils/InitializableAbstractStrategy.sol\";\n\ninterface IBalancerVault {\n    enum WeightedPoolJoinKind {\n        INIT,\n        EXACT_TOKENS_IN_FOR_BPT_OUT,\n        TOKEN_IN_FOR_EXACT_BPT_OUT,\n        ALL_TOKENS_IN_FOR_EXACT_BPT_OUT,\n        ADD_TOKEN\n    }\n\n    enum WeightedPoolExitKind {\n        EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n        EXACT_BPT_IN_FOR_TOKENS_OUT,\n        BPT_IN_FOR_EXACT_TOKENS_OUT,\n        REMOVE_TOKEN\n    }\n\n    /**\n     * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\n     * Pool shares.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\n     * these maximums.\n     *\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\n     * back to the caller (not the sender, which is important for relayers).\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\n     *\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\n     *\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\n     * directly to the Pool's contract, as is `recipient`.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n\n    struct JoinPoolRequest {\n        address[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n\n    /**\n     * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\n     * `getPoolTokenInfo`).\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\n     * it just enforces these minimums.\n     *\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\n     *\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\n     * do so will trigger a revert.\n     *\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\n     * `tokens` array. This array must match the Pool's registered tokens.\n     *\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\n     * passed directly to the Pool's contract.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external;\n\n    struct ExitPoolRequest {\n        address[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n\n    /**\n     * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\n     * the tokens' `balances` changed.\n     *\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\n     *\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\n     * order as passed to `registerTokens`.\n     *\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\n     * instead.\n     */\n    function getPoolTokens(bytes32 poolId)\n        external\n        view\n        returns (\n            IERC20[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangeBlock\n        );\n\n    /**\n     * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\n     * it lets integrators reuse a user's Vault allowance.\n     *\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\n     */\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable;\n\n    struct UserBalanceOp {\n        UserBalanceOpKind kind;\n        address asset;\n        uint256 amount;\n        address sender;\n        address payable recipient;\n    }\n\n    enum UserBalanceOpKind {\n        DEPOSIT_INTERNAL,\n        WITHDRAW_INTERNAL,\n        TRANSFER_INTERNAL,\n        TRANSFER_EXTERNAL\n    }\n\n    enum SwapKind {\n        GIVEN_IN,\n        GIVEN_OUT\n    }\n\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        address assetIn;\n        address assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n\n    function swap(\n        SingleSwap calldata singleSwap,\n        FundManagement calldata funds,\n        uint256 limit,\n        uint256 deadline\n    ) external returns (uint256 amountCalculated);\n\n    function getPoolTokenInfo(bytes32 poolId, address token)\n        external\n        view\n        returns (\n            uint256 cash,\n            uint256 managed,\n            uint256 lastChangeBlock,\n            address assetManager\n        );\n}\n"
    },
    "contracts/interfaces/balancer/IMetaStablePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IRateProvider } from \"./IRateProvider.sol\";\n\ninterface IMetaStablePool {\n    function getRateProviders()\n        external\n        view\n        returns (IRateProvider[] memory providers);\n}\n"
    },
    "contracts/interfaces/balancer/IOracleWeightedPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// The three values that can be queried:\n//\n// - PAIR_PRICE: the price of the tokens in the Pool, expressed as the price of the second token in units of the\n//   first token. For example, if token A is worth $2, and token B is worth $4, the pair price will be 2.0.\n//   Note that the price is computed *including* the tokens decimals. This means that the pair price of a Pool with\n//   DAI and USDC will be close to 1.0, despite DAI having 18 decimals and USDC 6.\n//\n// - BPT_PRICE: the price of the Pool share token (BPT), in units of the first token.\n//   Note that the price is computed *including* the tokens decimals. This means that the BPT price of a Pool with\n//   USDC in which BPT is worth $5 will be 5.0, despite the BPT having 18 decimals and USDC 6.\n//\n// - INVARIANT: the value of the Pool's invariant, which serves as a measure of its liquidity.\nenum Variable {\n    PAIR_PRICE,\n    BPT_PRICE,\n    INVARIANT\n}\n\n/**\n * @dev Information for a Time Weighted Average query.\n *\n * Each query computes the average over a window of duration `secs` seconds that ended `ago` seconds ago. For\n * example, the average over the past 30 minutes is computed by settings secs to 1800 and ago to 0. If secs is 1800\n * and ago is 1800 as well, the average between 60 and 30 minutes ago is computed instead.\n */\nstruct OracleAverageQuery {\n    Variable variable;\n    uint256 secs;\n    uint256 ago;\n}\n\ninterface IOracleWeightedPool {\n    /**\n     * @dev Returns the time average weighted price corresponding to each of `queries`. Prices are represented as 18\n     * decimal fixed point values.\n     */\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n        external\n        view\n        returns (uint256[] memory results);\n}\n"
    },
    "contracts/interfaces/balancer/IRateProvider.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\ninterface IRateProvider {\n    function getRate() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/chainlink/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "contracts/interfaces/IBasicToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBasicToken {\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IBuyback.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBuyback {\n    function swap() external;\n}\n"
    },
    "contracts/interfaces/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IComptroller {\n    // Claim all the COMP accrued by specific holders in specific markets for their supplies and/or borrows\n    function claimComp(\n        address[] memory holders,\n        address[] memory cTokens,\n        bool borrowers,\n        bool suppliers\n    ) external;\n\n    function oracle() external view returns (address);\n}\n"
    },
    "contracts/interfaces/ICVXLocker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ICVXLocker {\n    function lock(\n        address _account,\n        uint256 _amount,\n        uint256 _spendRatio\n    ) external;\n\n    function lockedBalanceOf(address _account) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IDepositContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IDepositContract {\n    /// @notice A processed deposit event.\n    event DepositEvent(\n        bytes pubkey,\n        bytes withdrawal_credentials,\n        bytes amount,\n        bytes signature,\n        bytes index\n    );\n\n    /// @notice Submit a Phase 0 DepositData object.\n    /// @param pubkey A BLS12-381 public key.\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\n    /// @param signature A BLS12-381 signature.\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\n    /// Used as a protection against malformed input.\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawal_credentials,\n        bytes calldata signature,\n        bytes32 deposit_data_root\n    ) external payable;\n\n    /// @notice Query the current deposit root hash.\n    /// @return The deposit root hash.\n    function get_deposit_root() external view returns (bytes32);\n\n    /// @notice Query the current deposit count.\n    /// @return The deposit count encoded as a little endian 64-bit number.\n    function get_deposit_count() external view returns (bytes memory);\n}\n"
    },
    "contracts/interfaces/IDripper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IDripper {\n    /// @notice How much funds have dripped out already and are currently\n    //   available to be sent to the vault.\n    /// @return The amount that would be sent if a collect was called\n    function availableFunds() external view returns (uint256);\n\n    /// @notice Collect all dripped funds and send to vault.\n    ///  Recalculate new drip rate.\n    function collect() external;\n\n    /// @notice Collect all dripped funds, send to vault, recalculate new drip\n    ///  rate, and rebase mToken.\n    function collectAndRebase() external;\n\n    /// @notice Change the drip duration. Governor only.\n    /// @param _durationSeconds the number of seconds to drip out the entire\n    ///  balance over if no collects were called during that time.\n    function setDripDuration(uint256 _durationSeconds) external;\n\n    /// @dev Transfer out ERC20 tokens held by the contract. Governor only.\n    /// @param _asset ERC20 token address\n    /// @param _amount amount to transfer\n    function transferToken(address _asset, uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/IEthUsdOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IEthUsdOracle {\n    /**\n     * @notice Returns ETH price in USD.\n     * @return Price in USD with 6 decimal digits.\n     */\n    function ethUsdPrice() external view returns (uint256);\n\n    /**\n     * @notice Returns token price in USD.\n     * @param symbol. Asset symbol. For ex. \"DAI\".\n     * @return Price in USD with 6 decimal digits.\n     */\n    function tokUsdPrice(string calldata symbol)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the asset price in ETH.\n     * @param symbol. Asset symbol. For ex. \"DAI\".\n     * @return Price in ETH with 8 decimal digits.\n     */\n    function tokEthPrice(string calldata symbol)\n        external\n        view\n        returns (uint256);\n}\n\ninterface IViewEthUsdOracle {\n    /**\n     * @notice Returns ETH price in USD.\n     * @return Price in USD with 6 decimal digits.\n     */\n    function ethUsdPrice() external view returns (uint256);\n\n    /**\n     * @notice Returns token price in USD.\n     * @param symbol. Asset symbol. For ex. \"DAI\".\n     * @return Price in USD with 6 decimal digits.\n     */\n    function tokUsdPrice(string calldata symbol)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the asset price in ETH.\n     * @param symbol. Asset symbol. For ex. \"DAI\".\n     * @return Price in ETH with 8 decimal digits.\n     */\n    function tokEthPrice(string calldata symbol)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/interfaces/IFraxETHMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IFraxETHMinter {\n    function submitAndDeposit(address recipient)\n        external\n        payable\n        returns (uint256 shares);\n}\n"
    },
    "contracts/interfaces/IGetExchangeRateToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IGetExchangeRateToken {\n    function getExchangeRate() external view returns (uint256 _exchangeRate);\n}\n"
    },
    "contracts/interfaces/IMinMaxOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IMinMaxOracle {\n    //Assuming 8 decimals\n    function priceMin(string calldata symbol) external view returns (uint256);\n\n    function priceMax(string calldata symbol) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IOETHZapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOETHZapper {\n    function deposit() external payable returns (uint256);\n}\n"
    },
    "contracts/interfaces/IOneInch.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// 1Inch swap data\nstruct SwapDescription {\n    IERC20 srcToken; // contract address of a token to sell\n    IERC20 dstToken; // contract address of a token to buy\n    address payable srcReceiver;\n    address payable dstReceiver; // Receiver of destination currency. default: fromAddress\n    uint256 amount;\n    uint256 minReturnAmount;\n    uint256 flags;\n}\n\n/// @title Interface for making arbitrary calls during swap\ninterface IAggregationExecutor {\n    /// @notice propagates information about original msg.sender and executes arbitrary data\n    function execute(address msgSender) external payable; // 0x4b64e492\n}\n\ninterface IOneInchRouter {\n    /// @notice Performs a swap, delegating all calls encoded in `data` to `executor`.\n    function swap(\n        IAggregationExecutor executor,\n        SwapDescription calldata desc,\n        bytes calldata permit,\n        bytes calldata data\n    ) external returns (uint256 returnAmount, uint256 spentAmount);\n\n    /// @notice Performs swap using Uniswap exchange. Wraps and unwraps ETH if required.\n    function unoswapTo(\n        address payable recipient,\n        IERC20 srcToken,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] calldata pools\n    ) external payable returns (uint256 returnAmount);\n\n    /// @notice Performs swap using Uniswap V3 exchange. Wraps and unwraps ETH if required.\n    function uniswapV3SwapTo(\n        address payable recipient,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] calldata pools\n    ) external payable returns (uint256 returnAmount);\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOracle {\n    /**\n     * @dev returns the asset price in USD, in 8 decimal digits.\n     *\n     * The version of priceProvider deployed for OETH has 18 decimal digits\n     */\n    function price(address asset) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IOUSD.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOUSD {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event GovernorshipTransferred(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n    event PendingGovernorshipTransfer(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n    event TotalSupplyUpdatedHighres(\n        uint256 totalSupply,\n        uint256 rebasingCredits,\n        uint256 rebasingCreditsPerToken\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function _totalSupply() external view returns (uint256);\n\n    function allowance(address _owner, address _spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function balanceOf(address _account) external view returns (uint256);\n\n    function burn(address account, uint256 amount) external;\n\n    function changeSupply(uint256 _newTotalSupply) external;\n\n    function claimGovernance() external;\n\n    function creditsBalanceOf(address _account)\n        external\n        view\n        returns (uint256, uint256);\n\n    function creditsBalanceOfHighres(address _account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            bool\n        );\n\n    function decimals() external view returns (uint8);\n\n    function decreaseAllowance(address _spender, uint256 _subtractedValue)\n        external\n        returns (bool);\n\n    function governor() external view returns (address);\n\n    function increaseAllowance(address _spender, uint256 _addedValue)\n        external\n        returns (bool);\n\n    function initialize(\n        string memory _nameArg,\n        string memory _symbolArg,\n        address _vaultAddress\n    ) external;\n\n    function isGovernor() external view returns (bool);\n\n    function isUpgraded(address) external view returns (uint256);\n\n    function mint(address _account, uint256 _amount) external;\n\n    function name() external view returns (string memory);\n\n    function nonRebasingCreditsPerToken(address)\n        external\n        view\n        returns (uint256);\n\n    function nonRebasingSupply() external view returns (uint256);\n\n    function rebaseOptIn() external;\n\n    function rebaseOptOut() external;\n\n    function rebaseState(address) external view returns (uint8);\n\n    function rebasingCredits() external view returns (uint256);\n\n    function rebasingCreditsHighres() external view returns (uint256);\n\n    function rebasingCreditsPerToken() external view returns (uint256);\n\n    function rebasingCreditsPerTokenHighres() external view returns (uint256);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function transferGovernance(address _newGovernor) external;\n\n    function vaultAddress() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPriceOracle {\n    /**\n     * @dev returns the asset price in USD, 6 decimal digits.\n     * Compatible with the Open Price Feed.\n     */\n    function price(string calldata symbol) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IRETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IRETH {\n    function getEthValue(uint256 _rethAmount) external view returns (uint256);\n\n    function getRethValue(uint256 _ethAmount) external view returns (uint256);\n\n    function getExchangeRate() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/ISfrxETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ISfrxETH {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 amount\n    );\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n    event NewRewardsCycle(uint32 indexed cycleEnd, uint256 rewardAmount);\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function allowance(address, address) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function asset() external view returns (address);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function convertToAssets(uint256 shares) external view returns (uint256);\n\n    function convertToShares(uint256 assets) external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function deposit(uint256 assets, address receiver)\n        external\n        returns (uint256 shares);\n\n    function depositWithSignature(\n        uint256 assets,\n        address receiver,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 shares);\n\n    function lastRewardAmount() external view returns (uint192);\n\n    function lastSync() external view returns (uint32);\n\n    function maxDeposit(address) external view returns (uint256);\n\n    function maxMint(address) external view returns (uint256);\n\n    function maxRedeem(address owner) external view returns (uint256);\n\n    function maxWithdraw(address owner) external view returns (uint256);\n\n    function mint(uint256 shares, address receiver)\n        external\n        returns (uint256 assets);\n\n    function name() external view returns (string memory);\n\n    function nonces(address) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function previewDeposit(uint256 assets) external view returns (uint256);\n\n    function previewMint(uint256 shares) external view returns (uint256);\n\n    function previewRedeem(uint256 shares) external view returns (uint256);\n\n    function previewWithdraw(uint256 assets) external view returns (uint256);\n\n    function pricePerShare() external view returns (uint256);\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n\n    function rewardsCycleEnd() external view returns (uint32);\n\n    function rewardsCycleLength() external view returns (uint32);\n\n    function symbol() external view returns (string memory);\n\n    function syncRewards() external;\n\n    function totalAssets() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n}\n"
    },
    "contracts/interfaces/ISSVNetwork.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct Cluster {\n    uint32 validatorCount;\n    uint64 networkFeeIndex;\n    uint64 index;\n    bool active;\n    uint256 balance;\n}\n\ninterface ISSVNetwork {\n    /**********/\n    /* Errors */\n    /**********/\n\n    error CallerNotOwner(); // 0x5cd83192\n    error CallerNotWhitelisted(); // 0x8c6e5d71\n    error FeeTooLow(); // 0x732f9413\n    error FeeExceedsIncreaseLimit(); // 0x958065d9\n    error NoFeeDeclared(); // 0x1d226c30\n    error ApprovalNotWithinTimeframe(); // 0x97e4b518\n    error OperatorDoesNotExist(); // 0x961e3e8c\n    error InsufficientBalance(); // 0xf4d678b8\n    error ValidatorDoesNotExist(); // 0xe51315d2\n    error ClusterNotLiquidatable(); // 0x60300a8d\n    error InvalidPublicKeyLength(); // 0x637297a4\n    error InvalidOperatorIdsLength(); // 0x38186224\n    error ClusterAlreadyEnabled(); // 0x3babafd2\n    error ClusterIsLiquidated(); // 0x95a0cf33\n    error ClusterDoesNotExists(); // 0x185e2b16\n    error IncorrectClusterState(); // 0x12e04c87\n    error UnsortedOperatorsList(); // 0xdd020e25\n    error NewBlockPeriodIsBelowMinimum(); // 0x6e6c9cac\n    error ExceedValidatorLimit(); // 0x6df5ab76\n    error TokenTransferFailed(); // 0x045c4b02\n    error SameFeeChangeNotAllowed(); // 0xc81272f8\n    error FeeIncreaseNotAllowed(); // 0x410a2b6c\n    error NotAuthorized(); // 0xea8e4eb5\n    error OperatorsListNotUnique(); // 0xa5a1ff5d\n    error OperatorAlreadyExists(); // 0x289c9494\n    error TargetModuleDoesNotExist(); // 0x8f9195fb\n    error MaxValueExceeded(); // 0x91aa3017\n    error FeeTooHigh(); // 0xcd4e6167\n    error PublicKeysSharesLengthMismatch(); // 0x9ad467b8\n    error IncorrectValidatorStateWithData(bytes publicKey); // 0x89307938\n    error ValidatorAlreadyExistsWithData(bytes publicKey); // 0x388e7999\n    error EmptyPublicKeysList(); // df83e679\n\n    // legacy errors\n    error ValidatorAlreadyExists(); // 0x8d09a73e\n    error IncorrectValidatorState(); // 0x2feda3c1\n\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    event ClusterDeposited(\n        address indexed owner,\n        uint64[] operatorIds,\n        uint256 value,\n        Cluster cluster\n    );\n    event ClusterLiquidated(\n        address indexed owner,\n        uint64[] operatorIds,\n        Cluster cluster\n    );\n    event ClusterReactivated(\n        address indexed owner,\n        uint64[] operatorIds,\n        Cluster cluster\n    );\n    event ClusterWithdrawn(\n        address indexed owner,\n        uint64[] operatorIds,\n        uint256 value,\n        Cluster cluster\n    );\n    event DeclareOperatorFeePeriodUpdated(uint64 value);\n    event ExecuteOperatorFeePeriodUpdated(uint64 value);\n    event FeeRecipientAddressUpdated(\n        address indexed owner,\n        address recipientAddress\n    );\n    event Initialized(uint8 version);\n    event LiquidationThresholdPeriodUpdated(uint64 value);\n    event MinimumLiquidationCollateralUpdated(uint256 value);\n    event NetworkEarningsWithdrawn(uint256 value, address recipient);\n    event NetworkFeeUpdated(uint256 oldFee, uint256 newFee);\n    event OperatorAdded(\n        uint64 indexed operatorId,\n        address indexed owner,\n        bytes publicKey,\n        uint256 fee\n    );\n    event OperatorFeeDeclarationCancelled(\n        address indexed owner,\n        uint64 indexed operatorId\n    );\n    event OperatorFeeDeclared(\n        address indexed owner,\n        uint64 indexed operatorId,\n        uint256 blockNumber,\n        uint256 fee\n    );\n    event OperatorFeeExecuted(\n        address indexed owner,\n        uint64 indexed operatorId,\n        uint256 blockNumber,\n        uint256 fee\n    );\n    event OperatorFeeIncreaseLimitUpdated(uint64 value);\n    event OperatorMaximumFeeUpdated(uint64 maxFee);\n    event OperatorRemoved(uint64 indexed operatorId);\n    event OperatorWhitelistUpdated(\n        uint64 indexed operatorId,\n        address whitelisted\n    );\n    event OperatorWithdrawn(\n        address indexed owner,\n        uint64 indexed operatorId,\n        uint256 value\n    );\n    event OwnershipTransferStarted(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event Upgraded(address indexed implementation);\n    event ValidatorAdded(\n        address indexed owner,\n        uint64[] operatorIds,\n        bytes publicKey,\n        bytes shares,\n        Cluster cluster\n    );\n    event ValidatorExited(\n        address indexed owner,\n        uint64[] operatorIds,\n        bytes publicKey\n    );\n    event ValidatorRemoved(\n        address indexed owner,\n        uint64[] operatorIds,\n        bytes publicKey,\n        Cluster cluster\n    );\n\n    fallback() external;\n\n    function acceptOwnership() external;\n\n    function cancelDeclaredOperatorFee(uint64 operatorId) external;\n\n    function declareOperatorFee(uint64 operatorId, uint256 fee) external;\n\n    function deposit(\n        address clusterOwner,\n        uint64[] memory operatorIds,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function executeOperatorFee(uint64 operatorId) external;\n\n    function exitValidator(bytes memory publicKey, uint64[] memory operatorIds)\n        external;\n\n    function bulkExitValidator(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds\n    ) external;\n\n    function getVersion() external pure returns (string memory version);\n\n    function initialize(\n        address token_,\n        address ssvOperators_,\n        address ssvClusters_,\n        address ssvDAO_,\n        address ssvViews_,\n        uint64 minimumBlocksBeforeLiquidation_,\n        uint256 minimumLiquidationCollateral_,\n        uint32 validatorsPerOperatorLimit_,\n        uint64 declareOperatorFeePeriod_,\n        uint64 executeOperatorFeePeriod_,\n        uint64 operatorMaxFeeIncrease_\n    ) external;\n\n    function liquidate(\n        address clusterOwner,\n        uint64[] memory operatorIds,\n        Cluster memory cluster\n    ) external;\n\n    function owner() external view returns (address);\n\n    function pendingOwner() external view returns (address);\n\n    function proxiableUUID() external view returns (bytes32);\n\n    function reactivate(\n        uint64[] memory operatorIds,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function reduceOperatorFee(uint64 operatorId, uint256 fee) external;\n\n    function registerOperator(bytes memory publicKey, uint256 fee)\n        external\n        returns (uint64 id);\n\n    function registerValidator(\n        bytes memory publicKey,\n        uint64[] memory operatorIds,\n        bytes memory sharesData,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function bulkRegisterValidator(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds,\n        bytes[] calldata sharesData,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function removeOperator(uint64 operatorId) external;\n\n    function removeValidator(\n        bytes memory publicKey,\n        uint64[] memory operatorIds,\n        Cluster memory cluster\n    ) external;\n\n    function bulkRemoveValidator(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds,\n        Cluster memory cluster\n    ) external;\n\n    function renounceOwnership() external;\n\n    function setFeeRecipientAddress(address recipientAddress) external;\n\n    function setOperatorWhitelist(uint64 operatorId, address whitelisted)\n        external;\n\n    function transferOwnership(address newOwner) external;\n\n    function updateDeclareOperatorFeePeriod(uint64 timeInSeconds) external;\n\n    function updateExecuteOperatorFeePeriod(uint64 timeInSeconds) external;\n\n    function updateLiquidationThresholdPeriod(uint64 blocks) external;\n\n    function updateMaximumOperatorFee(uint64 maxFee) external;\n\n    function updateMinimumLiquidationCollateral(uint256 amount) external;\n\n    function updateModule(uint8 moduleId, address moduleAddress) external;\n\n    function updateNetworkFee(uint256 fee) external;\n\n    function updateOperatorFeeIncreaseLimit(uint64 percentage) external;\n\n    function upgradeTo(address newImplementation) external;\n\n    function upgradeToAndCall(address newImplementation, bytes memory data)\n        external\n        payable;\n\n    function withdraw(\n        uint64[] memory operatorIds,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function withdrawAllOperatorEarnings(uint64 operatorId) external;\n\n    function withdrawNetworkEarnings(uint256 amount) external;\n\n    function withdrawOperatorEarnings(uint64 operatorId, uint256 amount)\n        external;\n}\n"
    },
    "contracts/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Platform interface to integrate with lending platform like Compound, AAVE etc.\n */\ninterface IStrategy {\n    /**\n     * @dev Deposit the given asset to platform\n     * @param _asset asset address\n     * @param _amount Amount to deposit\n     */\n    function deposit(address _asset, uint256 _amount) external;\n\n    /**\n     * @dev Deposit the entire balance of all supported assets in the Strategy\n     *      to the platform\n     */\n    function depositAll() external;\n\n    /**\n     * @dev Withdraw given asset from Lending platform\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external;\n\n    /**\n     * @dev Liquidate all assets in strategy and return them to Vault.\n     */\n    function withdrawAll() external;\n\n    /**\n     * @dev Returns the current balance of the given asset.\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        returns (uint256 balance);\n\n    /**\n     * @dev Returns bool indicating whether strategy supports asset.\n     */\n    function supportsAsset(address _asset) external view returns (bool);\n\n    /**\n     * @dev Collect reward tokens from the Strategy.\n     */\n    function collectRewardTokens() external;\n\n    /**\n     * @dev The address array of the reward tokens for the Strategy.\n     */\n    function getRewardTokenAddresses() external view returns (address[] memory);\n}\n"
    },
    "contracts/interfaces/ISwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ISwapper {\n    /**\n     * @param fromAsset The token address of the asset being sold.\n     * @param toAsset The token address of the asset being purchased.\n     * @param fromAssetAmount The amount of assets being sold.\n     * @param minToAssetAmmount The minimum amount of assets to be purchased.\n     * @param data tx.data returned from 1Inch's /v5.0/1/swap API\n     */\n    function swap(\n        address fromAsset,\n        address toAsset,\n        uint256 fromAssetAmount,\n        uint256 minToAssetAmmount,\n        bytes calldata data\n    ) external returns (uint256 toAssetAmount);\n}\n"
    },
    "contracts/interfaces/ITimelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ITimelock {\n    function delay() external view returns (uint256);\n\n    function GRACE_PERIOD() external view returns (uint256);\n\n    function acceptAdmin() external;\n\n    function queuedTransactions(bytes32 hash) external view returns (bool);\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external returns (bytes32);\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external;\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external payable returns (bytes memory);\n}\n"
    },
    "contracts/interfaces/ITimelockController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ITimelockController {\n    function grantRole(bytes32 role, address account) external;\n\n    function revokeRole(bytes32 role, address account) external;\n\n    function renounceRole(bytes32 role, address account) external;\n\n    function hasRole(bytes32 role, address account)\n        external\n        view\n        returns (bool);\n\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) external payable;\n\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) external;\n\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) external view returns (bytes32);\n\n    function isOperationDone(bytes32 opHash) external view returns (bool);\n\n    function isOperationReady(bytes32 opHash) external view returns (bool);\n\n    function isOperation(bytes32 opHash) external view returns (bool);\n\n    function getMinDelay() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { VaultStorage } from \"../vault/VaultStorage.sol\";\n\ninterface IVault {\n    event AssetSupported(address _asset);\n    event AssetDefaultStrategyUpdated(address _asset, address _strategy);\n    event AssetAllocated(address _asset, address _strategy, uint256 _amount);\n    event StrategyApproved(address _addr);\n    event StrategyRemoved(address _addr);\n    event Mint(address _addr, uint256 _value);\n    event Redeem(address _addr, uint256 _value);\n    event CapitalPaused();\n    event CapitalUnpaused();\n    event RebasePaused();\n    event RebaseUnpaused();\n    event VaultBufferUpdated(uint256 _vaultBuffer);\n    event RedeemFeeUpdated(uint256 _redeemFeeBps);\n    event PriceProviderUpdated(address _priceProvider);\n    event AllocateThresholdUpdated(uint256 _threshold);\n    event RebaseThresholdUpdated(uint256 _threshold);\n    event StrategistUpdated(address _address);\n    event MaxSupplyDiffChanged(uint256 maxSupplyDiff);\n    event YieldDistribution(address _to, uint256 _yield, uint256 _fee);\n    event TrusteeFeeBpsChanged(uint256 _basis);\n    event TrusteeAddressChanged(address _address);\n    event SwapperChanged(address _address);\n    event SwapAllowedUndervalueChanged(uint256 _basis);\n    event SwapSlippageChanged(address _asset, uint256 _basis);\n    event Swapped(\n        address indexed _fromAsset,\n        address indexed _toAsset,\n        uint256 _fromAssetAmount,\n        uint256 _toAssetAmount\n    );\n    event StrategyAddedToMintWhitelist(address indexed strategy);\n    event StrategyRemovedFromMintWhitelist(address indexed strategy);\n    event DripperChanged(address indexed _dripper);\n    event WithdrawalRequested(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount,\n        uint256 _queued\n    );\n    event WithdrawalClaimed(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount\n    );\n    event WithdrawalClaimable(uint256 _claimable, uint256 _newClaimable);\n\n    // Governable.sol\n    function transferGovernance(address _newGovernor) external;\n\n    function claimGovernance() external;\n\n    function governor() external view returns (address);\n\n    // VaultAdmin.sol\n    function setPriceProvider(address _priceProvider) external;\n\n    function priceProvider() external view returns (address);\n\n    function setRedeemFeeBps(uint256 _redeemFeeBps) external;\n\n    function redeemFeeBps() external view returns (uint256);\n\n    function setVaultBuffer(uint256 _vaultBuffer) external;\n\n    function vaultBuffer() external view returns (uint256);\n\n    function setAutoAllocateThreshold(uint256 _threshold) external;\n\n    function autoAllocateThreshold() external view returns (uint256);\n\n    function setRebaseThreshold(uint256 _threshold) external;\n\n    function rebaseThreshold() external view returns (uint256);\n\n    function setStrategistAddr(address _address) external;\n\n    function strategistAddr() external view returns (address);\n\n    function setMaxSupplyDiff(uint256 _maxSupplyDiff) external;\n\n    function maxSupplyDiff() external view returns (uint256);\n\n    function setTrusteeAddress(address _address) external;\n\n    function trusteeAddress() external view returns (address);\n\n    function setTrusteeFeeBps(uint256 _basis) external;\n\n    function trusteeFeeBps() external view returns (uint256);\n\n    function ousdMetaStrategy() external view returns (address);\n\n    function setSwapper(address _swapperAddr) external;\n\n    function setSwapAllowedUndervalue(uint16 _percentageBps) external;\n\n    function setOracleSlippage(address _asset, uint16 _allowedOracleSlippageBps)\n        external;\n\n    function supportAsset(address _asset, uint8 _supportsAsset) external;\n\n    function approveStrategy(address _addr) external;\n\n    function removeStrategy(address _addr) external;\n\n    function setAssetDefaultStrategy(address _asset, address _strategy)\n        external;\n\n    function assetDefaultStrategies(address _asset)\n        external\n        view\n        returns (address);\n\n    function pauseRebase() external;\n\n    function unpauseRebase() external;\n\n    function rebasePaused() external view returns (bool);\n\n    function pauseCapital() external;\n\n    function unpauseCapital() external;\n\n    function capitalPaused() external view returns (bool);\n\n    function transferToken(address _asset, uint256 _amount) external;\n\n    function priceUnitMint(address asset) external view returns (uint256);\n\n    function priceUnitRedeem(address asset) external view returns (uint256);\n\n    function withdrawAllFromStrategy(address _strategyAddr) external;\n\n    function withdrawAllFromStrategies() external;\n\n    function withdrawFromStrategy(\n        address _strategyFromAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external;\n\n    function depositToStrategy(\n        address _strategyToAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external;\n\n    // VaultCore.sol\n    function mint(\n        address _asset,\n        uint256 _amount,\n        uint256 _minimumOusdAmount\n    ) external;\n\n    function mintForStrategy(uint256 _amount) external;\n\n    function redeem(uint256 _amount, uint256 _minimumUnitAmount) external;\n\n    function burnForStrategy(uint256 _amount) external;\n\n    function redeemAll(uint256 _minimumUnitAmount) external;\n\n    function allocate() external;\n\n    function rebase() external;\n\n    function swapCollateral(\n        address fromAsset,\n        address toAsset,\n        uint256 fromAssetAmount,\n        uint256 minToAssetAmount,\n        bytes calldata data\n    ) external returns (uint256 toAssetAmount);\n\n    function totalValue() external view returns (uint256 value);\n\n    function checkBalance(address _asset) external view returns (uint256);\n\n    function calculateRedeemOutputs(uint256 _amount)\n        external\n        view\n        returns (uint256[] memory);\n\n    function getAssetCount() external view returns (uint256);\n\n    function getAssetConfig(address _asset)\n        external\n        view\n        returns (VaultStorage.Asset memory config);\n\n    function getAllAssets() external view returns (address[] memory);\n\n    function getStrategyCount() external view returns (uint256);\n\n    function swapper() external view returns (address);\n\n    function allowedSwapUndervalue() external view returns (uint256);\n\n    function getAllStrategies() external view returns (address[] memory);\n\n    function isSupportedAsset(address _asset) external view returns (bool);\n\n    function netOusdMintForStrategyThreshold() external view returns (uint256);\n\n    function setOusdMetaStrategy(address _ousdMetaStrategy) external;\n\n    function setNetOusdMintForStrategyThreshold(uint256 _threshold) external;\n\n    function netOusdMintedForStrategy() external view returns (int256);\n\n    function setDripper(address _dripper) external;\n\n    function weth() external view returns (address);\n\n    function cacheWETHAssetIndex() external;\n\n    function wethAssetIndex() external view returns (uint256);\n\n    function initialize(address, address) external;\n\n    function setAdminImpl(address) external;\n\n    function removeAsset(address _asset) external;\n\n    // These are OETH specific functions\n    function addWithdrawalQueueLiquidity() external;\n\n    function requestWithdrawal(uint256 _amount)\n        external\n        returns (uint256 requestId, uint256 queued);\n\n    function claimWithdrawal(uint256 requestId)\n        external\n        returns (uint256 amount);\n\n    function claimWithdrawals(uint256[] memory requestIds)\n        external\n        returns (uint256[] memory amounts, uint256 totalAmount);\n\n    function withdrawalQueueMetadata()\n        external\n        view\n        returns (VaultStorage.WithdrawalQueueMetadata memory);\n\n    function withdrawalRequests(uint256 requestId)\n        external\n        view\n        returns (VaultStorage.WithdrawalRequest memory);\n\n    // OETHb specific functions\n    function addStrategyToMintWhitelist(address strategyAddr) external;\n\n    function removeStrategyFromMintWhitelist(address strategyAddr) external;\n\n    function isMintWhitelistedStrategy(address strategyAddr)\n        external\n        view\n        returns (bool);\n}\n"
    },
    "contracts/interfaces/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWETH9 {\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    function allowance(address, address) external view returns (uint256);\n\n    function approve(address guy, uint256 wad) external returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function deposit() external payable;\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address dst, uint256 wad) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function withdraw(uint256 wad) external;\n}\n"
    },
    "contracts/interfaces/IWstETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWstETH {\n    /**\n     * @notice Get amount of wstETH for a given amount of stETH\n     * @param _stETHAmount amount of stETH\n     * @return Amount of wstETH for a given stETH amount\n     */\n    function getWstETHByStETH(uint256 _stETHAmount)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Get amount of stETH for a given amount of wstETH\n     * @param _wstETHAmount amount of wstETH\n     * @return Amount of stETH for a given wstETH amount\n     */\n    function getStETHByWstETH(uint256 _wstETHAmount)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Get amount of stETH for a one wstETH\n     * @return Amount of stETH for 1 wstETH\n     */\n    function stEthPerToken() external view returns (uint256);\n\n    /**\n     * @notice Get amount of wstETH for a one stETH\n     * @return Amount of wstETH for a 1 stETH\n     */\n    function tokensPerStEth() external view returns (uint256);\n\n    /**\n     * @notice Exchanges stETH to wstETH\n     * @param _stETHAmount amount of stETH to wrap in exchange for wstETH\n     * @dev Requirements:\n     *  - `_stETHAmount` must be non-zero\n     *  - msg.sender must approve at least `_stETHAmount` stETH to this\n     *    contract.\n     *  - msg.sender must have at least `_stETHAmount` of stETH.\n     * User should first approve _stETHAmount to the WstETH contract\n     * @return Amount of wstETH user receives after wrap\n     */\n    function wrap(uint256 _stETHAmount) external returns (uint256);\n\n    /**\n     * @notice Exchanges wstETH to stETH\n     * @param _wstETHAmount amount of wstETH to uwrap in exchange for stETH\n     * @dev Requirements:\n     *  - `_wstETHAmount` must be non-zero\n     *  - msg.sender must have at least `_wstETHAmount` wstETH.\n     * @return Amount of stETH user receives after unwrap\n     */\n    function unwrap(uint256 _wstETHAmount) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/morpho/compound/ICompoundOracle.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.0;\n\ninterface ICompoundOracle {\n    function getUnderlyingPrice(address) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/morpho/ILens.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.0;\n\nimport \"./compound/ICompoundOracle.sol\";\nimport \"./IMorpho.sol\";\n\ninterface ILens {\n    /// STORAGE ///\n\n    function MAX_BASIS_POINTS() external view returns (uint256);\n\n    function WAD() external view returns (uint256);\n\n    function morpho() external view returns (IMorpho);\n\n    function comptroller() external view returns (IComptroller);\n\n    /// GENERAL ///\n\n    function getTotalSupply()\n        external\n        view\n        returns (\n            uint256 p2pSupplyAmount,\n            uint256 poolSupplyAmount,\n            uint256 totalSupplyAmount\n        );\n\n    function getTotalBorrow()\n        external\n        view\n        returns (\n            uint256 p2pBorrowAmount,\n            uint256 poolBorrowAmount,\n            uint256 totalBorrowAmount\n        );\n\n    /// MARKETS ///\n\n    function isMarketCreated(address _poolToken) external view returns (bool);\n\n    function isMarketCreatedAndNotPaused(address _poolToken)\n        external\n        view\n        returns (bool);\n\n    function isMarketCreatedAndNotPausedNorPartiallyPaused(address _poolToken)\n        external\n        view\n        returns (bool);\n\n    function getAllMarkets()\n        external\n        view\n        returns (address[] memory marketsCreated_);\n\n    function getMainMarketData(address _poolToken)\n        external\n        view\n        returns (\n            uint256 avgSupplyRatePerBlock,\n            uint256 avgBorrowRatePerBlock,\n            uint256 p2pSupplyAmount,\n            uint256 p2pBorrowAmount,\n            uint256 poolSupplyAmount,\n            uint256 poolBorrowAmount\n        );\n\n    function getAdvancedMarketData(address _poolToken)\n        external\n        view\n        returns (\n            uint256 p2pSupplyIndex,\n            uint256 p2pBorrowIndex,\n            uint256 poolSupplyIndex,\n            uint256 poolBorrowIndex,\n            uint32 lastUpdateBlockNumber,\n            uint256 p2pSupplyDelta,\n            uint256 p2pBorrowDelta\n        );\n\n    function getMarketConfiguration(address _poolToken)\n        external\n        view\n        returns (\n            address underlying,\n            bool isCreated,\n            bool p2pDisabled,\n            bool isPaused,\n            bool isPartiallyPaused,\n            uint16 reserveFactor,\n            uint16 p2pIndexCursor,\n            uint256 collateralFactor\n        );\n\n    function getTotalMarketSupply(address _poolToken)\n        external\n        view\n        returns (uint256 p2pSupplyAmount, uint256 poolSupplyAmount);\n\n    function getTotalMarketBorrow(address _poolToken)\n        external\n        view\n        returns (uint256 p2pBorrowAmount, uint256 poolBorrowAmount);\n\n    /// INDEXES ///\n\n    function getCurrentP2PSupplyIndex(address _poolToken)\n        external\n        view\n        returns (uint256);\n\n    function getCurrentP2PBorrowIndex(address _poolToken)\n        external\n        view\n        returns (uint256);\n\n    function getCurrentPoolIndexes(address _poolToken)\n        external\n        view\n        returns (\n            uint256 currentPoolSupplyIndex,\n            uint256 currentPoolBorrowIndex\n        );\n\n    function getIndexes(address _poolToken, bool _computeUpdatedIndexes)\n        external\n        view\n        returns (\n            uint256 p2pSupplyIndex,\n            uint256 p2pBorrowIndex,\n            uint256 poolSupplyIndex,\n            uint256 poolBorrowIndex\n        );\n\n    /// USERS ///\n\n    function getEnteredMarkets(address _user)\n        external\n        view\n        returns (address[] memory enteredMarkets);\n\n    function getUserHealthFactor(\n        address _user,\n        address[] calldata _updatedMarkets\n    ) external view returns (uint256);\n\n    function getUserBalanceStates(\n        address _user,\n        address[] calldata _updatedMarkets\n    )\n        external\n        view\n        returns (\n            uint256 collateralValue,\n            uint256 debtValue,\n            uint256 maxDebtValue\n        );\n\n    function getCurrentSupplyBalanceInOf(address _poolToken, address _user)\n        external\n        view\n        returns (\n            uint256 balanceOnPool,\n            uint256 balanceInP2P,\n            uint256 totalBalance\n        );\n\n    function getCurrentBorrowBalanceInOf(address _poolToken, address _user)\n        external\n        view\n        returns (\n            uint256 balanceOnPool,\n            uint256 balanceInP2P,\n            uint256 totalBalance\n        );\n\n    function getUserMaxCapacitiesForAsset(address _user, address _poolToken)\n        external\n        view\n        returns (uint256 withdrawable, uint256 borrowable);\n\n    function getUserHypotheticalBalanceStates(\n        address _user,\n        address _poolToken,\n        uint256 _withdrawnAmount,\n        uint256 _borrowedAmount\n    ) external view returns (uint256 debtValue, uint256 maxDebtValue);\n\n    function getUserLiquidityDataForAsset(\n        address _user,\n        address _poolToken,\n        bool _computeUpdatedIndexes,\n        ICompoundOracle _oracle\n    ) external view returns (Types.AssetLiquidityData memory assetData);\n\n    function isLiquidatable(address _user, address[] memory _updatedMarkets)\n        external\n        view\n        returns (bool);\n\n    function computeLiquidationRepayAmount(\n        address _user,\n        address _poolTokenBorrowed,\n        address _poolTokenCollateral,\n        address[] calldata _updatedMarkets\n    ) external view returns (uint256 toRepay);\n\n    /// RATES ///\n\n    function getAverageSupplyRatePerBlock(address _poolToken)\n        external\n        view\n        returns (\n            uint256 avgSupplyRatePerBlock,\n            uint256 p2pSupplyAmount,\n            uint256 poolSupplyAmount\n        );\n\n    function getAverageBorrowRatePerBlock(address _poolToken)\n        external\n        view\n        returns (\n            uint256 avgBorrowRatePerBlock,\n            uint256 p2pBorrowAmount,\n            uint256 poolBorrowAmount\n        );\n\n    function getNextUserSupplyRatePerBlock(\n        address _poolToken,\n        address _user,\n        uint256 _amount\n    )\n        external\n        view\n        returns (\n            uint256 nextSupplyRatePerBlock,\n            uint256 balanceOnPool,\n            uint256 balanceInP2P,\n            uint256 totalBalance\n        );\n\n    function getNextUserBorrowRatePerBlock(\n        address _poolToken,\n        address _user,\n        uint256 _amount\n    )\n        external\n        view\n        returns (\n            uint256 nextBorrowRatePerBlock,\n            uint256 balanceOnPool,\n            uint256 balanceInP2P,\n            uint256 totalBalance\n        );\n\n    function getCurrentUserSupplyRatePerBlock(address _poolToken, address _user)\n        external\n        view\n        returns (uint256);\n\n    function getCurrentUserBorrowRatePerBlock(address _poolToken, address _user)\n        external\n        view\n        returns (uint256);\n\n    function getRatesPerBlock(address _poolToken)\n        external\n        view\n        returns (\n            uint256 p2pSupplyRate,\n            uint256 p2pBorrowRate,\n            uint256 poolSupplyRate,\n            uint256 poolBorrowRate\n        );\n\n    /// REWARDS ///\n\n    function getUserUnclaimedRewards(\n        address[] calldata _poolTokens,\n        address _user\n    ) external view returns (uint256 unclaimedRewards);\n\n    function getAccruedSupplierComp(\n        address _supplier,\n        address _poolToken,\n        uint256 _balance\n    ) external view returns (uint256);\n\n    function getAccruedBorrowerComp(\n        address _borrower,\n        address _poolToken,\n        uint256 _balance\n    ) external view returns (uint256);\n\n    function getCurrentCompSupplyIndex(address _poolToken)\n        external\n        view\n        returns (uint256);\n\n    function getCurrentCompBorrowIndex(address _poolToken)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/interfaces/morpho/IMorpho.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.0;\n\nimport \"./Types.sol\";\nimport \"../IComptroller.sol\";\nimport \"./compound/ICompoundOracle.sol\";\n\n// prettier-ignore\ninterface IMorpho {\n    function comptroller() external view returns (IComptroller);\n    function supply(address _poolTokenAddress, address _onBehalf, uint256 _amount) external;\n    function supply(address _poolTokenAddress, address _onBehalf, uint256 _amount, uint256 _maxGasForMatching) external;\n    function withdraw(address _poolTokenAddress, uint256 _amount) external;\n    function claimRewards(\n        address[] calldata _cTokenAddresses,\n        bool _tradeForMorphoToken\n    ) external returns (uint256 claimedAmount);\n}\n"
    },
    "contracts/interfaces/morpho/Types.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.0;\n\n/// @title Types.\n/// @author Morpho Labs.\n/// @custom:contact security@morpho.xyz\n/// @dev Common types and structs used in Moprho contracts.\nlibrary Types {\n    /// ENUMS ///\n\n    enum PositionType {\n        SUPPLIERS_IN_P2P,\n        SUPPLIERS_ON_POOL,\n        BORROWERS_IN_P2P,\n        BORROWERS_ON_POOL\n    }\n\n    /// STRUCTS ///\n\n    struct SupplyBalance {\n        uint256 inP2P; // In supplier's peer-to-peer unit, a unit that grows in underlying value, to keep track of the interests earned by suppliers in peer-to-peer. Multiply by the peer-to-peer supply index to get the underlying amount.\n        uint256 onPool; // In cToken. Multiply by the pool supply index to get the underlying amount.\n    }\n\n    struct BorrowBalance {\n        uint256 inP2P; // In borrower's peer-to-peer unit, a unit that grows in underlying value, to keep track of the interests paid by borrowers in peer-to-peer. Multiply by the peer-to-peer borrow index to get the underlying amount.\n        uint256 onPool; // In cdUnit, a unit that grows in value, to keep track of the debt increase when borrowers are on Compound. Multiply by the pool borrow index to get the underlying amount.\n    }\n\n    // Max gas to consume during the matching process for supply, borrow, withdraw and repay functions.\n    struct MaxGasForMatching {\n        uint64 supply;\n        uint64 borrow;\n        uint64 withdraw;\n        uint64 repay;\n    }\n\n    struct Delta {\n        uint256 p2pSupplyDelta; // Difference between the stored peer-to-peer supply amount and the real peer-to-peer supply amount (in pool supply unit).\n        uint256 p2pBorrowDelta; // Difference between the stored peer-to-peer borrow amount and the real peer-to-peer borrow amount (in pool borrow unit).\n        uint256 p2pSupplyAmount; // Sum of all stored peer-to-peer supply (in peer-to-peer supply unit).\n        uint256 p2pBorrowAmount; // Sum of all stored peer-to-peer borrow (in peer-to-peer borrow unit).\n    }\n\n    struct AssetLiquidityData {\n        uint256 collateralValue; // The collateral value of the asset.\n        uint256 maxDebtValue; // The maximum possible debt value of the asset.\n        uint256 debtValue; // The debt value of the asset.\n        uint256 underlyingPrice; // The price of the token.\n        uint256 collateralFactor; // The liquidation threshold applied on this token.\n    }\n\n    struct LiquidityData {\n        uint256 collateralValue; // The collateral value.\n        uint256 maxDebtValue; // The maximum debt value possible.\n        uint256 debtValue; // The debt value.\n    }\n\n    // Variables are packed together to save gas (will not exceed their limit during Morpho's lifetime).\n    struct LastPoolIndexes {\n        uint32 lastUpdateBlockNumber; // The last time the peer-to-peer indexes were updated.\n        uint112 lastSupplyPoolIndex; // Last pool supply index.\n        uint112 lastBorrowPoolIndex; // Last pool borrow index.\n    }\n\n    struct MarketParameters {\n        uint16 reserveFactor; // Proportion of the interest earned by users sent to the DAO for each market, in basis point (100% = 10 000). The value is set at market creation.\n        uint16 p2pIndexCursor; // Position of the peer-to-peer rate in the pool's spread. Determine the weights of the weighted arithmetic average in the indexes computations ((1 - p2pIndexCursor) * r^S + p2pIndexCursor * r^B) (in basis point).\n    }\n\n    struct MarketStatus {\n        bool isCreated; // Whether or not this market is created.\n        bool isPaused; // Whether the market is paused or not (all entry points on Morpho are frozen; supply, borrow, withdraw, repay and liquidate).\n        bool isPartiallyPaused; // Whether the market is partially paused or not (only supply and borrow are frozen).\n    }\n}\n"
    },
    "contracts/interfaces/Tether.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface Tether {\n    function transfer(address to, uint256 value) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external;\n\n    function balanceOf(address) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/uniswap/IUniswapUniversalRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUniswapUniversalRouter {\n    /// @notice Executes encoded commands along with provided inputs. Reverts if deadline has expired.\n    /// @param commands A set of concatenated commands, each 1 byte in length\n    /// @param inputs An array of byte strings containing abi encoded inputs for each command\n    /// @param deadline The deadline by which the transaction must be executed\n    function execute(\n        bytes calldata commands,\n        bytes[] calldata inputs,\n        uint256 deadline\n    ) external payable;\n\n    function execute(bytes calldata commands, bytes[] calldata inputs)\n        external\n        payable;\n}\n"
    },
    "contracts/interfaces/uniswap/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Pair {\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function sync() external;\n}\n"
    },
    "contracts/interfaces/uniswap/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Router {\n    function WETH() external pure returns (address);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n}\n"
    },
    "contracts/interfaces/uniswap/IUniswapV3Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// -- Solididy v0.5.x compatible interface\ninterface IUniswapV3Router {\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n}\n"
    },
    "contracts/liquidity/LiquidityReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\n\n//\n// LiquidityReward contract doles out reward for liquidity\n//   base off of Sushiswap's MasterChef: https://github.com/sushiswap/sushiswap/blob/master/contracts/MasterChef.sol\n//\ncontract LiquidityReward is Initializable, Governable {\n    using SafeMath for uint256;\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // Info of each user.\n    struct UserInfo {\n        uint256 amount; // How many LP tokens the user has provided.\n        int256 rewardDebt; // Reward debt. See explanation below.\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of Reward Tokens\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * pool.accRewardPerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. The pool's `accRewardPerShare` (and `lastRewardBlock`) gets updated.\n        //   2. User receives the pending reward sent to his/her address.\n        //   3. User's `amount` gets updated.\n        //   4. User's `rewardDebt` gets updated.\n        //\n        // NOTE: rewardDebt can go negative because we allow withdraws without claiming the reward\n        //       in that case we owe the account holder some reward.\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 lpToken; // Address of LP token contract.\n        uint256 lastRewardBlock; // Last block number that Reward calculation occurs.\n        uint256 accRewardPerShare; // Accumulated Reward per share in reward precision. See below.\n    }\n\n    // The Reward token\n    IERC20 public reward;\n\n    // Reward tokens created per block in 1e18 precision.\n    uint256 public rewardPerBlock;\n\n    // Info on the LP.\n    PoolInfo public pool;\n    // total Reward debt, useful to calculate if we have enough to pay out all rewards\n    int256 public totalRewardDebt;\n    // total Supply that is accounted for via deposit/withdraw so that our rewards calc are stable\n    uint256 public totalSupply;\n    // Info of each user that stakes LP tokens.\n    mapping(address => UserInfo) public userInfo;\n    // The block number when Liquidity rewards ends.\n    uint256 public endBlock;\n\n    event CampaignStarted(\n        uint256 rewardRate,\n        uint256 startBlock,\n        uint256 endBlock\n    );\n    event CampaignStopped(uint256 endBlock);\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event Claim(address indexed user, uint256 amount);\n    event DrainExtraReward(address indexed user, uint256 amount);\n    event DrainExtraLP(address indexed user, uint256 amount);\n\n    /**\n     * Initializer for setting up Liquidity Reward internal state.\n     * @param _reward Address of the reward token(OGN)\n     * @param _lpToken Address of the LP token(Uniswap Pair)\n     */\n    function initialize(IERC20 _reward, IERC20 _lpToken)\n        external\n        onlyGovernor\n        initializer\n    {\n        reward = _reward;\n        pool.lpToken = _lpToken;\n        pool.lastRewardBlock = block.number;\n    }\n\n    /**\n     * @dev start a new reward campaign.\n     *      This will calculate all rewards up to the current block at the old rate.\n     *      This ensures that we pay everyone at the promised rate before update to the new rate.\n     * @param _rewardPerBlock Amount rewarded per block\n     * @param _startBlock Block number that we want to start the rewards at (0 for current block)\n     * @param _numBlocks number of blocks that the campaign should last\n     */\n    function startCampaign(\n        uint256 _rewardPerBlock,\n        uint256 _startBlock,\n        uint256 _numBlocks\n    ) external onlyGovernor {\n        // Calculate up to the current block at the current rate for everyone.\n        updatePool();\n\n        // total Pending calculated at the current pool rate\n        uint256 totalPending = subDebt(\n            pool.accRewardPerShare.mulTruncate(totalSupply),\n            totalRewardDebt\n        );\n\n        require(_numBlocks > 0, \"startCampaign: zero blocks\");\n\n        require(\n            reward.balanceOf(address(this)) >=\n                _rewardPerBlock.mul(_numBlocks).add(totalPending),\n            \"startCampaign: insufficient rewards\"\n        );\n\n        uint256 startBlock = _startBlock;\n        if (startBlock == 0) {\n            // start block number isn't given so we start at the current\n            startBlock = block.number;\n        }\n        require(\n            startBlock >= block.number,\n            \"startCampaign: _startBlock can't be in the past\"\n        );\n        endBlock = startBlock.add(_numBlocks);\n        // we don't start accrue until the startBlock\n        pool.lastRewardBlock = startBlock;\n        // new blocks start at the new reward rate\n        rewardPerBlock = _rewardPerBlock;\n        emit CampaignStarted(rewardPerBlock, startBlock, endBlock);\n    }\n\n    function stopCampaign() external onlyGovernor {\n        //calculate until current pool\n        updatePool();\n        //end the block here (the CampaignMultiplier will be zero)\n        endBlock = block.number;\n        emit CampaignStopped(endBlock);\n    }\n\n    function drainExtraRewards() external onlyGovernor {\n        require(endBlock < block.number, \"drainExtraRewards:Campaign active\");\n        updatePool();\n        uint256 extraRewards = reward.balanceOf(address(this)).sub(\n            subDebt(\n                pool.accRewardPerShare.mulTruncate(totalSupply),\n                totalRewardDebt\n            )\n        );\n        if (extraRewards > 0) {\n            emit DrainExtraReward(msg.sender, extraRewards);\n            reward.safeTransfer(msg.sender, extraRewards);\n        }\n    }\n\n    function drainExtraLP() external onlyGovernor {\n        uint256 extraLP = pool.lpToken.balanceOf(address(this)).sub(\n            totalSupply\n        );\n        require(extraLP > 0, \"drainExtraLP:no extra\");\n        emit DrainExtraLP(msg.sender, extraLP);\n        pool.lpToken.safeTransfer(msg.sender, extraLP);\n    }\n\n    function campaignActive() external view returns (bool) {\n        return endBlock > block.number && block.number >= pool.lastRewardBlock;\n    }\n\n    function balanceOf(address _account) external view returns (uint256) {\n        return userInfo[_account].amount;\n    }\n\n    /**\n     * @dev calculate the number of blocks since we last updated\n     *       within start and end as constraints\n     * @param _to Block number of the ending point.\n     * @return multiplier Multiplier over the given _from to _to block.\n     */\n    function getCampaignMultiplier(uint256 _to)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 from = pool.lastRewardBlock;\n        if (from > endBlock) {\n            return 0;\n        } else {\n            return (_to < endBlock ? _to : endBlock).sub(from);\n        }\n    }\n\n    /**\n     * @dev View function to see pending rewards for each account on frontend.\n     * @param _user Address of the account we're looking up.\n     * @return reward Total rewards owed to this account.\n     */\n    function pendingRewards(address _user) external view returns (uint256) {\n        UserInfo storage user = userInfo[_user];\n        return _pendingRewards(user);\n    }\n\n    function _pendingRewards(UserInfo storage user)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        if (block.number > pool.lastRewardBlock) {\n            if (totalSupply != 0) {\n                uint256 multiplier = getCampaignMultiplier(block.number);\n                uint256 incReward = multiplier.mul(rewardPerBlock);\n                accRewardPerShare = accRewardPerShare.add(\n                    incReward.divPrecisely(totalSupply)\n                );\n            }\n        }\n        return\n            subDebt(\n                user.amount.mulTruncate(accRewardPerShare),\n                user.rewardDebt\n            );\n    }\n\n    /**\n     * @dev View function to see total outstanding rewards for the entire contract.\n     *      This is how much is owed when everyone pulls out.\n     * @return reward Total rewards owed to everyone.\n     */\n    function totalOutstandingRewards() external view returns (uint256) {\n        if (block.number > pool.lastRewardBlock && totalSupply != 0) {\n            uint256 multiplier = getCampaignMultiplier(block.number);\n            uint256 incReward = multiplier.mul(rewardPerBlock);\n            uint256 accRewardPerShare = pool.accRewardPerShare;\n            accRewardPerShare = accRewardPerShare.add(\n                incReward.divPrecisely(totalSupply)\n            );\n            return\n                subDebt(\n                    accRewardPerShare.mulTruncate(totalSupply),\n                    totalRewardDebt\n                );\n        }\n        // no supply or not even started\n        return 0;\n    }\n\n    /**\n     * @dev External call for updating the pool.\n     */\n    function doUpdatePool() external {\n        // There should be no harm allowing anyone to call this function.\n        // It just updates the latest accRewardPerShare for the pool.\n        updatePool();\n    }\n\n    /**\n     * @dev Update the Liquidity Pool reward multiplier.\n     *      This locks in the accRewardPerShare from the last update block number to now.\n     *      Will fail if we do not have enough to pay everyone.\n     *      Always call updatePool whenever the balance changes!\n     */\n    function updatePool() internal {\n        if (\n            block.number <= pool.lastRewardBlock ||\n            endBlock <= pool.lastRewardBlock\n        ) {\n            return;\n        }\n\n        if (totalSupply == 0) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }\n\n        uint256 incReward = getCampaignMultiplier(block.number).mul(\n            rewardPerBlock\n        );\n        // we are of course assuming lpTokens are in 1e18 precision\n        uint256 accRewardPerShare = pool.accRewardPerShare.add(\n            incReward.divPrecisely(totalSupply)\n        );\n\n        pool.accRewardPerShare = accRewardPerShare;\n        pool.lastRewardBlock = block.number;\n    }\n\n    /**\n     * @dev Deposit LP tokens into contract, must be preapproved.\n     * @param _amount Amount of LPToken to deposit.\n     */\n    function deposit(uint256 _amount) external {\n        UserInfo storage user = userInfo[msg.sender];\n        updatePool();\n        if (_amount > 0) {\n            user.amount = user.amount.add(_amount);\n            // newDebt is equal to the change in amount * accRewardPerShare (note accRewardPerShare is historic)\n            int256 newDebt = int256(\n                _amount.mulTruncate(pool.accRewardPerShare)\n            );\n            user.rewardDebt += newDebt;\n            totalRewardDebt += newDebt;\n            totalSupply = totalSupply.add(_amount);\n            emit Deposit(msg.sender, _amount);\n            pool.lpToken.safeTransferFrom(\n                address(msg.sender),\n                address(this),\n                _amount\n            );\n        }\n    }\n\n    /**\n     * @dev Exit out of the contract completely, withdraw LP tokens and claim rewards\n     */\n    function exit() external {\n        UserInfo storage user = userInfo[msg.sender];\n        // withdraw everything\n        _withdraw(user, user.amount, true);\n    }\n\n    /**\n     * @dev Withdraw LP tokens from contract.\n     * @param _amount Amount of LPToken to withdraw.\n     * @param _claim Boolean do we want to claim our rewards or not\n     */\n    function withdraw(uint256 _amount, bool _claim) external {\n        UserInfo storage user = userInfo[msg.sender];\n        _withdraw(user, _amount, _claim);\n    }\n\n    function _withdraw(\n        UserInfo storage user,\n        uint256 _amount,\n        bool _claim\n    ) internal {\n        require(user.amount >= _amount, \"withdraw: overflow\");\n        updatePool();\n\n        // newDebt is equal to the change in amount * accRewardPerShare (note accRewardPerShare is historic)\n        int256 newDebt = -int256(_amount.mulTruncate(pool.accRewardPerShare));\n        uint256 pending = 0;\n        if (_claim) {\n            //This is an optimization so we don't modify the storage variable twice\n            pending = subDebt(\n                user.amount.mulTruncate(pool.accRewardPerShare),\n                user.rewardDebt\n            );\n\n            newDebt += int256(pending);\n        }\n\n        user.rewardDebt += newDebt;\n        totalRewardDebt += newDebt;\n        emit Withdraw(msg.sender, _amount);\n        // actually make the changes to the amount and debt\n        if (_amount > 0) {\n            user.amount = user.amount.sub(_amount);\n            totalSupply = totalSupply.sub(_amount, \"withdraw: total overflow\");\n        }\n        //putting this all at the end to avoid reentrancy error\n        if (pending > 0) {\n            emit Claim(msg.sender, pending);\n            reward.safeTransfer(msg.sender, pending);\n        }\n        if (_amount > 0) {\n            pool.lpToken.safeTransfer(address(msg.sender), _amount);\n        }\n    }\n\n    /**\n     * @dev Claim all pending rewards up to current block\n     */\n    function claim() external {\n        UserInfo storage user = userInfo[msg.sender];\n        uint256 pending = _pendingRewards(user);\n        if (pending > 0) {\n            emit Claim(msg.sender, pending);\n            int256 debtDelta = int256(pending);\n            user.rewardDebt += debtDelta;\n            totalRewardDebt += debtDelta;\n            reward.safeTransfer(msg.sender, pending);\n        }\n    }\n\n    function subDebt(uint256 amount, int256 debt)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        if (debt < 0) {\n            result = amount.add(uint256(-debt));\n        } else {\n            result = amount.sub(uint256(debt));\n        }\n    }\n}\n"
    },
    "contracts/mocks/BurnableERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IBurnableERC20 {\n    function burn(uint256 value) external returns (bool);\n\n    function burnFrom(address account, uint256 value) external returns (bool);\n}\n\n/**\n * @title BurnableERC20\n * @dev Exposes the burn function of ERC20 for tests\n */\nabstract contract BurnableERC20 is IBurnableERC20, ERC20 {\n    /**\n     * @dev Function to burn tokens\n     * @param value The amount of tokens to burn.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function burn(uint256 value) public virtual override returns (bool) {\n        _burn(msg.sender, value);\n        return true;\n    }\n\n    /**\n     * @dev Function to burn tokens from a specific account\n     * @param account The address with the tokens to burn.\n     * @param value The amount of tokens to burn.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function burnFrom(address account, uint256 value)\n        public\n        override\n        returns (bool)\n    {\n        _burn(account, value);\n        return true;\n    }\n}\n"
    },
    "contracts/mocks/curve/Mock3CRV.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ERC20, MintableERC20 } from \"../MintableERC20.sol\";\nimport { BurnableERC20 } from \"../BurnableERC20.sol\";\n\ncontract Mock3CRV is MintableERC20, BurnableERC20 {\n    constructor() ERC20(\"Curve.fi DAI/USDC/USDT\", \"3Crv\") {}\n\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n}\n"
    },
    "contracts/mocks/curve/MockBooster.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { MockRewardPool } from \"./MockRewardPool.sol\";\n\nimport { IRewardStaking } from \"../../strategies/IRewardStaking.sol\";\nimport { IMintableERC20, MintableERC20, ERC20 } from \"../MintableERC20.sol\";\nimport { IBurnableERC20, BurnableERC20 } from \"../BurnableERC20.sol\";\n\ncontract MockDepositToken is MintableERC20, BurnableERC20 {\n    constructor() ERC20(\"DCVX\", \"CVX Deposit Token\") {}\n}\n\ncontract MockBooster {\n    using SafeERC20 for IERC20;\n\n    struct PoolInfo {\n        address lptoken;\n        address token;\n        address crvRewards;\n    }\n\n    address public minter; // this is CVx for the booster on live\n    address public crv; // Curve rewards token\n    address public cvx; // Convex rewards token\n    mapping(uint256 => PoolInfo) public poolInfo;\n\n    constructor(\n        address _rewardsMinter,\n        address _crv,\n        address _cvx\n    ) public {\n        minter = _rewardsMinter;\n        crv = _crv;\n        cvx = _cvx;\n    }\n\n    function setPool(uint256 pid, address _lpToken)\n        external\n        returns (address rewards)\n    {\n        address token = address(new MockDepositToken());\n        // Deploy a new Convex Rewards Pool\n        rewards = address(\n            new MockRewardPool(pid, token, crv, cvx, address(this))\n        );\n\n        poolInfo[pid] = PoolInfo({\n            lptoken: _lpToken,\n            token: token,\n            crvRewards: rewards\n        });\n    }\n\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool _stake\n    ) public returns (bool) {\n        PoolInfo storage pool = poolInfo[_pid];\n\n        address lptoken = pool.lptoken;\n\n        // hold on to the Curve LP tokens\n        IERC20(lptoken).safeTransferFrom(msg.sender, address(this), _amount);\n\n        address token = pool.token;\n        if (_stake) {\n            // mint Convex pool LP tokens and stake in rewards contract on user behalf\n            IMintableERC20(token).mint(_amount);\n            address rewardContract = pool.crvRewards;\n            IERC20(token).safeApprove(rewardContract, 0);\n            IERC20(token).safeApprove(rewardContract, _amount);\n            IRewardStaking(rewardContract).stakeFor(msg.sender, _amount);\n        } else {\n            // mint Convex pool LP tokens and send to user\n            IMintableERC20(token).mint(_amount);\n            IERC20(token).transfer(msg.sender, _amount);\n        }\n        return true;\n    }\n\n    // Deposit all Curve LP tokens and stake\n    function depositAll(uint256 _pid, bool _stake) external returns (bool) {\n        address lptoken = poolInfo[_pid].lptoken;\n        uint256 balance = IERC20(lptoken).balanceOf(msg.sender);\n        deposit(_pid, balance, _stake);\n        return true;\n    }\n\n    // withdraw Curve LP tokens\n    function _withdraw(\n        uint256 _pid,\n        uint256 _amount,\n        address _from,\n        address _to\n    ) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n\n        // burn the Convex pool LP tokens\n        IBurnableERC20(pool.token).burnFrom(_from, _amount);\n\n        // return the Curve LP tokens\n        IERC20(pool.lptoken).safeTransfer(_to, _amount);\n    }\n\n    // withdraw Curve LP tokens\n    function withdraw(uint256 _pid, uint256 _amount) public returns (bool) {\n        _withdraw(_pid, _amount, msg.sender, msg.sender);\n        return true;\n    }\n\n    // withdraw all Curve LP tokens\n    function withdrawAll(uint256 _pid) public returns (bool) {\n        address token = poolInfo[_pid].token;\n        uint256 userBal = IERC20(token).balanceOf(msg.sender);\n        withdraw(_pid, userBal);\n        return true;\n    }\n\n    // allow reward contracts to send here and withdraw to user\n    function withdrawTo(\n        uint256 _pid,\n        uint256 _amount,\n        address _to\n    ) external returns (bool) {\n        address rewardContract = poolInfo[_pid].crvRewards;\n        require(msg.sender == rewardContract, \"!auth\");\n\n        _withdraw(_pid, _amount, msg.sender, _to);\n        return true;\n    }\n\n    // callback from reward contract when crv is received.\n    function rewardClaimed(\n        uint256 _pid,\n        // solhint-disable-next-line no-unused-vars\n        address _address,\n        uint256 _amount\n    ) external returns (bool) {\n        address rewardContract = poolInfo[_pid].crvRewards;\n        require(msg.sender == rewardContract, \"!auth\");\n\n        //mint reward tokens\n        // and transfer it\n        IMintableERC20(minter).mint(_amount);\n        IERC20(minter).transfer(msg.sender, _amount);\n        return true;\n    }\n}\n"
    },
    "contracts/mocks/curve/MockCRV.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../MintableERC20.sol\";\n\ncontract MockCRV is MintableERC20 {\n    constructor() ERC20(\"Curve DAO Token\", \"CRV\") {}\n\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n}\n"
    },
    "contracts/mocks/curve/MockCRVMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IMintableERC20 } from \"../MintableERC20.sol\";\n\ncontract MockCRVMinter {\n    address crv;\n\n    constructor(address _crv) {\n        crv = _crv;\n    }\n\n    function mint(address _address) external {\n        uint256 amount = 2e18;\n        IMintableERC20(crv).mint(amount);\n        IERC20(crv).transfer(_address, amount);\n    }\n}\n"
    },
    "contracts/mocks/curve/MockCurveAbstractMetapool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { MintableERC20, IMintableERC20 } from \"../MintableERC20.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\nimport \"../../utils/Helpers.sol\";\n\nabstract contract MockCurveAbstractMetapool is MintableERC20 {\n    using StableMath for uint256;\n\n    address[] public coins;\n    uint256[2] public balances;\n\n    // Returns the same amount of LP tokens in 1e18 decimals\n    function add_liquidity(uint256[2] calldata _amounts, uint256 _minAmount)\n        external\n        returns (uint256 lpAmount)\n    {\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            if (_amounts[i] > 0) {\n                IERC20(coins[i]).transferFrom(\n                    msg.sender,\n                    address(this),\n                    _amounts[i]\n                );\n                uint256 assetDecimals = Helpers.getDecimals(coins[i]);\n                // Convert to 1e18 and add to sum\n                lpAmount += _amounts[i].scaleBy(18, assetDecimals);\n                balances[i] = balances[i] + _amounts[i];\n            }\n        }\n        // Hacky way of simulating slippage to check _minAmount\n        if (lpAmount == 29000e18) lpAmount = 14500e18;\n        require(lpAmount >= _minAmount, \"Slippage ruined your day\");\n        // Send LP token to sender, e.g. 3CRV\n        _mint(msg.sender, lpAmount);\n    }\n\n    // Dumb implementation that returns the same amount\n    function calc_withdraw_one_coin(uint256 _amount, int128 _index)\n        public\n        view\n        returns (uint256 lpAmount)\n    {\n        uint256 assetDecimals = Helpers.getDecimals(coins[uint128(_index)]);\n        lpAmount = _amount.scaleBy(assetDecimals, 18);\n    }\n\n    function remove_liquidity_one_coin(\n        uint256 _lpAmount,\n        int128 _index,\n        // solhint-disable-next-line no-unused-vars\n        uint256 _minAmount\n    ) external returns (uint256 amount) {\n        _burn(msg.sender, _lpAmount);\n        uint256[] memory amounts = new uint256[](coins.length);\n        amounts[uint128(_index)] = _lpAmount;\n        amount = calc_withdraw_one_coin(_lpAmount, _index);\n        balances[uint128(_index)] -= amount;\n        IERC20(coins[uint128(_index)]).transfer(msg.sender, amount);\n    }\n\n    function get_virtual_price() external pure returns (uint256) {\n        return 1e18;\n    }\n\n    // solhint-disable-next-line no-unused-vars\n    function remove_liquidity(uint256 _amount, uint256[2] memory _min_amounts)\n        public\n        returns (uint256[2] memory amounts)\n    {\n        _burn(msg.sender, _amount);\n        uint256 totalSupply = totalSupply();\n        for (uint256 i = 0; i < 2; i++) {\n            amounts[i] = totalSupply > 0\n                ? (_amount * IERC20(coins[i]).balanceOf(address(this))) /\n                    totalSupply\n                : IERC20(coins[i]).balanceOf(address(this));\n            balances[i] -= amounts[i];\n            IERC20(coins[i]).transfer(msg.sender, amounts[i]);\n        }\n    }\n\n    function remove_liquidity_imbalance(\n        uint256[2] memory _amounts,\n        uint256 _max_burned_tokens\n    ) public returns (uint256) {\n        return\n            _remove_liquidity_imbalance(\n                _amounts,\n                _max_burned_tokens,\n                msg.sender\n            );\n    }\n\n    function remove_liquidity_imbalance(\n        uint256[2] memory _amounts,\n        uint256 _max_burned_tokens,\n        address _reveiver\n    ) public returns (uint256) {\n        return\n            _remove_liquidity_imbalance(\n                _amounts,\n                _max_burned_tokens,\n                _reveiver\n            );\n    }\n\n    function _remove_liquidity_imbalance(\n        uint256[2] memory _amounts,\n        uint256 _max_burned_tokens,\n        address _reveiver\n    ) internal returns (uint256 lpTokens) {\n        lpTokens = _max_burned_tokens;\n        _burn(msg.sender, lpTokens);\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            balances[i] -= _amounts[i];\n            if (_amounts[i] > 0) {\n                IERC20(coins[i]).transfer(_reveiver, _amounts[i]);\n            }\n        }\n    }\n\n    // Dumb implementation that sums the scaled amounts\n    function calc_token_amount(uint256[2] memory _amounts, bool)\n        public\n        view\n        returns (uint256 lpTokens)\n    {\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            uint256 assetDecimals = Helpers.getDecimals(coins[i]);\n            // Convert to 1e18 and add to lpTokens\n            lpTokens += _amounts[i].scaleBy(18, assetDecimals);\n        }\n    }\n\n    /// @notice 0.02% fee\n    function fee() external pure returns (uint256) {\n        return 2000000;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n\n    function burnFrom(address from, uint256 value) public {\n        _burn(from, value);\n    }\n}\n"
    },
    "contracts/mocks/curve/MockCurveGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { ICurveGauge } from \"../../strategies/ICurveGauge.sol\";\n\ncontract MockCurveGauge is ICurveGauge {\n    mapping(address => uint256) private _balances;\n    address lpToken;\n\n    constructor(address _lpToken) {\n        lpToken = _lpToken;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function deposit(uint256 _value, address _account) external override {\n        IERC20(lpToken).transferFrom(msg.sender, address(this), _value);\n        _balances[_account] += _value;\n    }\n\n    function withdraw(uint256 _value) external override {\n        IERC20(lpToken).transfer(msg.sender, _value);\n        // solhint-disable-next-line reentrancy\n        _balances[msg.sender] -= _value;\n    }\n}\n"
    },
    "contracts/mocks/curve/MockCurveLUSDMetapool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { MockCurveAbstractMetapool } from \"./MockCurveAbstractMetapool.sol\";\nimport \"../MintableERC20.sol\";\n\ncontract MockCurveLUSDMetapool is MockCurveAbstractMetapool {\n    constructor(address[2] memory _coins)\n        ERC20(\"Curve.fi Factory USD Metapool: LUSD\", \"LUSD3CRV-f\")\n    {\n        coins = _coins;\n    }\n}\n"
    },
    "contracts/mocks/curve/MockCurveMetapool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { MockCurveAbstractMetapool } from \"./MockCurveAbstractMetapool.sol\";\nimport \"../MintableERC20.sol\";\n\ncontract MockCurveMetapool is MockCurveAbstractMetapool {\n    constructor(address[2] memory _coins)\n        ERC20(\"Curve.fi 3pool/OUSD metapool\", \"3crv_OUSD\")\n    {\n        coins = _coins;\n    }\n}\n"
    },
    "contracts/mocks/curve/MockCurvePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IBurnableERC20 } from \"../BurnableERC20.sol\";\n\nimport { IMintableERC20 } from \"../MintableERC20.sol\";\nimport { ICurvePool } from \"../../strategies/ICurvePool.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\nimport \"../../utils/Helpers.sol\";\n\ncontract MockCurvePool {\n    using StableMath for uint256;\n\n    address[] public coins;\n    uint256[3] public balances;\n    address lpToken;\n    uint256 public slippage = 1 ether;\n\n    constructor(address[3] memory _coins, address _lpToken) {\n        coins = _coins;\n        lpToken = _lpToken;\n    }\n\n    function setCoins(address[] memory _coins) external {\n        coins = _coins;\n    }\n\n    // Returns the same amount of LP tokens in 1e18 decimals\n    function add_liquidity(uint256[3] calldata _amounts, uint256 _minAmount)\n        external\n    {\n        uint256 sum = 0;\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            if (_amounts[i] > 0) {\n                IERC20(coins[i]).transferFrom(\n                    msg.sender,\n                    address(this),\n                    _amounts[i]\n                );\n                uint256 assetDecimals = Helpers.getDecimals(coins[i]);\n                // Convert to 1e18 and add to sum\n                sum += _amounts[i].scaleBy(18, assetDecimals);\n                balances[i] = balances[i] + _amounts[i];\n            }\n        }\n        // Hacky way of simulating slippage to check _minAmount\n        if (sum == 29000e18) sum = 14500e18;\n        require(sum >= _minAmount, \"Slippage ruined your day\");\n        // Send LP token to sender, e.g. 3CRV\n        IMintableERC20(lpToken).mint(sum);\n        IERC20(lpToken).transfer(msg.sender, sum);\n    }\n\n    // Dumb implementation that returns the same amount\n    function calc_withdraw_one_coin(uint256 _amount, int128 _index)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 assetDecimals = Helpers.getDecimals(coins[uint128(_index)]);\n        return _amount.scaleBy(assetDecimals, 18);\n    }\n\n    function remove_liquidity_one_coin(\n        uint256 _amount,\n        int128 _index,\n        // solhint-disable-next-line no-unused-vars\n        uint256 _minAmount\n    ) external {\n        // Burn the Curve LP tokens\n        IBurnableERC20(lpToken).burnFrom(msg.sender, _amount);\n        uint256[] memory amounts = new uint256[](coins.length);\n        amounts[uint128(_index)] = _amount;\n        uint256 coinAmount = calc_withdraw_one_coin(_amount, _index);\n        balances[uint128(_index)] -= coinAmount;\n        IERC20(coins[uint128(_index)]).transfer(msg.sender, coinAmount);\n    }\n\n    function get_virtual_price() external pure returns (uint256) {\n        return 1e18;\n    }\n\n    // solhint-disable-next-line no-unused-vars\n    function remove_liquidity(uint256 _lpAmount, uint256[3] memory _min_amounts)\n        public\n    {\n        // Burn the Curve LP tokens\n        IBurnableERC20(lpToken).burnFrom(msg.sender, _lpAmount);\n        uint256 totalSupply = IERC20(lpToken).totalSupply();\n        for (uint256 i = 0; i < 3; i++) {\n            uint256 coinAmount = totalSupply > 0\n                ? (_lpAmount * IERC20(coins[i]).balanceOf(address(this))) /\n                    totalSupply\n                : IERC20(coins[i]).balanceOf(address(this));\n            balances[i] -= coinAmount;\n            IERC20(coins[i]).transfer(msg.sender, coinAmount);\n        }\n    }\n\n    function remove_liquidity_imbalance(\n        uint256[3] memory _amounts,\n        uint256 _max_burned_tokens\n    ) public {\n        // Burn the Curve LP tokens\n        IBurnableERC20(lpToken).burnFrom(msg.sender, _max_burned_tokens);\n        // For each coin, transfer to the caller\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            balances[i] -= _amounts[i];\n            if (_amounts[i] > 0) {\n                IERC20(coins[i]).transfer(msg.sender, _amounts[i]);\n            }\n        }\n    }\n\n    // Dumb implementation that sums the scaled amounts\n    function calc_token_amount(uint256[3] memory _amounts, bool)\n        public\n        view\n        returns (uint256 lpTokens)\n    {\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            uint256 assetDecimals = Helpers.getDecimals(coins[i]);\n            // Convert to 1e18 and add to lpTokens\n            lpTokens += _amounts[i].scaleBy(18, assetDecimals);\n        }\n    }\n\n    function fee() external pure returns (uint256) {\n        return 1000000;\n    }\n\n    function exchange(\n        uint256 coin0,\n        uint256 coin1,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) external returns (uint256 amountOut) {\n        IERC20(coins[coin0]).transferFrom(msg.sender, address(this), amountIn);\n        amountOut = (minAmountOut * slippage) / 1 ether;\n        require(amountOut >= minAmountOut, \"Slippage error\");\n        IMintableERC20(coins[coin1]).mintTo(msg.sender, amountOut);\n    }\n\n    function setSlippage(uint256 _slippage) external {\n        slippage = _slippage;\n    }\n}\n"
    },
    "contracts/mocks/curve/MockCVX.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../MintableERC20.sol\";\n\ncontract MockCVX is MintableERC20 {\n    constructor() ERC20(\"CVX\", \"CVX DAO Token\") {}\n}\n"
    },
    "contracts/mocks/curve/MockLUSD.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../MintableERC20.sol\";\n\ncontract MockLUSD is MintableERC20 {\n    constructor() ERC20(\"LUSD\", \"Liquity Token\") {}\n}\n"
    },
    "contracts/mocks/curve/MockRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IMintableERC20 } from \"../MintableERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ninterface IDeposit {\n    function poolInfo(uint256)\n        external\n        view\n        returns (\n            address,\n            address,\n            address,\n            address,\n            address,\n            bool\n        );\n\n    function rewardClaimed(\n        uint256,\n        address,\n        uint256\n    ) external;\n\n    function withdrawTo(\n        uint256,\n        uint256,\n        address\n    ) external;\n}\n\ncontract MockRewardPool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public pid;\n    address public stakingToken;\n    address public rewardTokenA;\n    address public rewardTokenB;\n    address public operator;\n\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) private _balances;\n    mapping(address => uint256) public rewards;\n\n    constructor(\n        uint256 _pid,\n        address _stakingToken,\n        address _rewardTokenA,\n        address _rewardTokenB,\n        address _operator\n    ) public {\n        pid = _pid;\n        stakingToken = _stakingToken;\n        rewardTokenA = _rewardTokenA;\n        rewardTokenB = _rewardTokenB;\n        operator = _operator;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function stakeFor(address _for, uint256 _amount) public returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //give to _for\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[_for] = _balances[_for].add(_amount);\n\n        //take away from sender\n        IERC20(stakingToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        return true;\n    }\n\n    function withdrawAndUnwrap(uint256 amount, bool claim)\n        public\n        returns (bool)\n    {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        //tell operator to withdraw from here directly to user\n        IDeposit(operator).withdrawTo(pid, amount, msg.sender);\n\n        //get rewards too\n        if (claim) {\n            getReward(msg.sender, true);\n        }\n        return true;\n    }\n\n    function withdrawAllAndUnwrap(bool claim) external {\n        withdrawAndUnwrap(_balances[msg.sender], claim);\n    }\n\n    // solhint-disable-next-line no-unused-vars\n    function getReward(address _account, bool _claimExtras)\n        public\n        returns (bool)\n    {\n        IMintableERC20(rewardTokenA).mint(2 * 1e18);\n        IERC20(rewardTokenA).transfer(_account, 2 * 1e18);\n\n        IMintableERC20(rewardTokenB).mint(3 * 1e18);\n        IERC20(rewardTokenB).transfer(_account, 3 * 1e18);\n\n        return true;\n    }\n\n    function getReward() public returns (bool) {\n        getReward(msg.sender, true);\n    }\n}\n"
    },
    "contracts/mocks/MintableERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IMintableERC20 {\n    function mint(uint256 value) external;\n\n    function mintTo(address to, uint256 value) external;\n}\n\n/**\n * @title MintableERC20\n * @dev Exposes the mint function of ERC20 for tests\n */\nabstract contract MintableERC20 is IMintableERC20, ERC20 {\n    /**\n     * @dev Function to mint tokens\n     * @param _value The amount of tokens to mint.\n     */\n    function mint(uint256 _value) public virtual override {\n        _mint(msg.sender, _value);\n    }\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to Address to mint to.\n     * @param _value The amount of tokens to mint.\n     */\n    function mintTo(address _to, uint256 _value) public virtual override {\n        _mint(_to, _value);\n    }\n}\n"
    },
    "contracts/mocks/Mock1InchSwapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { SwapDescription } from \"../interfaces/IOneInch.sol\";\n\ncontract Mock1InchSwapRouter {\n    using SafeERC20 for IERC20;\n\n    event MockSwap(address executor, bytes permitData, bytes executorData);\n\n    event MockSwapDesc(\n        address srcToken,\n        address dstToken,\n        address srcReceiver,\n        address dstReceiver,\n        uint256 amount,\n        uint256 minReturnAmount,\n        uint256 flags\n    );\n\n    event MockUnoswapTo(\n        address recipient,\n        address srcToken,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] pools\n    );\n\n    event MockUniswapV3SwapTo(\n        address recipient,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] pools\n    );\n\n    /**\n     * @dev transfers the shource asset and returns the minReturnAmount of the destination asset.\n     */\n    function swap(\n        address executor,\n        SwapDescription calldata desc,\n        bytes calldata permitData,\n        bytes calldata executorData\n    ) public returns (uint256 returnAmount, uint256 spentAmount) {\n        // Transfer the source tokens to the receiver contract\n        IERC20(desc.srcToken).safeTransferFrom(\n            msg.sender,\n            desc.srcReceiver,\n            desc.amount\n        );\n\n        // Transfer the destination tokens to the recipient\n        IERC20(desc.dstToken).safeTransfer(\n            desc.dstReceiver,\n            desc.minReturnAmount\n        );\n\n        emit MockSwap(executor, permitData, executorData);\n        _swapDesc(desc);\n        returnAmount = 0;\n        spentAmount = 0;\n    }\n\n    function _swapDesc(SwapDescription calldata desc) public {\n        emit MockSwapDesc(\n            address(desc.srcToken),\n            address(desc.dstToken),\n            desc.srcReceiver,\n            desc.dstReceiver,\n            desc.amount,\n            desc.minReturnAmount,\n            desc.flags\n        );\n    }\n\n    /**\n     * @dev only transfers the source asset to this contract.\n     * Ideally it would return the destination asset but that's encoded in the pools array.\n     */\n    function unoswapTo(\n        address payable recipient,\n        address srcToken,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] calldata pools\n    ) public returns (uint256 returnAmount) {\n        // transfer the from asset from the caller\n        IERC20(srcToken).safeTransferFrom(msg.sender, address(this), amount);\n\n        emit MockUnoswapTo(recipient, srcToken, amount, minReturn, pools);\n        returnAmount = 0;\n    }\n\n    /**\n     * @dev does not do any transfers. Just emits MockUniswapV3SwapTo.\n     */\n    function uniswapV3SwapTo(\n        address payable recipient,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] calldata pools\n    ) public returns (uint256 returnAmount) {\n        emit MockUniswapV3SwapTo(recipient, amount, minReturn, pools);\n        returnAmount = 0;\n    }\n}\n"
    },
    "contracts/mocks/MockAave.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20, ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { MintableERC20 } from \"./MintableERC20.sol\";\nimport { IAaveLendingPool, ILendingPoolAddressesProvider } from \"../strategies/IAave.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\n// 1. User calls 'getLendingPool'\n// 2. User calls 'deposit' (Aave)\n//  - Deposit their underlying\n//  - Mint aToken to them\n// 3. User calls redeem (aToken)\n//  - Retrieve their aToken\n//  - Return equal amount of underlying\n\ncontract MockAToken is MintableERC20 {\n    address public lendingPool;\n    IERC20 public underlyingToken;\n    using SafeERC20 for IERC20;\n\n    constructor(\n        address _lendingPool,\n        string memory _name,\n        string memory _symbol,\n        IERC20 _underlyingToken\n    ) ERC20(_name, _symbol) {\n        lendingPool = _lendingPool;\n        underlyingToken = _underlyingToken;\n        // addMinter(_lendingPool);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return ERC20(address(underlyingToken)).decimals();\n    }\n\n    function poolRedeem(uint256 _amount, address _to) external {\n        require(msg.sender == lendingPool, \"pool only\");\n        // Redeem these a Tokens\n        _burn(_to, _amount);\n        // For the underlying\n        underlyingToken.safeTransferFrom(lendingPool, _to, _amount);\n    }\n}\n\ncontract MockAave is IAaveLendingPool, ILendingPoolAddressesProvider {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    mapping(address => address) reserveToAToken;\n    address pool = address(this);\n    address payable core = payable(address(this));\n    uint256 factor;\n\n    function addAToken(address _aToken, address _underlying) public {\n        IERC20(_underlying).safeApprove(_aToken, 0);\n        IERC20(_underlying).safeApprove(_aToken, type(uint256).max);\n        reserveToAToken[_underlying] = _aToken;\n    }\n\n    // set the reserve factor / basically the interest on deposit\n    // in 18 precision\n    // so 0.5% would be 5 * 10 ^ 15\n    function setFactor(uint256 factor_) public {\n        factor = factor_;\n    }\n\n    function deposit(\n        address _reserve,\n        uint256 _amount,\n        address _to,\n        uint16 /*_referralCode*/\n    ) external override {\n        uint256 previousBal = IERC20(reserveToAToken[_reserve]).balanceOf(\n            msg.sender\n        );\n        uint256 interest = previousBal.mulTruncate(factor);\n        MintableERC20(reserveToAToken[_reserve]).mintTo(msg.sender, interest);\n        // Take their reserve\n        IERC20(_reserve).safeTransferFrom(msg.sender, address(this), _amount);\n        // Credit them with aToken\n        MintableERC20(reserveToAToken[_reserve]).mintTo(_to, _amount);\n    }\n\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external override returns (uint256) {\n        MockAToken atoken = MockAToken(reserveToAToken[asset]);\n        atoken.poolRedeem(amount, to);\n        return amount;\n    }\n\n    function getLendingPool() external view override returns (address) {\n        return pool;\n    }\n}\n"
    },
    "contracts/mocks/MockAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { MockStkAave } from \"./MockStkAave.sol\";\n\ncontract MockAaveIncentivesController {\n    mapping(address => uint256) private rewards;\n    MockStkAave public REWARD_TOKEN;\n\n    constructor(address _reward_token) {\n        REWARD_TOKEN = MockStkAave(_reward_token);\n    }\n\n    function setRewardsBalance(address user, uint256 amount) external {\n        rewards[user] = amount;\n    }\n\n    /**\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n     * @param user The address of the user\n     * @return The rewards\n     **/\n    // solhint-disable-next-line no-unused-vars\n    function getRewardsBalance(address[] calldata assets, address user)\n        external\n        view\n        returns (uint256)\n    {\n        return rewards[user];\n    }\n\n    /**\n     * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\n     * @param amount Amount of rewards to claim\n     * @param to Address that will be receiving the rewards\n     * @return Rewards claimed\n     **/\n    function claimRewards(\n        // solhint-disable-next-line no-unused-vars\n        address[] calldata assets,\n        uint256 amount,\n        address to\n    ) external returns (uint256) {\n        require(amount > 0);\n        require(rewards[to] == amount);\n        REWARD_TOKEN.mint(amount);\n        require(REWARD_TOKEN.transfer(to, amount));\n        // solhint-disable-next-line reentrancy\n        rewards[to] = 0;\n        return amount;\n    }\n}\n"
    },
    "contracts/mocks/MockAAVEToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockAAVEToken is MintableERC20 {\n    constructor() ERC20(\"AAVE\", \"AAVE\") {}\n}\n"
    },
    "contracts/mocks/MockAero.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockAero is MintableERC20 {\n    constructor() ERC20(\"Aerodrome\", \"AERO\") {}\n\n    function deposit() external payable {\n        _mint(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) external {\n        _burn(msg.sender, wad);\n        payable(msg.sender).transfer(wad);\n    }\n}\n"
    },
    "contracts/mocks/MockAura.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockAura is MintableERC20 {\n    constructor() ERC20(\"Aura\", \"AURA\") {}\n}\n"
    },
    "contracts/mocks/MockBAL.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockBAL is MintableERC20 {\n    constructor() ERC20(\"Balancer\", \"BAL\") {}\n}\n"
    },
    "contracts/mocks/MockBalancerVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IBalancerVault } from \"../interfaces/balancer/IBalancerVault.sol\";\nimport { MintableERC20 } from \"./MintableERC20.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\n// import \"hardhat/console.sol\";\n\ncontract MockBalancerVault {\n    using StableMath for uint256;\n    uint256 public slippage = 1 ether;\n    bool public transferDisabled = false;\n    bool public slippageErrorDisabled = false;\n\n    function swap(\n        IBalancerVault.SingleSwap calldata singleSwap,\n        IBalancerVault.FundManagement calldata funds,\n        uint256 minAmountOut,\n        uint256\n    ) external returns (uint256 amountCalculated) {\n        amountCalculated = (minAmountOut * slippage) / 1 ether;\n        if (!slippageErrorDisabled) {\n            require(amountCalculated >= minAmountOut, \"Slippage error\");\n        }\n        IERC20(singleSwap.assetIn).transferFrom(\n            funds.sender,\n            address(this),\n            singleSwap.amount\n        );\n        if (!transferDisabled) {\n            MintableERC20(singleSwap.assetOut).mintTo(\n                funds.recipient,\n                amountCalculated\n            );\n        }\n    }\n\n    function setSlippage(uint256 _slippage) external {\n        slippage = _slippage;\n    }\n\n    function getPoolTokenInfo(bytes32 poolId, address token)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            address\n        )\n    {}\n\n    function disableTransfer() external {\n        transferDisabled = true;\n    }\n\n    function disableSlippageError() external {\n        slippageErrorDisabled = true;\n    }\n}\n"
    },
    "contracts/mocks/MockChainlinkOracleFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\n\ncontract MockChainlinkOracleFeed is AggregatorV3Interface {\n    int256 price;\n    uint8 numDecimals;\n\n    constructor(int256 _price, uint8 _decimals) {\n        price = _price;\n        numDecimals = _decimals;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return numDecimals;\n    }\n\n    function description() external pure override returns (string memory) {\n        return \"MockOracleEthFeed\";\n    }\n\n    function version() external pure override returns (uint256) {\n        return 1;\n    }\n\n    function setPrice(int256 _price) public {\n        price = _price;\n    }\n\n    function setDecimals(uint8 _decimals) public {\n        numDecimals = _decimals;\n    }\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        roundId = _roundId;\n        answer = price;\n        startedAt = 0;\n        updatedAt = 0;\n        answeredInRound = 0;\n    }\n\n    function latestRoundData()\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        roundId = 0;\n        answer = price;\n        startedAt = 0;\n        updatedAt = block.timestamp;\n        answeredInRound = 0;\n    }\n}\n"
    },
    "contracts/mocks/MockCOMP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockCOMP is MintableERC20 {\n    constructor() ERC20(\"COMP\", \"COMP\") {}\n}\n"
    },
    "contracts/mocks/MockComptroller.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MockComptroller {\n    // Claim all the COMP accrued by specific holders in specific markets for their supplies and/or borrows\n    function claimComp(\n        address[] memory holders,\n        address[] memory cTokens,\n        bool borrowers,\n        bool suppliers\n    ) external {}\n}\n"
    },
    "contracts/mocks/MockCToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20, ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { ICERC20 } from \"../strategies/ICompound.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\ncontract MockCToken is ICERC20, ERC20 {\n    using StableMath for uint256;\n\n    IERC20 public underlyingToken;\n    // underlying = cToken * exchangeRate\n    // cToken = underlying / exchangeRate\n    uint256 exchangeRate;\n    address public override comptroller;\n\n    constructor(ERC20 _underlyingToken, address _comptroller)\n        ERC20(\"cMock\", \"cMK\")\n    {\n        uint8 underlyingDecimals = _underlyingToken.decimals();\n        // if has 18 dp, exchange rate should be 1e26\n        // if has 8 dp, exchange rate should be 1e18\n        if (underlyingDecimals > 8) {\n            exchangeRate = 10**uint256(18 + underlyingDecimals - 10);\n        } else if (underlyingDecimals < 8) {\n            // e.g. 18-8+6 = 16\n            exchangeRate = 10**uint256(18 - 8 + underlyingDecimals);\n        } else {\n            exchangeRate = 1e18;\n        }\n        underlyingToken = _underlyingToken;\n        comptroller = _comptroller;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return 8;\n    }\n\n    function mint(uint256 mintAmount) public override returns (uint256) {\n        // Credit them with cToken\n        _mint(msg.sender, mintAmount.divPrecisely(exchangeRate));\n        // Take their reserve\n        underlyingToken.transferFrom(msg.sender, address(this), mintAmount);\n        return 0;\n    }\n\n    function redeem(uint256 redeemAmount) external override returns (uint256) {\n        uint256 tokenAmount = redeemAmount.mulTruncate(exchangeRate);\n        // Burn the cToken\n        _burn(msg.sender, redeemAmount);\n        // Transfer underlying to caller\n        underlyingToken.transfer(msg.sender, tokenAmount);\n        return 0;\n    }\n\n    function redeemUnderlying(uint256 redeemAmount)\n        external\n        override\n        returns (uint256)\n    {\n        uint256 cTokens = redeemAmount.divPrecisely(exchangeRate);\n        // Burn the cToken\n        _burn(msg.sender, cTokens);\n        // Transfer underlying to caller\n        underlyingToken.transfer(msg.sender, redeemAmount);\n        return 0;\n    }\n\n    function balanceOfUnderlying(address owner)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 cTokenBal = this.balanceOf(owner);\n        return cTokenBal.mulTruncate(exchangeRate);\n    }\n\n    function balanceOf(address owner)\n        public\n        view\n        override(ICERC20, ERC20)\n        returns (uint256)\n    {\n        return ERC20.balanceOf(owner);\n    }\n\n    function updateExchangeRate()\n        internal\n        view\n        returns (uint256 newExchangeRate)\n    {\n        uint256 factor = 100002 * (10**13); // 0.002%\n        newExchangeRate = exchangeRate.mulTruncate(factor);\n    }\n\n    function exchangeRateStored() external view override returns (uint256) {\n        return exchangeRate;\n    }\n\n    function supplyRatePerBlock() external pure override returns (uint256) {\n        return 141 * (10**8);\n    }\n}\n"
    },
    "contracts/mocks/MockCVXLocker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockCVXLocker {\n    address public immutable cvx;\n    mapping(address => uint256) public lockedBalanceOf;\n\n    constructor(address _cvx) {\n        cvx = _cvx;\n    }\n\n    function lock(\n        address _account,\n        uint256 _amount,\n        uint256\n    ) external {\n        lockedBalanceOf[_account] += _amount;\n        ERC20(cvx).transferFrom(msg.sender, address(this), _amount);\n    }\n\n    function unlockAllTokens(address _account) external {\n        lockedBalanceOf[_account] = 0;\n        ERC20(cvx).transfer(_account, lockedBalanceOf[_account]);\n    }\n}\n"
    },
    "contracts/mocks/MockDAI.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockDAI is MintableERC20 {\n    constructor() ERC20(\"DAI\", \"DAI\") {}\n}\n"
    },
    "contracts/mocks/MockDepositContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IDepositContract } from \"./../interfaces/IDepositContract.sol\";\n\ncontract MockDepositContract is IDepositContract {\n    uint256 deposit_count;\n\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawal_credentials,\n        bytes calldata signature,\n        bytes32 deposit_data_root\n    ) external payable override {\n        require(pubkey.length == 48, \"DepositContract: invalid pubkey length\");\n        require(\n            withdrawal_credentials.length == 32,\n            \"DepositContract: invalid withdrawal_credentials length\"\n        );\n        require(\n            signature.length == 96,\n            \"DepositContract: invalid signature length\"\n        );\n\n        // Check deposit amount\n        require(msg.value >= 1 ether, \"DepositContract: deposit value too low\");\n        require(\n            msg.value % 1 gwei == 0,\n            \"DepositContract: deposit value not multiple of gwei\"\n        );\n        uint256 deposit_amount = msg.value / 1 gwei;\n        require(\n            deposit_amount <= type(uint64).max,\n            \"DepositContract: deposit value too high\"\n        );\n\n        // Emit `DepositEvent` log\n        bytes memory amount = to_little_endian_64(uint64(deposit_amount));\n        emit DepositEvent(\n            pubkey,\n            withdrawal_credentials,\n            amount,\n            signature,\n            to_little_endian_64(uint64(deposit_count))\n        );\n        require(\n            deposit_data_root != 0,\n            \"DepositContract: invalid deposit_data_root\"\n        );\n    }\n\n    function get_deposit_root() external view override returns (bytes32) {\n        // just return some bytes32\n        return sha256(abi.encodePacked(deposit_count, bytes16(0)));\n    }\n\n    /// @notice Query the current deposit count.\n    /// @return The deposit count encoded as a little endian 64-bit number.\n    function get_deposit_count() external view override returns (bytes memory) {\n        return to_little_endian_64(uint64(deposit_count));\n    }\n\n    function to_little_endian_64(uint64 value)\n        internal\n        pure\n        returns (bytes memory ret)\n    {\n        ret = new bytes(8);\n        bytes8 bytesValue = bytes8(value);\n        // Byteswapping during copying to bytes.\n        ret[0] = bytesValue[7];\n        ret[1] = bytesValue[6];\n        ret[2] = bytesValue[5];\n        ret[3] = bytesValue[4];\n        ret[4] = bytesValue[3];\n        ret[5] = bytesValue[2];\n        ret[6] = bytesValue[1];\n        ret[7] = bytesValue[0];\n    }\n}\n"
    },
    "contracts/mocks/MockEvilDAI.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract MockEvilDAI is MintableERC20 {\n    address host;\n    address realCoin;\n\n    constructor(address _host, address _realCoin) ERC20(\"DAI\", \"DAI\") {\n        host = _host;\n        realCoin = _realCoin;\n    }\n\n    function transferFrom(\n        // solhint-disable-next-line no-unused-vars\n        address _from,\n        // solhint-disable-next-line no-unused-vars\n        address _to,\n        uint256 _amount\n    ) public override returns (bool) {\n        // call mint again!\n        if (_amount != 69) {\n            IVault(host).mint(address(this), 69, 0);\n        }\n        return true;\n    }\n}\n"
    },
    "contracts/mocks/MockEvilReentrantContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { IRateProvider } from \"../interfaces/balancer/IRateProvider.sol\";\n\nimport { IBalancerVault } from \"../interfaces/balancer/IBalancerVault.sol\";\nimport { IERC20 } from \"../utils/InitializableAbstractStrategy.sol\";\n\nimport { StableMath } from \"../utils/StableMath.sol\";\n\ncontract MockEvilReentrantContract {\n    using StableMath for uint256;\n\n    IBalancerVault public immutable balancerVault;\n    IERC20 public immutable reth;\n    IERC20 public immutable weth;\n    IVault public immutable oethVault;\n    address public immutable poolAddress;\n    bytes32 public immutable balancerPoolId;\n\n    constructor(\n        address _balancerVault,\n        address _oethVault,\n        address _reth,\n        address _weth,\n        address _poolAddress,\n        bytes32 _poolId\n    ) {\n        balancerVault = IBalancerVault(_balancerVault);\n        oethVault = IVault(_oethVault);\n        reth = IERC20(_reth);\n        weth = IERC20(_weth);\n        poolAddress = _poolAddress;\n        balancerPoolId = _poolId;\n    }\n\n    function doEvilStuff() public {\n        address priceProvider = oethVault.priceProvider();\n        uint256 rethPrice = IOracle(priceProvider).price(address(reth));\n\n        // 1. Join pool\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = uint256(10 ether);\n        amounts[1] = rethPrice * 10;\n\n        address[] memory assets = new address[](2);\n        assets[0] = address(reth);\n        assets[1] = address(weth);\n\n        uint256 minBPT = getBPTExpected(assets, amounts).mulTruncate(\n            0.99 ether\n        );\n\n        bytes memory joinUserData = abi.encode(\n            IBalancerVault.WeightedPoolJoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n            amounts,\n            minBPT\n        );\n\n        IBalancerVault.JoinPoolRequest memory joinRequest = IBalancerVault\n            .JoinPoolRequest(assets, amounts, joinUserData, false);\n\n        balancerVault.joinPool(\n            balancerPoolId,\n            address(this),\n            address(this),\n            joinRequest\n        );\n\n        uint256 bptTokenBalance = IERC20(poolAddress).balanceOf(address(this));\n\n        // 2. Redeem as ETH\n        bytes memory exitUserData = abi.encode(\n            IBalancerVault.WeightedPoolExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n            bptTokenBalance,\n            1\n        );\n\n        assets[1] = address(0); // Receive ETH instead of WETH\n        uint256[] memory exitAmounts = new uint256[](2);\n        exitAmounts[1] = 15 ether;\n        IBalancerVault.ExitPoolRequest memory exitRequest = IBalancerVault\n            .ExitPoolRequest(assets, exitAmounts, exitUserData, false);\n\n        balancerVault.exitPool(\n            balancerPoolId,\n            address(this),\n            payable(address(this)),\n            exitRequest\n        );\n        bptTokenBalance = IERC20(poolAddress).balanceOf(address(this));\n    }\n\n    function getBPTExpected(address[] memory _assets, uint256[] memory _amounts)\n        internal\n        view\n        virtual\n        returns (uint256 bptExpected)\n    {\n        // Get the oracle from the OETH Vault\n        address priceProvider = oethVault.priceProvider();\n\n        for (uint256 i = 0; i < _assets.length; ++i) {\n            uint256 strategyAssetMarketPrice = IOracle(priceProvider).price(\n                _assets[i]\n            );\n            // convert asset amount to ETH amount\n            bptExpected =\n                bptExpected +\n                _amounts[i].mulTruncate(strategyAssetMarketPrice);\n        }\n\n        uint256 bptRate = IRateProvider(poolAddress).getRate();\n        // Convert ETH amount to BPT amount\n        bptExpected = bptExpected.divPrecisely(bptRate);\n    }\n\n    function approveAllTokens() public {\n        // Approve all tokens\n        weth.approve(address(oethVault), type(uint256).max);\n        reth.approve(poolAddress, type(uint256).max);\n        weth.approve(poolAddress, type(uint256).max);\n        reth.approve(address(balancerVault), type(uint256).max);\n        weth.approve(address(balancerVault), type(uint256).max);\n    }\n\n    receive() external payable {\n        // 3. Try to mint OETH\n        oethVault.mint(address(weth), 1 ether, 0.9 ether);\n    }\n}\n"
    },
    "contracts/mocks/MockfrxETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockfrxETH is MintableERC20 {\n    constructor() ERC20(\"frxETH\", \"frxETH\") {}\n}\n"
    },
    "contracts/mocks/MockFrxETHMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockFrxETHMinter {\n    address public immutable frxETH;\n    address public immutable sfrxETH;\n\n    constructor(address _frxETH, address _sfrxETH) {\n        frxETH = _frxETH;\n        sfrxETH = _sfrxETH;\n    }\n\n    function submitAndDeposit(address recipient)\n        external\n        payable\n        returns (uint256 shares)\n    {\n        IMintableERC20(frxETH).mintTo(sfrxETH, msg.value);\n        IMintableERC20(sfrxETH).mintTo(recipient, msg.value);\n        shares = msg.value;\n    }\n}\n"
    },
    "contracts/mocks/MockLimitedWrappedOusd.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { WrappedOusd } from \"../token/WrappedOusd.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockLimitedWrappedOusd is WrappedOusd {\n    constructor(\n        ERC20 underlying_,\n        string memory name_,\n        string memory symbol_\n    ) WrappedOusd(underlying_, name_, symbol_) {}\n\n    function maxDeposit(address)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return 1e18;\n    }\n}\n"
    },
    "contracts/mocks/MockMetadataToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// IERC20Metadata is used in the resolveAsset function in contracts/utils/assets.js\n// We just need to import it here to make its ABI available to Hardhat\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n"
    },
    "contracts/mocks/MockMintableUniswapPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\nimport \"./MockUniswapPair.sol\";\n\ncontract MockMintableUniswapPair is MockUniswapPair, MintableERC20 {\n    constructor(\n        address _token0,\n        address _token1,\n        uint112 _reserve0,\n        uint112 _reserve1\n    )\n        MockUniswapPair(_token0, _token1, _reserve0, _reserve1)\n        ERC20(\"Uniswap V2\", \"UNI-v2\")\n    {}\n\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n}\n"
    },
    "contracts/mocks/MockNonRebasing.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IVault } from \"../interfaces/IVault.sol\";\n\nimport { OUSD } from \"../token/OUSD.sol\";\n\ncontract MockNonRebasing {\n    OUSD oUSD;\n\n    function setOUSD(address _oUSDAddress) public {\n        oUSD = OUSD(_oUSDAddress);\n    }\n\n    function rebaseOptIn() public {\n        oUSD.rebaseOptIn();\n    }\n\n    function rebaseOptOut() public {\n        oUSD.rebaseOptOut();\n    }\n\n    function transfer(address _to, uint256 _value) public {\n        oUSD.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public {\n        oUSD.transferFrom(_from, _to, _value);\n    }\n\n    function increaseAllowance(address _spender, uint256 _addedValue) public {\n        oUSD.increaseAllowance(_spender, _addedValue);\n    }\n\n    function mintOusd(\n        address _vaultContract,\n        address _asset,\n        uint256 _amount\n    ) public {\n        IVault(_vaultContract).mint(_asset, _amount, 0);\n    }\n\n    function redeemOusd(address _vaultContract, uint256 _amount) public {\n        IVault(_vaultContract).redeem(_amount, 0);\n    }\n\n    function approveFor(\n        address _contract,\n        address _spender,\n        uint256 _addedValue\n    ) public {\n        IERC20(_contract).approve(_spender, _addedValue);\n    }\n}\n"
    },
    "contracts/mocks/MockNonStandardToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"./MintableERC20.sol\";\n\n/**\n * Mock token contract to simulate tokens that don't\n * throw/revert when a transfer/transferFrom call fails\n */\ncontract MockNonStandardToken is MintableERC20 {\n    using SafeMath for uint256;\n\n    constructor() ERC20(\"NonStandardToken\", \"NonStandardToken\") {}\n\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n\n    function transfer(address recipient, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        if (balanceOf(msg.sender) < amount) {\n            // Fail silently\n            return false;\n        }\n\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        if (balanceOf(sender) < amount) {\n            // Fail silently\n            return false;\n        }\n\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            allowance(sender, _msgSender()).sub(\n                amount,\n                \"ERC20: transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n}\n"
    },
    "contracts/mocks/MockOETHVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { OETHVaultCore } from \"../vault/OETHVaultCore.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport \"../utils/Helpers.sol\";\n\ncontract MockOETHVault is OETHVaultCore {\n    using StableMath for uint256;\n\n    constructor(address _weth) OETHVaultCore(_weth) {}\n\n    function supportAsset(address asset) external {\n        assets[asset] = Asset({\n            isSupported: true,\n            unitConversion: UnitConversion(0),\n            decimals: 18,\n            allowedOracleSlippageBps: 0\n        });\n\n        allAssets.push(asset);\n    }\n}\n"
    },
    "contracts/mocks/MockOGN.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./BurnableERC20.sol\";\nimport \"./MintableERC20.sol\";\n\n/**\n * @title Origin token (OGN).\n *\n * @dev Token that allows minting and burning.\n * @dev Important note:\n * @dev   There is a known race condition in the ERC20 standard on the approve() method.\n * @dev   See details: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n * @dev   The Origin token contract implements the increaseApproval() and decreaseApproval() methods.\n * @dev   It is strongly recommended to use those methods rather than approve()\n * @dev   when updating the token allowance.\n */\ncontract MockOGN is MintableERC20, BurnableERC20 {\n    event SetWhitelistExpiration(uint256 expiration);\n    event AllowedTransactorAdded(address sender);\n    event AllowedTransactorRemoved(address sender);\n    event AddCallSpenderWhitelist(address enabler, address spender);\n    event RemoveCallSpenderWhitelist(address disabler, address spender);\n\n    mapping(address => bool) public callSpenderWhitelist;\n    address public owner = msg.sender;\n    // UNIX timestamp (in seconds) after which this whitelist no longer applies\n    uint256 public whitelistExpiration;\n    // While the whitelist is active, either the sender or recipient must be\n    // in allowedTransactors.\n    mapping(address => bool) public allowedTransactors;\n\n    // @dev Constructor that gives msg.sender all initial tokens.\n    constructor(uint256 _initialSupply) ERC20(\"OriginToken\", \"OGN\") {\n        owner = msg.sender;\n        _mint(owner, _initialSupply);\n    }\n\n    //\n    // approveAndCall methods\n    //\n\n    // @dev Add spender to whitelist of spenders for approveAndCall\n    // @param _spender Address to add\n    function addCallSpenderWhitelist(address _spender) public onlyOwner {\n        callSpenderWhitelist[_spender] = true;\n        emit AddCallSpenderWhitelist(msg.sender, _spender);\n    }\n\n    // @dev Remove spender from whitelist of spenders for approveAndCall\n    // @param _spender Address to remove\n    function removeCallSpenderWhitelist(address _spender) public onlyOwner {\n        delete callSpenderWhitelist[_spender];\n        emit RemoveCallSpenderWhitelist(msg.sender, _spender);\n    }\n\n    // @dev Approve transfer of tokens and make a contract call in a single\n    // @dev transaction. This allows a DApp to avoid requiring two MetaMask\n    // @dev approvals for a single logical action, such as creating a listing,\n    // @dev which requires the seller to approve a token transfer and the\n    // @dev marketplace contract to transfer tokens from the seller.\n    //\n    // @dev This is based on the ERC827 function approveAndCall and avoids\n    // @dev security issues by only working with a whitelisted set of _spender\n    // @dev addresses. The other difference is that the combination of this\n    // @dev function ensures that the proxied function call receives the\n    // @dev msg.sender for this function as its first parameter.\n    //\n    // @param _spender The address that will spend the funds.\n    // @param _value The amount of tokens to be spent.\n    // @param _selector Function selector for function to be called.\n    // @param _callParams Packed, encoded parameters, omitting the first parameter which is always msg.sender\n    function approveAndCallWithSender(\n        address _spender,\n        uint256 _value,\n        bytes4 _selector,\n        bytes memory _callParams\n    ) public payable returns (bool) {\n        require(_spender != address(this), \"token contract can't be approved\");\n        require(callSpenderWhitelist[_spender], \"spender not in whitelist\");\n\n        require(super.approve(_spender, _value), \"approve failed\");\n\n        bytes memory callData = abi.encodePacked(\n            _selector,\n            uint256(uint160(msg.sender)),\n            _callParams\n        );\n        // solium-disable-next-line security/no-call-value\n        (bool success, ) = _spender.call{ value: msg.value }(callData);\n        require(success, \"proxied call failed\");\n        return true;\n    }\n\n    //\n    // Functions for maintaining whitelist\n    //\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    modifier allowedTransfer(address _from, address _to) {\n        require(\n            // solium-disable-next-line operator-whitespace\n            !whitelistActive() ||\n                allowedTransactors[_from] ||\n                allowedTransactors[_to],\n            \"neither sender nor recipient are allowed\"\n        );\n        _;\n    }\n\n    function whitelistActive() public view returns (bool) {\n        return block.timestamp < whitelistExpiration;\n    }\n\n    function addAllowedTransactor(address _transactor) public onlyOwner {\n        emit AllowedTransactorAdded(_transactor);\n        allowedTransactors[_transactor] = true;\n    }\n\n    function removeAllowedTransactor(address _transactor) public onlyOwner {\n        emit AllowedTransactorRemoved(_transactor);\n        delete allowedTransactors[_transactor];\n    }\n\n    /**\n     * @dev Set the whitelist expiration, after which the whitelist no longer\n     * applies.\n     */\n    function setWhitelistExpiration(uint256 _expiration) public onlyOwner {\n        // allow only if whitelist expiration hasn't yet been set, or if the\n        // whitelist expiration hasn't passed yet\n        require(\n            whitelistExpiration == 0 || whitelistActive(),\n            \"an expired whitelist cannot be extended\"\n        );\n        // prevent possible mistakes in calling this function\n        require(\n            _expiration >= block.timestamp + 1 days,\n            \"whitelist expiration not far enough into the future\"\n        );\n        emit SetWhitelistExpiration(_expiration);\n        whitelistExpiration = _expiration;\n    }\n\n    //\n    // ERC20 transfer functions that have been overridden to enforce the\n    // whitelist.\n    //\n\n    function transfer(address _to, uint256 _value)\n        public\n        override\n        allowedTransfer(msg.sender, _to)\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public override allowedTransfer(_from, _to) returns (bool) {\n        return super.transferFrom(_from, _to, _value);\n    }\n}\n"
    },
    "contracts/mocks/MockOGV.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockOGV is MintableERC20 {\n    constructor() ERC20(\"OGV\", \"OGV\") {}\n}\n"
    },
    "contracts/mocks/MockOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IPriceOracle.sol\";\nimport \"../interfaces/IMinMaxOracle.sol\";\n\n/**\n * Mock of both price Oracle and min max oracles\n */\ncontract MockOracle is IPriceOracle, IMinMaxOracle {\n    mapping(bytes32 => uint256) prices;\n    mapping(bytes32 => uint256[]) pricesMinMax;\n    uint256 ethMin;\n    uint256 ethMax;\n\n    /**\n     * @dev returns the asset price in USD, 6 decimal digits.\n     * Compatible with the Open Price Feed.\n     */\n    function price(string calldata symbol)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return prices[keccak256(abi.encodePacked(symbol))];\n    }\n\n    /**\n     * @dev sets the price of the asset in USD, 6 decimal digits\n     *\n     */\n    function setPrice(string calldata symbol, uint256 _price) external {\n        prices[keccak256(abi.encodePacked(symbol))] = _price;\n    }\n\n    /**\n     * @dev sets the min and max price of ETH in USD, 6 decimal digits\n     *\n     */\n    function setEthPriceMinMax(uint256 _min, uint256 _max) external {\n        ethMin = _min;\n        ethMax = _max;\n    }\n\n    /**\n     * @dev sets the prices Min Max for a specific symbol in ETH, 8 decimal digits\n     *\n     */\n    function setTokPriceMinMax(\n        string calldata symbol,\n        uint256 _min,\n        uint256 _max\n    ) external {\n        pricesMinMax[keccak256(abi.encodePacked(symbol))] = [_min, _max];\n    }\n\n    /**\n     * @dev get the price of asset in ETH, 8 decimal digits.\n     */\n    function priceMin(string calldata symbol)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256[] storage pMinMax = pricesMinMax[\n            keccak256(abi.encodePacked(symbol))\n        ];\n        return (pMinMax[0] * ethMin) / 1e6;\n    }\n\n    /**\n     * @dev get the price of asset in USD, 8 decimal digits.\n     * Not needed for now\n     */\n    function priceMax(string calldata symbol)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256[] storage pMinMax = pricesMinMax[\n            keccak256(abi.encodePacked(symbol))\n        ];\n        return (pMinMax[1] * ethMax) / 1e6;\n    }\n}\n"
    },
    "contracts/mocks/MockOracleRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { AbstractOracleRouter } from \"../oracle/AbstractOracleRouter.sol\";\n\n// @notice Oracle Router required for testing environment\ncontract MockOracleRouter is AbstractOracleRouter {\n    struct FeedMetadata {\n        address feedAddress;\n        uint256 maxStaleness;\n    }\n\n    mapping(address => FeedMetadata) public assetToFeedMetadata;\n\n    /* @dev Override feed and maxStaleness information for a particular asset\n     * @param _asset the asset to override feed for\n     * @param _feed new feed\n     * @param _maxStaleness new maximum time allowed for feed data to be stale\n     */\n    function setFeed(\n        address _asset,\n        address _feed,\n        uint256 _maxStaleness\n    ) external {\n        assetToFeedMetadata[_asset] = FeedMetadata(_feed, _maxStaleness);\n    }\n\n    /*\n     * The dev version of the Oracle doesn't need to gas optimize and cache the decimals\n     */\n    function getDecimals(address _feed) internal view override returns (uint8) {\n        require(_feed != address(0), \"Asset not available\");\n        require(_feed != FIXED_PRICE, \"Fixed price feeds not supported\");\n\n        return AggregatorV3Interface(_feed).decimals();\n    }\n\n    /**\n     * @dev The price feed contract to use for a particular asset along with\n     *      maximum data staleness\n     * @param asset address of the asset\n     * @return feedAddress address of the price feed for the asset\n     * @return maxStaleness maximum acceptable data staleness duration\n     */\n    function feedMetadata(address asset)\n        internal\n        view\n        override\n        returns (address feedAddress, uint256 maxStaleness)\n    {\n        FeedMetadata storage fm = assetToFeedMetadata[asset];\n        feedAddress = fm.feedAddress;\n        maxStaleness = fm.maxStaleness;\n    }\n}\n"
    },
    "contracts/mocks/MockOracleRouterNoStale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { OracleRouter } from \"../oracle/OracleRouter.sol\";\nimport { OETHOracleRouter } from \"../oracle/OETHOracleRouter.sol\";\n\n// @notice Oracle Router used to bypass staleness\ncontract MockOracleRouterNoStale is OracleRouter {\n    function feedMetadata(address asset)\n        internal\n        pure\n        virtual\n        override\n        returns (address feedAddress, uint256 maxStaleness)\n    {\n        (feedAddress, ) = super.feedMetadata(asset);\n        maxStaleness = 365 days;\n    }\n}\n\n// @notice Oracle Router used to bypass staleness\ncontract MockOETHOracleRouterNoStale is OETHOracleRouter {\n    constructor(address auraPriceFeed) OETHOracleRouter(auraPriceFeed) {}\n\n    function feedMetadata(address asset)\n        internal\n        view\n        virtual\n        override\n        returns (address feedAddress, uint256 maxStaleness)\n    {\n        (feedAddress, ) = super.feedMetadata(asset);\n        maxStaleness = 365 days;\n    }\n}\n"
    },
    "contracts/mocks/MockOracleWeightedPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Variable, OracleAverageQuery, IOracleWeightedPool } from \"../interfaces/balancer/IOracleWeightedPool.sol\";\n\ncontract MockOracleWeightedPool is IOracleWeightedPool {\n    uint256[] public nextResults;\n\n    constructor() {\n        nextResults = [1 ether, 1 ether];\n    }\n\n    function getTimeWeightedAverage(OracleAverageQuery[] memory)\n        external\n        view\n        override\n        returns (uint256[] memory results)\n    {\n        return nextResults;\n    }\n\n    function setNextResults(uint256[] calldata results) external {\n        nextResults = results;\n    }\n}\n"
    },
    "contracts/mocks/MockRebornMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n// solhint-disable-next-line no-console\nimport \"hardhat/console.sol\";\n\ncontract Sanctum {\n    address public asset;\n    address public vault;\n    address public reborner;\n    bool public shouldAttack = false;\n    uint256 public targetMethod;\n    address public ousdContract;\n\n    constructor(address _asset, address _vault) {\n        asset = _asset;\n        vault = _vault;\n    }\n\n    function deploy(uint256 salt, bytes memory bytecode)\n        public\n        returns (address addr)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n    }\n\n    function computeAddress(uint256 salt, bytes memory bytecode)\n        public\n        view\n        returns (address)\n    {\n        bytes32 bytecodeHashHash = keccak256(bytecode);\n        bytes32 _data = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                salt,\n                bytecodeHashHash\n            )\n        );\n        return address(bytes20(_data << 96));\n    }\n\n    function setShouldAttack(bool _shouldAttack) public {\n        shouldAttack = _shouldAttack;\n    }\n\n    function setTargetMethod(uint256 target) public {\n        targetMethod = target;\n    }\n\n    function setOUSDAddress(address _ousdContract) public {\n        ousdContract = _ousdContract;\n    }\n}\n\ncontract Reborner {\n    Sanctum sanctum;\n    bool logging = false;\n\n    constructor(address _sanctum) {\n        log(\"We are created...\");\n        sanctum = Sanctum(_sanctum);\n        if (sanctum.shouldAttack()) {\n            log(\"We are attacking now...\");\n\n            uint256 target = sanctum.targetMethod();\n\n            if (target == 1) {\n                redeem();\n            } else if (target == 2) {\n                transfer();\n            } else {\n                mint();\n            }\n        }\n    }\n\n    function mint() public {\n        log(\"We are attempting to mint..\");\n        address asset = sanctum.asset();\n        address vault = sanctum.vault();\n        IERC20(asset).approve(vault, 1e18);\n        IVault(vault).mint(asset, 1e18, 0);\n        log(\"We are now minting..\");\n    }\n\n    function redeem() public {\n        log(\"We are attempting to redeem..\");\n        address vault = sanctum.vault();\n        IVault(vault).redeem(1e18, 1e18);\n        log(\"We are now redeeming..\");\n    }\n\n    function transfer() public {\n        log(\"We are attempting to transfer..\");\n        address ousd = sanctum.ousdContract();\n        require(IERC20(ousd).transfer(address(1), 1e18), \"transfer failed\");\n        log(\"We are now transfering..\");\n    }\n\n    function bye() public {\n        log(\"We are now destructing..\");\n        selfdestruct(payable(msg.sender));\n    }\n\n    function log(string memory message) internal view {\n        if (logging) {\n            // solhint-disable-next-line no-console\n            console.log(message);\n        }\n    }\n}\n"
    },
    "contracts/mocks/MockRETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\nimport \"../interfaces/IGetExchangeRateToken.sol\";\n\ncontract MockRETH is MintableERC20, IGetExchangeRateToken {\n    uint256 private exchangeRate = 12e17;\n\n    constructor() ERC20(\"Rocket Pool ETH\", \"rETH\") {}\n\n    function getExchangeRate() external view override returns (uint256) {\n        return exchangeRate;\n    }\n\n    function setExchangeRate(uint256 _rate) external {\n        exchangeRate = _rate;\n    }\n}\n"
    },
    "contracts/mocks/MocksfrxETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MocksfrxETH is MintableERC20 {\n    address public frxETH;\n\n    constructor(address _frxETH) ERC20(\"sfrxETH\", \"sfrxETH\") {\n        frxETH = _frxETH;\n    }\n\n    function setMockfrxETHAddress(address _frxETH) external {\n        frxETH = _frxETH;\n    }\n\n    function deposit(uint256 assets, address receiver)\n        external\n        returns (uint256 shares)\n    {\n        ERC20(frxETH).transferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, assets);\n\n        return assets;\n    }\n\n    function maxWithdraw(address owner) external view returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    function setMaxWithdrawableBalance(address owner, uint256 balance)\n        external\n    {\n        uint256 currentBalance = balanceOf(owner);\n        if (currentBalance > balance) {\n            _burn(owner, currentBalance - balance);\n        } else if (balance > currentBalance) {\n            _mint(owner, balance - currentBalance);\n        }\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets) {\n        _burn(owner, shares);\n\n        ERC20(frxETH).transfer(receiver, shares);\n\n        assets = shares;\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares) {\n        _burn(owner, assets);\n\n        ERC20(frxETH).transfer(receiver, assets);\n\n        shares = assets;\n    }\n\n    function submitAndDeposit(address recipient)\n        external\n        payable\n        returns (uint256 shares)\n    {\n        _mint(recipient, msg.value);\n        shares = msg.value;\n    }\n}\n"
    },
    "contracts/mocks/MockSSV.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockSSV is MintableERC20 {\n    constructor() ERC20(\"SSV Token\", \"SSV\") {}\n}\n"
    },
    "contracts/mocks/MockSSVNetwork.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Cluster } from \"./../interfaces/ISSVNetwork.sol\";\n\ncontract MockSSVNetwork {\n    function registerValidator(\n        bytes calldata publicKey,\n        uint64[] calldata operatorIds,\n        bytes calldata sharesData,\n        uint256 amount,\n        Cluster memory cluster\n    ) external {}\n\n    function bulkRegisterValidator(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds,\n        bytes[] calldata sharesData,\n        uint256 amount,\n        Cluster memory cluster\n    ) external {}\n\n    function exitValidator(\n        bytes calldata publicKey,\n        uint64[] calldata operatorIds\n    ) external {}\n\n    function removeValidator(\n        bytes calldata publicKey,\n        uint64[] calldata operatorIds,\n        Cluster memory cluster\n    ) external {}\n\n    function deposit(\n        address clusterOwner,\n        uint64[] calldata operatorIds,\n        uint256 amount,\n        Cluster memory cluster\n    ) external {}\n\n    function setFeeRecipientAddress(address recipient) external {}\n}\n"
    },
    "contracts/mocks/MockstETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockstETH is MintableERC20 {\n    constructor() ERC20(\"stETH\", \"stETH\") {}\n}\n"
    },
    "contracts/mocks/MockStkAave.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./MintableERC20.sol\";\n\ncontract MockStkAave is MintableERC20 {\n    uint256 public COOLDOWN_SECONDS = 864000;\n    uint256 public UNSTAKE_WINDOW = 172800;\n    address public STAKED_TOKEN;\n\n    mapping(address => uint256) public stakerRewardsToClaim;\n    mapping(address => uint256) public stakersCooldowns;\n\n    using SafeERC20 for IERC20;\n\n    constructor(address _stakedToken) ERC20(\"Staked Aave\", \"stkAAVE\") {\n        STAKED_TOKEN = _stakedToken;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n\n    function setStakedToken(address _stakedToken) external {\n        STAKED_TOKEN = _stakedToken;\n    }\n\n    /**\n     * @dev Redeems staked tokens, and stop earning rewards\n     * @param to Address to redeem to\n     * @param amount Amount to redeem\n     **/\n    function redeem(address to, uint256 amount) external {\n        uint256 cooldownStartTimestamp = stakersCooldowns[msg.sender];\n        uint256 windowStart = cooldownStartTimestamp + COOLDOWN_SECONDS;\n        require(amount != 0, \"INVALID_ZERO_AMOUNT\");\n        require(block.timestamp > windowStart, \"INSUFFICIENT_COOLDOWN\");\n        require(\n            block.timestamp - windowStart <= UNSTAKE_WINDOW,\n            \"UNSTAKE_WINDOW_FINISHED\"\n        );\n        uint256 balanceOfMessageSender = balanceOf(msg.sender);\n        uint256 amountToRedeem = (amount > balanceOfMessageSender)\n            ? balanceOfMessageSender\n            : amount;\n\n        stakersCooldowns[msg.sender] = 0;\n        _burn(msg.sender, amountToRedeem);\n        IERC20(STAKED_TOKEN).safeTransfer(to, amountToRedeem);\n    }\n\n    /**\n     * @dev Activates the cooldown period to unstake\n     * - It can't be called if the user is not staking\n     **/\n    function cooldown() external {\n        require(balanceOf(msg.sender) != 0, \"INVALID_BALANCE_ON_COOLDOWN\");\n        stakersCooldowns[msg.sender] = block.timestamp;\n    }\n\n    /**\n     * @dev Test helper function to allow changing the cooldown\n     **/\n    function setCooldown(address account, uint256 _cooldown) external {\n        stakersCooldowns[account] = _cooldown;\n    }\n}\n"
    },
    "contracts/mocks/MockStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockStrategy {\n    address[] public assets;\n\n    address public withdrawAllAsset;\n    address public withdrawAllRecipient;\n\n    constructor() {}\n\n    function deposit(address asset, uint256 amount) external {}\n\n    function depositAll() external {}\n\n    function withdraw(\n        address recipient,\n        address asset,\n        uint256 amount\n    ) external {\n        IERC20(asset).transfer(recipient, amount);\n    }\n\n    function withdrawAll() external {\n        IERC20(withdrawAllAsset).transfer(\n            withdrawAllRecipient,\n            IERC20(withdrawAllAsset).balanceOf(address(this))\n        );\n    }\n\n    function checkBalance(address asset)\n        external\n        view\n        returns (uint256 balance)\n    {\n        balance = IERC20(asset).balanceOf(address(this));\n    }\n\n    function supportsAsset(address) external view returns (bool) {\n        return true;\n    }\n\n    function collectRewardTokens() external {}\n\n    function getRewardTokenAddresses()\n        external\n        view\n        returns (address[] memory)\n    {\n        return new address[](0);\n    }\n\n    function setWithdrawAll(address asset, address recipient) external {\n        withdrawAllAsset = asset;\n        withdrawAllRecipient = recipient;\n    }\n}\n"
    },
    "contracts/mocks/MockSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IMintableERC20 } from \"./MintableERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockSwapper {\n    uint256 public nextOutAmount;\n\n    function swap(\n        // solhint-disable-next-line no-unused-vars\n        address _fromAsset,\n        address _toAsset,\n        // solhint-disable-next-line no-unused-vars\n        uint256 _fromAssetAmount,\n        uint256 _minToAssetAmount,\n        // solhint-disable-next-line no-unused-vars\n        bytes calldata _data\n    ) external returns (uint256 toAssetAmount) {\n        toAssetAmount = (nextOutAmount > 0) ? nextOutAmount : _minToAssetAmount;\n        nextOutAmount = 0;\n        IMintableERC20(_toAsset).mint(toAssetAmount);\n        IERC20(_toAsset).transfer(msg.sender, toAssetAmount);\n    }\n\n    function setNextOutAmount(uint256 _nextOutAmount) public {\n        nextOutAmount = _nextOutAmount;\n    }\n}\n"
    },
    "contracts/mocks/MockTUSD.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockTUSD is MintableERC20 {\n    constructor() ERC20(\"TrueUSD\", \"TUSD\") {}\n\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n}\n"
    },
    "contracts/mocks/MockUniswapPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IUniswapV2Pair } from \"../interfaces/uniswap/IUniswapV2Pair.sol\";\n\ncontract MockUniswapPair is IUniswapV2Pair {\n    address tok0;\n    address tok1;\n    uint112 reserve0;\n    uint112 reserve1;\n    uint256 blockTimestampLast;\n\n    bool public hasSynced = false;\n\n    constructor(\n        address _token0,\n        address _token1,\n        uint112 _reserve0,\n        uint112 _reserve1\n    ) {\n        tok0 = _token0;\n        tok1 = _token1;\n        reserve0 = _reserve0;\n        reserve1 = _reserve1;\n        blockTimestampLast = block.timestamp;\n    }\n\n    function token0() external view override returns (address) {\n        return tok0;\n    }\n\n    function token1() external view override returns (address) {\n        return tok1;\n    }\n\n    function getReserves()\n        external\n        view\n        override\n        returns (\n            uint112,\n            uint112,\n            uint32\n        )\n    {\n        return (reserve0, reserve1, uint32(blockTimestampLast));\n    }\n\n    function setReserves(uint112 _reserve0, uint112 _reserve1) public {\n        reserve0 = _reserve0;\n        reserve1 = _reserve1;\n        blockTimestampLast = block.timestamp;\n    }\n\n    // CAUTION This will not work if you setReserves multiple times over\n    // multiple different blocks because then it wouldn't be a continuous\n    // reserve factor over that blockTimestamp, this assumes an even reserve\n    // ratio all the way through\n    function price0CumulativeLast() external view override returns (uint256) {\n        return\n            uint256(FixedPoint.fraction(reserve1, reserve0)._x) *\n            blockTimestampLast;\n    }\n\n    function price1CumulativeLast() external view override returns (uint256) {\n        return\n            uint256(FixedPoint.fraction(reserve0, reserve1)._x) *\n            blockTimestampLast;\n    }\n\n    function sync() external override {\n        hasSynced = true;\n    }\n\n    function checkHasSynced() external view {\n        require(hasSynced, \"Not synced\");\n    }\n}\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // returns a uq112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).div(denominator)\n    function fraction(uint112 numerator, uint112 denominator)\n        internal\n        pure\n        returns (uq112x112 memory)\n    {\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) << 112) / denominator);\n    }\n}\n"
    },
    "contracts/mocks/MockUniswapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { MintableERC20 } from \"./MintableERC20.sol\";\nimport { IUniswapV2Router } from \"../interfaces/uniswap/IUniswapV2Router02.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\ncontract MockUniswapRouter is IUniswapV2Router {\n    using StableMath for uint256;\n\n    mapping(address => address) public pairMaps;\n    uint256 public slippage = 1 ether;\n\n    function initialize(\n        address[] calldata _0tokens,\n        address[] calldata _1tokens\n    ) public {\n        require(\n            _0tokens.length == _1tokens.length,\n            \"Mock token pairs should be of the same length\"\n        );\n        for (uint256 i = 0; i < _0tokens.length; i++) {\n            pairMaps[_0tokens[i]] = _1tokens[i];\n        }\n    }\n\n    function setSlippage(uint256 _slippage) external {\n        slippage = _slippage;\n    }\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        // solhint-disable-next-line no-unused-vars\n        uint256\n    ) external override returns (uint256[] memory amountsOut) {\n        address tok0 = path[0];\n        address tok1 = path[path.length - 1];\n\n        uint256 amountOut = (amountOutMin * slippage) / 1 ether;\n        require(amountOut >= amountOutMin, \"Slippage error\");\n\n        IERC20(tok0).transferFrom(msg.sender, address(this), amountIn);\n        MintableERC20(tok1).mintTo(to, amountOut);\n\n        amountsOut = new uint256[](path.length);\n        amountsOut[path.length - 1] = amountOut;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    function exactInput(ExactInputParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut)\n    {\n        (address tok0, address tok1) = _getFirstAndLastToken(params.path);\n\n        amountOut = (params.amountOutMinimum * slippage) / 1 ether;\n\n        IERC20(tok0).transferFrom(msg.sender, address(this), params.amountIn);\n        MintableERC20(tok1).mintTo(params.recipient, amountOut);\n\n        require(\n            amountOut >= params.amountOutMinimum,\n            \"UniswapMock: amountOut less than amountOutMinimum\"\n        );\n        return amountOut;\n    }\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        override\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        // this is needed to make this contract whole else it'd be just virtual\n    }\n\n    function WETH() external pure override returns (address) {\n        return address(0);\n    }\n\n    // Universal router mock\n    function execute(\n        bytes calldata,\n        bytes[] calldata inputs,\n        uint256\n    ) external payable {\n        uint256 inLen = inputs.length;\n        for (uint256 i = 0; i < inLen; ++i) {\n            (\n                address recipient,\n                ,\n                uint256 amountOutMinimum,\n                bytes memory path,\n\n            ) = abi.decode(inputs[i], (address, uint256, uint256, bytes, bool));\n\n            (address token0, address token1) = _getFirstAndLastToken(path);\n\n            amountOutMinimum = amountOutMinimum.scaleBy(\n                Helpers.getDecimals(token0),\n                Helpers.getDecimals(token1)\n            );\n\n            MintableERC20(token1).mintTo(recipient, amountOutMinimum);\n        }\n    }\n\n    function _getFirstAndLastToken(bytes memory path)\n        internal\n        view\n        returns (address token0, address token1)\n    {\n        bytes memory tok0Bytes = new bytes(20);\n        for (uint256 j = 0; j < 20; ++j) {\n            tok0Bytes[j] = path[j];\n        }\n        token0 = address(bytes20(tok0Bytes));\n\n        if (pairMaps[token0] != address(0)) {\n            token0 = pairMaps[token0];\n        }\n\n        bytes memory tok1Bytes = new bytes(20);\n        uint256 tok1Offset = path.length - 20;\n        for (uint256 j = 0; j < 20; ++j) {\n            tok1Bytes[j] = path[j + tok1Offset];\n        }\n        token1 = address(bytes20(tok1Bytes));\n\n        if (pairMaps[token1] != address(0)) {\n            token1 = pairMaps[token1];\n        }\n    }\n}\n"
    },
    "contracts/mocks/MockUSDC.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockUSDC is MintableERC20 {\n    constructor() ERC20(\"USDC Coin\", \"USDC\") {}\n\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n}\n"
    },
    "contracts/mocks/MockUSDT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockUSDT is MintableERC20 {\n    constructor() ERC20(\"USDT Coin\", \"USDT\") {}\n\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n}\n"
    },
    "contracts/mocks/MockVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { VaultCore } from \"../vault/VaultCore.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { VaultInitializer } from \"../vault/VaultInitializer.sol\";\nimport \"../utils/Helpers.sol\";\n\ncontract MockVault is VaultCore {\n    using StableMath for uint256;\n\n    uint256 storedTotalValue;\n\n    function setTotalValue(uint256 _value) public {\n        storedTotalValue = _value;\n    }\n\n    function totalValue() external view override returns (uint256) {\n        return storedTotalValue;\n    }\n\n    function _totalValue() internal view override returns (uint256) {\n        return storedTotalValue;\n    }\n\n    function _checkBalance(address _asset)\n        internal\n        view\n        override\n        returns (uint256 balance)\n    {\n        // Avoids rounding errors by returning the total value\n        // in a single currency\n        if (allAssets[0] == _asset) {\n            uint256 decimals = Helpers.getDecimals(_asset);\n            return storedTotalValue.scaleBy(decimals, 18);\n        } else {\n            return 0;\n        }\n    }\n\n    function setMaxSupplyDiff(uint256 _maxSupplyDiff) external onlyGovernor {\n        maxSupplyDiff = _maxSupplyDiff;\n    }\n}\n"
    },
    "contracts/mocks/MockWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockWETH is MintableERC20 {\n    constructor() ERC20(\"WETH\", \"WETH\") {}\n\n    function deposit() external payable {\n        _mint(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) external {\n        _burn(msg.sender, wad);\n        payable(msg.sender).transfer(wad);\n    }\n}\n"
    },
    "contracts/oracle/AbstractOracleRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// @notice Abstract functionality that is shared between various Oracle Routers\nabstract contract AbstractOracleRouter is IOracle {\n    using StableMath for uint256;\n    using SafeCast for int256;\n\n    uint256 internal constant MIN_DRIFT = 0.7e18;\n    uint256 internal constant MAX_DRIFT = 1.3e18;\n    address internal constant FIXED_PRICE =\n        0x0000000000000000000000000000000000000001;\n    // Maximum allowed staleness buffer above normal Oracle maximum staleness\n    uint256 internal constant STALENESS_BUFFER = 1 days;\n    mapping(address => uint8) internal decimalsCache;\n\n    /**\n     * @dev The price feed contract to use for a particular asset along with\n     *      maximum data staleness\n     * @param asset address of the asset\n     * @return feedAddress address of the price feed for the asset\n     * @return maxStaleness maximum acceptable data staleness duration\n     */\n    function feedMetadata(address asset)\n        internal\n        view\n        virtual\n        returns (address feedAddress, uint256 maxStaleness);\n\n    /**\n     * @notice Returns the total price in 18 digit unit for a given asset.\n     * @param asset address of the asset\n     * @return uint256 unit price for 1 asset unit, in 18 decimal fixed\n     */\n    function price(address asset)\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        (address _feed, uint256 maxStaleness) = feedMetadata(asset);\n        require(_feed != address(0), \"Asset not available\");\n        require(_feed != FIXED_PRICE, \"Fixed price feeds not supported\");\n\n        // slither-disable-next-line unused-return\n        (, int256 _iprice, , uint256 updatedAt, ) = AggregatorV3Interface(_feed)\n            .latestRoundData();\n\n        require(\n            updatedAt + maxStaleness >= block.timestamp,\n            \"Oracle price too old\"\n        );\n\n        uint8 decimals = getDecimals(_feed);\n\n        uint256 _price = _iprice.toUint256().scaleBy(18, decimals);\n        if (shouldBePegged(asset)) {\n            require(_price <= MAX_DRIFT, \"Oracle: Price exceeds max\");\n            require(_price >= MIN_DRIFT, \"Oracle: Price under min\");\n        }\n        return _price;\n    }\n\n    function getDecimals(address _feed) internal view virtual returns (uint8) {\n        uint8 decimals = decimalsCache[_feed];\n        require(decimals > 0, \"Oracle: Decimals not cached\");\n        return decimals;\n    }\n\n    /**\n     * @notice Before an asset/feed price is fetches for the first time the\n     *         decimals need to be cached. This is a gas optimization\n     * @param asset address of the asset\n     * @return uint8 corresponding asset decimals\n     */\n    function cacheDecimals(address asset) external returns (uint8) {\n        (address _feed, ) = feedMetadata(asset);\n        require(_feed != address(0), \"Asset not available\");\n        require(_feed != FIXED_PRICE, \"Fixed price feeds not supported\");\n\n        uint8 decimals = AggregatorV3Interface(_feed).decimals();\n        decimalsCache[_feed] = decimals;\n        return decimals;\n    }\n\n    function shouldBePegged(address _asset) internal view returns (bool) {\n        string memory symbol = Helpers.getSymbol(_asset);\n        bytes32 symbolHash = keccak256(abi.encodePacked(symbol));\n        return\n            symbolHash == keccak256(abi.encodePacked(\"DAI\")) ||\n            symbolHash == keccak256(abi.encodePacked(\"USDC\")) ||\n            symbolHash == keccak256(abi.encodePacked(\"USDT\"));\n    }\n}\n"
    },
    "contracts/oracle/AuraWETHPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Variable, OracleAverageQuery, IOracleWeightedPool } from \"../interfaces/balancer/IOracleWeightedPool.sol\";\nimport { Strategizable } from \"../governance/Strategizable.sol\";\nimport { AggregatorV3Interface } from \"../interfaces/chainlink/AggregatorV3Interface.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\ncontract AuraWETHPriceFeed is AggregatorV3Interface, Strategizable {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    event PriceFeedPaused();\n    event PriceFeedUnpaused();\n    event ToleranceChanged(uint256 oldTolerance, uint256 newTolerance);\n\n    error PriceFeedPausedError();\n    error PriceFeedUnpausedError();\n    error InvalidToleranceBps();\n    error HighPriceVolatility(uint256 deviation);\n\n    bool public paused;\n    uint256 public tolerance = 0.02 ether; // 2% by default\n\n    // Fields to make it compatible with `AggregatorV3Interface`\n    uint8 public constant override decimals = 18;\n    string public constant override description = \"\";\n    uint256 public constant override version = 1;\n\n    IOracleWeightedPool public immutable auraOracleWeightedPool;\n\n    constructor(address _auraOracleWeightedPool, address _governor) {\n        _setGovernor(_governor);\n        auraOracleWeightedPool = IOracleWeightedPool(_auraOracleWeightedPool);\n    }\n\n    /**\n     * @dev Queries the OracleWeightedPool for TWAP of two intervals\n     * (1h data from 5m ago and the recent 5m data) and ensures that\n     * the price hasn't deviated too much and returns the most recent\n     * TWAP price.\n     *\n     * @return price The price scaled to 18 decimals\n     **/\n    function price() external view returns (int256) {\n        return _price();\n    }\n\n    function _price() internal view returns (int256) {\n        if (paused) {\n            revert PriceFeedPausedError();\n        }\n        OracleAverageQuery[] memory queries = new OracleAverageQuery[](2);\n\n        queries[0] = OracleAverageQuery({\n            variable: Variable.PAIR_PRICE,\n            secs: 3600, // Get 1h data\n            ago: 300 // From 5min ago\n        });\n        queries[1] = OracleAverageQuery({\n            variable: Variable.PAIR_PRICE,\n            secs: 300, // Get 5min data\n            ago: 0 // From now\n        });\n\n        uint256[] memory prices = auraOracleWeightedPool.getTimeWeightedAverage(\n            queries\n        );\n        int256 price_1h = prices[0].toInt256();\n        int256 price_5m = prices[1].toInt256();\n\n        int256 diff = (1e18 * (price_1h - price_5m)) /\n            ((price_1h + price_5m) / 2);\n        uint256 absDiff = diff >= 0 ? diff.toUint256() : (-diff).toUint256();\n\n        // Ensure the price hasn't moved too much (2% tolerance)\n        // between now and the past hour\n        if (absDiff > tolerance) {\n            revert HighPriceVolatility(absDiff);\n        }\n\n        // Return the recent price\n        return price_5m;\n    }\n\n    /**\n     * Pauses the price feed. Callable by Strategist as well.\n     **/\n    function pause() external onlyGovernorOrStrategist {\n        if (paused) {\n            revert PriceFeedPausedError();\n        }\n        paused = true;\n        emit PriceFeedPaused();\n    }\n\n    /**\n     * Unpauses the price feed. Only Governor can call it\n     **/\n    function unpause() external onlyGovernor {\n        if (!paused) {\n            revert PriceFeedUnpausedError();\n        }\n        paused = false;\n        emit PriceFeedUnpaused();\n    }\n\n    /**\n     * Set the max amount of tolerance acceptable between\n     * two different price points.\n     *\n     * @param _tolerance New tolerance value\n     **/\n    function setTolerance(uint256 _tolerance) external onlyGovernor {\n        if (_tolerance > 0.1 ether) {\n            revert InvalidToleranceBps();\n        }\n        emit ToleranceChanged(tolerance, _tolerance);\n        tolerance = _tolerance;\n    }\n\n    /**\n     * @dev This function exists to make the contract compatible\n     * with AggregatorV3Interface (which OETHOracleRouter uses to\n     * get the price).\n     *\n     * The `answer` returned by this is same as what `price()` would return.\n     *\n     * It doesn't return any data about rounds (since those doesn't exist).\n     **/\n    function latestRoundData()\n        external\n        view\n        override\n        returns (\n            uint80,\n            int256 answer,\n            uint256,\n            uint256 updatedAt,\n            uint80\n        )\n    {\n        answer = _price();\n        updatedAt = block.timestamp;\n    }\n\n    /**\n     * @dev This function exists to make the contract compatible\n     * with AggregatorV3Interface.\n     *\n     * Always reverts since there're no round data in this contract.\n     **/\n    function getRoundData(uint80)\n        external\n        pure\n        override\n        returns (\n            uint80,\n            int256,\n            uint256,\n            uint256,\n            uint80\n        )\n    {\n        revert(\"No data present\");\n    }\n}\n"
    },
    "contracts/oracle/OETHBaseOracleRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { AbstractOracleRouter } from \"./AbstractOracleRouter.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\n\n// @notice Oracle Router (for OETH on Base) that denominates all prices in ETH\ncontract OETHBaseOracleRouter is AbstractOracleRouter {\n    using StableMath for uint256;\n    using SafeCast for int256;\n\n    address constant WETH = 0x4200000000000000000000000000000000000006;\n    address constant WOETH = 0xD8724322f44E5c58D7A815F542036fb17DbbF839;\n    address constant WOETH_CHAINLINK_FEED =\n        0xe96EB1EDa83d18cbac224233319FA5071464e1b9;\n\n    constructor() {}\n\n    /**\n     * @notice Returns the total price in 18 digit units for a given asset.\n     *         This implementation does not (!) do range checks as the\n     *         parent OracleRouter does.\n     * @param asset address of the asset\n     * @return uint256 unit price for 1 asset unit, in 18 decimal fixed\n     */\n    function price(address asset)\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        (address _feed, uint256 maxStaleness) = feedMetadata(asset);\n        if (_feed == FIXED_PRICE) {\n            return 1e18;\n        }\n        require(_feed != address(0), \"Asset not available\");\n\n        // slither-disable-next-line unused-return\n        (, int256 _iprice, , uint256 updatedAt, ) = AggregatorV3Interface(_feed)\n            .latestRoundData();\n\n        require(\n            updatedAt + maxStaleness >= block.timestamp,\n            \"Oracle price too old\"\n        );\n\n        uint8 decimals = getDecimals(_feed);\n        uint256 _price = _iprice.toUint256().scaleBy(18, decimals);\n        return _price;\n    }\n\n    /**\n     * @dev The price feed contract to use for a particular asset along with\n     *      maximum data staleness\n     * @param asset address of the asset\n     * @return feedAddress address of the price feed for the asset\n     * @return maxStaleness maximum acceptable data staleness duration\n     */\n    function feedMetadata(address asset)\n        internal\n        view\n        virtual\n        override\n        returns (address feedAddress, uint256 maxStaleness)\n    {\n        if (asset == WETH) {\n            // FIXED_PRICE: WETH/ETH\n            feedAddress = FIXED_PRICE;\n            maxStaleness = 0;\n        } else if (asset == WOETH) {\n            // Chainlink: https://data.chain.link/feeds/base/base/woeth-oeth-exchange-rate\n            // Bridged wOETH/OETH\n            feedAddress = WOETH_CHAINLINK_FEED;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else {\n            revert(\"Asset not available\");\n        }\n    }\n}\n"
    },
    "contracts/oracle/OETHFixedOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { OETHOracleRouter } from \"./OETHOracleRouter.sol\";\n\n// @notice Oracle Router that returns 1e18 for all prices\n// used solely for deployment to testnets\ncontract OETHFixedOracle is OETHOracleRouter {\n    constructor(address _auraPriceFeed) OETHOracleRouter(_auraPriceFeed) {}\n\n    /**\n     * @dev The price feed contract to use for a particular asset along with\n     *      maximum data staleness\n     * @param asset address of the asset\n     * @return feedAddress address of the price feed for the asset\n     * @return maxStaleness maximum acceptable data staleness duration\n     */\n    // solhint-disable-next-line no-unused-vars\n    function feedMetadata(address asset)\n        internal\n        view\n        virtual\n        override\n        returns (address feedAddress, uint256 maxStaleness)\n    {\n        // fixes price for all of the assets\n        feedAddress = FIXED_PRICE;\n        maxStaleness = 0;\n    }\n}\n"
    },
    "contracts/oracle/OETHOracleRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\nimport { AbstractOracleRouter } from \"./AbstractOracleRouter.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\n// @notice Oracle Router that denominates all prices in ETH\ncontract OETHOracleRouter is AbstractOracleRouter {\n    using StableMath for uint256;\n\n    address public immutable auraPriceFeed;\n\n    constructor(address _auraPriceFeed) {\n        auraPriceFeed = _auraPriceFeed;\n    }\n\n    /**\n     * @notice Returns the total price in 18 digit units for a given asset.\n     *         This implementation does not (!) do range checks as the\n     *         parent OracleRouter does.\n     * @param asset address of the asset\n     * @return uint256 unit price for 1 asset unit, in 18 decimal fixed\n     */\n    function price(address asset)\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        (address _feed, uint256 maxStaleness) = feedMetadata(asset);\n        if (_feed == FIXED_PRICE) {\n            return 1e18;\n        }\n        require(_feed != address(0), \"Asset not available\");\n\n        // slither-disable-next-line unused-return\n        (, int256 _iprice, , uint256 updatedAt, ) = AggregatorV3Interface(_feed)\n            .latestRoundData();\n\n        require(\n            updatedAt + maxStaleness >= block.timestamp,\n            \"Oracle price too old\"\n        );\n\n        uint8 decimals = getDecimals(_feed);\n        uint256 _price = uint256(_iprice).scaleBy(18, decimals);\n        return _price;\n    }\n\n    /**\n     * @dev The price feed contract to use for a particular asset along with\n     *      maximum data staleness\n     * @param asset address of the asset\n     * @return feedAddress address of the price feed for the asset\n     * @return maxStaleness maximum acceptable data staleness duration\n     */\n    function feedMetadata(address asset)\n        internal\n        view\n        virtual\n        override\n        returns (address feedAddress, uint256 maxStaleness)\n    {\n        if (asset == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) {\n            // FIXED_PRICE: WETH/ETH\n            feedAddress = FIXED_PRICE;\n            maxStaleness = 0;\n        } else if (asset == 0x5E8422345238F34275888049021821E8E08CAa1f) {\n            // frxETH/ETH\n            feedAddress = 0xC58F3385FBc1C8AD2c0C9a061D7c13b141D7A5Df;\n            maxStaleness = 18 hours + STALENESS_BUFFER;\n        } else if (asset == 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84) {\n            // https://data.chain.link/ethereum/mainnet/crypto-eth/steth-eth\n            // Chainlink: stETH/ETH\n            feedAddress = 0x86392dC19c0b719886221c78AB11eb8Cf5c52812;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else if (asset == 0xae78736Cd615f374D3085123A210448E74Fc6393) {\n            // https://data.chain.link/ethereum/mainnet/crypto-eth/reth-eth\n            // Chainlink: rETH/ETH\n            feedAddress = 0x536218f9E9Eb48863970252233c8F271f554C2d0;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else if (asset == 0xD533a949740bb3306d119CC777fa900bA034cd52) {\n            // https://data.chain.link/ethereum/mainnet/crypto-eth/crv-eth\n            // Chainlink: CRV/ETH\n            feedAddress = 0x8a12Be339B0cD1829b91Adc01977caa5E9ac121e;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else if (asset == 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B) {\n            // https://data.chain.link/ethereum/mainnet/crypto-eth/cvx-eth\n            // Chainlink: CVX/ETH\n            feedAddress = 0xC9CbF687f43176B302F03f5e58470b77D07c61c6;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else if (asset == 0xBe9895146f7AF43049ca1c1AE358B0541Ea49704) {\n            // https://data.chain.link/ethereum/mainnet/crypto-eth/cbeth-eth\n            // Chainlink: cbETH/ETH\n            feedAddress = 0xF017fcB346A1885194689bA23Eff2fE6fA5C483b;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else if (asset == 0xba100000625a3754423978a60c9317c58a424e3D) {\n            // https://data.chain.link/ethereum/mainnet/crypto-eth/bal-eth\n            // Chainlink: BAL/ETH\n            feedAddress = 0xC1438AA3823A6Ba0C159CfA8D98dF5A994bA120b;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else if (asset == 0xC0c293ce456fF0ED870ADd98a0828Dd4d2903DBF) {\n            // AURA/ETH\n            feedAddress = auraPriceFeed;\n            maxStaleness = 0;\n        } else {\n            revert(\"Asset not available\");\n        }\n    }\n}\n"
    },
    "contracts/oracle/OracleRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\nimport { AbstractOracleRouter } from \"./AbstractOracleRouter.sol\";\n\n// @notice Oracle Router that denominates all prices in USD\ncontract OracleRouter is AbstractOracleRouter {\n    /**\n     * @dev The price feed contract to use for a particular asset along with\n     *      maximum data staleness\n     * @param asset address of the asset\n     * @return feedAddress address of the price feed for the asset\n     * @return maxStaleness maximum acceptable data staleness duration\n     */\n    function feedMetadata(address asset)\n        internal\n        pure\n        virtual\n        override\n        returns (address feedAddress, uint256 maxStaleness)\n    {\n        /* + STALENESS_BUFFER is added in case Oracle for some reason doesn't\n         * update on heartbeat and we add a generous buffer amount.\n         */\n        if (asset == 0x6B175474E89094C44Da98b954EedeAC495271d0F) {\n            // https://data.chain.link/ethereum/mainnet/stablecoins/dai-usd\n            // Chainlink: DAI/USD\n            feedAddress = 0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9;\n            maxStaleness = 1 hours + STALENESS_BUFFER;\n        } else if (asset == 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48) {\n            // https://data.chain.link/ethereum/mainnet/stablecoins/usdc-usd\n            // Chainlink: USDC/USD\n            feedAddress = 0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else if (asset == 0xdAC17F958D2ee523a2206206994597C13D831ec7) {\n            // https://data.chain.link/ethereum/mainnet/stablecoins/usdt-usd\n            // Chainlink: USDT/USD\n            feedAddress = 0x3E7d1eAB13ad0104d2750B8863b489D65364e32D;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else if (asset == 0xc00e94Cb662C3520282E6f5717214004A7f26888) {\n            // https://data.chain.link/ethereum/mainnet/crypto-usd/comp-usd\n            // Chainlink: COMP/USD\n            feedAddress = 0xdbd020CAeF83eFd542f4De03e3cF0C28A4428bd5;\n            maxStaleness = 1 hours + STALENESS_BUFFER;\n        } else if (asset == 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9) {\n            // https://data.chain.link/ethereum/mainnet/crypto-usd/aave-usd\n            // Chainlink: AAVE/USD\n            feedAddress = 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9;\n            maxStaleness = 1 hours + STALENESS_BUFFER;\n        } else if (asset == 0xD533a949740bb3306d119CC777fa900bA034cd52) {\n            // https://data.chain.link/ethereum/mainnet/crypto-usd/crv-usd\n            // Chainlink: CRV/USD\n            feedAddress = 0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else if (asset == 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B) {\n            // Chainlink: CVX/USD\n            feedAddress = 0xd962fC30A72A84cE50161031391756Bf2876Af5D;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else {\n            revert(\"Asset not available\");\n        }\n    }\n}\n"
    },
    "contracts/proxies/InitializeGovernedUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { Governable } from \"../governance/Governable.sol\";\n\n/**\n * @title BaseGovernedUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with our governor system.\n * It is based on an older version of OpenZeppelins BaseUpgradeabilityProxy\n * with Solidity ^0.8.0.\n * @author Origin Protocol Inc\n */\ncontract InitializeGovernedUpgradeabilityProxy is Governable {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     * @param implementation Address of the new implementation.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Contract initializer with Governor enforcement\n     * @param _logic Address of the initial implementation.\n     * @param _initGovernor Address of the initial Governor.\n     * @param _data Data to send as msg.data to the implementation to initialize\n     * the proxied contract.\n     * It should include the signature and the parameters of the function to be\n     * called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     * This parameter is optional, if no data is given the initialization call\n     * to proxied contract will be skipped.\n     */\n    function initialize(\n        address _logic,\n        address _initGovernor,\n        bytes calldata _data\n    ) public payable onlyGovernor {\n        require(_implementation() == address(0));\n        require(_logic != address(0), \"Implementation not set\");\n        assert(\n            IMPLEMENTATION_SLOT ==\n                bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1)\n        );\n        _setImplementation(_logic);\n        if (_data.length > 0) {\n            (bool success, ) = _logic.delegatecall(_data);\n            require(success);\n        }\n        _changeGovernor(_initGovernor);\n    }\n\n    /**\n     * @return The address of the proxy admin/it's also the governor.\n     */\n    function admin() external view returns (address) {\n        return _governor();\n    }\n\n    /**\n     * @return The address of the implementation.\n     */\n    function implementation() external view returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @dev Upgrade the backing implementation of the proxy.\n     * Only the admin can call this function.\n     * @param _newImplementation Address of the new implementation.\n     */\n    function upgradeTo(address _newImplementation) external onlyGovernor {\n        _upgradeTo(_newImplementation);\n    }\n\n    /**\n     * @dev Upgrade the backing implementation of the proxy and call a function\n     * on the new implementation.\n     * This is useful to initialize the proxied contract.\n     * @param newImplementation Address of the new implementation.\n     * @param data Data to send as msg.data in the low level call.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\n        external\n        payable\n        onlyGovernor\n    {\n        _upgradeTo(newImplementation);\n        (bool success, ) = newImplementation.delegatecall(data);\n        require(success);\n    }\n\n    /**\n     * @dev Fallback function.\n     * Implemented entirely in `_fallback`.\n     */\n    fallback() external payable {\n        _fallback();\n    }\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * This is a low level function that doesn't return to its internal call site.\n     * It will return to the external caller whatever the implementation returns.\n     * @param _impl Address to delegate.\n     */\n    function _delegate(address _impl) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev Function that is run as the first thing in the fallback function.\n     * Can be redefined in derived contracts to add functionality.\n     * Redefinitions must call super._willFallback().\n     */\n    function _willFallback() internal {}\n\n    /**\n     * @dev fallback implementation.\n     * Extracted to enable manual triggering.\n     */\n    function _fallback() internal {\n        _willFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation.\n     * @return impl Address of the current implementation\n     */\n    function _implementation() internal view returns (address impl) {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Upgrades the proxy to a new implementation.\n     * @param newImplementation Address of the new implementation.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation address of the proxy.\n     * @param newImplementation Address of the new implementation.\n     */\n    function _setImplementation(address newImplementation) internal {\n        require(\n            Address.isContract(newImplementation),\n            \"Cannot set a proxy implementation to a non-contract address\"\n        );\n\n        bytes32 slot = IMPLEMENTATION_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n}\n"
    },
    "contracts/proxies/Proxies.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { InitializeGovernedUpgradeabilityProxy } from \"./InitializeGovernedUpgradeabilityProxy.sol\";\n\n/**\n * @notice OUSDProxy delegates calls to an OUSD implementation\n */\ncontract OUSDProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice WrappedOUSDProxy delegates calls to a WrappedOUSD implementation\n */\ncontract WrappedOUSDProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice VaultProxy delegates calls to a Vault implementation\n */\ncontract VaultProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice CompoundStrategyProxy delegates calls to a CompoundStrategy implementation\n */\ncontract CompoundStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice AaveStrategyProxy delegates calls to a AaveStrategy implementation\n */\ncontract AaveStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice ThreePoolStrategyProxy delegates calls to a ThreePoolStrategy implementation\n */\ncontract ThreePoolStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice ConvexStrategyProxy delegates calls to a ConvexStrategy implementation\n */\ncontract ConvexStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice HarvesterProxy delegates calls to a Harvester implementation\n */\ncontract HarvesterProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice DripperProxy delegates calls to a Dripper implementation\n */\ncontract DripperProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice MorphoCompoundStrategyProxy delegates calls to a MorphoCompoundStrategy implementation\n */\ncontract MorphoCompoundStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice ConvexOUSDMetaStrategyProxy delegates calls to a ConvexOUSDMetaStrategy implementation\n */\ncontract ConvexOUSDMetaStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice ConvexLUSDMetaStrategyProxy delegates calls to a ConvexalGeneralizedMetaStrategy implementation\n */\ncontract ConvexLUSDMetaStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice MorphoAaveStrategyProxy delegates calls to a MorphoCompoundStrategy implementation\n */\ncontract MorphoAaveStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHProxy delegates calls to nowhere for now\n */\ncontract OETHProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice WOETHProxy delegates calls to nowhere for now\n */\ncontract WOETHProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHVaultProxy delegates calls to a Vault implementation\n */\ncontract OETHVaultProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHDripperProxy delegates calls to a OETHDripper implementation\n */\ncontract OETHDripperProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHHarvesterProxy delegates calls to a Harvester implementation\n */\ncontract OETHHarvesterProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice FraxETHStrategyProxy delegates calls to a FraxETHStrategy implementation\n */\ncontract FraxETHStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice CurveEthStrategyProxy delegates calls to a CurveEthStrategy implementation\n */\ncontract ConvexEthMetaStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice BuybackProxy delegates calls to Buyback implementation\n */\ncontract BuybackProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHMorphoAaveStrategyProxy delegates calls to a MorphoAaveStrategy implementation\n */\ncontract OETHMorphoAaveStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHBalancerMetaPoolrEthStrategyProxy delegates calls to a BalancerMetaPoolStrategy implementation\n */\ncontract OETHBalancerMetaPoolrEthStrategyProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice OETHBalancerMetaPoolwstEthStrategyProxy delegates calls to a BalancerMetaPoolStrategy implementation\n */\ncontract OETHBalancerMetaPoolwstEthStrategyProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice FluxStrategyProxy delegates calls to a CompoundStrategy implementation\n */\ncontract FluxStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice MakerDsrStrategyProxy delegates calls to a Generalized4626Strategy implementation\n */\ncontract MakerDsrStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice FrxEthRedeemStrategyProxy delegates calls to a FrxEthRedeemStrategy implementation\n */\ncontract FrxEthRedeemStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHBuybackProxy delegates calls to Buyback implementation\n */\ncontract OETHBuybackProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice BridgedWOETHProxy delegates calls to BridgedWOETH implementation\n */\ncontract BridgedWOETHProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice NativeStakingSSVStrategyProxy delegates calls to NativeStakingSSVStrategy implementation\n */\ncontract NativeStakingSSVStrategyProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice NativeStakingFeeAccumulatorProxy delegates calls to FeeAccumulator implementation\n */\ncontract NativeStakingFeeAccumulatorProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice NativeStakingSSVStrategy2Proxy delegates calls to NativeStakingSSVStrategy implementation\n */\ncontract NativeStakingSSVStrategy2Proxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice NativeStakingFeeAccumulator2Proxy delegates calls to FeeAccumulator implementation\n */\ncontract NativeStakingFeeAccumulator2Proxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice LidoWithdrawalStrategyProxy delegates calls to a LidoWithdrawalStrategy implementation\n */\ncontract LidoWithdrawalStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice BridgedBaseWOETHProxy delegates calls to BridgedWOETH implementation\n */\ncontract BridgedBaseWOETHProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHBaseVaultProxy delegates calls to OETHBaseVault implementation\n */\ncontract OETHBaseVaultProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHBaseProxy delegates calls to OETH implementation\n */\ncontract OETHBaseProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice WOETHBaseProxy delegates calls to WOETH implementation\n */\ncontract WOETHBaseProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHBaseDripperProxy delegates calls to a OETHDripper implementation\n */\ncontract OETHBaseDripperProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice AerodromeAMOStrategyProxy delegates calls to AerodromeAMOStrategy implementation\n */\ncontract AerodromeAMOStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice BridgedWOETHStrategyProxy delegates calls to BridgedWOETHStrategy implementation\n */\ncontract BridgedWOETHStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n"
    },
    "contracts/staking/SingleAssetStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\ncontract SingleAssetStaking is Initializable, Governable {\n    using SafeMath for uint256;\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    IERC20 public stakingToken; // this is both the staking and rewards\n\n    struct Stake {\n        uint256 amount; // amount to stake\n        uint256 end; // when does the staking period end\n        uint256 duration; // the duration of the stake\n        uint240 rate; // rate to charge use 248 to reserve 8 bits for the bool\n        bool paid;\n        uint8 stakeType;\n    }\n\n    struct DropRoot {\n        bytes32 hash;\n        uint256 depth;\n    }\n\n    uint256[] public durations; // allowed durations\n    uint256[] public rates; // rates that correspond with the allowed durations\n\n    uint256 public totalOutstanding;\n    bool public paused;\n\n    mapping(address => Stake[]) public userStakes;\n\n    mapping(uint8 => DropRoot) public dropRoots;\n\n    // type 0 is reserved for stakes done by the user, all other types will be drop/preApproved stakes\n    uint8 constant USER_STAKE_TYPE = 0;\n    uint256 constant MAX_STAKES = 256;\n\n    address public transferAgent;\n\n    /* ========== Initialize ========== */\n\n    /**\n     * @dev Initialize the contracts, sets up durations, rates, and preApprover\n     *      for preApproved contracts can only be called once\n     * @param _stakingToken Address of the token that we are staking\n     * @param _durations Array of allowed durations in seconds\n     * @param _rates Array of rates(0.3 is 30%) that correspond to the allowed\n     *               durations in 1e18 precision\n     */\n    function initialize(\n        address _stakingToken,\n        uint256[] calldata _durations,\n        uint256[] calldata _rates\n    ) external onlyGovernor initializer {\n        stakingToken = IERC20(_stakingToken);\n        _setDurationRates(_durations, _rates);\n    }\n\n    /* ========= Internal helper functions ======== */\n\n    /**\n     * @dev Validate and set the duration and corresponding rates, will emit\n     *      events NewRate and NewDurations\n     */\n    function _setDurationRates(\n        uint256[] memory _durations,\n        uint256[] memory _rates\n    ) internal {\n        require(\n            _rates.length == _durations.length,\n            \"Mismatch durations and rates\"\n        );\n\n        for (uint256 i = 0; i < _rates.length; i++) {\n            require(_rates[i] < type(uint240).max, \"Max rate exceeded\");\n        }\n\n        rates = _rates;\n        durations = _durations;\n\n        emit NewRates(msg.sender, rates);\n        emit NewDurations(msg.sender, durations);\n    }\n\n    function _totalExpectedRewards(Stake[] storage stakes)\n        internal\n        view\n        returns (uint256 total)\n    {\n        for (uint256 i = 0; i < stakes.length; i++) {\n            Stake storage stake = stakes[i];\n            if (!stake.paid) {\n                total = total.add(stake.amount.mulTruncate(stake.rate));\n            }\n        }\n    }\n\n    function _totalExpected(Stake storage _stake)\n        internal\n        view\n        returns (uint256)\n    {\n        return _stake.amount.add(_stake.amount.mulTruncate(_stake.rate));\n    }\n\n    function _airDroppedStakeClaimed(address account, uint8 stakeType)\n        internal\n        view\n        returns (bool)\n    {\n        Stake[] storage stakes = userStakes[account];\n        for (uint256 i = 0; i < stakes.length; i++) {\n            if (stakes[i].stakeType == stakeType) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _findDurationRate(uint256 duration)\n        internal\n        view\n        returns (uint240)\n    {\n        for (uint256 i = 0; i < durations.length; i++) {\n            if (duration == durations[i]) {\n                return uint240(rates[i]);\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * @dev Internal staking function\n     *      will insert the stake into the stakes array and verify we have\n     *      enough to pay off stake + reward\n     * @param staker Address of the staker\n     * @param stakeType Number that represent the type of the stake, 0 is user\n     *                  initiated all else is currently preApproved\n     * @param duration Number of seconds this stake will be held for\n     * @param rate Rate(0.3 is 30%) of reward for this stake in 1e18, uint240 =\n     *             to fit the bool and type in struct Stake\n     * @param amount Number of tokens to stake in 1e18\n     */\n    function _stake(\n        address staker,\n        uint8 stakeType,\n        uint256 duration,\n        uint240 rate,\n        uint256 amount\n    ) internal {\n        require(!paused, \"Staking paused\");\n\n        Stake[] storage stakes = userStakes[staker];\n\n        uint256 end = block.timestamp.add(duration);\n\n        uint256 i = stakes.length; // start at the end of the current array\n\n        require(i < MAX_STAKES, \"Max stakes\");\n\n        stakes.push(); // grow the array\n        // find the spot where we can insert the current stake\n        // this should make an increasing list sorted by end\n        while (i != 0 && stakes[i - 1].end > end) {\n            // shift it back one\n            stakes[i] = stakes[i - 1];\n            i -= 1;\n        }\n\n        // insert the stake\n        Stake storage newStake = stakes[i];\n        newStake.rate = rate;\n        newStake.stakeType = stakeType;\n        newStake.end = end;\n        newStake.duration = duration;\n        newStake.amount = amount;\n\n        totalOutstanding = totalOutstanding.add(_totalExpected(newStake));\n\n        emit Staked(staker, amount, duration, rate);\n    }\n\n    function _stakeWithChecks(\n        address staker,\n        uint256 amount,\n        uint256 duration\n    ) internal {\n        require(amount > 0, \"Cannot stake 0\");\n\n        uint240 rewardRate = _findDurationRate(duration);\n        require(rewardRate > 0, \"Invalid duration\"); // we couldn't find the rate that correspond to the passed duration\n\n        _stake(staker, USER_STAKE_TYPE, duration, rewardRate, amount);\n        // transfer in the token so that we can stake the correct amount\n        stakingToken.safeTransferFrom(staker, address(this), amount);\n    }\n\n    modifier requireLiquidity() {\n        // we need to have enough balance to cover the rewards after the operation is complete\n        _;\n        require(\n            stakingToken.balanceOf(address(this)) >= totalOutstanding,\n            \"Insufficient rewards\"\n        );\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getAllDurations() external view returns (uint256[] memory) {\n        return durations;\n    }\n\n    function getAllRates() external view returns (uint256[] memory) {\n        return rates;\n    }\n\n    /**\n     * @dev Return all the stakes paid and unpaid for a given user\n     * @param account Address of the account that we want to look up\n     */\n    function getAllStakes(address account)\n        external\n        view\n        returns (Stake[] memory)\n    {\n        return userStakes[account];\n    }\n\n    /**\n     * @dev Find the rate that corresponds to a given duration\n     * @param _duration Number of seconds\n     */\n    function durationRewardRate(uint256 _duration)\n        external\n        view\n        returns (uint256)\n    {\n        return _findDurationRate(_duration);\n    }\n\n    /**\n     * @dev Has the airdropped stake already been claimed\n     */\n    function airDroppedStakeClaimed(address account, uint8 stakeType)\n        external\n        view\n        returns (bool)\n    {\n        return _airDroppedStakeClaimed(account, stakeType);\n    }\n\n    /**\n     * @dev Calculate all the staked value a user has put into the contract,\n     *      rewards not included\n     * @param account Address of the account that we want to look up\n     */\n    function totalStaked(address account)\n        external\n        view\n        returns (uint256 total)\n    {\n        Stake[] storage stakes = userStakes[account];\n\n        for (uint256 i = 0; i < stakes.length; i++) {\n            if (!stakes[i].paid) {\n                total = total.add(stakes[i].amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Calculate all the rewards a user can expect to receive.\n     * @param account Address of the account that we want to look up\n     */\n    function totalExpectedRewards(address account)\n        external\n        view\n        returns (uint256)\n    {\n        return _totalExpectedRewards(userStakes[account]);\n    }\n\n    /**\n     * @dev Calculate all current holdings of a user: staked value + prorated rewards\n     * @param account Address of the account that we want to look up\n     */\n    function totalCurrentHoldings(address account)\n        external\n        view\n        returns (uint256 total)\n    {\n        Stake[] storage stakes = userStakes[account];\n\n        for (uint256 i = 0; i < stakes.length; i++) {\n            Stake storage stake = stakes[i];\n            if (stake.paid) {\n                continue;\n            } else if (stake.end < block.timestamp) {\n                total = total.add(_totalExpected(stake));\n            } else {\n                //calcualte the precentage accrued in term of rewards\n                total = total.add(\n                    stake.amount.add(\n                        stake.amount.mulTruncate(stake.rate).mulTruncate(\n                            stake\n                                .duration\n                                .sub(stake.end.sub(block.timestamp))\n                                .divPrecisely(stake.duration)\n                        )\n                    )\n                );\n            }\n        }\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @dev Make a preapproved stake for the user, this is a presigned voucher that the user can redeem either from\n     *      an airdrop or a compensation program.\n     *      Only 1 of each type is allowed per user. The proof must match the root hash\n     * @param index Number that is zero base index of the stake in the payout entry\n     * @param stakeType Number that represent the type of the stake, must not be 0 which is user stake\n     * @param duration Number of seconds this stake will be held for\n     * @param rate Rate(0.3 is 30%) of reward for this stake in 1e18, uint240 to fit the bool and type in struct Stake\n     * @param amount Number of tokens to stake in 1e18\n     * @param merkleProof Array of proofs for that amount\n     */\n    function airDroppedStake(\n        uint256 index,\n        uint8 stakeType,\n        uint256 duration,\n        uint256 rate,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external requireLiquidity {\n        require(stakeType != USER_STAKE_TYPE, \"Cannot be normal staking\");\n        require(rate < type(uint240).max, \"Max rate exceeded\");\n        require(index < 2**merkleProof.length, \"Invalid index\");\n        DropRoot storage dropRoot = dropRoots[stakeType];\n        require(merkleProof.length == dropRoot.depth, \"Invalid proof\");\n\n        // Compute the merkle root\n        bytes32 node = keccak256(\n            abi.encodePacked(\n                index,\n                stakeType,\n                address(this),\n                msg.sender,\n                duration,\n                rate,\n                amount\n            )\n        );\n        uint256 path = index;\n        for (uint16 i = 0; i < merkleProof.length; i++) {\n            if ((path & 0x01) == 1) {\n                node = keccak256(abi.encodePacked(merkleProof[i], node));\n            } else {\n                node = keccak256(abi.encodePacked(node, merkleProof[i]));\n            }\n            path /= 2;\n        }\n\n        // Check the merkle proof\n        require(node == dropRoot.hash, \"Stake not approved\");\n\n        // verify that we haven't already staked\n        require(\n            !_airDroppedStakeClaimed(msg.sender, stakeType),\n            \"Already staked\"\n        );\n\n        _stake(msg.sender, stakeType, duration, uint240(rate), amount);\n    }\n\n    /**\n     * @dev Stake an approved amount of staking token into the contract.\n     *      User must have already approved the contract for specified amount.\n     * @param amount Number of tokens to stake in 1e18\n     * @param duration Number of seconds this stake will be held for\n     */\n    function stake(uint256 amount, uint256 duration) external requireLiquidity {\n        // no checks are performed in this function since those are already present in _stakeWithChecks\n        _stakeWithChecks(msg.sender, amount, duration);\n    }\n\n    /**\n     * @dev Stake an approved amount of staking token into the contract. This function\n     *      can only be called by OGN token contract.\n     * @param staker Address of the account that is creating the stake\n     * @param amount Number of tokens to stake in 1e18\n     * @param duration Number of seconds this stake will be held for\n     */\n    function stakeWithSender(\n        address staker,\n        uint256 amount,\n        uint256 duration\n    ) external requireLiquidity returns (bool) {\n        require(\n            msg.sender == address(stakingToken),\n            \"Only token contract can make this call\"\n        );\n\n        _stakeWithChecks(staker, amount, duration);\n        return true;\n    }\n\n    /**\n     * @dev Exit out of all possible stakes\n     */\n    function exit() external requireLiquidity {\n        Stake[] storage stakes = userStakes[msg.sender];\n        require(stakes.length > 0, \"Nothing staked\");\n\n        uint256 totalWithdraw = 0;\n        uint256 stakedAmount = 0;\n        uint256 l = stakes.length;\n        do {\n            Stake storage exitStake = stakes[l - 1];\n            // stop on the first ended stake that's already been paid\n            if (exitStake.end < block.timestamp && exitStake.paid) {\n                break;\n            }\n            //might not be ended\n            if (exitStake.end < block.timestamp) {\n                //we are paying out the stake\n                exitStake.paid = true;\n                totalWithdraw = totalWithdraw.add(_totalExpected(exitStake));\n                stakedAmount = stakedAmount.add(exitStake.amount);\n            }\n            l--;\n        } while (l > 0);\n        require(totalWithdraw > 0, \"All stakes in lock-up\");\n\n        totalOutstanding = totalOutstanding.sub(totalWithdraw);\n        emit Withdrawn(msg.sender, totalWithdraw, stakedAmount);\n        stakingToken.safeTransfer(msg.sender, totalWithdraw);\n    }\n\n    /**\n     * @dev Use to transfer all the stakes of an account in the case that the account is compromised\n     *      Requires access to both the account itself and the transfer agent\n     * @param _frmAccount the address to transfer from\n     * @param _dstAccount the address to transfer to(must be a clean address with no stakes)\n     * @param r r portion of the signature by the transfer agent\n     * @param s s portion of the signature\n     * @param v v portion of the signature\n     */\n    function transferStakes(\n        address _frmAccount,\n        address _dstAccount,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) external {\n        require(transferAgent == msg.sender, \"must be transfer agent\");\n        Stake[] storage dstStakes = userStakes[_dstAccount];\n        require(dstStakes.length == 0, \"Dest stakes must be empty\");\n        require(_frmAccount != address(0), \"from account not set\");\n        Stake[] storage stakes = userStakes[_frmAccount];\n        require(stakes.length > 0, \"Nothing to transfer\");\n\n        // matches ethers.signMsg(ethers.utils.solidityPack([string(4), address, adddress, address]))\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n64\",\n                abi.encodePacked(\n                    \"tran\",\n                    address(this),\n                    _frmAccount,\n                    _dstAccount\n                )\n            )\n        );\n        require(ecrecover(hash, v, r, s) == _frmAccount, \"Transfer not authed\");\n\n        // copy the stakes into the dstAccount array and delete the old one\n        userStakes[_dstAccount] = stakes;\n        delete userStakes[_frmAccount];\n        emit StakesTransfered(_frmAccount, _dstAccount, stakes.length);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    function setPaused(bool _paused) external onlyGovernor {\n        paused = _paused;\n        emit Paused(msg.sender, paused);\n    }\n\n    /**\n     * @dev Set new durations and rates will not effect existing stakes\n     * @param _durations Array of durations in seconds\n     * @param _rates Array of rates that corresponds to the durations (0.01 is 1%) in 1e18\n     */\n    function setDurationRates(\n        uint256[] calldata _durations,\n        uint256[] calldata _rates\n    ) external onlyGovernor {\n        _setDurationRates(_durations, _rates);\n    }\n\n    /**\n     * @dev Set the agent that will authorize transfers\n     * @param _agent Address of agent\n     */\n    function setTransferAgent(address _agent) external onlyGovernor {\n        transferAgent = _agent;\n    }\n\n    /**\n     * @dev Set air drop root for a specific stake type\n     * @param _stakeType Type of staking must be greater than 0\n     * @param _rootHash Root hash of the Merkle Tree\n     * @param _proofDepth Depth of the Merklke Tree\n     */\n    function setAirDropRoot(\n        uint8 _stakeType,\n        bytes32 _rootHash,\n        uint256 _proofDepth\n    ) external onlyGovernor {\n        require(_stakeType != USER_STAKE_TYPE, \"Cannot be normal staking\");\n        dropRoots[_stakeType].hash = _rootHash;\n        dropRoots[_stakeType].depth = _proofDepth;\n        emit NewAirDropRootHash(_stakeType, _rootHash, _proofDepth);\n    }\n\n    /* ========== EVENTS ========== */\n\n    event Staked(\n        address indexed user,\n        uint256 amount,\n        uint256 duration,\n        uint256 rate\n    );\n    event Withdrawn(address indexed user, uint256 amount, uint256 stakedAmount);\n    event Paused(address indexed user, bool yes);\n    event NewDurations(address indexed user, uint256[] durations);\n    event NewRates(address indexed user, uint256[] rates);\n    event NewAirDropRootHash(\n        uint8 stakeType,\n        bytes32 rootHash,\n        uint256 proofDepth\n    );\n    event StakesTransfered(\n        address indexed fromUser,\n        address toUser,\n        uint256 numStakes\n    );\n}\n"
    },
    "contracts/strategies/AaveStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD Aave Strategy\n * @notice Investment strategy for investing stablecoins via Aave\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./IAave.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\n\nimport { IAaveStakedToken } from \"./IAaveStakeToken.sol\";\nimport { IAaveIncentivesController } from \"./IAaveIncentivesController.sol\";\n\ncontract AaveStrategy is InitializableAbstractStrategy {\n    using SafeERC20 for IERC20;\n\n    uint16 constant referralCode = 92;\n\n    IAaveIncentivesController public incentivesController;\n    IAaveStakedToken public stkAave;\n\n    /**\n     * @param _stratConfig The platform and OToken vault addresses\n     */\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as AAVE needs several extra\n     * addresses for the rewards program.\n     * @param _rewardTokenAddresses Address of the AAVE token\n     * @param _assets Addresses of supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     * @param _incentivesAddress Address of the AAVE incentives controller\n     * @param _stkAaveAddress Address of the stkAave contract\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // AAVE\n        address[] calldata _assets,\n        address[] calldata _pTokens,\n        address _incentivesAddress,\n        address _stkAaveAddress\n    ) external onlyGovernor initializer {\n        incentivesController = IAaveIncentivesController(_incentivesAddress);\n        stkAave = IAaveStakedToken(_stkAaveAddress);\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n    }\n\n    /**\n     * @dev Deposit asset into Aave\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @dev Deposit asset into Aave\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_amount > 0, \"Must deposit something\");\n        // Following line also doubles as a check that we are depositing\n        // an asset that we support.\n        emit Deposit(_asset, _getATokenFor(_asset), _amount);\n        _getLendingPool().deposit(_asset, _amount, address(this), referralCode);\n    }\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into Aave\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            uint256 balance = IERC20(assetsMapped[i]).balanceOf(address(this));\n            if (balance > 0) {\n                _deposit(assetsMapped[i], balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw asset from Aave\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        emit Withdrawal(_asset, _getATokenFor(_asset), _amount);\n        uint256 actual = _getLendingPool().withdraw(\n            _asset,\n            _amount,\n            address(this)\n        );\n        require(actual == _amount, \"Did not withdraw enough\");\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            // Redeem entire balance of aToken\n            IERC20 asset = IERC20(assetsMapped[i]);\n            address aToken = _getATokenFor(assetsMapped[i]);\n            uint256 balance = IERC20(aToken).balanceOf(address(this));\n            if (balance > 0) {\n                uint256 actual = _getLendingPool().withdraw(\n                    address(asset),\n                    balance,\n                    address(this)\n                );\n                require(actual == balance, \"Did not withdraw enough\");\n\n                uint256 assetBalance = asset.balanceOf(address(this));\n                // Transfer entire balance to Vault\n                asset.safeTransfer(vaultAddress, assetBalance);\n\n                emit Withdrawal(address(asset), aToken, assetBalance);\n            }\n        }\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        // Balance is always with token aToken decimals\n        address aToken = _getATokenFor(_asset);\n        balance = IERC20(aToken).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @dev Approve the spending of all assets by their corresponding aToken,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        address lendingPool = address(_getLendingPool());\n        // approve the pool to spend the Asset\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            address asset = assetsMapped[i];\n            // Safe approval\n            IERC20(asset).safeApprove(lendingPool, 0);\n            IERC20(asset).safeApprove(lendingPool, type(uint256).max);\n        }\n    }\n\n    /**\n     * @dev Internal method to respond to the addition of new asset / aTokens\n            We need to give the AAVE lending pool approval to transfer the\n            asset.\n     * @param _asset Address of the asset to approve\n     * @param _aToken Address of the aToken\n     */\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address _aToken)\n        internal\n        override\n    {\n        address lendingPool = address(_getLendingPool());\n        IERC20(_asset).safeApprove(lendingPool, 0);\n        IERC20(_asset).safeApprove(lendingPool, type(uint256).max);\n    }\n\n    /**\n     * @dev Get the aToken wrapped in the IERC20 interface for this asset.\n     *      Fails if the pToken doesn't exist in our mappings.\n     * @param _asset Address of the asset\n     * @return Corresponding aToken to this asset\n     */\n    function _getATokenFor(address _asset) internal view returns (address) {\n        address aToken = assetToPToken[_asset];\n        require(aToken != address(0), \"aToken does not exist\");\n        return aToken;\n    }\n\n    /**\n     * @dev Get the current address of the Aave lending pool, which is the gateway to\n     *      depositing.\n     * @return Current lending pool implementation\n     */\n    function _getLendingPool() internal view returns (IAaveLendingPool) {\n        address lendingPool = ILendingPoolAddressesProvider(platformAddress)\n            .getLendingPool();\n        require(lendingPool != address(0), \"Lending pool does not exist\");\n        return IAaveLendingPool(lendingPool);\n    }\n\n    /**\n     * @dev Collect stkAave, convert it to AAVE send to Vault.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        if (address(stkAave) == address(0)) {\n            return;\n        }\n\n        // Check staked AAVE cooldown timer\n        uint256 cooldown = stkAave.stakersCooldowns(address(this));\n        uint256 windowStart = cooldown + stkAave.COOLDOWN_SECONDS();\n        uint256 windowEnd = windowStart + stkAave.UNSTAKE_WINDOW();\n\n        // If inside the unlock window, then we can redeem stkAave\n        // for AAVE and send it to the vault.\n        if (block.timestamp > windowStart && block.timestamp <= windowEnd) {\n            // Redeem to AAVE\n            uint256 stkAaveBalance = stkAave.balanceOf(address(this));\n            stkAave.redeem(address(this), stkAaveBalance);\n\n            // Transfer AAVE to harvesterAddress\n            uint256 aaveBalance = IERC20(rewardTokenAddresses[0]).balanceOf(\n                address(this)\n            );\n            if (aaveBalance > 0) {\n                IERC20(rewardTokenAddresses[0]).safeTransfer(\n                    harvesterAddress,\n                    aaveBalance\n                );\n            }\n        }\n\n        // Collect available rewards and restart the cooldown timer, if either of\n        // those should be run.\n        if (block.timestamp > windowStart || cooldown == 0) {\n            uint256 assetsLen = assetsMapped.length;\n            // aToken addresses for incentives controller\n            address[] memory aTokens = new address[](assetsLen);\n            for (uint256 i = 0; i < assetsLen; ++i) {\n                aTokens[i] = _getATokenFor(assetsMapped[i]);\n            }\n\n            // 1. If we have rewards availabile, collect them\n            uint256 pendingRewards = incentivesController.getRewardsBalance(\n                aTokens,\n                address(this)\n            );\n            if (pendingRewards > 0) {\n                // Because getting more stkAAVE from the incentives controller\n                // with claimRewards() may push the stkAAVE cooldown time\n                // forward, it is called after stakedAAVE has been turned into\n                // AAVE.\n                uint256 collected = incentivesController.claimRewards(\n                    aTokens,\n                    pendingRewards,\n                    address(this)\n                );\n                require(collected == pendingRewards, \"AAVE reward difference\");\n            }\n\n            // 2. Start cooldown counting down.\n            if (stkAave.balanceOf(address(this)) > 0) {\n                // Protected with if since cooldown call would revert\n                // if no stkAave balance.\n                stkAave.cooldown();\n            }\n        }\n    }\n}\n"
    },
    "contracts/strategies/AbstractCompoundStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Base Compound Abstract Strategy\n * @author Origin Protocol Inc\n */\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ICERC20 } from \"./ICompound.sol\";\nimport { IComptroller } from \"../interfaces/IComptroller.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\n\nabstract contract AbstractCompoundStrategy is InitializableAbstractStrategy {\n    using SafeERC20 for IERC20;\n\n    int256[50] private __reserved;\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @dev Get the cToken wrapped in the ICERC20 interface for this asset.\n     *      Fails if the pToken doesn't exist in our mappings.\n     * @param _asset Address of the asset\n     * @return Corresponding cToken to this asset\n     */\n    function _getCTokenFor(address _asset) internal view returns (ICERC20) {\n        address cToken = assetToPToken[_asset];\n        require(cToken != address(0), \"cToken does not exist\");\n        return ICERC20(cToken);\n    }\n\n    /**\n     * @dev Converts an underlying amount into cToken amount\n     *      cTokenAmt = (underlying * 1e18) / exchangeRate\n     * @param _cToken     cToken for which to change\n     * @param _underlying Amount of underlying to convert\n     * @return amount     Equivalent amount of cTokens\n     */\n    function _convertUnderlyingToCToken(ICERC20 _cToken, uint256 _underlying)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // e.g. 1e18*1e18 / 205316390724364402565641705 = 50e8\n        // e.g. 1e8*1e18 / 205316390724364402565641705 = 0.45 or 0\n        amount = (_underlying * 1e18) / _cToken.exchangeRateStored();\n    }\n}\n"
    },
    "contracts/strategies/AbstractConvexMetaStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Curve Convex Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IRewardStaking } from \"./IRewardStaking.sol\";\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { ICurveMetaPool } from \"./ICurveMetaPool.sol\";\nimport { IERC20, AbstractCurveStrategy, InitializableAbstractStrategy } from \"./AbstractCurveStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\n\nabstract contract AbstractConvexMetaStrategy is AbstractCurveStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    event MaxWithdrawalSlippageUpdated(\n        uint256 _prevMaxSlippagePercentage,\n        uint256 _newMaxSlippagePercentage\n    );\n\n    // used to circumvent the stack too deep issue\n    struct InitConfig {\n        address cvxDepositorAddress; //Address of the Convex depositor(AKA booster) for this pool\n        address metapoolAddress; //Address of the Curve MetaPool\n        address metapoolMainToken; //Address of Main metapool token\n        address cvxRewardStakerAddress; //Address of the CVX rewards staker\n        address metapoolLPToken; //Address of metapool LP token\n        uint256 cvxDepositorPTokenId; //Pid of the pool referred to by Depositor and staker\n    }\n\n    address internal cvxDepositorAddress;\n    address internal cvxRewardStakerAddress;\n    uint256 internal cvxDepositorPTokenId;\n    ICurveMetaPool internal metapool;\n    IERC20 internal metapoolMainToken;\n    IERC20 internal metapoolLPToken;\n    // Ordered list of metapool assets\n    address[] internal metapoolAssets;\n    // Max withdrawal slippage denominated in 1e18 (1e18 == 100%)\n    uint256 public maxWithdrawalSlippage;\n    uint128 internal crvCoinIndex;\n    uint128 internal mainCoinIndex;\n\n    int256[41] private ___reserved;\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Curve strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Address of CRV & CVX\n     * @param _assets Addresses of supported assets. MUST be passed in the same\n     *                order as returned by coins on the pool contract, i.e.\n     *                DAI, USDC, USDT\n     * @param _pTokens Platform Token corresponding addresses\n     * @param initConfig Various addresses and info for initialization state\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // CRV + CVX\n        address[] calldata _assets,\n        address[] calldata _pTokens,\n        InitConfig calldata initConfig\n    ) external onlyGovernor initializer {\n        require(_assets.length == 3, \"Must have exactly three assets\");\n        // Should be set prior to abstract initialize call otherwise\n        // abstractSetPToken calls will fail\n        cvxDepositorAddress = initConfig.cvxDepositorAddress;\n        pTokenAddress = _pTokens[0];\n        metapool = ICurveMetaPool(initConfig.metapoolAddress);\n        metapoolMainToken = IERC20(initConfig.metapoolMainToken);\n        cvxRewardStakerAddress = initConfig.cvxRewardStakerAddress;\n        metapoolLPToken = IERC20(initConfig.metapoolLPToken);\n        cvxDepositorPTokenId = initConfig.cvxDepositorPTokenId;\n        maxWithdrawalSlippage = 1e16;\n\n        metapoolAssets = [metapool.coins(0), metapool.coins(1)];\n        crvCoinIndex = _getMetapoolCoinIndex(pTokenAddress);\n        mainCoinIndex = _getMetapoolCoinIndex(initConfig.metapoolMainToken);\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n        _approveBase();\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        virtual\n        override\n        returns (uint256 balance)\n    {\n        require(assetToPToken[_asset] != address(0), \"Unsupported asset\");\n        balance = 0;\n\n        // LP tokens in this contract. This should generally be nothing as we\n        // should always stake the full balance in the Gauge, but include for\n        // safety\n        uint256 contractPTokens = IERC20(pTokenAddress).balanceOf(\n            address(this)\n        );\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        if (contractPTokens > 0) {\n            uint256 virtual_price = curvePool.get_virtual_price();\n            uint256 value = contractPTokens.mulTruncate(virtual_price);\n            balance += value;\n        }\n\n        /* We intentionally omit the metapoolLp tokens held by the metastrategyContract\n         * since the contract should never (except in the middle of deposit/withdrawal\n         * transaction) hold any amount of those tokens in normal operation. There\n         * could be tokens sent to it by a 3rd party and we decide to actively ignore\n         * those.\n         */\n        uint256 metapoolGaugePTokens = IRewardStaking(cvxRewardStakerAddress)\n            .balanceOf(address(this));\n\n        if (metapoolGaugePTokens > 0) {\n            uint256 value = metapoolGaugePTokens.mulTruncate(\n                metapool.get_virtual_price()\n            );\n            balance += value;\n        }\n\n        uint256 assetDecimals = Helpers.getDecimals(_asset);\n        balance = balance.scaleBy(assetDecimals, 18) / THREEPOOL_ASSET_COUNT;\n    }\n\n    /**\n     * @dev This function is completely analogous to _calcCurveTokenAmount[AbstractCurveStrategy]\n     * and just utilizes different Curve (meta)pool API\n     */\n    function _calcCurveMetaTokenAmount(uint128 _coinIndex, uint256 _amount)\n        internal\n        returns (uint256 requiredMetapoolLP)\n    {\n        uint256[2] memory _amounts = [uint256(0), uint256(0)];\n        _amounts[uint256(_coinIndex)] = _amount;\n\n        // LP required when removing required asset ignoring fees\n        uint256 lpRequiredNoFees = metapool.calc_token_amount(_amounts, false);\n        /* LP required if fees would apply to entirety of removed amount\n         *\n         * fee is 1e10 denominated number: https://curve.readthedocs.io/exchange-pools.html#StableSwap.fee\n         */\n        uint256 lpRequiredFullFees = lpRequiredNoFees.mulTruncateScale(\n            1e10 + metapool.fee(),\n            1e10\n        );\n\n        /* asset received when withdrawing full fee applicable LP accounting for\n         * slippage and fees\n         */\n        uint256 assetReceivedForFullLPFees = metapool.calc_withdraw_one_coin(\n            lpRequiredFullFees,\n            int128(_coinIndex)\n        );\n\n        // exact amount of LP required\n        requiredMetapoolLP =\n            (lpRequiredFullFees * _amount) /\n            assetReceivedForFullLPFees;\n    }\n\n    function _approveBase() internal override {\n        IERC20 pToken = IERC20(pTokenAddress);\n        // 3Pool for LP token (required for removing liquidity)\n        pToken.safeApprove(platformAddress, 0);\n        pToken.safeApprove(platformAddress, type(uint256).max);\n        // Gauge for LP token\n        metapoolLPToken.safeApprove(cvxDepositorAddress, 0);\n        metapoolLPToken.safeApprove(cvxDepositorAddress, type(uint256).max);\n        // Metapool for LP token\n        pToken.safeApprove(address(metapool), 0);\n        pToken.safeApprove(address(metapool), type(uint256).max);\n        // Metapool for Metapool main token\n        metapoolMainToken.safeApprove(address(metapool), 0);\n        metapoolMainToken.safeApprove(address(metapool), type(uint256).max);\n    }\n\n    /**\n     * @dev Get the index of the coin\n     */\n    function _getMetapoolCoinIndex(address _asset)\n        internal\n        view\n        returns (uint128)\n    {\n        for (uint128 i = 0; i < 2; i++) {\n            if (metapoolAssets[i] == _asset) return i;\n        }\n        revert(\"Invalid Metapool asset\");\n    }\n\n    /**\n     * @dev Sets max withdrawal slippage that is considered when removing\n     * liquidity from Metapools.\n     * @param _maxWithdrawalSlippage Max withdrawal slippage denominated in\n     *        wad (number with 18 decimals): 1e18 == 100%, 1e16 == 1%\n     *\n     * IMPORTANT Minimum maxWithdrawalSlippage should actually be 0.1% (1e15)\n     * for production usage. Contract allows as low value as 0% for confirming\n     * correct behavior in test suite.\n     */\n    function setMaxWithdrawalSlippage(uint256 _maxWithdrawalSlippage)\n        external\n        onlyVaultOrGovernorOrStrategist\n    {\n        require(\n            _maxWithdrawalSlippage <= 1e18,\n            \"Max withdrawal slippage needs to be between 0% - 100%\"\n        );\n        emit MaxWithdrawalSlippageUpdated(\n            maxWithdrawalSlippage,\n            _maxWithdrawalSlippage\n        );\n        maxWithdrawalSlippage = _maxWithdrawalSlippage;\n    }\n\n    /**\n     * @dev Collect accumulated CRV and CVX and send to Harvester.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Collect CRV and CVX\n        IRewardStaking(cvxRewardStakerAddress).getReward();\n        _collectRewardTokens();\n    }\n\n    /**\n     * @dev Returns the largest of two numbers int256 version\n     */\n    function _max(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n}\n"
    },
    "contracts/strategies/AbstractCurveStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Curve 3Pool Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\n\nabstract contract AbstractCurveStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant MAX_SLIPPAGE = 1e16; // 1%, same as the Curve UI\n    // number of assets in Curve 3Pool (USDC, DAI, USDT)\n    uint256 internal constant THREEPOOL_ASSET_COUNT = 3;\n    address internal pTokenAddress;\n\n    int256[49] private __reserved;\n\n    /**\n     * @dev Deposit asset into the Curve 3Pool\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        require(_amount > 0, \"Must deposit something\");\n        emit Deposit(_asset, pTokenAddress, _amount);\n\n        // 3Pool requires passing deposit amounts for all 3 assets, set to 0 for\n        // all\n        uint256[3] memory _amounts;\n        uint256 poolCoinIndex = _getCoinIndex(_asset);\n        // Set the amount on the asset we want to deposit\n        _amounts[poolCoinIndex] = _amount;\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        uint256 assetDecimals = Helpers.getDecimals(_asset);\n        uint256 depositValue = _amount.scaleBy(18, assetDecimals).divPrecisely(\n            curvePool.get_virtual_price()\n        );\n        uint256 minMintAmount = depositValue.mulTruncate(\n            uint256(1e18) - MAX_SLIPPAGE\n        );\n        // Do the deposit to 3pool\n        curvePool.add_liquidity(_amounts, minMintAmount);\n        _lpDepositAll();\n    }\n\n    function _lpDepositAll() internal virtual;\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into the Curve 3pool\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256[3] memory _amounts = [uint256(0), uint256(0), uint256(0)];\n        uint256 depositValue = 0;\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        uint256 curveVirtualPrice = curvePool.get_virtual_price();\n\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; i++) {\n            address assetAddress = assetsMapped[i];\n            uint256 balance = IERC20(assetAddress).balanceOf(address(this));\n            if (balance > 0) {\n                uint256 poolCoinIndex = _getCoinIndex(assetAddress);\n                // Set the amount on the asset we want to deposit\n                _amounts[poolCoinIndex] = balance;\n                uint256 assetDecimals = Helpers.getDecimals(assetAddress);\n                // Get value of deposit in Curve LP token to later determine\n                // the minMintAmount argument for add_liquidity\n                depositValue =\n                    depositValue +\n                    balance.scaleBy(18, assetDecimals).divPrecisely(\n                        curveVirtualPrice\n                    );\n                emit Deposit(assetAddress, pTokenAddress, balance);\n            }\n        }\n\n        uint256 minMintAmount = depositValue.mulTruncate(\n            uint256(1e18) - MAX_SLIPPAGE\n        );\n        // Do the deposit to 3pool\n        curvePool.add_liquidity(_amounts, minMintAmount);\n\n        /* In case of Curve Strategy all assets are mapped to the same pToken (3CrvLP). Let\n         * descendants further handle the pToken. By either deploying it to the metapool and\n         * resulting tokens in Gauge. Or deploying pTokens directly to the Gauge.\n         */\n        _lpDepositAll();\n    }\n\n    function _lpWithdraw(uint256 numCrvTokens) internal virtual;\n\n    function _lpWithdrawAll() internal virtual;\n\n    /**\n     * @dev Withdraw asset from Curve 3Pool\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_amount > 0, \"Invalid amount\");\n\n        emit Withdrawal(_asset, pTokenAddress, _amount);\n\n        uint256 contractCrv3Tokens = IERC20(pTokenAddress).balanceOf(\n            address(this)\n        );\n\n        uint256 coinIndex = _getCoinIndex(_asset);\n        ICurvePool curvePool = ICurvePool(platformAddress);\n\n        uint256 requiredCrv3Tokens = _calcCurveTokenAmount(coinIndex, _amount);\n\n        // We have enough LP tokens, make sure they are all on this contract\n        if (contractCrv3Tokens < requiredCrv3Tokens) {\n            _lpWithdraw(requiredCrv3Tokens - contractCrv3Tokens);\n        }\n\n        uint256[3] memory _amounts = [uint256(0), uint256(0), uint256(0)];\n        _amounts[coinIndex] = _amount;\n\n        curvePool.remove_liquidity_imbalance(_amounts, requiredCrv3Tokens);\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Calculate amount of LP required when withdrawing specific amount of one\n     * of the underlying assets accounting for fees and slippage.\n     *\n     * Curve pools unfortunately do not contain a calculation function for\n     * amount of LP required when withdrawing a specific amount of one of the\n     * underlying tokens and also accounting for fees (Curve's calc_token_amount\n     * does account for slippage but not fees).\n     *\n     * Steps taken to calculate the metric:\n     *  - get amount of LP required if fees wouldn't apply\n     *  - increase the LP amount as if fees would apply to the entirety of the underlying\n     *    asset withdrawal. (when withdrawing only one coin fees apply only to amounts\n     *    of other assets pool would return in case of balanced removal - since those need\n     *    to be swapped for the single underlying asset being withdrawn)\n     *  - get amount of underlying asset withdrawn (this Curve function does consider slippage\n     *    and fees) when using the increased LP amount. As LP amount is slightly over-increased\n     *    so is amount of underlying assets returned.\n     *  - since we know exactly how much asset we require take the rate of LP required for asset\n     *    withdrawn to get the exact amount of LP.\n     */\n    function _calcCurveTokenAmount(uint256 _coinIndex, uint256 _amount)\n        internal\n        returns (uint256 required3Crv)\n    {\n        ICurvePool curvePool = ICurvePool(platformAddress);\n\n        uint256[3] memory _amounts = [uint256(0), uint256(0), uint256(0)];\n        _amounts[_coinIndex] = _amount;\n\n        // LP required when removing required asset ignoring fees\n        uint256 lpRequiredNoFees = curvePool.calc_token_amount(_amounts, false);\n        /* LP required if fees would apply to entirety of removed amount\n         *\n         * fee is 1e10 denominated number: https://curve.readthedocs.io/exchange-pools.html#StableSwap.fee\n         */\n        uint256 lpRequiredFullFees = lpRequiredNoFees.mulTruncateScale(\n            1e10 + curvePool.fee(),\n            1e10\n        );\n\n        /* asset received when withdrawing full fee applicable LP accounting for\n         * slippage and fees\n         */\n        uint256 assetReceivedForFullLPFees = curvePool.calc_withdraw_one_coin(\n            lpRequiredFullFees,\n            int128(uint128(_coinIndex))\n        );\n\n        // exact amount of LP required\n        required3Crv =\n            (lpRequiredFullFees * _amount) /\n            assetReceivedForFullLPFees;\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        _lpWithdrawAll();\n        // Withdraws are proportional to assets held by 3Pool\n        uint256[3] memory minWithdrawAmounts = [\n            uint256(0),\n            uint256(0),\n            uint256(0)\n        ];\n\n        // Remove liquidity\n        ICurvePool threePool = ICurvePool(platformAddress);\n        threePool.remove_liquidity(\n            IERC20(pTokenAddress).balanceOf(address(this)),\n            minWithdrawAmounts\n        );\n        // Transfer assets out of Vault\n        // Note that Curve will provide all 3 of the assets in 3pool even if\n        // we have not set PToken addresses for all of them in this strategy\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            IERC20 asset = IERC20(threePool.coins(i));\n            asset.safeTransfer(vaultAddress, asset.balanceOf(address(this)));\n        }\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        virtual\n        override\n        returns (uint256 balance)\n    {\n        require(assetToPToken[_asset] != address(0), \"Unsupported asset\");\n        // LP tokens in this contract. This should generally be nothing as we\n        // should always stake the full balance in the Gauge, but include for\n        // safety\n        uint256 totalPTokens = IERC20(pTokenAddress).balanceOf(address(this));\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        if (totalPTokens > 0) {\n            uint256 virtual_price = curvePool.get_virtual_price();\n            uint256 value = (totalPTokens * virtual_price) / 1e18;\n            uint256 assetDecimals = Helpers.getDecimals(_asset);\n            balance = value.scaleBy(assetDecimals, 18) / THREEPOOL_ASSET_COUNT;\n        }\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @dev Approve the spending of all assets by their corresponding pool tokens,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        _approveBase();\n        // This strategy is a special case since it only supports one asset\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            _approveAsset(assetsMapped[i]);\n        }\n    }\n\n    /**\n     * @dev Call the necessary approvals for the Curve pool and gauge\n     * @param _asset Address of the asset\n     */\n    function _abstractSetPToken(address _asset, address) internal override {\n        _approveAsset(_asset);\n    }\n\n    function _approveAsset(address _asset) internal {\n        IERC20 asset = IERC20(_asset);\n        // 3Pool for asset (required for adding liquidity)\n        asset.safeApprove(platformAddress, 0);\n        asset.safeApprove(platformAddress, type(uint256).max);\n    }\n\n    function _approveBase() internal virtual;\n\n    /**\n     * @dev Get the index of the coin\n     */\n    function _getCoinIndex(address _asset) internal view returns (uint256) {\n        for (uint256 i = 0; i < 3; i++) {\n            if (assetsMapped[i] == _asset) return i;\n        }\n        revert(\"Invalid 3pool asset\");\n    }\n}\n"
    },
    "contracts/strategies/aerodrome/AerodromeAMOStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Aerodrome AMO strategy\n * @author Origin Protocol Inc\n */\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { IERC20, InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\n\nimport { ISugarHelper } from \"../../interfaces/aerodrome/ISugarHelper.sol\";\nimport { INonfungiblePositionManager } from \"../../interfaces/aerodrome/INonfungiblePositionManager.sol\";\nimport { ISwapRouter } from \"../../interfaces/aerodrome/ISwapRouter.sol\";\nimport { ICLPool } from \"../../interfaces/aerodrome/ICLPool.sol\";\nimport { ICLGauge } from \"../../interfaces/aerodrome/ICLGauge.sol\";\nimport { IVault } from \"../../interfaces/IVault.sol\";\n\ncontract AerodromeAMOStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    /************************************************\n            Important (!) setup configuration\n    *************************************************/\n\n    /**\n     * In order to be able to remove a reasonable amount of complexity from the contract one of the\n     * preconditions for this contract to function correctly is to have an outside account mint a small\n     * amount of liquidity in the tick space where the contract will deploy's its liquidity and then send\n     * that NFT LP position to a dead address (transfer to zero address not allowed.) See example of such\n     * NFT LP token:\n     * https://basescan.org/token/0x827922686190790b37229fd06084350e74485b72?a=413296#inventory\n     */\n\n    /***************************************\n            Storage slot members\n    ****************************************/\n\n    /// @notice tokenId of the liquidity position\n    uint256 public tokenId;\n    /// @dev Minimum amount of tokens the strategy would be able to withdraw from the pool.\n    ///      minimum amount of tokens are withdrawn at a 1:1 price\n    uint256 public underlyingAssets;\n    /// @notice Marks the start of the interval that defines the allowed range of WETH share in\n    /// the pre-configured pool's liquidity ticker\n    uint256 public allowedWethShareStart;\n    /// @notice Marks the end of the interval that defines the allowed range of WETH share in\n    /// the pre-configured pool's liquidity ticker\n    uint256 public allowedWethShareEnd;\n    /// @dev reserved for inheritance\n    int256[46] private __reserved;\n\n    /***************************************\n          Constants, structs and events\n    ****************************************/\n\n    /// @notice The address of the Wrapped ETH (WETH) token contract\n    address public immutable WETH;\n    /// @notice The address of the OETHb token contract\n    address public immutable OETHb;\n    /// @notice lower tick set to -1 representing the price of 1.0001 of WETH for 1 OETHb.\n    int24 public immutable lowerTick;\n    /// @notice lower tick set to 0 representing the price of 1.0000 of WETH for 1 OETHb.\n    int24 public immutable upperTick;\n    /// @notice tick spacing of the pool (set to 1)\n    int24 public immutable tickSpacing;\n    /// @notice the swapRouter for performing swaps\n    ISwapRouter public immutable swapRouter;\n    /// @notice the underlying AMO Slipstream pool\n    ICLPool public immutable clPool;\n    /// @notice the gauge for the corresponding Slipstream pool (clPool)\n    /// @dev can become an immutable once the gauge is created on the base main-net\n    ICLGauge public immutable clGauge;\n    /// @notice the Position manager contract that is used to manage the pool's position\n    INonfungiblePositionManager public immutable positionManager;\n    /// @notice helper contract for liquidity and ticker math\n    ISugarHelper public immutable helper;\n    /// @notice sqrtRatioX96TickLower\n    /// @dev tick lower has value -1 and represents the lowest price of WETH priced in OETHb. Meaning the pool\n    /// offers less than 1 OETHb for 1 WETH. In other terms to get 1 OETHB the swap needs to offer 1.0001 WETH\n    /// this is where purchasing OETHb with WETH within the liquidity position is most expensive\n    uint160 public immutable sqrtRatioX96TickLower;\n    /// @notice sqrtRatioX96TickHigher\n    /// @dev tick higher has value 0 and represents 1:1 price parity of WETH to OETHb\n    uint160 public immutable sqrtRatioX96TickHigher;\n    /// @dev tick closest to 1:1 price parity\n    ///      Correctly assessing which tick is closer to 1:1 price parity is important since it affects\n    ///      the way we calculate the underlying assets in check Balance. The underlying aerodrome pool\n    ///      orders the tokens depending on the values of their addresses. If OETH token is token0 in the pool\n    ///      then sqrtRatioX96TickClosestToParity=sqrtRatioX96TickLower. If it is token1 in the pool then\n    ///      sqrtRatioX96TickClosestToParity=sqrtRatioX96TickHigher\n    uint160 public immutable sqrtRatioX96TickClosestToParity;\n\n    /// @dev a threshold under which the contract no longer allows for the protocol to rebalance. Guarding\n    ///      against a strategist / guardian being taken over and with multiple transactions draining the\n    ///      protocol funds.\n    uint256 public constant SOLVENCY_THRESHOLD = 0.998 ether;\n\n    error NotEnoughWethForSwap(uint256 wethBalance, uint256 requiredWeth); // 0x989e5ca8\n    error NotEnoughWethLiquidity(uint256 wethBalance, uint256 requiredWeth); // 0xa6737d87\n    error PoolRebalanceOutOfBounds(\n        uint256 currentPoolWethShare,\n        uint256 allowedWethShareStart,\n        uint256 allowedWethShareEnd\n    ); // 0x3681e8e0\n    error OutsideExpectedTickRange(int24 currentTick); // 0x5a2eba75\n\n    event PoolRebalanced(uint256 currentPoolWethShare);\n\n    event PoolWethShareIntervalUpdated(\n        uint256 allowedWethShareStart,\n        uint256 allowedWethShareEnd\n    );\n\n    event LiquidityRemoved(\n        uint256 withdrawLiquidityShare,\n        uint256 removedWETHAmount,\n        uint256 removedOETHbAmount,\n        uint256 wethAmountCollected,\n        uint256 oethbAmountCollected,\n        uint256 underlyingAssets\n    );\n\n    event LiquidityAdded(\n        uint256 wethAmountDesired,\n        uint256 oethbAmountDesired,\n        uint256 wethAmountSupplied,\n        uint256 oethbAmountSupplied,\n        uint256 tokenId,\n        uint256 underlyingAssets\n    );\n\n    event UnderlyingAssetsUpdated(uint256 underlyingAssets);\n\n    /**\n     * @dev Verifies that the caller is the Governor, or Strategist.\n     */\n    modifier onlyGovernorOrStrategist() {\n        require(\n            msg.sender == IVault(vaultAddress).strategistAddr() ||\n                msg.sender == governor(),\n            \"Not the Governor or Strategist\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Un-stakes the token from the gauge for the execution duration of\n     * the function and after that re-stakes it back in.\n     *\n     * It is important that the token is unstaked and owned by the strategy contract\n     * during any liquidity altering operations and that it is re-staked back into the\n     * gauge after liquidity changes. If the token fails to re-stake back to the\n     * gauge it is not earning incentives.\n     */\n    // all functions using this modifier are used by functions with reentrancy check\n    // slither-disable-start reentrancy-no-eth\n    modifier gaugeUnstakeAndRestake() {\n        // because of solidity short-circuit _isLpTokenStakedInGauge doesn't get called\n        // when tokenId == 0\n        if (tokenId != 0 && _isLpTokenStakedInGauge()) {\n            clGauge.withdraw(tokenId);\n        }\n        _;\n        // because of solidity short-circuit _isLpTokenStakedInGauge doesn't get called\n        // when tokenId == 0\n        if (tokenId != 0 && !_isLpTokenStakedInGauge()) {\n            /**\n             * It can happen that a withdrawal (or a full withdrawal) transactions would\n             * remove all of the liquidity from the token with a NFT token still existing.\n             * In that case the token can not be staked into the gauge, as some liquidity\n             * needs to be added to it first.\n             */\n            if (_getLiquidity() > 0) {\n                // if token liquidity changes the positionManager requires re-approval.\n                // to any contract pre-approved to handle the token.\n                positionManager.approve(address(clGauge), tokenId);\n                clGauge.deposit(tokenId);\n            }\n        }\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice the constructor\n    /// @param _stratConfig the basic strategy configuration\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\n    /// @param _oethbAddress Address of the Erc20 OETHb Token contract\n    /// @param _swapRouter Address of the Aerodrome Universal Swap Router\n    /// @param _nonfungiblePositionManager Address of position manager to add/remove\n    ///         the liquidity\n    /// @param _clPool Address of the Aerodrome concentrated liquidity pool\n    /// @param _clGauge Address of the Aerodrome slipstream pool gauge\n    /// @param _sugarHelper Address of the Aerodrome Sugar helper contract\n    /// @param _lowerBoundingTick Smaller bounding tick of our liquidity position\n    /// @param _upperBoundingTick Larger bounding tick of our liquidity position\n    /// @param _tickClosestToParity Tick that is closer to 1:1 price parity\n    constructor(\n        BaseStrategyConfig memory _stratConfig,\n        address _wethAddress,\n        address _oethbAddress,\n        address _swapRouter,\n        address _nonfungiblePositionManager,\n        address _clPool,\n        address _clGauge,\n        address _sugarHelper,\n        int24 _lowerBoundingTick,\n        int24 _upperBoundingTick,\n        int24 _tickClosestToParity\n    ) InitializableAbstractStrategy(_stratConfig) {\n        require(\n            _lowerBoundingTick == _tickClosestToParity ||\n                _upperBoundingTick == _tickClosestToParity,\n            \"Misconfigured tickClosestToParity\"\n        );\n        require(\n            ICLPool(_clPool).token0() == _wethAddress,\n            \"Only WETH supported as token0\"\n        );\n        require(\n            ICLPool(_clPool).token1() == _oethbAddress,\n            \"Only OETHb supported as token1\"\n        );\n        int24 _tickSpacing = ICLPool(_clPool).tickSpacing();\n        // when we generalize AMO we might support other tick spacings\n        require(_tickSpacing == 1, \"Unsupported tickSpacing\");\n\n        WETH = _wethAddress;\n        OETHb = _oethbAddress;\n        swapRouter = ISwapRouter(_swapRouter);\n        positionManager = INonfungiblePositionManager(\n            _nonfungiblePositionManager\n        );\n        clPool = ICLPool(_clPool);\n        clGauge = ICLGauge(_clGauge);\n        helper = ISugarHelper(_sugarHelper);\n        sqrtRatioX96TickLower = ISugarHelper(_sugarHelper).getSqrtRatioAtTick(\n            _lowerBoundingTick\n        );\n        sqrtRatioX96TickHigher = ISugarHelper(_sugarHelper).getSqrtRatioAtTick(\n            _upperBoundingTick\n        );\n        sqrtRatioX96TickClosestToParity = ISugarHelper(_sugarHelper)\n            .getSqrtRatioAtTick(_tickClosestToParity);\n\n        lowerTick = _lowerBoundingTick;\n        upperTick = _upperBoundingTick;\n        tickSpacing = _tickSpacing;\n    }\n\n    /**\n     * @notice initialize function, to set up initial internal state\n     * @param _rewardTokenAddresses Address of reward token for platform\n     */\n    function initialize(address[] memory _rewardTokenAddresses)\n        external\n        onlyGovernor\n        initializer\n    {\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            new address[](0),\n            new address[](0)\n        );\n    }\n\n    /***************************************\n                  Configuration \n    ****************************************/\n\n    /**\n     * @notice Set allowed pool weth share interval. After the rebalance happens\n     * the share of WETH token in the ticker needs to be withing the specifications\n     * of the interval.\n     *\n     * @param _allowedWethShareStart Start of WETH share interval expressed as 18 decimal amount\n     * @param _allowedWethShareEnd End of WETH share interval expressed as 18 decimal amount\n     */\n    function setAllowedPoolWethShareInterval(\n        uint256 _allowedWethShareStart,\n        uint256 _allowedWethShareEnd\n    ) external onlyGovernor {\n        require(\n            _allowedWethShareStart < _allowedWethShareEnd,\n            \"Invalid interval\"\n        );\n        // can not go below 1% weth share\n        require(_allowedWethShareStart > 0.01 ether, \"Invalid interval start\");\n        // can not go above 95% weth share\n        require(_allowedWethShareEnd < 0.95 ether, \"Invalid interval end\");\n\n        allowedWethShareStart = _allowedWethShareStart;\n        allowedWethShareEnd = _allowedWethShareEnd;\n        emit PoolWethShareIntervalUpdated(\n            allowedWethShareStart,\n            allowedWethShareEnd\n        );\n    }\n\n    /***************************************\n                Periphery utils\n    ****************************************/\n\n    function _isLpTokenStakedInGauge() internal view returns (bool) {\n        require(tokenId != 0, \"Missing NFT LP token\");\n\n        address owner = positionManager.ownerOf(tokenId);\n        require(\n            owner == address(clGauge) || owner == address(this),\n            \"Unexpected token owner\"\n        );\n        return owner == address(clGauge);\n    }\n\n    /***************************************\n               Strategy overrides \n    ****************************************/\n\n    /**\n     * @notice Deposit an amount of assets into the strategy contract. Calling deposit doesn't\n     *         automatically deposit funds into the underlying Aerodrome pool\n     * @param _asset   Address for the asset\n     * @param _amount  Units of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @notice Deposit WETH to the strategy contract. This function does not add liquidity to the\n     *         underlying Aerodrome pool.\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        if (_wethBalance > 0) {\n            _deposit(WETH, _wethBalance);\n        }\n    }\n\n    /**\n     * @dev Deposit WETH to the contract. This function doesn't deposit the liquidity to the\n     *      pool, that is done via the rebalance call.\n     * @param _asset Address of the asset to deposit\n     * @param _amount Amount of assets to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_asset == WETH, \"Unsupported asset\");\n        require(_amount > 0, \"Must deposit something\");\n        emit Deposit(_asset, address(0), _amount);\n    }\n\n    /**\n     * @notice Rebalance the pool to the desired token split and Deposit any WETH on the contract to the\n     * underlying aerodrome pool. Print the required amount of corresponding OETHb. After the rebalancing is\n     * done burn any potentially remaining OETHb tokens still on the strategy contract.\n     *\n     * This function has a slightly different behaviour depending on the status of the underlying Aerodrome\n     * slipstream pool. The function consists of the following 3 steps:\n     * 1. withdrawPartialLiqidity -> so that moving the activeTrading price via  a swap is cheaper\n     * 2. swapToDesiredPosition   -> move active trading price in the pool to be able to deposit WETH & OETHb\n     *                               tokens with the desired pre-configured shares\n     * 3. addLiquidity            -> add liquidity into the pool respecting share split configuration\n     *\n     * Scenario 1: When there is no liquidity in the pool from the strategy but there is from other LPs then\n     *             only step 1 is skipped. (It is important to note that liquidity needs to exist in the configured\n     *             strategy tick ranges in order for the swap to be possible) Step 3 mints new liquidity position\n     *             instead of adding to an existing one.\n     * Scenario 2: When there is strategy's liquidity in the pool all 3 steps are taken\n     *\n     *\n     * Exact _amountToSwap, _swapWeth & _minTokenReceived parameters shall be determined by simulating the\n     * transaction off-chain. The strategy checks that after the swap the share of the tokens is in the\n     * expected ranges.\n     *\n     * @param _amountToSwap The amount of the token to swap\n     * @param _swapWeth Swap using WETH when true, use OETHb when false\n     * @param _minTokenReceived Slippage check -> minimum amount of token expected in return\n     */\n    function rebalance(\n        uint256 _amountToSwap,\n        bool _swapWeth,\n        uint256 _minTokenReceived\n    ) external nonReentrant onlyGovernorOrStrategist {\n        /**\n         * Would be nice to check if there is any total liquidity in the pool before performing this swap\n         * but there is no easy way to do that in UniswapV3:\n         * - clPool.liquidity() -> only liquidity in the active tick\n         * - asset[1&2].balanceOf(address(clPool)) -> will include uncollected tokens of LP providers\n         *   after their liquidity position has been decreased\n         */\n\n        /**\n         * When rebalance is called for the first time there is no strategy\n         * liquidity in the pool yet. The full liquidity removal is thus skipped.\n         */\n        if (tokenId != 0) {\n            _removeLiquidity(1e18);\n        }\n        // in some cases we will just want to add liquidity and not issue a swap to move the\n        // active trading position within the pool\n        if (_amountToSwap > 0) {\n            _swapToDesiredPosition(_amountToSwap, _swapWeth, _minTokenReceived);\n        }\n        // calling check liquidity early so we don't get unexpected errors when adding liquidity\n        // in the later stages of this function\n        _checkForExpectedPoolPrice();\n\n        _addLiquidity();\n        // this call shouldn't be necessary, since adding liquidity shouldn't affect the active\n        // trading price. It is a defensive programming measure.\n        _checkForExpectedPoolPrice();\n\n        // revert if protocol insolvent\n        _solvencyAssert();\n    }\n\n    /**\n     * Checks that the protocol is solvent, protecting from a rogue Strategist / Guardian that can\n     * keep rebalancing the pool in both directions making the protocol lose a tiny amount of\n     * funds each time.\n     *\n     * Protocol must be at least SOLVENCY_THRESHOLD (99,8 %) backed in order for the rebalances to\n     * function.\n     */\n    function _solvencyAssert() internal view {\n        uint256 _totalVaultValue = IVault(vaultAddress).totalValue();\n        uint256 _totalOethbSupply = IERC20(OETHb).totalSupply();\n\n        if (\n            _totalVaultValue.divPrecisely(_totalOethbSupply) <\n            SOLVENCY_THRESHOLD\n        ) {\n            revert(\"Protocol insolvent\");\n        }\n    }\n\n    /**\n     * @dev Decrease partial or all liquidity from the pool.\n     * @param _liquidityToDecrease The amount of liquidity to remove expressed in 18 decimal point\n     */\n    function _removeLiquidity(uint256 _liquidityToDecrease)\n        internal\n        gaugeUnstakeAndRestake\n    {\n        require(_liquidityToDecrease > 0, \"Must remove some liquidity\");\n\n        uint128 _liquidity = _getLiquidity();\n        // need to convert to uint256 since intermittent result is to big for uint128 to handle\n        uint128 _liqudityToRemove = uint256(_liquidity)\n            .mulTruncate(_liquidityToDecrease)\n            .toUint128();\n\n        /**\n         * There is no liquidity to remove -> exit function early. This can happen after a\n         * withdraw/withdrawAll removes all of the liquidity while retaining the NFT token.\n         */\n        if (_liquidity == 0 || _liqudityToRemove == 0) {\n            return;\n        }\n\n        (uint256 _amountWeth, uint256 _amountOethb) = positionManager\n            .decreaseLiquidity(\n                // Both expected amounts can be 0 since we don't really care if any swaps\n                // happen just before the liquidity removal.\n                INonfungiblePositionManager.DecreaseLiquidityParams({\n                    tokenId: tokenId,\n                    liquidity: _liqudityToRemove,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    deadline: block.timestamp\n                })\n            );\n\n        (\n            uint256 _amountWethCollected,\n            uint256 _amountOethbCollected\n        ) = positionManager.collect(\n                INonfungiblePositionManager.CollectParams({\n                    tokenId: tokenId,\n                    recipient: address(this),\n                    amount0Max: type(uint128).max, // defaults to all tokens owed\n                    amount1Max: type(uint128).max // defaults to all tokens owed\n                })\n            );\n\n        _updateUnderlyingAssets();\n\n        emit LiquidityRemoved(\n            _liquidityToDecrease,\n            _amountWeth, //removedWethAmount\n            _amountOethb, //removedOethbAmount\n            _amountWethCollected,\n            _amountOethbCollected,\n            underlyingAssets\n        );\n    }\n\n    /**\n     * @dev Perform a swap so that after the swap the ticker has the desired WETH to OETHb token share.\n     */\n    function _swapToDesiredPosition(\n        uint256 _amountToSwap,\n        bool _swapWeth,\n        uint256 _minTokenReceived\n    ) internal {\n        IERC20 _tokenToSwap = IERC20(_swapWeth ? WETH : OETHb);\n        uint256 _balance = _tokenToSwap.balanceOf(address(this));\n\n        if (_balance < _amountToSwap) {\n            if (_swapWeth) {\n                revert NotEnoughWethForSwap(_balance, _amountToSwap);\n            }\n            // if swapping OETHb\n            uint256 mintForSwap = _amountToSwap - _balance;\n            IVault(vaultAddress).mintForStrategy(mintForSwap);\n        }\n\n        // Swap it\n        swapRouter.exactInputSingle(\n            // sqrtPriceLimitX96 is just a rough sanity check that we are within 0 -> 1 tick\n            // a more fine check is performed in _checkForExpectedPoolPrice\n            // Note: this needs further work if we want to generalize this approach\n            ISwapRouter.ExactInputSingleParams({\n                tokenIn: address(_tokenToSwap),\n                tokenOut: _swapWeth ? OETHb : WETH,\n                tickSpacing: tickSpacing, // set to 1\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountIn: _amountToSwap,\n                amountOutMinimum: _minTokenReceived, // slippage check\n                sqrtPriceLimitX96: _swapWeth\n                    ? sqrtRatioX96TickLower\n                    : sqrtRatioX96TickHigher\n            })\n        );\n    }\n\n    /**\n     * @dev Add liquidity into the pool in the pre-configured WETH to OETHb share ratios\n     * defined by the allowedPoolWethShareStart|End interval. This function will respect\n     * liquidity ratios when there no liquidity yet in the pool. If liquidity is already\n     * present then it relies on the `_swapToDesiredPosition` function in a step before\n     * to already move the trading price to desired position (with some tolerance).\n     */\n    // rebalance already has re-entrency checks\n    // slither-disable-start reentrancy-no-eth\n    function _addLiquidity() internal gaugeUnstakeAndRestake {\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        uint256 _oethbBalance = IERC20(OETHb).balanceOf(address(this));\n        require(_wethBalance > 0, \"Must add some WETH\");\n\n        uint160 _currentPrice = getPoolX96Price();\n        /**\n         * Sanity check active trading price is positioned within our desired tick.\n         *\n         * We revert when price is equal to the lower tick even though that is still\n         * a valid amount in regards to ticker position by Sugar.estimateAmount call.\n         * Current price equaling tick bound at the 1:1 price parity results in\n         * uint overfow when calculating the OETHb balance to deposit.\n         */\n        if (\n            _currentPrice <= sqrtRatioX96TickLower ||\n            _currentPrice >= sqrtRatioX96TickHigher\n        ) {\n            revert OutsideExpectedTickRange(getCurrentTradingTick());\n        }\n\n        /**\n         * If estimateAmount1 call fails it could be due to _currentPrice being really\n         * close to a tick and amount1 is a larger number than the sugar helper is able\n         * to compute.\n         *\n         * If token addresses were reversed estimateAmount0 would be required here\n         */\n        uint256 _oethbRequired = helper.estimateAmount1(\n            _wethBalance,\n            address(0), // no need to pass pool address when current price is specified\n            _currentPrice,\n            lowerTick,\n            upperTick\n        );\n\n        if (_oethbRequired > _oethbBalance) {\n            IVault(vaultAddress).mintForStrategy(\n                _oethbRequired - _oethbBalance\n            );\n        }\n\n        uint256 _wethAmountSupplied;\n        uint256 _oethbAmountSupplied;\n        if (tokenId == 0) {\n            (\n                tokenId,\n                ,\n                _wethAmountSupplied,\n                _oethbAmountSupplied\n            ) = positionManager.mint(\n                /** amount0Min & amount1Min are left at 0 because slippage protection is ensured by the\n                 * _checkForExpectedPoolPrice\n                 *\n                 * Also sqrtPriceX96 is 0 because the pool is already created\n                 * non zero amount attempts to create a new instance of the pool\n                 */\n                INonfungiblePositionManager.MintParams({\n                    token0: WETH,\n                    token1: OETHb,\n                    tickSpacing: tickSpacing,\n                    tickLower: lowerTick,\n                    tickUpper: upperTick,\n                    amount0Desired: _wethBalance,\n                    amount1Desired: _oethbRequired,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    recipient: address(this),\n                    deadline: block.timestamp,\n                    sqrtPriceX96: 0\n                })\n            );\n        } else {\n            (, _wethAmountSupplied, _oethbAmountSupplied) = positionManager\n                .increaseLiquidity(\n                    /** amount0Min & amount1Min are left at 0 because slippage protection is ensured by the\n                     * _checkForExpectedPoolPrice\n                     */\n                    INonfungiblePositionManager.IncreaseLiquidityParams({\n                        tokenId: tokenId,\n                        amount0Desired: _wethBalance,\n                        amount1Desired: _oethbRequired,\n                        amount0Min: 0,\n                        amount1Min: 0,\n                        deadline: block.timestamp\n                    })\n                );\n        }\n\n        _updateUnderlyingAssets();\n        emit LiquidityAdded(\n            _wethBalance, // wethAmountDesired\n            _oethbRequired, // oethbAmountDesired\n            _wethAmountSupplied, // wethAmountSupplied\n            _oethbAmountSupplied, // oethbAmountSupplied\n            tokenId, // tokenId\n            underlyingAssets\n        );\n\n        // burn remaining OETHb\n        _burnOethbOnTheContract();\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /**\n     * @dev Check that the Aerodrome pool price is within the expected\n     *      parameters.\n     *      This function works whether the strategy contract has liquidity\n     *      position in the pool or not.\n     */\n    function _checkForExpectedPoolPrice() internal {\n        require(\n            allowedWethShareStart != 0 && allowedWethShareEnd != 0,\n            \"Weth share interval not set\"\n        );\n\n        uint160 _currentPrice = getPoolX96Price();\n\n        /**\n         * First check we are in expected tick range\n         *\n         * We revert even though price being equal to the lower tick would still\n         * count being within lower tick for the purpose of Sugar.estimateAmount calls\n         */\n        if (\n            _currentPrice <= sqrtRatioX96TickLower ||\n            _currentPrice >= sqrtRatioX96TickHigher\n        ) {\n            revert OutsideExpectedTickRange(getCurrentTradingTick());\n        }\n\n        /**\n         * If estimateAmount1 call fails it could be due to _currentPrice being really\n         * close to a tick and amount1 too big to compute.\n         *\n         * If token addresses were reversed estimateAmount0 would be required here\n         */\n        uint256 _normalizedWethAmount = 1 ether;\n        uint256 _correspondingOethAmount = helper.estimateAmount1(\n            _normalizedWethAmount,\n            address(0), // no need to pass pool address when current price is specified\n            _currentPrice,\n            lowerTick,\n            upperTick\n        );\n\n        // 18 decimal number expressed weth tick share\n        uint256 _wethSharePct = _normalizedWethAmount.divPrecisely(\n            _normalizedWethAmount + _correspondingOethAmount\n        );\n\n        if (\n            _wethSharePct < allowedWethShareStart ||\n            _wethSharePct > allowedWethShareEnd\n        ) {\n            revert PoolRebalanceOutOfBounds(\n                _wethSharePct,\n                allowedWethShareStart,\n                allowedWethShareEnd\n            );\n        }\n        emit PoolRebalanced(_wethSharePct);\n    }\n\n    /**\n     * Burns any OETHb tokens remaining on the strategy contract\n     */\n    function _burnOethbOnTheContract() internal {\n        uint256 _oethbBalance = IERC20(OETHb).balanceOf(address(this));\n        if (_oethbBalance > 0) {\n            IVault(vaultAddress).burnForStrategy(_oethbBalance);\n        }\n    }\n\n    /// @dev This function assumes there are no uncollected tokens in the clPool owned by the strategy contract.\n    ///      For that reason any liquidity withdrawals must also collect the tokens.\n    function _updateUnderlyingAssets() internal {\n        if (tokenId == 0) {\n            underlyingAssets = 0;\n            emit UnderlyingAssetsUpdated(underlyingAssets);\n            return;\n        }\n\n        uint128 _liquidity = _getLiquidity();\n\n        /**\n         * Our net value represent the smallest amount of tokens we are able to extract from the position\n         * given our liquidity.\n         *\n         * The least amount of tokens extraditable from the position is where the active trading price is\n         * at the ticker 0 meaning the pool is offering 1:1 trades between WETH & OETHb. At that moment the pool\n         * consists completely of OETHb and no WETH.\n         *\n         * The more swaps from WETH -> OETHb happen on the pool the more the price starts to move towards the -1\n         * ticker making OETHb (priced in WETH) more expensive.\n         *\n         * An additional note: when liquidity is 0 then the helper returns 0 for both token amounts. And the\n         * function set underlying assets to 0.\n         */\n        (uint256 _wethAmount, uint256 _oethbAmount) = helper\n            .getAmountsForLiquidity(\n                sqrtRatioX96TickClosestToParity, // sqrtRatioX96\n                sqrtRatioX96TickLower, // sqrtRatioAX96\n                sqrtRatioX96TickHigher, // sqrtRatioBX96\n                _liquidity\n            );\n\n        require(_wethAmount == 0, \"Non zero wethAmount\");\n        underlyingAssets = _oethbAmount;\n        emit UnderlyingAssetsUpdated(underlyingAssets);\n    }\n\n    /**\n     * @notice Withdraw an `amount` of assets from the platform and\n     *         send to the `_recipient`.\n     * @param _recipient  Address to which the asset should be sent\n     * @param _asset      WETH address\n     * @param _amount     Amount of WETH to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_asset == WETH, \"Unsupported asset\");\n        require(_recipient == vaultAddress, \"Only withdraw to vault allowed\");\n\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        if (_wethBalance < _amount) {\n            require(tokenId != 0, \"No liquidity available\");\n            uint256 _additionalWethRequired = _amount - _wethBalance;\n            (uint256 _wethInThePool, ) = getPositionPrincipal();\n\n            if (_wethInThePool < _additionalWethRequired) {\n                revert NotEnoughWethLiquidity(\n                    _wethInThePool,\n                    _additionalWethRequired\n                );\n            }\n\n            uint256 shareOfWethToRemove = Math.min(\n                _additionalWethRequired.divPrecisely(_wethInThePool) + 1,\n                1e18\n            );\n            _removeLiquidity(shareOfWethToRemove);\n        }\n\n        // burn remaining OETHb\n        _burnOethbOnTheContract();\n        _withdraw(_recipient, _amount);\n    }\n\n    /**\n     * @notice Withdraw WETH and sends it to the Vault.\n     */\n    function withdrawAll() external override onlyVault nonReentrant {\n        if (tokenId != 0) {\n            _removeLiquidity(1e18);\n        }\n\n        uint256 _balance = IERC20(WETH).balanceOf(address(this));\n        if (_balance > 0) {\n            _withdraw(vaultAddress, _balance);\n        }\n        // burn remaining OETHb\n        _burnOethbOnTheContract();\n    }\n\n    function _withdraw(address _recipient, uint256 _amount) internal {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient == vaultAddress, \"Only withdraw to vault allowed\");\n\n        IERC20(WETH).safeTransfer(_recipient, _amount);\n        emit Withdrawal(WETH, address(0), _amount);\n    }\n\n    /**\n     * @dev Collect the AERO token from the gauge\n     */\n    function _collectRewardTokens() internal override {\n        if (tokenId != 0 && _isLpTokenStakedInGauge()) {\n            clGauge.getReward(tokenId);\n        }\n        super._collectRewardTokens();\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == WETH;\n    }\n\n    /**\n     * @dev Approve the spending of all assets\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        // to add liquidity to the clPool\n        IERC20(WETH).safeApprove(address(positionManager), type(uint256).max);\n        IERC20(OETHb).safeApprove(address(positionManager), type(uint256).max);\n        // to be able to rebalance using the swapRouter\n        IERC20(WETH).safeApprove(address(swapRouter), type(uint256).max);\n        IERC20(OETHb).safeApprove(address(swapRouter), type(uint256).max);\n    }\n\n    /***************************************\n            Balances and Fees\n    ****************************************/\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(_asset == WETH, \"Only WETH supported\");\n\n        // we could in theory deposit to the strategy and forget to call rebalance in the same\n        // governance transaction batch. In that case the WETH that is on the strategy contract\n        // also needs to be accounted for.\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        // just paranoia check, in case there is OETHb in the strategy that for some reason hasn't\n        // been burned yet.\n        uint256 _oethbBalance = IERC20(OETHb).balanceOf(address(this));\n        return underlyingAssets + _wethBalance + _oethbBalance;\n    }\n\n    /**\n     * @dev Returns the balance of both tokens in a given position (excluding fees)\n     * @return _amountWeth Amount of WETH in position\n     * @return _amountOethb Amount of OETHb in position\n     */\n    function getPositionPrincipal()\n        public\n        view\n        returns (uint256 _amountWeth, uint256 _amountOethb)\n    {\n        if (tokenId == 0) {\n            return (0, 0);\n        }\n\n        uint160 _sqrtRatioX96 = getPoolX96Price();\n        (_amountWeth, _amountOethb) = helper.principal(\n            positionManager,\n            tokenId,\n            _sqrtRatioX96\n        );\n    }\n\n    /**\n     * @notice Returns the current pool price in X96 format\n     * @return _sqrtRatioX96 Pool price\n     */\n    function getPoolX96Price() public view returns (uint160 _sqrtRatioX96) {\n        (_sqrtRatioX96, , , , , ) = clPool.slot0();\n    }\n\n    /**\n     * @notice Returns the current active trading tick of the underlying pool\n     * @return _currentTick Current pool trading tick\n     */\n    function getCurrentTradingTick() public view returns (int24 _currentTick) {\n        (, _currentTick, , , , ) = clPool.slot0();\n    }\n\n    /**\n     * @notice Returns the amount of liquidity in the contract's LP position\n     * @return _liquidity Amount of liquidity in the position\n     */\n    function _getLiquidity() internal view returns (uint128 _liquidity) {\n        if (tokenId == 0) {\n            revert(\"No LP position\");\n        }\n\n        (, , , , , , , _liquidity, , , , ) = positionManager.positions(tokenId);\n    }\n\n    /***************************************\n            Hidden functions\n    ****************************************/\n    /// @inheritdoc InitializableAbstractStrategy\n    function setPTokenAddress(address, address) external override {\n        // The pool tokens can never change.\n        revert(\"Unsupported method\");\n    }\n\n    /// @inheritdoc InitializableAbstractStrategy\n    function removePToken(uint256) external override {\n        // The pool tokens can never change.\n        revert(\"Unsupported method\");\n    }\n\n    /**\n     * @dev Not supported\n     */\n    function _abstractSetPToken(address, address) internal override {\n        // the deployer shall call safeApproveAllTokens() to set necessary approvals\n        revert(\"Unsupported method\");\n    }\n\n    /***************************************\n            ERC721 management\n    ****************************************/\n\n    /// @notice Callback function for whenever a NFT is transferred to this contract\n    //  solhint-disable-next-line max-line-length\n    /// Ref: https://docs.openzeppelin.com/contracts/3.x/api/token/erc721#IERC721Receiver-onERC721Received-address-address-uint256-bytes-\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/strategies/balancer/AbstractAuraStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OETH Base Balancer Abstract Strategy\n * @author Origin Protocol Inc\n */\n\nimport { AbstractBalancerStrategy } from \"./AbstractBalancerStrategy.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { IERC4626 } from \"../../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\nimport { IRewardStaking } from \"../IRewardStaking.sol\";\n\nabstract contract AbstractAuraStrategy is AbstractBalancerStrategy {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    /// @notice Address of the Aura rewards pool\n    address public immutable auraRewardPoolAddress;\n\n    // renamed from __reserved to not shadow AbstractBalancerStrategy.__reserved,\n    int256[50] private __reserved_baseAuraStrategy;\n\n    constructor(address _auraRewardPoolAddress) {\n        auraRewardPoolAddress = _auraRewardPoolAddress;\n    }\n\n    /**\n     * @dev Deposit all Balancer Pool Tokens (BPT) in this strategy contract\n     * to the Aura rewards pool.\n     */\n    function _lpDepositAll() internal virtual override {\n        uint256 bptBalance = IERC20(platformAddress).balanceOf(address(this));\n        uint256 auraLp = IERC4626(auraRewardPoolAddress).deposit(\n            bptBalance,\n            address(this)\n        );\n        require(bptBalance == auraLp, \"Aura LP != BPT\");\n    }\n\n    /**\n     * @dev Withdraw `numBPTTokens` Balancer Pool Tokens (BPT) from\n     * the Aura rewards pool to this strategy contract.\n     * @param numBPTTokens Number of Balancer Pool Tokens (BPT) to withdraw\n     */\n    function _lpWithdraw(uint256 numBPTTokens) internal virtual override {\n        IRewardStaking(auraRewardPoolAddress).withdrawAndUnwrap(\n            numBPTTokens,\n            true // also claim reward tokens\n        );\n    }\n\n    /**\n     * @dev Withdraw all Balancer Pool Tokens (BPT) from\n     * the Aura rewards pool to this strategy contract.\n     */\n    function _lpWithdrawAll() internal virtual override {\n        // Get all the strategy's BPTs in Aura\n        // maxRedeem is implemented as balanceOf(address) in Aura\n        uint256 bptBalance = IERC4626(auraRewardPoolAddress).maxRedeem(\n            address(this)\n        );\n\n        IRewardStaking(auraRewardPoolAddress).withdrawAndUnwrap(\n            bptBalance,\n            true // also claim reward tokens\n        );\n    }\n\n    /**\n     * @notice Collects BAL and AURA tokens from the rewards pool.\n     */\n    function collectRewardTokens()\n        external\n        virtual\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        /* Similar to Convex, calling this function collects both of the\n         * accrued BAL and AURA tokens.\n         */\n        IRewardStaking(auraRewardPoolAddress).getReward();\n        _collectRewardTokens();\n    }\n\n    /// @notice Balancer Pool Tokens (BPT) in the Balancer pool and the Aura rewards pool.\n    function _getBalancerPoolTokens()\n        internal\n        view\n        override\n        returns (uint256 balancerPoolTokens)\n    {\n        balancerPoolTokens =\n            IERC20(platformAddress).balanceOf(address(this)) +\n            // maxRedeem is implemented as balanceOf(address) in Aura\n            IERC4626(auraRewardPoolAddress).maxRedeem(address(this));\n    }\n\n    function _approveBase() internal virtual override {\n        super._approveBase();\n\n        IERC20 pToken = IERC20(platformAddress);\n        pToken.safeApprove(auraRewardPoolAddress, type(uint256).max);\n    }\n}\n"
    },
    "contracts/strategies/balancer/AbstractBalancerStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OETH Balancer Abstract Strategy\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { IBalancerVault } from \"../../interfaces/balancer/IBalancerVault.sol\";\nimport { IRateProvider } from \"../../interfaces/balancer/IRateProvider.sol\";\nimport { VaultReentrancyLib } from \"./VaultReentrancyLib.sol\";\nimport { IOracle } from \"../../interfaces/IOracle.sol\";\nimport { IWstETH } from \"../../interfaces/IWstETH.sol\";\nimport { IERC4626 } from \"../../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\n\nabstract contract AbstractBalancerStrategy is InitializableAbstractStrategy {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    address public immutable rETH;\n    address public immutable stETH;\n    address public immutable wstETH;\n    address public immutable frxETH;\n    address public immutable sfrxETH;\n\n    /// @notice Address of the Balancer vault\n    IBalancerVault public immutable balancerVault;\n    /// @notice Balancer pool identifier\n    bytes32 public immutable balancerPoolId;\n\n    // Max withdrawal deviation denominated in 1e18 (1e18 == 100%)\n    uint256 public maxWithdrawalDeviation;\n    // Max deposit deviation denominated in 1e18 (1e18 == 100%)\n    uint256 public maxDepositDeviation;\n\n    int256[48] private __reserved;\n\n    struct BaseBalancerConfig {\n        address rEthAddress; // Address of the rETH token\n        address stEthAddress; // Address of the stETH token\n        address wstEthAddress; // Address of the wstETH token\n        address frxEthAddress; // Address of the frxEth token\n        address sfrxEthAddress; // Address of the sfrxEth token\n        address balancerVaultAddress; // Address of the Balancer vault\n        bytes32 balancerPoolId; // Balancer pool identifier\n    }\n\n    event MaxWithdrawalDeviationUpdated(\n        uint256 _prevMaxDeviationPercentage,\n        uint256 _newMaxDeviationPercentage\n    );\n    event MaxDepositDeviationUpdated(\n        uint256 _prevMaxDeviationPercentage,\n        uint256 _newMaxDeviationPercentage\n    );\n\n    /**\n     * @dev Ensure we are not in a Vault context when this function is called, by attempting a no-op internal\n     * balance operation. If we are already in a Vault transaction (e.g., a swap, join, or exit), the Vault's\n     * reentrancy protection will cause this function to revert.\n     *\n     * Use this modifier with any function that can cause a state change in a pool and is either public itself,\n     * or called by a public function *outside* a Vault operation (e.g., join, exit, or swap).\n     *\n     * This is to protect against Balancer's read-only re-entrancy vulnerability:\n     * https://www.notion.so/originprotocol/Balancer-read-only-reentrancy-c686e72c82414ef18fa34312bb02e11b\n     */\n    modifier whenNotInBalancerVaultContext() {\n        VaultReentrancyLib.ensureNotInVaultContext(balancerVault);\n        _;\n    }\n\n    constructor(BaseBalancerConfig memory _balancerConfig) {\n        rETH = _balancerConfig.rEthAddress;\n        stETH = _balancerConfig.stEthAddress;\n        wstETH = _balancerConfig.wstEthAddress;\n        frxETH = _balancerConfig.frxEthAddress;\n        sfrxETH = _balancerConfig.sfrxEthAddress;\n\n        balancerVault = IBalancerVault(_balancerConfig.balancerVaultAddress);\n        balancerPoolId = _balancerConfig.balancerPoolId;\n    }\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Balancer's strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Address of BAL & AURA\n     * @param _assets Addresses of supported assets. MUST be passed in the same\n     *                order as returned by coins on the pool contract, i.e.\n     *                WETH, stETH\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // BAL & AURA\n        address[] calldata _assets,\n        address[] calldata _pTokens\n    ) external onlyGovernor initializer {\n        maxWithdrawalDeviation = 1e16;\n        maxDepositDeviation = 1e16;\n\n        emit MaxWithdrawalDeviationUpdated(0, maxWithdrawalDeviation);\n        emit MaxDepositDeviationUpdated(0, maxDepositDeviation);\n\n        IERC20[] memory poolAssets = _getPoolAssets();\n        require(\n            poolAssets.length == _assets.length,\n            \"Pool assets length mismatch\"\n        );\n        for (uint256 i = 0; i < _assets.length; ++i) {\n            address asset = _fromPoolAsset(address(poolAssets[i]));\n            require(_assets[i] == asset, \"Pool assets mismatch\");\n        }\n\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n        _approveBase();\n    }\n\n    /**\n     * @notice Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @notice Get strategy's share of an assets in the Balancer pool.\n     * This is not denominated in OUSD/ETH value of the assets in the Balancer pool.\n     * @param _asset  Address of the Vault collateral asset\n     * @return amount  the amount of vault collateral assets\n     *\n     * IMPORTANT if this function is overridden it needs to have a whenNotInBalancerVaultContext\n     * modifier on it or it is susceptible to read-only re-entrancy attack\n     *\n     * @dev it is important that this function is not affected by reporting inflated\n     * values of assets in case of any pool manipulation. Such a manipulation could easily\n     * exploit the protocol by:\n     *  - minting OETH\n     *  - tilting Balancer pool to report higher balances of assets\n     *  - rebasing() -> all that extra token balances get distributed to OETH holders\n     *  - tilting pool back\n     *  - redeeming OETH\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        virtual\n        override\n        whenNotInBalancerVaultContext\n        returns (uint256 amount)\n    {\n        require(assetToPToken[_asset] != address(0), \"Unsupported asset\");\n\n        uint256 bptBalance = _getBalancerPoolTokens();\n\n        /* To calculate the worth of queried asset:\n         *  - assume that all tokens normalized to their ETH value have an equal split balance\n         *    in the pool when it is balanced\n         *  - multiply the BPT amount with the bpt rate to get the ETH denominated amount\n         *    of strategy's holdings\n         *  - divide that by the number of tokens we support in the pool to get ETH denominated\n         *    amount that is applicable to each supported token in the pool.\n         *\n         *    It would be possible to support only 1 asset in the pool (and be exposed to all\n         *    the assets while holding BPT tokens) and deposit/withdraw/checkBalance using only\n         *    that asset. TBD: changes to other functions still required if we ever decide to\n         *    go with such configuration.\n         */\n        amount = (bptBalance.mulTruncate(\n            IRateProvider(platformAddress).getRate()\n        ) / assetsMapped.length);\n\n        /* If the pool asset is equal to (strategy )_asset it means that a rate\n         * provider for that asset exists and that asset is not necessarily\n         * pegged to a unit (ETH).\n         *\n         * Because this function returns the balance of the asset and is not denominated in\n         * ETH units we need to convert the ETH denominated amount to asset amount.\n         */\n        if (_toPoolAsset(_asset) == _asset) {\n            amount = amount.divPrecisely(_getRateProviderRate(_asset));\n        }\n    }\n\n    /**\n     * @notice Returns the value of all assets managed by this strategy.\n     * Uses the Balancer pool's rate (virtual price) to convert the strategy's\n     * Balancer Pool Tokens (BPT) to ETH value.\n     * @return value The ETH value\n     *\n     * IMPORTANT if this function is overridden it needs to have a whenNotInBalancerVaultContext\n     * modifier on it or it is susceptible to read-only re-entrancy attack\n     */\n    function checkBalance()\n        external\n        view\n        virtual\n        whenNotInBalancerVaultContext\n        returns (uint256 value)\n    {\n        uint256 bptBalance = _getBalancerPoolTokens();\n\n        // Convert BPT to ETH value\n        value = bptBalance.mulTruncate(\n            IRateProvider(platformAddress).getRate()\n        );\n    }\n\n    /// @notice Balancer Pool Tokens (BPT) in the Balancer pool.\n    function _getBalancerPoolTokens()\n        internal\n        view\n        virtual\n        returns (uint256 balancerPoolTokens)\n    {\n        balancerPoolTokens = IERC20(platformAddress).balanceOf(address(this));\n    }\n\n    /* solhint-disable max-line-length */\n    /**\n     * @notice BPT price is calculated by taking the rate from the rateProvider of the asset in\n     * question. If one does not exist it defaults to 1e18. To get the final BPT expected that\n     * is multiplied by the underlying asset amount divided by BPT token rate. BPT token rate is\n     * similar to Curve's virtual_price and expresses how much has the price of BPT appreciated\n     * (e.g. due to swap fees) in relation to the underlying assets\n     *\n     * Using the above approach makes the strategy vulnerable to a possible MEV attack using\n     * flash loan to manipulate the pool before a deposit/withdrawal since the function ignores\n     * market values of the assets being priced in BPT.\n     *\n     * At the time of writing there is no safe on-chain approach to pricing BPT in a way that it\n     * would make it invulnerable to MEV pool manipulation. See recent Balancer exploit:\n     * https://www.notion.so/originprotocol/Balancer-OETH-strategy-9becdea132704e588782a919d7d471eb?pvs=4#1cf07de12fc64f1888072321e0644348\n     *\n     * To mitigate MEV possibilities during deposits and withdraws, the VaultValueChecker will use checkBalance before and after the move\n     * to ensure the expected changes took place.\n     *\n     * @param _asset Address of the Balancer pool asset\n     * @param _amount Amount of the Balancer pool asset\n     * @return bptExpected of BPT expected in exchange for the asset\n     *\n     * @dev\n     * bptAssetPrice = 1e18 (asset peg) * pool_asset_rate\n     *\n     * bptExpected = bptAssetPrice * asset_amount / BPT_token_rate\n     *\n     * bptExpected = 1e18 (asset peg) * pool_asset_rate * asset_amount / BPT_token_rate\n     * bptExpected = asset_amount * pool_asset_rate / BPT_token_rate\n     *\n     * further information available here:\n     * https://www.notion.so/originprotocol/Balancer-OETH-strategy-9becdea132704e588782a919d7d471eb?pvs=4#ce01495ae70346d8971f5dced809fb83\n     */\n    /* solhint-enable max-line-length */\n    function _getBPTExpected(address _asset, uint256 _amount)\n        internal\n        view\n        virtual\n        returns (uint256 bptExpected)\n    {\n        uint256 bptRate = IRateProvider(platformAddress).getRate();\n        uint256 poolAssetRate = _getRateProviderRate(_asset);\n        bptExpected = _amount.mulTruncate(poolAssetRate).divPrecisely(bptRate);\n    }\n\n    function _getBPTExpected(\n        address[] memory _assets,\n        uint256[] memory _amounts\n    ) internal view virtual returns (uint256 bptExpected) {\n        require(_assets.length == _amounts.length, \"Assets & amounts mismatch\");\n\n        for (uint256 i = 0; i < _assets.length; ++i) {\n            uint256 poolAssetRate = _getRateProviderRate(_assets[i]);\n            // convert asset amount to ETH amount\n            bptExpected += _amounts[i].mulTruncate(poolAssetRate);\n        }\n\n        uint256 bptRate = IRateProvider(platformAddress).getRate();\n        // Convert ETH amount to BPT amount\n        bptExpected = bptExpected.divPrecisely(bptRate);\n    }\n\n    function _lpDepositAll() internal virtual;\n\n    function _lpWithdraw(uint256 numBPTTokens) internal virtual;\n\n    function _lpWithdrawAll() internal virtual;\n\n    /**\n     * @notice Balancer returns assets and rateProviders for corresponding assets ordered\n     * by numerical order.\n     */\n    function _getPoolAssets() internal view returns (IERC20[] memory assets) {\n        // slither-disable-next-line unused-return\n        (assets, , ) = balancerVault.getPoolTokens(balancerPoolId);\n    }\n\n    /**\n     * @dev If an asset is rebasing the Balancer pools have a wrapped versions of assets\n     * that the strategy supports. This function converts the pool(wrapped) asset\n     * and corresponding amount to strategy asset.\n     */\n    function _toPoolAsset(address asset, uint256 amount)\n        internal\n        view\n        returns (address poolAsset, uint256 poolAmount)\n    {\n        if (asset == stETH) {\n            poolAsset = wstETH;\n            if (amount > 0) {\n                poolAmount = IWstETH(wstETH).getWstETHByStETH(amount);\n            }\n        } else if (asset == frxETH) {\n            poolAsset = sfrxETH;\n            if (amount > 0) {\n                poolAmount = IERC4626(sfrxETH).convertToShares(amount);\n            }\n        } else {\n            poolAsset = asset;\n            poolAmount = amount;\n        }\n    }\n\n    /**\n     * @dev Converts a Vault collateral asset to a Balancer pool asset.\n     * stETH becomes wstETH, frxETH becomes sfrxETH and everything else stays the same.\n     * @param asset Address of the Vault collateral asset.\n     * @return Address of the Balancer pool asset.\n     */\n    function _toPoolAsset(address asset) internal view returns (address) {\n        if (asset == stETH) {\n            return wstETH;\n        } else if (asset == frxETH) {\n            return sfrxETH;\n        }\n        return asset;\n    }\n\n    /**\n     * @dev Converts rebasing asset to its wrapped counterpart.\n     */\n    function _wrapPoolAsset(address asset, uint256 amount)\n        internal\n        returns (address wrappedAsset, uint256 wrappedAmount)\n    {\n        if (asset == stETH) {\n            wrappedAsset = wstETH;\n            if (amount > 0) {\n                wrappedAmount = IWstETH(wstETH).wrap(amount);\n            }\n        } else if (asset == frxETH) {\n            wrappedAsset = sfrxETH;\n            if (amount > 0) {\n                wrappedAmount = IERC4626(sfrxETH).deposit(\n                    amount,\n                    address(this)\n                );\n            }\n        } else {\n            wrappedAsset = asset;\n            wrappedAmount = amount;\n        }\n    }\n\n    /**\n     * @dev Converts wrapped asset to its rebasing counterpart.\n     */\n    function _unwrapPoolAsset(address asset, uint256 amount)\n        internal\n        returns (uint256 unwrappedAmount)\n    {\n        if (asset == stETH) {\n            unwrappedAmount = IWstETH(wstETH).unwrap(amount);\n        } else if (asset == frxETH) {\n            unwrappedAmount = IERC4626(sfrxETH).withdraw(\n                amount,\n                address(this),\n                address(this)\n            );\n        } else {\n            unwrappedAmount = amount;\n        }\n    }\n\n    /**\n     * @dev If an asset is rebasing the Balancer pools have a wrapped versions of assets\n     * that the strategy supports. This function converts the rebasing strategy asset\n     * and corresponding amount to wrapped(pool) asset.\n     */\n    function _fromPoolAsset(address poolAsset, uint256 poolAmount)\n        internal\n        view\n        returns (address asset, uint256 amount)\n    {\n        if (poolAsset == wstETH) {\n            asset = stETH;\n            if (poolAmount > 0) {\n                amount = IWstETH(wstETH).getStETHByWstETH(poolAmount);\n            }\n        } else if (poolAsset == sfrxETH) {\n            asset = frxETH;\n            if (poolAmount > 0) {\n                amount = IERC4626(sfrxETH).convertToAssets(poolAmount);\n            }\n        } else {\n            asset = poolAsset;\n            amount = poolAmount;\n        }\n    }\n\n    function _fromPoolAsset(address poolAsset)\n        internal\n        view\n        returns (address asset)\n    {\n        if (poolAsset == wstETH) {\n            asset = stETH;\n        } else if (poolAsset == sfrxETH) {\n            asset = frxETH;\n        } else {\n            asset = poolAsset;\n        }\n    }\n\n    /**\n     * @notice Sets max withdrawal deviation that is considered when removing\n     * liquidity from Balancer pools.\n     * @param _maxWithdrawalDeviation Max withdrawal deviation denominated in\n     *        wad (number with 18 decimals): 1e18 == 100%, 1e16 == 1%\n     *\n     * IMPORTANT Minimum maxWithdrawalDeviation will be 1% (1e16) for production\n     * usage. Vault value checker in combination with checkBalance will\n     * catch any unexpected manipulation.\n     */\n    function setMaxWithdrawalDeviation(uint256 _maxWithdrawalDeviation)\n        external\n        onlyVaultOrGovernorOrStrategist\n    {\n        require(\n            _maxWithdrawalDeviation <= 1e18,\n            \"Withdrawal dev. out of bounds\"\n        );\n        emit MaxWithdrawalDeviationUpdated(\n            maxWithdrawalDeviation,\n            _maxWithdrawalDeviation\n        );\n        maxWithdrawalDeviation = _maxWithdrawalDeviation;\n    }\n\n    /**\n     * @notice Sets max deposit deviation that is considered when adding\n     * liquidity to Balancer pools.\n     * @param _maxDepositDeviation Max deposit deviation denominated in\n     *        wad (number with 18 decimals): 1e18 == 100%, 1e16 == 1%\n     *\n     * IMPORTANT Minimum maxDepositDeviation will default to 1% (1e16)\n     * for production usage. Vault value checker in combination with\n     * checkBalance will catch any unexpected manipulation.\n     */\n    function setMaxDepositDeviation(uint256 _maxDepositDeviation)\n        external\n        onlyVaultOrGovernorOrStrategist\n    {\n        require(_maxDepositDeviation <= 1e18, \"Deposit dev. out of bounds\");\n        emit MaxDepositDeviationUpdated(\n            maxDepositDeviation,\n            _maxDepositDeviation\n        );\n        maxDepositDeviation = _maxDepositDeviation;\n    }\n\n    function _approveBase() internal virtual {\n        IERC20 pToken = IERC20(platformAddress);\n        // Balancer vault for BPT token (required for removing liquidity)\n        pToken.safeApprove(address(balancerVault), type(uint256).max);\n    }\n\n    function _getRateProviderRate(address _asset)\n        internal\n        view\n        virtual\n        returns (uint256);\n}\n"
    },
    "contracts/strategies/balancer/BalancerMetaPoolStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OETH Balancer MetaStablePool Strategy\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { AbstractAuraStrategy, AbstractBalancerStrategy } from \"./AbstractAuraStrategy.sol\";\nimport { IBalancerVault } from \"../../interfaces/balancer/IBalancerVault.sol\";\nimport { IRateProvider } from \"../../interfaces/balancer/IRateProvider.sol\";\nimport { IMetaStablePool } from \"../../interfaces/balancer/IMetaStablePool.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\n\ncontract BalancerMetaPoolStrategy is AbstractAuraStrategy {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    constructor(\n        BaseStrategyConfig memory _stratConfig,\n        BaseBalancerConfig memory _balancerConfig,\n        address _auraRewardPoolAddress\n    )\n        InitializableAbstractStrategy(_stratConfig)\n        AbstractBalancerStrategy(_balancerConfig)\n        AbstractAuraStrategy(_auraRewardPoolAddress)\n    {}\n\n    /**\n     * @notice There are no plans to configure BalancerMetaPool as a default\n     * asset strategy. For that reason there is no need to support this\n     * functionality.\n     */\n    function deposit(address, uint256)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        revert(\"Not supported\");\n    }\n\n    /**\n     * @notice There are no plans to configure BalancerMetaPool as a default\n     * asset strategy. For that reason there is no need to support this\n     * functionality.\n     */\n    function deposit(address[] calldata, uint256[] calldata)\n        external\n        onlyVault\n        nonReentrant\n    {\n        revert(\"Not supported\");\n    }\n\n    /**\n     * @notice Deposits all supported assets in this strategy contract to the Balancer pool.\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 assetsLength = assetsMapped.length;\n        address[] memory strategyAssets = new address[](assetsLength);\n        uint256[] memory strategyAmounts = new uint256[](assetsLength);\n\n        // For each vault collateral asset\n        for (uint256 i = 0; i < assetsLength; ++i) {\n            strategyAssets[i] = assetsMapped[i];\n            // Get the asset balance in this strategy contract\n            strategyAmounts[i] = IERC20(strategyAssets[i]).balanceOf(\n                address(this)\n            );\n        }\n        _deposit(strategyAssets, strategyAmounts);\n    }\n\n    /*\n     * _deposit doesn't require a read-only re-entrancy protection since during the deposit\n     * the function enters the Balancer Vault Context. If this function were called as part of\n     * the attacking contract (while intercepting execution flow upon receiving ETH) the read-only\n     * protection of the Balancer Vault would be triggered. Since the attacking contract would\n     * already be in the Balancer Vault context and wouldn't be able to enter it again.\n     */\n    function _deposit(\n        address[] memory _strategyAssets,\n        uint256[] memory _strategyAmounts\n    ) internal {\n        require(\n            _strategyAssets.length == _strategyAmounts.length,\n            \"Array length missmatch\"\n        );\n\n        (IERC20[] memory tokens, , ) = balancerVault.getPoolTokens(\n            balancerPoolId\n        );\n\n        uint256[] memory strategyAssetAmountsToPoolAssetAmounts = new uint256[](\n            _strategyAssets.length\n        );\n        address[] memory strategyAssetsToPoolAssets = new address[](\n            _strategyAssets.length\n        );\n\n        for (uint256 i = 0; i < _strategyAssets.length; ++i) {\n            address strategyAsset = _strategyAssets[i];\n            uint256 strategyAmount = _strategyAmounts[i];\n\n            require(\n                assetToPToken[strategyAsset] != address(0),\n                \"Unsupported asset\"\n            );\n            strategyAssetsToPoolAssets[i] = _toPoolAsset(strategyAsset);\n\n            if (strategyAmount > 0) {\n                emit Deposit(strategyAsset, platformAddress, strategyAmount);\n\n                // wrap rebasing assets like stETH and frxETH to wstETH and sfrxETH\n                (, strategyAssetAmountsToPoolAssetAmounts[i]) = _wrapPoolAsset(\n                    strategyAsset,\n                    strategyAmount\n                );\n            }\n        }\n\n        uint256[] memory amountsIn = new uint256[](tokens.length);\n        address[] memory poolAssets = new address[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            // Convert IERC20 type to address\n            poolAssets[i] = address(tokens[i]);\n\n            // For each of the mapped assets\n            for (uint256 j = 0; j < strategyAssetsToPoolAssets.length; ++j) {\n                // If the pool asset is the same as the mapped asset\n                if (poolAssets[i] == strategyAssetsToPoolAssets[j]) {\n                    amountsIn[i] = strategyAssetAmountsToPoolAssetAmounts[j];\n                }\n            }\n        }\n\n        uint256 minBPT = _getBPTExpected(\n            strategyAssetsToPoolAssets,\n            strategyAssetAmountsToPoolAssetAmounts\n        );\n        uint256 minBPTwDeviation = minBPT.mulTruncate(\n            1e18 - maxDepositDeviation\n        );\n\n        /* EXACT_TOKENS_IN_FOR_BPT_OUT:\n         * User sends precise quantities of tokens, and receives an\n         * estimated but unknown (computed at run time) quantity of BPT.\n         *\n         * ['uint256', 'uint256[]', 'uint256']\n         * [EXACT_TOKENS_IN_FOR_BPT_OUT, amountsIn, minimumBPT]\n         */\n        bytes memory userData = abi.encode(\n            IBalancerVault.WeightedPoolJoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n            amountsIn,\n            minBPTwDeviation\n        );\n\n        IBalancerVault.JoinPoolRequest memory request = IBalancerVault\n            .JoinPoolRequest(poolAssets, amountsIn, userData, false);\n\n        // Add the pool assets in this strategy to the balancer pool\n        balancerVault.joinPool(\n            balancerPoolId,\n            address(this),\n            address(this),\n            request\n        );\n\n        // Deposit the Balancer Pool Tokens (BPT) into Aura\n        _lpDepositAll();\n    }\n\n    /**\n     * @notice Withdraw a Vault collateral asset from the Balancer pool.\n     * @param _recipient Address to receive the Vault collateral assets. Typically is the Vault.\n     * @param _strategyAsset Address of the Vault collateral asset\n     * @param _strategyAmount The amount of Vault collateral assets to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _strategyAsset,\n        uint256 _strategyAmount\n    ) external override onlyVault nonReentrant {\n        address[] memory strategyAssets = new address[](1);\n        uint256[] memory strategyAmounts = new uint256[](1);\n        strategyAssets[0] = _strategyAsset;\n        strategyAmounts[0] = _strategyAmount;\n\n        _withdraw(_recipient, strategyAssets, strategyAmounts);\n    }\n\n    /**\n     * @notice Withdraw multiple Vault collateral asset from the Balancer pool.\n     * @param _recipient Address to receive the Vault collateral assets. Typically is the Vault.\n     * @param _strategyAssets Addresses of the Vault collateral assets\n     * @param _strategyAmounts The amounts of Vault collateral assets to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address[] calldata _strategyAssets,\n        uint256[] calldata _strategyAmounts\n    ) external onlyVault nonReentrant {\n        _withdraw(_recipient, _strategyAssets, _strategyAmounts);\n    }\n\n    /**\n     * @dev Withdraw multiple Vault collateral asset from the Balancer pool.\n     * @param _recipient Address to receive the Vault collateral assets. Typically is the Vault.\n     * @param _strategyAssets Addresses of the Vault collateral assets\n     * @param _strategyAmounts The amounts of Vault collateral assets to withdraw\n     *\n     * _withdrawal doesn't require a read-only re-entrancy protection since during the withdrawal\n     * the function enters the Balancer Vault Context. If this function were called as part of\n     * the attacking contract (while intercepting execution flow upon receiving ETH) the read-only\n     * protection of the Balancer Vault would be triggered. Since the attacking contract would\n     * already be in the Balancer Vault context and wouldn't be able to enter it again.\n     */\n    function _withdraw(\n        address _recipient,\n        address[] memory _strategyAssets,\n        uint256[] memory _strategyAmounts\n    ) internal {\n        require(\n            _strategyAssets.length == _strategyAmounts.length,\n            \"Invalid input arrays\"\n        );\n\n        for (uint256 i = 0; i < _strategyAssets.length; ++i) {\n            require(\n                assetToPToken[_strategyAssets[i]] != address(0),\n                \"Unsupported asset\"\n            );\n        }\n\n        // STEP 1 - Calculate the Balancer pool assets and amounts from the vault collateral assets\n\n        // Get all the supported balancer pool assets\n        (IERC20[] memory tokens, , ) = balancerVault.getPoolTokens(\n            balancerPoolId\n        );\n        // Calculate the balancer pool assets and amounts to withdraw\n        uint256[] memory poolAssetsAmountsOut = new uint256[](tokens.length);\n        address[] memory poolAssets = new address[](tokens.length);\n        // Is the wrapped asset amount indexed by the assets array, not the order of the Balancer pool tokens\n        // eg wstETH and sfrxETH amounts, not the stETH and frxETH amounts\n        uint256[] memory strategyAssetsToPoolAssetsAmounts = new uint256[](\n            _strategyAssets.length\n        );\n\n        // For each of the Balancer pool assets\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            poolAssets[i] = address(tokens[i]);\n\n            // Convert the Balancer pool asset back to a vault collateral asset\n            address strategyAsset = _fromPoolAsset(poolAssets[i]);\n\n            // for each of the vault assets\n            for (uint256 j = 0; j < _strategyAssets.length; ++j) {\n                // If the vault asset equals the vault asset mapped from the Balancer pool asset\n                if (_strategyAssets[j] == strategyAsset) {\n                    (, poolAssetsAmountsOut[i]) = _toPoolAsset(\n                        strategyAsset,\n                        _strategyAmounts[j]\n                    );\n                    strategyAssetsToPoolAssetsAmounts[j] = poolAssetsAmountsOut[\n                        i\n                    ];\n\n                    /* Because of the potential Balancer rounding error mentioned below\n                     * the contract might receive 1-2 WEI smaller amount than required\n                     * in the withdraw user data encoding. If slightly lesser token amount\n                     * is received the strategy can not unwrap the pool asset as it is\n                     * smaller than expected.\n                     *\n                     * For that reason we `overshoot` the required tokens expected to\n                     * circumvent the error\n                     */\n                    if (poolAssetsAmountsOut[i] > 0) {\n                        poolAssetsAmountsOut[i] += 2;\n                    }\n                }\n            }\n        }\n\n        // STEP 2 - Calculate the max about of Balancer Pool Tokens (BPT) to withdraw\n\n        // Estimate the required amount of Balancer Pool Tokens (BPT) for the assets\n        uint256 maxBPTtoWithdraw = _getBPTExpected(\n            poolAssets,\n            /* all non 0 values are overshot by 2 WEI and with the expected mainnet\n             * ~1% withdrawal deviation, the 2 WEI aren't important\n             */\n            poolAssetsAmountsOut\n        );\n        // Increase BPTs by the max allowed deviation\n        // Any excess BPTs will be left in this strategy contract\n        maxBPTtoWithdraw = maxBPTtoWithdraw.mulTruncate(\n            1e18 + maxWithdrawalDeviation\n        );\n\n        // STEP 3  - Withdraw the Balancer Pool Tokens (BPT) from Aura to this strategy contract\n\n        // Withdraw BPT from Aura allowing for BPTs left in this strategy contract from previous withdrawals\n        _lpWithdraw(\n            maxBPTtoWithdraw - IERC20(platformAddress).balanceOf(address(this))\n        );\n\n        // STEP 4 - Withdraw the balancer pool assets from the pool\n\n        /* Custom asset exit: BPT_IN_FOR_EXACT_TOKENS_OUT:\n         * User sends an estimated but unknown (computed at run time) quantity of BPT,\n         * and receives precise quantities of specified tokens.\n         *\n         * ['uint256', 'uint256[]', 'uint256']\n         * [BPT_IN_FOR_EXACT_TOKENS_OUT, amountsOut, maxBPTAmountIn]\n         */\n        bytes memory userData = abi.encode(\n            IBalancerVault.WeightedPoolExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT,\n            poolAssetsAmountsOut,\n            maxBPTtoWithdraw\n        );\n\n        IBalancerVault.ExitPoolRequest memory request = IBalancerVault\n            .ExitPoolRequest(\n                poolAssets,\n                /* We specify the exact amount of a tokens we are expecting in the encoded\n                 * userData, for that reason we don't need to specify the amountsOut here.\n                 *\n                 * Also Balancer has a rounding issue that can make a transaction fail:\n                 * https://github.com/balancer/balancer-v2-monorepo/issues/2541\n                 * which is an extra reason why this field is empty.\n                 */\n                new uint256[](tokens.length),\n                userData,\n                false\n            );\n\n        balancerVault.exitPool(\n            balancerPoolId,\n            address(this),\n            /* Payable keyword is required because of the IBalancerVault interface even though\n             * this strategy shall never be receiving native ETH\n             */\n            payable(address(this)),\n            request\n        );\n\n        // STEP 5 - Re-deposit any left over BPT tokens back into Aura\n        /* When concluding how much of BPT we need to withdraw from Aura we overshoot by\n         * roughly around 1% (initial mainnet setting of maxWithdrawalDeviation). After exiting\n         * the pool strategy could have left over BPT tokens that are not earning boosted yield.\n         * We re-deploy those back in.\n         */\n        _lpDepositAll();\n\n        // STEP 6 - Unswap balancer pool assets to vault collateral assets and send to the vault.\n\n        // For each of the specified assets\n        for (uint256 i = 0; i < _strategyAssets.length; ++i) {\n            // Unwrap assets like wstETH and sfrxETH to rebasing assets stETH and frxETH\n            if (strategyAssetsToPoolAssetsAmounts[i] > 0) {\n                _unwrapPoolAsset(\n                    _strategyAssets[i],\n                    strategyAssetsToPoolAssetsAmounts[i]\n                );\n            }\n\n            // Transfer the vault collateral assets to the recipient, which is typically the vault\n            if (_strategyAmounts[i] > 0) {\n                IERC20(_strategyAssets[i]).safeTransfer(\n                    _recipient,\n                    _strategyAmounts[i]\n                );\n\n                emit Withdrawal(\n                    _strategyAssets[i],\n                    platformAddress,\n                    _strategyAmounts[i]\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraws all supported Vault collateral assets from the Balancer pool\n     * and send to the OToken's Vault.\n     *\n     * Is only executable by the OToken's Vault or the Governor.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        // STEP 1 - Withdraw all Balancer Pool Tokens (BPT) from Aura to this strategy contract\n\n        _lpWithdrawAll();\n        // Get the BPTs withdrawn from Aura plus any that were already in this strategy contract\n        uint256 BPTtoWithdraw = IERC20(platformAddress).balanceOf(\n            address(this)\n        );\n        // Get the balancer pool assets and their total balances\n        (IERC20[] memory tokens, , ) = balancerVault.getPoolTokens(\n            balancerPoolId\n        );\n        uint256[] memory minAmountsOut = new uint256[](tokens.length);\n        address[] memory poolAssets = new address[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            poolAssets[i] = address(tokens[i]);\n        }\n\n        // STEP 2 - Withdraw the Balancer pool assets from the pool\n        /* Proportional exit: EXACT_BPT_IN_FOR_TOKENS_OUT:\n         * User sends a precise quantity of BPT, and receives an estimated but unknown\n         * (computed at run time) quantity of a single token\n         *\n         * ['uint256', 'uint256']\n         * [EXACT_BPT_IN_FOR_TOKENS_OUT, bptAmountIn]\n         *\n         * It is ok to pass an empty minAmountsOut since tilting the pool in any direction\n         * when doing a proportional exit can only be beneficial to the strategy. Since\n         * it will receive more of the underlying tokens for the BPT traded in.\n         */\n        bytes memory userData = abi.encode(\n            IBalancerVault.WeightedPoolExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT,\n            BPTtoWithdraw\n        );\n\n        IBalancerVault.ExitPoolRequest memory request = IBalancerVault\n            .ExitPoolRequest(poolAssets, minAmountsOut, userData, false);\n\n        balancerVault.exitPool(\n            balancerPoolId,\n            address(this),\n            /* Payable keyword is required because of the IBalancerVault interface even though\n             * this strategy shall never be receiving native ETH\n             */\n            payable(address(this)),\n            request\n        );\n\n        // STEP 3 - Convert the balancer pool assets to the vault collateral assets and send to the vault\n        // For each of the Balancer pool assets\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            address poolAsset = address(tokens[i]);\n            // Convert the balancer pool asset to the strategy asset\n            address strategyAsset = _fromPoolAsset(poolAsset);\n            // Get the balancer pool assets withdraw from the pool plus any that were already in this strategy contract\n            uint256 poolAssetAmount = IERC20(poolAsset).balanceOf(\n                address(this)\n            );\n\n            // Unwrap assets like wstETH and sfrxETH to rebasing assets stETH and frxETH\n            uint256 unwrappedAmount = 0;\n            if (poolAssetAmount > 0) {\n                unwrappedAmount = _unwrapPoolAsset(\n                    strategyAsset,\n                    poolAssetAmount\n                );\n            }\n\n            // Transfer the vault collateral assets to the vault\n            if (unwrappedAmount > 0) {\n                IERC20(strategyAsset).safeTransfer(\n                    vaultAddress,\n                    unwrappedAmount\n                );\n                emit Withdrawal(\n                    strategyAsset,\n                    platformAddress,\n                    unwrappedAmount\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Approves the Balancer Vault to transfer poolAsset counterparts\n     * of all of the supported assets from this strategy. E.g. stETH is a supported\n     * strategy and Balancer Vault gets unlimited approval to transfer wstETH.\n     *\n     * If Balancer pool uses a wrapped version of a supported asset then also approve\n     * unlimited usage of an asset to the contract responsible for wrapping.\n     *\n     * Approve unlimited spending by Balancer Vault and Aura reward pool of the\n     * pool BPT tokens.\n     *\n     * Is only executable by the Governor.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            _abstractSetPToken(assetsMapped[i], platformAddress);\n        }\n        _approveBase();\n    }\n\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address) internal override {\n        address poolAsset = _toPoolAsset(_asset);\n        if (_asset == stETH) {\n            // slither-disable-next-line unused-return\n            IERC20(stETH).approve(wstETH, type(uint256).max);\n        } else if (_asset == frxETH) {\n            // slither-disable-next-line unused-return\n            IERC20(frxETH).approve(sfrxETH, type(uint256).max);\n        }\n        _approveAsset(poolAsset);\n    }\n\n    /**\n     * @dev Approves the Balancer Vault to transfer an asset from\n     * this strategy. The assets could be a Vault collateral asset\n     * like WETH or rETH; or a Balancer pool asset that wraps the vault asset\n     * like wstETH or sfrxETH.\n     */\n    function _approveAsset(address _asset) internal {\n        IERC20 asset = IERC20(_asset);\n        // slither-disable-next-line unused-return\n        asset.approve(address(balancerVault), type(uint256).max);\n    }\n\n    /**\n     * @notice Returns the rate supplied by the Balancer configured rate\n     * provider. Rate is used to normalize the token to common underlying\n     * pool denominator. (ETH for ETH Liquid staking derivatives)\n     *\n     * @param _asset Address of the Balancer pool asset\n     * @return rate of the corresponding asset\n     */\n    function _getRateProviderRate(address _asset)\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        IMetaStablePool pool = IMetaStablePool(platformAddress);\n        IRateProvider[] memory providers = pool.getRateProviders();\n        (IERC20[] memory tokens, , ) = balancerVault.getPoolTokens(\n            balancerPoolId\n        );\n\n        uint256 providersLength = providers.length;\n        for (uint256 i = 0; i < providersLength; ++i) {\n            // _assets and corresponding rate providers are all in the same order\n            if (address(tokens[i]) == _asset) {\n                // rate provider doesn't exist, defaults to 1e18\n                if (address(providers[i]) == address(0)) {\n                    return 1e18;\n                }\n                return providers[i].getRate();\n            }\n        }\n\n        // should never happen\n        assert(false);\n    }\n}\n"
    },
    "contracts/strategies/balancer/VaultReentrancyLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../../utils/BalancerErrors.sol\";\nimport { IBalancerVault } from \"../../interfaces/balancer/IBalancerVault.sol\";\n\nlibrary VaultReentrancyLib {\n    /**\n     * @dev Ensure we are not in a Vault context when this function is called, by attempting a no-op internal\n     * balance operation. If we are already in a Vault transaction (e.g., a swap, join, or exit), the Vault's\n     * reentrancy protection will cause this function to revert.\n     *\n     * The exact function call doesn't really matter: we're just trying to trigger the Vault reentrancy check\n     * (and not hurt anything in case it works). An empty operation array with no specific operation at all works\n     * for that purpose, and is also the least expensive in terms of gas and bytecode size.\n     *\n     * Call this at the top of any function that can cause a state change in a pool and is either public itself,\n     * or called by a public function *outside* a Vault operation (e.g., join, exit, or swap).\n     *\n     * If this is *not* called in functions that are vulnerable to the read-only reentrancy issue described\n     * here (https://forum.balancer.fi/t/reentrancy-vulnerability-scope-expanded/4345), those functions are unsafe,\n     * and subject to manipulation that may result in loss of funds.\n     */\n    function ensureNotInVaultContext(IBalancerVault vault) internal view {\n        // Perform the following operation to trigger the Vault's reentrancy guard:\n        //\n        // IBalancerVault.UserBalanceOp[] memory noop = new IBalancerVault.UserBalanceOp[](0);\n        // _vault.manageUserBalance(noop);\n        //\n        // However, use a static call so that it can be a view function (even though the function is non-view).\n        // This allows the library to be used more widely, as some functions that need to be protected might be\n        // view.\n        //\n        // This staticcall always reverts, but we need to make sure it doesn't fail due to a re-entrancy attack.\n        // Staticcalls consume all gas forwarded to them on a revert caused by storage modification.\n        // By default, almost the entire available gas is forwarded to the staticcall,\n        // causing the entire call to revert with an 'out of gas' error.\n        //\n        // We set the gas limit to 10k for the staticcall to\n        // avoid wasting gas when it reverts due to storage modification.\n        // `manageUserBalance` is a non-reentrant function in the Vault, so calling it invokes `_enterNonReentrant`\n        // in the `ReentrancyGuard` contract, reproduced here:\n        //\n        //    function _enterNonReentrant() private {\n        //        // If the Vault is actually being reentered, it will revert in the first line, at the `_require` that\n        //        // checks the reentrancy flag, with \"BAL#400\" (corresponding to Errors.REENTRANCY) in the revertData.\n        //        // The full revertData will be: `abi.encodeWithSignature(\"Error(string)\", \"BAL#400\")`.\n        //        _require(_status != _ENTERED, Errors.REENTRANCY);\n        //\n        //        // If the Vault is not being reentered, the check above will pass: but it will *still* revert,\n        //        // because the next line attempts to modify storage during a staticcall. However, this type of\n        //        // failure results in empty revertData.\n        //        _status = _ENTERED;\n        //    }\n        //\n        // So based on this analysis, there are only two possible revertData values: empty, or abi.encoded BAL#400.\n        //\n        // It is of course much more bytecode and gas efficient to check for zero-length revertData than to compare it\n        // to the encoded REENTRANCY revertData.\n        //\n        // While it should be impossible for the call to fail in any other way (especially since it reverts before\n        // `manageUserBalance` even gets called), any other error would generate non-zero revertData, so checking for\n        // empty data guards against this case too.\n\n        (, bytes memory revertData) = address(vault).staticcall{ gas: 10_000 }(\n            abi.encodeWithSelector(vault.manageUserBalance.selector, 0)\n        );\n\n        _require(revertData.length == 0, Errors.REENTRANCY);\n    }\n}\n"
    },
    "contracts/strategies/BridgedWOETHStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20, SafeERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { AggregatorV3Interface } from \"../interfaces/chainlink/AggregatorV3Interface.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\n\ncontract BridgedWOETHStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n    using StableMath for uint128;\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n\n    event MaxPriceDiffBpsUpdated(uint128 oldValue, uint128 newValue);\n    event WOETHPriceUpdated(uint128 oldValue, uint128 newValue);\n\n    IWETH9 public immutable weth;\n    IERC20 public immutable bridgedWOETH;\n    IERC20 public immutable oethb;\n\n    uint256 public constant MAX_PRICE_STALENESS = 2 days;\n\n    uint128 public lastOraclePrice;\n    uint128 public maxPriceDiffBps;\n\n    /**\n     * @dev Verifies that the caller is the Governor or Strategist.\n     */\n    modifier onlyGovernorOrStrategist() {\n        require(\n            isGovernor() || msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    constructor(\n        BaseStrategyConfig memory _stratConfig,\n        address _weth,\n        address _bridgedWOETH,\n        address _oethb\n    ) InitializableAbstractStrategy(_stratConfig) {\n        weth = IWETH9(_weth);\n        bridgedWOETH = IERC20(_bridgedWOETH);\n        oethb = IERC20(_oethb);\n    }\n\n    function initialize(uint128 _maxPriceDiffBps)\n        external\n        onlyGovernor\n        initializer\n    {\n        InitializableAbstractStrategy._initialize(\n            new address[](0), // No reward tokens\n            new address[](0), // No assets\n            new address[](0) // No pTokens\n        );\n\n        _setMaxPriceDiffBps(_maxPriceDiffBps);\n    }\n\n    /**\n     * @dev Sets the max price diff bps for the wOETH value appreciation\n     * @param _maxPriceDiffBps Bps value, 10k == 100%\n     */\n    function setMaxPriceDiffBps(uint128 _maxPriceDiffBps)\n        external\n        onlyGovernor\n    {\n        _setMaxPriceDiffBps(_maxPriceDiffBps);\n    }\n\n    /**\n     * @dev Sets the max price diff bps for the wOETH value appreciation\n     * @param _maxPriceDiffBps Bps value, 10k == 100%\n     */\n    function _setMaxPriceDiffBps(uint128 _maxPriceDiffBps) internal {\n        require(\n            _maxPriceDiffBps > 0 && _maxPriceDiffBps <= 10000,\n            \"Invalid bps value\"\n        );\n\n        emit MaxPriceDiffBpsUpdated(maxPriceDiffBps, _maxPriceDiffBps);\n\n        maxPriceDiffBps = _maxPriceDiffBps;\n    }\n\n    /**\n     * @dev Wrapper for _updateWOETHOraclePrice with nonReentrant flag\n     * @return The latest price of wOETH from Oracle\n     */\n    function updateWOETHOraclePrice() external nonReentrant returns (uint256) {\n        return _updateWOETHOraclePrice();\n    }\n\n    /**\n     * @dev Finds the value of bridged wOETH from the Oracle.\n     *      Ensures that it's within the bounds and reasonable.\n     *      And stores it.\n     *\n     *      NOTE: Intentionally not caching `Vault.priceProvider` here,\n     *      since doing so would mean that we also have to update this\n     *      strategy every time there's a change in oracle router.\n     *      Besides on L2, the gas is considerably cheaper than mainnet.\n     *\n     * @return Latest price from oracle\n     */\n    function _updateWOETHOraclePrice() internal returns (uint256) {\n        // WETH price per unit of bridged wOETH\n        uint256 oraclePrice = IOracle(IVault(vaultAddress).priceProvider())\n            .price(address(bridgedWOETH));\n\n        // 1 wOETH > 1 WETH, always\n        require(oraclePrice > 1 ether, \"Invalid wOETH value\");\n\n        uint128 oraclePrice128 = oraclePrice.toUint128();\n\n        // Do some checks\n        if (lastOraclePrice > 0) {\n            // Make sure the value only goes up\n            require(oraclePrice128 >= lastOraclePrice, \"Negative wOETH yield\");\n\n            // lastOraclePrice * (1 + maxPriceDiffBps)\n            uint256 maxPrice = (lastOraclePrice * (1e4 + maxPriceDiffBps)) /\n                1e4;\n\n            // And that it's within the bounds.\n            require(oraclePrice128 <= maxPrice, \"Price diff beyond threshold\");\n        }\n\n        emit WOETHPriceUpdated(lastOraclePrice, oraclePrice128);\n\n        // Store the price\n        lastOraclePrice = oraclePrice128;\n\n        return oraclePrice;\n    }\n\n    /**\n     * @dev Computes & returns the value of given wOETH in WETH\n     * @param woethAmount Amount of wOETH\n     * @return Value of wOETH in WETH (using the last stored oracle price)\n     */\n    function getBridgedWOETHValue(uint256 woethAmount)\n        public\n        view\n        returns (uint256)\n    {\n        return (woethAmount * lastOraclePrice) / 1 ether;\n    }\n\n    /**\n     * @dev Takes in bridged wOETH and mints & returns\n     *      equivalent amount of OETHb.\n     * @param woethAmount Amount of bridged wOETH to transfer in\n     */\n    function depositBridgedWOETH(uint256 woethAmount)\n        external\n        onlyGovernorOrStrategist\n        nonReentrant\n    {\n        // Update wOETH price\n        uint256 oraclePrice = _updateWOETHOraclePrice();\n\n        // Figure out how much they are worth\n        uint256 oethToMint = (woethAmount * oraclePrice) / 1 ether;\n\n        require(oethToMint > 0, \"Invalid deposit amount\");\n\n        // There's no pToken, however, it just uses WOETH address in the event\n        emit Deposit(address(weth), address(bridgedWOETH), oethToMint);\n\n        // Mint OETHb tokens and transfer it to the caller\n        IVault(vaultAddress).mintForStrategy(oethToMint);\n\n        // Transfer out minted OETHb\n        // slither-disable-next-line unchecked-transfer unused-return\n        oethb.transfer(msg.sender, oethToMint);\n\n        // Transfer in all bridged wOETH tokens\n        // slither-disable-next-line unchecked-transfer unused-return\n        bridgedWOETH.transferFrom(msg.sender, address(this), woethAmount);\n    }\n\n    /**\n     * @dev Takes in OETHb and burns it and returns\n     *      equivalent amount of bridged wOETH.\n     * @param oethToBurn Amount of OETHb to burn\n     */\n    function withdrawBridgedWOETH(uint256 oethToBurn)\n        external\n        onlyGovernorOrStrategist\n        nonReentrant\n    {\n        // Update wOETH price\n        uint256 oraclePrice = _updateWOETHOraclePrice();\n\n        // Figure out how much they are worth\n        uint256 woethAmount = (oethToBurn * 1 ether) / oraclePrice;\n\n        require(woethAmount > 0, \"Invalid withdraw amount\");\n\n        // There's no pToken, however, it just uses WOETH address in the event\n        emit Withdrawal(address(weth), address(bridgedWOETH), oethToBurn);\n\n        // Transfer WOETH back\n        // slither-disable-next-line unchecked-transfer unused-return\n        bridgedWOETH.transfer(msg.sender, woethAmount);\n\n        // Transfer in OETHb\n        // slither-disable-next-line unchecked-transfer unused-return\n        oethb.transferFrom(msg.sender, address(this), oethToBurn);\n\n        // Burn OETHb\n        IVault(vaultAddress).burnForStrategy(oethToBurn);\n    }\n\n    /**\n     * @notice Returns the amount of backing WETH the strategy holds\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == address(weth), \"Unsupported asset\");\n\n        // Figure out how much wOETH is worth at the time.\n        // Always uses the last stored oracle price.\n        // Call updateWOETHOraclePrice manually to pull in latest yields.\n\n        // NOTE: If the contract has been deployed but the call to\n        // `updateWOETHOraclePrice()` has never been made, then this\n        // will return zero. It should be fine because the strategy\n        // should update the price whenever a deposit/withdraw happens.\n\n        // If `updateWOETHOraclePrice()` hasn't been called in a while,\n        // the strategy will underreport its holdings but never overreport it.\n\n        balance =\n            (bridgedWOETH.balanceOf(address(this)) * lastOraclePrice) /\n            1 ether;\n    }\n\n    /**\n     * @notice Check if an asset is supported.\n     * @param _asset    Address of the asset\n     * @return bool     Whether asset is supported\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        // Strategist deposits bridged wOETH but the contract only\n        // reports the balance in WETH. As far as Vault is concerned,\n        // it isn't aware of bridged wOETH token\n        return _asset == address(weth);\n    }\n\n    /***************************************\n               Overridden methods\n    ****************************************/\n    /**\n     * @inheritdoc InitializableAbstractStrategy\n     */\n    function transferToken(address _asset, uint256 _amount)\n        public\n        override\n        onlyGovernor\n    {\n        require(\n            _asset != address(bridgedWOETH) && _asset != address(weth),\n            \"Cannot transfer supported asset\"\n        );\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /**\n     * @notice deposit() function not used for this strategy\n     */\n    function deposit(address, uint256)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        // Use depositBridgedWOETH() instead\n        require(false, \"Deposit disabled\");\n    }\n\n    /**\n     * @notice depositAll() function not used for this strategy\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        // Use depositBridgedWOETH() instead\n        require(false, \"Deposit disabled\");\n    }\n\n    /**\n     * @notice withdraw() function not used for this strategy\n     */\n    function withdraw(\n        // solhint-disable-next-line no-unused-vars\n        address _recipient,\n        // solhint-disable-next-line no-unused-vars\n        address _asset,\n        // solhint-disable-next-line no-unused-vars\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(false, \"Withdrawal disabled\");\n    }\n\n    /**\n     * @notice withdrawAll() function not used for this strategy\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        // Withdrawal disabled\n    }\n\n    function _abstractSetPToken(address, address) internal override {\n        revert(\"No pTokens are used\");\n    }\n\n    function safeApproveAllTokens() external override {}\n\n    /**\n     * @inheritdoc InitializableAbstractStrategy\n     */\n    function removePToken(uint256) external override {\n        revert(\"No pTokens are used\");\n    }\n\n    /**\n     * @inheritdoc InitializableAbstractStrategy\n     */\n    function collectRewardTokens() external override {}\n}\n"
    },
    "contracts/strategies/CompoundStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Compound Strategy\n * @notice Investment strategy for Compound like lending platforms. eg Compound and Flux\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ICERC20 } from \"./ICompound.sol\";\nimport { AbstractCompoundStrategy, InitializableAbstractStrategy } from \"./AbstractCompoundStrategy.sol\";\nimport { IComptroller } from \"../interfaces/IComptroller.sol\";\nimport { IERC20 } from \"../utils/InitializableAbstractStrategy.sol\";\n\ncontract CompoundStrategy is AbstractCompoundStrategy {\n    using SafeERC20 for IERC20;\n    event SkippedWithdrawal(address asset, uint256 amount);\n\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /**\n     * @notice initialize function, to set up initial internal state\n     * @param _rewardTokenAddresses Address of reward token for platform\n     * @param _assets Addresses of initial supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function initialize(\n        address[] memory _rewardTokenAddresses,\n        address[] memory _assets,\n        address[] memory _pTokens\n    ) external onlyGovernor initializer {\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n    }\n\n    /**\n     * @notice Collect accumulated COMP and send to Harvester.\n     */\n    function collectRewardTokens()\n        external\n        virtual\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Claim COMP from Comptroller\n        ICERC20 cToken = _getCTokenFor(assetsMapped[0]);\n        IComptroller comptroller = IComptroller(cToken.comptroller());\n        // Only collect from active cTokens, saves gas\n        address[] memory ctokensToCollect = new address[](assetsMapped.length);\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            ctokensToCollect[i] = address(_getCTokenFor(assetsMapped[i]));\n        }\n        // Claim only for this strategy\n        address[] memory claimers = new address[](1);\n        claimers[0] = address(this);\n        // Claim COMP from Comptroller. Only collect for supply, saves gas\n        comptroller.claimComp(claimers, ctokensToCollect, false, true);\n        // Transfer COMP to Harvester\n        IERC20 rewardToken = IERC20(rewardTokenAddresses[0]);\n        uint256 balance = rewardToken.balanceOf(address(this));\n        emit RewardTokenCollected(\n            harvesterAddress,\n            rewardTokenAddresses[0],\n            balance\n        );\n        rewardToken.safeTransfer(harvesterAddress, balance);\n    }\n\n    /**\n     * @notice Deposit asset into the underlying platform\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of assets to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @dev Deposit an asset into the underlying platform\n     * @param _asset Address of the asset to deposit\n     * @param _amount Amount of assets to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_amount > 0, \"Must deposit something\");\n        ICERC20 cToken = _getCTokenFor(_asset);\n        emit Deposit(_asset, address(cToken), _amount);\n        require(cToken.mint(_amount) == 0, \"cToken mint failed\");\n    }\n\n    /**\n     * @notice Deposit the entire balance of any supported asset in the strategy into the underlying platform\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            IERC20 asset = IERC20(assetsMapped[i]);\n            uint256 assetBalance = asset.balanceOf(address(this));\n            if (assetBalance > 0) {\n                _deposit(address(asset), assetBalance);\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraw an asset from the underlying platform\n     * @param _recipient Address to receive withdrawn assets\n     * @param _asset Address of the asset to withdraw\n     * @param _amount Amount of assets to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        ICERC20 cToken = _getCTokenFor(_asset);\n        // If redeeming 0 cTokens, just skip, else COMP will revert\n        uint256 cTokensToRedeem = _convertUnderlyingToCToken(cToken, _amount);\n        if (cTokensToRedeem == 0) {\n            emit SkippedWithdrawal(_asset, _amount);\n            return;\n        }\n\n        emit Withdrawal(_asset, address(cToken), _amount);\n        require(cToken.redeemUnderlying(_amount) == 0, \"Redeem failed\");\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Internal method to respond to the addition of new asset / cTokens\n     *      We need to approve the cToken and give it permission to spend the asset\n     * @param _asset Address of the asset to approve. eg DAI\n     * @param _pToken The pToken for the approval. eg cDAI or fDAI\n     */\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        override\n    {\n        // Safe approval\n        IERC20(_asset).safeApprove(_pToken, 0);\n        IERC20(_asset).safeApprove(_pToken, type(uint256).max);\n    }\n\n    /**\n     * @notice Remove all supported assets from the underlying platform and send them to Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            IERC20 asset = IERC20(assetsMapped[i]);\n            // Redeem entire balance of cToken\n            ICERC20 cToken = _getCTokenFor(address(asset));\n            uint256 cTokenBalance = cToken.balanceOf(address(this));\n            if (cTokenBalance > 0) {\n                require(cToken.redeem(cTokenBalance) == 0, \"Redeem failed\");\n                uint256 assetBalance = asset.balanceOf(address(this));\n                // Transfer entire balance to Vault\n                asset.safeTransfer(vaultAddress, assetBalance);\n\n                emit Withdrawal(address(asset), address(cToken), assetBalance);\n            }\n        }\n    }\n\n    /**\n     * @notice Get the total asset value held in the underlying platform\n     *      This includes any interest that was generated since depositing.\n     *      The exchange rate between the cToken and asset gradually increases,\n     *      causing the cToken to be worth more corresponding asset.\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        // Balance is always with token cToken decimals\n        ICERC20 cToken = _getCTokenFor(_asset);\n        balance = _checkBalance(cToken);\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     *      underlying = (cTokenAmt * exchangeRate) / 1e18\n     * @param _cToken     cToken for which to check balance\n     * @return balance    Total value of the asset in the platform\n     */\n    function _checkBalance(ICERC20 _cToken)\n        internal\n        view\n        returns (uint256 balance)\n    {\n        // e.g. 50e8*205316390724364402565641705 / 1e18 = 1.0265..e18\n        balance =\n            (_cToken.balanceOf(address(this)) * _cToken.exchangeRateStored()) /\n            1e18;\n    }\n\n    /**\n     * @notice Approve the spending of all assets by their corresponding cToken,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens() external override {\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            IERC20 asset = IERC20(assetsMapped[i]);\n            address cToken = assetToPToken[address(asset)];\n            // Safe approval\n            asset.safeApprove(cToken, 0);\n            asset.safeApprove(cToken, type(uint256).max);\n        }\n    }\n}\n"
    },
    "contracts/strategies/ConvexEthMetaStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Convex Automated Market Maker (AMO) Strategy\n * @notice AMO strategy for the Curve OETH/ETH pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { ICurveETHPoolV1 } from \"./ICurveETHPoolV1.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { IConvexDeposits } from \"./IConvexDeposits.sol\";\nimport { IRewardStaking } from \"./IRewardStaking.sol\";\n\ncontract ConvexEthMetaStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant MAX_SLIPPAGE = 1e16; // 1%, same as the Curve UI\n    address public constant ETH_ADDRESS =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    // The following slots have been deprecated with immutable variables\n    // slither-disable-next-line constable-states\n    address private _deprecated_cvxDepositorAddress;\n    // slither-disable-next-line constable-states\n    address private _deprecated_cvxRewardStaker;\n    // slither-disable-next-line constable-states\n    uint256 private _deprecated_cvxDepositorPTokenId;\n    // slither-disable-next-line constable-states\n    address private _deprecated_curvePool;\n    // slither-disable-next-line constable-states\n    address private _deprecated_lpToken;\n    // slither-disable-next-line constable-states\n    address private _deprecated_oeth;\n    // slither-disable-next-line constable-states\n    address private _deprecated_weth;\n\n    // Ordered list of pool assets\n    // slither-disable-next-line constable-states\n    uint128 private _deprecated_oethCoinIndex;\n    // slither-disable-next-line constable-states\n    uint128 private _deprecated_ethCoinIndex;\n\n    // New immutable variables that must be set in the constructor\n    address public immutable cvxDepositorAddress;\n    IRewardStaking public immutable cvxRewardStaker;\n    uint256 public immutable cvxDepositorPTokenId;\n    ICurveETHPoolV1 public immutable curvePool;\n    IERC20 public immutable lpToken;\n    IERC20 public immutable oeth;\n    IWETH9 public immutable weth;\n\n    // Ordered list of pool assets\n    uint128 public constant oethCoinIndex = 1;\n    uint128 public constant ethCoinIndex = 0;\n\n    /**\n     * @dev Verifies that the caller is the Strategist.\n     */\n    modifier onlyStrategist() {\n        require(\n            msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Strategist\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Checks the Curve pool's balances have improved and the balances\n     * have not tipped to the other side.\n     * This modifier only works on functions that do a single sided add or remove.\n     * The standard deposit function adds to both sides of the pool in a way that\n     * the pool's balance is not worsened.\n     * Withdrawals are proportional so doesn't change the pools asset balance.\n     */\n    modifier improvePoolBalance() {\n        // Get the asset and OToken balances in the Curve pool\n        uint256[2] memory balancesBefore = curvePool.get_balances();\n        // diff = ETH balance - OETH balance\n        int256 diffBefore = int256(balancesBefore[ethCoinIndex]) -\n            int256(balancesBefore[oethCoinIndex]);\n\n        _;\n\n        // Get the asset and OToken balances in the Curve pool\n        uint256[2] memory balancesAfter = curvePool.get_balances();\n        // diff = ETH balance - OETH balance\n        int256 diffAfter = int256(balancesAfter[ethCoinIndex]) -\n            int256(balancesAfter[oethCoinIndex]);\n\n        if (diffBefore <= 0) {\n            // If the pool was originally imbalanced in favor of OETH, then\n            // we want to check that the pool is now more balanced\n            require(diffAfter <= 0, \"OTokens overshot peg\");\n            require(diffBefore < diffAfter, \"OTokens balance worse\");\n        }\n        if (diffBefore >= 0) {\n            // If the pool was originally imbalanced in favor of ETH, then\n            // we want to check that the pool is now more balanced\n            require(diffAfter >= 0, \"Assets overshot peg\");\n            require(diffAfter < diffBefore, \"Assets balance worse\");\n        }\n    }\n\n    // Used to circumvent the stack too deep issue\n    struct ConvexEthMetaConfig {\n        address cvxDepositorAddress; //Address of the Convex depositor(AKA booster) for this pool\n        address cvxRewardStakerAddress; //Address of the CVX rewards staker\n        uint256 cvxDepositorPTokenId; //Pid of the pool referred to by Depositor and staker\n        address oethAddress; //Address of OETH token\n        address wethAddress; //Address of WETH\n    }\n\n    constructor(\n        BaseStrategyConfig memory _baseConfig,\n        ConvexEthMetaConfig memory _convexConfig\n    ) InitializableAbstractStrategy(_baseConfig) {\n        lpToken = IERC20(_baseConfig.platformAddress);\n        curvePool = ICurveETHPoolV1(_baseConfig.platformAddress);\n\n        cvxDepositorAddress = _convexConfig.cvxDepositorAddress;\n        cvxRewardStaker = IRewardStaking(_convexConfig.cvxRewardStakerAddress);\n        cvxDepositorPTokenId = _convexConfig.cvxDepositorPTokenId;\n        oeth = IERC20(_convexConfig.oethAddress);\n        weth = IWETH9(_convexConfig.wethAddress);\n    }\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Curve strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Address of CRV & CVX\n     * @param _assets Addresses of supported assets. eg WETH\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // CRV + CVX\n        address[] calldata _assets // WETH\n    ) external onlyGovernor initializer {\n        require(_assets.length == 1, \"Must have exactly one asset\");\n        require(_assets[0] == address(weth), \"Asset not WETH\");\n\n        address[] memory pTokens = new address[](1);\n        pTokens[0] = address(curvePool);\n\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            pTokens\n        );\n\n        _approveBase();\n    }\n\n    /***************************************\n                    Deposit\n    ****************************************/\n\n    /**\n     * @notice Deposit WETH into the Curve pool\n     * @param _weth Address of Wrapped ETH (WETH) contract.\n     * @param _amount Amount of WETH to deposit.\n     */\n    function deposit(address _weth, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_weth, _amount);\n    }\n\n    function _deposit(address _weth, uint256 _wethAmount) internal {\n        require(_wethAmount > 0, \"Must deposit something\");\n        require(_weth == address(weth), \"Can only deposit WETH\");\n        weth.withdraw(_wethAmount);\n\n        emit Deposit(_weth, address(lpToken), _wethAmount);\n\n        // Get the asset and OToken balances in the Curve pool\n        uint256[2] memory balances = curvePool.get_balances();\n        // safe to cast since min value is at least 0\n        uint256 oethToAdd = uint256(\n            _max(\n                0,\n                int256(balances[ethCoinIndex]) +\n                    int256(_wethAmount) -\n                    int256(balances[oethCoinIndex])\n            )\n        );\n\n        /* Add so much OETH so that the pool ends up being balanced. And at minimum\n         * add as much OETH as WETH and at maximum twice as much OETH.\n         */\n        oethToAdd = Math.max(oethToAdd, _wethAmount);\n        oethToAdd = Math.min(oethToAdd, _wethAmount * 2);\n\n        /* Mint OETH with a strategy that attempts to contribute to stability of OETH/WETH pool. Try\n         * to mint so much OETH that after deployment of liquidity pool ends up being balanced.\n         *\n         * To manage unpredictability minimal OETH minted will always be at least equal or greater\n         * to WETH amount deployed. And never larger than twice the WETH amount deployed even if\n         * it would have a further beneficial effect on pool stability.\n         */\n        IVault(vaultAddress).mintForStrategy(oethToAdd);\n\n        emit Deposit(address(oeth), address(lpToken), oethToAdd);\n\n        uint256[2] memory _amounts;\n        _amounts[ethCoinIndex] = _wethAmount;\n        _amounts[oethCoinIndex] = oethToAdd;\n\n        uint256 valueInLpTokens = (_wethAmount + oethToAdd).divPrecisely(\n            curvePool.get_virtual_price()\n        );\n        uint256 minMintAmount = valueInLpTokens.mulTruncate(\n            uint256(1e18) - MAX_SLIPPAGE\n        );\n\n        // Do the deposit to the Curve pool\n        // slither-disable-next-line arbitrary-send\n        uint256 lpDeposited = curvePool.add_liquidity{ value: _wethAmount }(\n            _amounts,\n            minMintAmount\n        );\n\n        // Deposit the Curve pool's LP tokens into the Convex rewards pool\n        require(\n            IConvexDeposits(cvxDepositorAddress).deposit(\n                cvxDepositorPTokenId,\n                lpDeposited,\n                true // Deposit with staking\n            ),\n            \"Depositing LP to Convex not successful\"\n        );\n    }\n\n    /**\n     * @notice Deposit the strategy's entire balance of WETH into the Curve pool\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 balance = weth.balanceOf(address(this));\n        if (balance > 0) {\n            _deposit(address(weth), balance);\n        }\n    }\n\n    /***************************************\n                    Withdraw\n    ****************************************/\n\n    /**\n     * @notice Withdraw ETH and OETH from the Curve pool, burn the OETH,\n     * convert the ETH to WETH and transfer to the recipient.\n     * @param _recipient Address to receive withdrawn asset which is normally the Vault.\n     * @param _weth Address of the Wrapped ETH (WETH) contract.\n     * @param _amount Amount of WETH to withdraw.\n     */\n    function withdraw(\n        address _recipient,\n        address _weth,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_amount > 0, \"Invalid amount\");\n        require(_weth == address(weth), \"Can only withdraw WETH\");\n\n        emit Withdrawal(_weth, address(lpToken), _amount);\n\n        uint256 requiredLpTokens = calcTokenToBurn(_amount);\n\n        _lpWithdraw(requiredLpTokens);\n\n        /* math in requiredLpTokens should correctly calculate the amount of LP to remove\n         * in that the strategy receives enough WETH on balanced removal\n         */\n        uint256[2] memory _minWithdrawalAmounts = [uint256(0), uint256(0)];\n        _minWithdrawalAmounts[ethCoinIndex] = _amount;\n        // slither-disable-next-line unused-return\n        curvePool.remove_liquidity(requiredLpTokens, _minWithdrawalAmounts);\n\n        // Burn all the removed OETH and any that was left in the strategy\n        uint256 oethToBurn = oeth.balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(oethToBurn);\n\n        emit Withdrawal(address(oeth), address(lpToken), oethToBurn);\n\n        // Transfer WETH to the recipient\n        weth.deposit{ value: _amount }();\n        require(\n            weth.transfer(_recipient, _amount),\n            \"Transfer of WETH not successful\"\n        );\n    }\n\n    function calcTokenToBurn(uint256 _wethAmount)\n        internal\n        view\n        returns (uint256 lpToBurn)\n    {\n        /* The rate between coins in the pool determines the rate at which pool returns\n         * tokens when doing balanced removal (remove_liquidity call). And by knowing how much WETH\n         * we want we can determine how much of OETH we receive by removing liquidity.\n         *\n         * Because we are doing balanced removal we should be making profit when removing liquidity in a\n         * pool tilted to either side.\n         *\n         * Important: A downside is that the Strategist / Governor needs to be\n         * cognisant of not removing too much liquidity. And while the proposal to remove liquidity\n         * is being voted on the pool tilt might change so much that the proposal that has been valid while\n         * created is no longer valid.\n         */\n\n        uint256 poolWETHBalance = curvePool.balances(ethCoinIndex);\n        /* K is multiplied by 1e36 which is used for higher precision calculation of required\n         * pool LP tokens. Without it the end value can have rounding errors up to precision of\n         * 10 digits. This way we move the decimal point by 36 places when doing the calculation\n         * and again by 36 places when we are done with it.\n         */\n        uint256 k = (1e36 * lpToken.totalSupply()) / poolWETHBalance;\n        // prettier-ignore\n        // slither-disable-next-line divide-before-multiply\n        uint256 diff = (_wethAmount + 1) * k;\n        lpToBurn = diff / 1e36;\n    }\n\n    /**\n     * @notice Remove all ETH and OETH from the Curve pool, burn the OETH,\n     * convert the ETH to WETH and transfer to the Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        uint256 gaugeTokens = cvxRewardStaker.balanceOf(address(this));\n        _lpWithdraw(gaugeTokens);\n\n        // Withdraws are proportional to assets held by 3Pool\n        uint256[2] memory minWithdrawAmounts = [uint256(0), uint256(0)];\n\n        // Remove liquidity\n        // slither-disable-next-line unused-return\n        curvePool.remove_liquidity(\n            lpToken.balanceOf(address(this)),\n            minWithdrawAmounts\n        );\n\n        // Burn all OETH\n        uint256 oethToBurn = oeth.balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(oethToBurn);\n\n        // Get the strategy contract's ether balance.\n        // This includes all that was removed from the Curve pool and\n        // any ether that was sitting in the strategy contract before the removal.\n        uint256 ethBalance = address(this).balance;\n        // Convert all the strategy contract's ether to WETH and transfer to the vault.\n        weth.deposit{ value: ethBalance }();\n        require(\n            weth.transfer(vaultAddress, ethBalance),\n            \"Transfer of WETH not successful\"\n        );\n\n        emit Withdrawal(address(weth), address(lpToken), ethBalance);\n        emit Withdrawal(address(oeth), address(lpToken), oethToBurn);\n    }\n\n    /***************************************\n            Curve pool Rebalancing\n    ****************************************/\n\n    /**\n     * @notice Mint OTokens and one-sided add to the Curve pool.\n     * This is used when the Curve pool does not have enough OTokens and too many ETH.\n     * The OToken/Asset, eg OETH/ETH, price with increase.\n     * The amount of assets in the vault is unchanged.\n     * The total supply of OTokens is increased.\n     * The asset value of the strategy and vault is increased.\n     * @param _oTokens The amount of OTokens to be minted and added to the pool.\n     */\n    function mintAndAddOTokens(uint256 _oTokens)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n    {\n        IVault(vaultAddress).mintForStrategy(_oTokens);\n\n        uint256[2] memory amounts = [uint256(0), uint256(0)];\n        amounts[oethCoinIndex] = _oTokens;\n\n        // Convert OETH to Curve pool LP tokens\n        uint256 valueInLpTokens = (_oTokens).divPrecisely(\n            curvePool.get_virtual_price()\n        );\n        // Apply slippage to LP tokens\n        uint256 minMintAmount = valueInLpTokens.mulTruncate(\n            uint256(1e18) - MAX_SLIPPAGE\n        );\n\n        // Add the minted OTokens to the Curve pool\n        uint256 lpDeposited = curvePool.add_liquidity(amounts, minMintAmount);\n\n        // Deposit the Curve pool LP tokens to the Convex rewards pool\n        require(\n            IConvexDeposits(cvxDepositorAddress).deposit(\n                cvxDepositorPTokenId,\n                lpDeposited,\n                true // Deposit with staking\n            ),\n            \"Failed to Deposit LP to Convex\"\n        );\n\n        emit Deposit(address(oeth), address(lpToken), _oTokens);\n    }\n\n    /**\n     * @notice One-sided remove of OTokens from the Curve pool which are then burned.\n     * This is used when the Curve pool has too many OTokens and not enough ETH.\n     * The amount of assets in the vault is unchanged.\n     * The total supply of OTokens is reduced.\n     * The asset value of the strategy and vault is reduced.\n     * @param _lpTokens The amount of Curve pool LP tokens to be burned for OTokens.\n     */\n    function removeAndBurnOTokens(uint256 _lpTokens)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n    {\n        // Withdraw Curve pool LP tokens from Convex and remove OTokens from the Curve pool\n        uint256 oethToBurn = _withdrawAndRemoveFromPool(\n            _lpTokens,\n            oethCoinIndex\n        );\n\n        // The vault burns the OTokens from this strategy\n        IVault(vaultAddress).burnForStrategy(oethToBurn);\n\n        emit Withdrawal(address(oeth), address(lpToken), oethToBurn);\n    }\n\n    /**\n     * @notice One-sided remove of ETH from the Curve pool, convert to WETH\n     * and transfer to the vault.\n     * This is used when the Curve pool does not have enough OTokens and too many ETH.\n     * The OToken/Asset, eg OETH/ETH, price with decrease.\n     * The amount of assets in the vault increases.\n     * The total supply of OTokens does not change.\n     * The asset value of the strategy reduces.\n     * The asset value of the vault should be close to the same.\n     * @param _lpTokens The amount of Curve pool LP tokens to be burned for ETH.\n     * @dev Curve pool LP tokens is used rather than WETH assets as Curve does not\n     * have a way to accurately calculate the amount of LP tokens for a required\n     * amount of ETH. Curve's `calc_token_amount` functioun does not include fees.\n     * A 3rd party libary can be used that takes into account the fees, but this\n     * is a gas intensive process. It's easier for the trusted strategist to\n     * caclulate the amount of Curve pool LP tokens required off-chain.\n     */\n    function removeOnlyAssets(uint256 _lpTokens)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n    {\n        // Withdraw Curve pool LP tokens from Convex and remove ETH from the Curve pool\n        uint256 ethAmount = _withdrawAndRemoveFromPool(_lpTokens, ethCoinIndex);\n\n        // Convert ETH to WETH and transfer to the vault\n        weth.deposit{ value: ethAmount }();\n        require(\n            weth.transfer(vaultAddress, ethAmount),\n            \"Transfer of WETH not successful\"\n        );\n\n        emit Withdrawal(address(weth), address(lpToken), ethAmount);\n    }\n\n    /**\n     * @dev Remove Curve pool LP tokens from the Convex pool and\n     * do a one-sided remove of ETH or OETH from the Curve pool.\n     * @param _lpTokens The amount of Curve pool LP tokens to be removed from the Convex pool.\n     * @param coinIndex The index of the coin to be removed from the Curve pool. 0 = ETH, 1 = OETH.\n     * @return coinsRemoved The amount of ETH or OETH removed from the Curve pool.\n     */\n    function _withdrawAndRemoveFromPool(uint256 _lpTokens, uint128 coinIndex)\n        internal\n        returns (uint256 coinsRemoved)\n    {\n        // Withdraw Curve pool LP tokens from Convex pool\n        _lpWithdraw(_lpTokens);\n\n        // Convert Curve pool LP tokens to ETH value\n        uint256 valueInEth = _lpTokens.mulTruncate(\n            curvePool.get_virtual_price()\n        );\n        // Apply slippage to ETH value\n        uint256 minAmount = valueInEth.mulTruncate(\n            uint256(1e18) - MAX_SLIPPAGE\n        );\n\n        // Remove just the ETH from the Curve pool\n        coinsRemoved = curvePool.remove_liquidity_one_coin(\n            _lpTokens,\n            int128(coinIndex),\n            minAmount,\n            address(this)\n        );\n    }\n\n    /***************************************\n                Assets and Rewards\n    ****************************************/\n\n    /**\n     * @notice Collect accumulated CRV and CVX rewards and send to the Harvester.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Collect CRV and CVX\n        cvxRewardStaker.getReward();\n        _collectRewardTokens();\n    }\n\n    function _lpWithdraw(uint256 _wethAmount) internal {\n        // withdraw and unwrap with claim takes back the lpTokens\n        // and also collects the rewards for deposit\n        cvxRewardStaker.withdrawAndUnwrap(_wethAmount, true);\n    }\n\n    /**\n     * @notice Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == address(weth), \"Unsupported asset\");\n\n        // Eth balance needed here for the balance check that happens from vault during depositing.\n        balance = address(this).balance;\n        uint256 lpTokens = cvxRewardStaker.balanceOf(address(this));\n        if (lpTokens > 0) {\n            balance += (lpTokens * curvePool.get_virtual_price()) / 1e18;\n        }\n    }\n\n    /**\n     * @notice Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == address(weth);\n    }\n\n    /***************************************\n                    Approvals\n    ****************************************/\n\n    /**\n     * @notice Approve the spending of all assets by their corresponding pool tokens,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        _approveBase();\n    }\n\n    /**\n     * @notice Accept unwrapped WETH\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Since we are unwrapping WETH before depositing it to Curve\n     *      there is no need to set an approval for WETH on the Curve\n     *      pool\n     * @param _asset Address of the asset\n     * @param _pToken Address of the Curve LP token\n     */\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        override\n    {}\n\n    function _approveBase() internal {\n        // Approve Curve pool for OETH (required for adding liquidity)\n        // No approval is needed for ETH\n        // slither-disable-next-line unused-return\n        oeth.approve(platformAddress, type(uint256).max);\n\n        // Approve Convex deposit contract to transfer Curve pool LP tokens\n        // This is needed for deposits if Curve pool LP tokens into the Convex rewards pool\n        // slither-disable-next-line unused-return\n        lpToken.approve(cvxDepositorAddress, type(uint256).max);\n    }\n\n    /**\n     * @dev Returns the largest of two numbers int256 version\n     */\n    function _max(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n}\n"
    },
    "contracts/strategies/ConvexGeneralizedMetaStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Curve Convex Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport { IRewardStaking } from \"./IRewardStaking.sol\";\nimport { IConvexDeposits } from \"./IConvexDeposits.sol\";\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"./AbstractCurveStrategy.sol\";\nimport { AbstractConvexMetaStrategy } from \"./AbstractConvexMetaStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\ncontract ConvexGeneralizedMetaStrategy is AbstractConvexMetaStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /* Take 3pool LP and deposit it to metapool. Take the LP from metapool\n     * and deposit them to Convex.\n     */\n    function _lpDepositAll() internal override {\n        IERC20 threePoolLp = IERC20(pTokenAddress);\n        ICurvePool curvePool = ICurvePool(platformAddress);\n\n        uint256 threePoolLpBalance = threePoolLp.balanceOf(address(this));\n        uint256 curve3PoolVirtualPrice = curvePool.get_virtual_price();\n        uint256 threePoolLpDollarValue = threePoolLpBalance.mulTruncate(\n            curve3PoolVirtualPrice\n        );\n\n        uint256[2] memory _amounts = [0, threePoolLpBalance];\n\n        uint256 metapoolVirtualPrice = metapool.get_virtual_price();\n        /**\n         * First convert all the deposited tokens to dollar values,\n         * then divide by virtual price to convert to metapool LP tokens\n         * and apply the max slippage\n         */\n        uint256 minReceived = threePoolLpDollarValue\n            .divPrecisely(metapoolVirtualPrice)\n            .mulTruncate(uint256(1e18) - MAX_SLIPPAGE);\n\n        uint256 metapoolLp = metapool.add_liquidity(_amounts, minReceived);\n\n        bool success = IConvexDeposits(cvxDepositorAddress).deposit(\n            cvxDepositorPTokenId,\n            metapoolLp,\n            true // Deposit with staking\n        );\n\n        require(success, \"Failed to deposit to Convex\");\n    }\n\n    /**\n     * Withdraw the specified amount of tokens from the gauge. And use all the resulting tokens\n     * to remove liquidity from metapool\n     * @param num3CrvTokens Number of Convex 3pool LP tokens to withdraw from metapool\n     */\n    function _lpWithdraw(uint256 num3CrvTokens) internal override {\n        uint256 gaugeTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n\n        uint256 requiredMetapoolLpTokens = _calcCurveMetaTokenAmount(\n            crvCoinIndex,\n            num3CrvTokens\n        );\n\n        require(\n            requiredMetapoolLpTokens <= gaugeTokens,\n            string(\n                bytes.concat(\n                    bytes(\"Attempting to withdraw \"),\n                    bytes(Strings.toString(requiredMetapoolLpTokens)),\n                    bytes(\", metapoolLP but only \"),\n                    bytes(Strings.toString(gaugeTokens)),\n                    bytes(\" available.\")\n                )\n            )\n        );\n\n        // withdraw and unwrap with claim takes back the lpTokens and also collects the rewards for deposit\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            requiredMetapoolLpTokens,\n            true\n        );\n\n        if (requiredMetapoolLpTokens > 0) {\n            // slither-disable-next-line unused-return\n            metapool.remove_liquidity_one_coin(\n                requiredMetapoolLpTokens,\n                int128(crvCoinIndex),\n                num3CrvTokens\n            );\n        }\n    }\n\n    function _lpWithdrawAll() internal override {\n        uint256 gaugeTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            gaugeTokens,\n            true\n        );\n\n        if (gaugeTokens > 0) {\n            uint256 burnDollarAmount = gaugeTokens.mulTruncate(\n                metapool.get_virtual_price()\n            );\n            uint256 curve3PoolExpected = burnDollarAmount.divPrecisely(\n                ICurvePool(platformAddress).get_virtual_price()\n            );\n\n            // Always withdraw all of the available metapool LP tokens (similar to how we always deposit all)\n            // slither-disable-next-line unused-return\n            metapool.remove_liquidity_one_coin(\n                gaugeTokens,\n                int128(crvCoinIndex),\n                curve3PoolExpected -\n                    curve3PoolExpected.mulTruncate(maxWithdrawalSlippage)\n            );\n        }\n    }\n}\n"
    },
    "contracts/strategies/ConvexOUSDMetaStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Curve Convex Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { IRewardStaking } from \"./IRewardStaking.sol\";\nimport { IConvexDeposits } from \"./IConvexDeposits.sol\";\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"./AbstractCurveStrategy.sol\";\nimport { AbstractConvexMetaStrategy } from \"./AbstractConvexMetaStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract ConvexOUSDMetaStrategy is AbstractConvexMetaStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /* Take 3pool LP and mint the corresponding amount of ousd. Deposit and stake that to\n     * ousd Curve Metapool. Take the LP from metapool and deposit them to Convex.\n     */\n    function _lpDepositAll() internal override {\n        ICurvePool curvePool = ICurvePool(platformAddress);\n\n        uint256 threePoolLpBalance = IERC20(pTokenAddress).balanceOf(\n            address(this)\n        );\n        uint256 curve3PoolVirtualPrice = curvePool.get_virtual_price();\n        uint256 threePoolLpDollarValue = threePoolLpBalance.mulTruncate(\n            curve3PoolVirtualPrice\n        );\n\n        // safe to cast since min value is at least 0\n        uint256 ousdToAdd = uint256(\n            _max(\n                0,\n                int256(\n                    metapool.balances(crvCoinIndex).mulTruncate(\n                        curve3PoolVirtualPrice\n                    )\n                ) -\n                    int256(metapool.balances(mainCoinIndex)) +\n                    int256(threePoolLpDollarValue)\n            )\n        );\n\n        /* Add so much OUSD so that the pool ends up being balanced. And at minimum\n         * add twice as much OUSD as 3poolLP and at maximum at twice as\n         * much OUSD.\n         */\n        ousdToAdd = Math.max(ousdToAdd, threePoolLpDollarValue);\n        ousdToAdd = Math.min(ousdToAdd, threePoolLpDollarValue * 2);\n\n        /* Mint OUSD with a strategy that attempts to contribute to stability of OUSD metapool. Try\n         * to mint so much OUSD that after deployment of liquidity pool ends up being balanced.\n         *\n         * To manage unpredictability minimal OUSD minted will always be at least equal or greater\n         * to stablecoin(DAI, USDC, USDT) amount of 3CRVLP deployed. And never larger than twice the\n         * stablecoin amount of 3CRVLP deployed even if it would have a further beneficial effect\n         * on pool stability.\n         */\n        if (ousdToAdd > 0) {\n            IVault(vaultAddress).mintForStrategy(ousdToAdd);\n        }\n\n        uint256[2] memory _amounts = [ousdToAdd, threePoolLpBalance];\n\n        uint256 metapoolVirtualPrice = metapool.get_virtual_price();\n        /**\n         * First convert all the deposited tokens to dollar values,\n         * then divide by virtual price to convert to metapool LP tokens\n         * and apply the max slippage\n         */\n        uint256 minReceived = (ousdToAdd + threePoolLpDollarValue)\n            .divPrecisely(metapoolVirtualPrice)\n            .mulTruncate(uint256(1e18) - MAX_SLIPPAGE);\n\n        uint256 metapoolLp = metapool.add_liquidity(_amounts, minReceived);\n\n        bool success = IConvexDeposits(cvxDepositorAddress).deposit(\n            cvxDepositorPTokenId,\n            metapoolLp,\n            true // Deposit with staking\n        );\n\n        require(success, \"Failed to deposit to Convex\");\n    }\n\n    /**\n     * Withdraw the specified amount of tokens from the gauge. And use all the resulting tokens\n     * to remove liquidity from metapool\n     * @param num3CrvTokens Number of 3CRV tokens to withdraw from metapool\n     */\n    function _lpWithdraw(uint256 num3CrvTokens) internal override {\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        /* The rate between coins in the metapool determines the rate at which metapool returns\n         * tokens when doing balanced removal (remove_liquidity call). And by knowing how much 3crvLp\n         * we want we can determine how much of OUSD we receive by removing liquidity.\n         *\n         * Because we are doing balanced removal we should be making profit when removing liquidity in a\n         * pool tilted to either side.\n         *\n         * Important: A downside is that the Strategist / Governor needs to be\n         * cognisant of not removing too much liquidity. And while the proposal to remove liquidity\n         * is being voted on the pool tilt might change so much that the proposal that has been valid while\n         * created is no longer valid.\n         */\n\n        uint256 crvPoolBalance = metapool.balances(crvCoinIndex);\n        /* K is multiplied by 1e36 which is used for higher precision calculation of required\n         * metapool LP tokens. Without it the end value can have rounding errors up to precision of\n         * 10 digits. This way we move the decimal point by 36 places when doing the calculation\n         * and again by 36 places when we are done with it.\n         */\n        uint256 k = (1e36 * metapoolLPToken.totalSupply()) / crvPoolBalance;\n        // simplifying below to: `uint256 diff = (num3CrvTokens - 1) * k` causes loss of precision\n        // prettier-ignore\n        // slither-disable-next-line divide-before-multiply\n        uint256 diff = crvPoolBalance * k -\n            (crvPoolBalance - num3CrvTokens - 1) * k;\n        uint256 lpToBurn = diff / 1e36;\n\n        uint256 gaugeTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n\n        require(\n            lpToBurn <= gaugeTokens,\n            string(\n                bytes.concat(\n                    bytes(\"Attempting to withdraw \"),\n                    bytes(Strings.toString(lpToBurn)),\n                    bytes(\", metapoolLP but only \"),\n                    bytes(Strings.toString(gaugeTokens)),\n                    bytes(\" available.\")\n                )\n            )\n        );\n\n        // withdraw and unwrap with claim takes back the lpTokens and also collects the rewards for deposit\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            lpToBurn,\n            true\n        );\n\n        // calculate the min amount of OUSD expected for the specified amount of LP tokens\n        uint256 minOUSDAmount = lpToBurn.mulTruncate(\n            metapool.get_virtual_price()\n        ) -\n            num3CrvTokens.mulTruncate(curvePool.get_virtual_price()) -\n            1;\n\n        // withdraw the liquidity from metapool\n        uint256[2] memory _removedAmounts = metapool.remove_liquidity(\n            lpToBurn,\n            [minOUSDAmount, num3CrvTokens]\n        );\n\n        IVault(vaultAddress).burnForStrategy(_removedAmounts[mainCoinIndex]);\n    }\n\n    function _lpWithdrawAll() internal override {\n        IERC20 metapoolErc20 = IERC20(address(metapool));\n        uint256 gaugeTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            gaugeTokens,\n            true\n        );\n\n        uint256[2] memory _minAmounts = [uint256(0), uint256(0)];\n        uint256[2] memory _removedAmounts = metapool.remove_liquidity(\n            metapoolErc20.balanceOf(address(this)),\n            _minAmounts\n        );\n\n        IVault(vaultAddress).burnForStrategy(_removedAmounts[mainCoinIndex]);\n    }\n}\n"
    },
    "contracts/strategies/ConvexStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Curve Convex Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { IRewardStaking } from \"./IRewardStaking.sol\";\nimport { IConvexDeposits } from \"./IConvexDeposits.sol\";\nimport { IERC20, AbstractCurveStrategy, InitializableAbstractStrategy } from \"./AbstractCurveStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\n\n/*\n * IMPORTANT(!) If ConvexStrategy needs to be re-deployed, it requires new\n * proxy contract with fresh storage slots. Changes in `AbstractCurveStrategy`\n * storage slots would break existing implementation.\n *\n * Remove this notice if ConvexStrategy is re-deployed\n */\ncontract ConvexStrategy is AbstractCurveStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address internal cvxDepositorAddress;\n    address internal cvxRewardStakerAddress;\n    // slither-disable-next-line constable-states\n    address private _deprecated_cvxRewardTokenAddress;\n    uint256 internal cvxDepositorPTokenId;\n\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Curve strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Address of CRV & CVX\n     * @param _assets Addresses of supported assets. MUST be passed in the same\n     *                order as returned by coins on the pool contract, i.e.\n     *                DAI, USDC, USDT\n     * @param _pTokens Platform Token corresponding addresses\n     * @param _cvxDepositorAddress Address of the Convex depositor(AKA booster) for this pool\n     * @param _cvxRewardStakerAddress Address of the CVX rewards staker\n     * @param _cvxDepositorPTokenId Pid of the pool referred to by Depositor and staker\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // CRV + CVX\n        address[] calldata _assets,\n        address[] calldata _pTokens,\n        address _cvxDepositorAddress,\n        address _cvxRewardStakerAddress,\n        uint256 _cvxDepositorPTokenId\n    ) external onlyGovernor initializer {\n        require(_assets.length == 3, \"Must have exactly three assets\");\n        // Should be set prior to abstract initialize call otherwise\n        // abstractSetPToken calls will fail\n        cvxDepositorAddress = _cvxDepositorAddress;\n        cvxRewardStakerAddress = _cvxRewardStakerAddress;\n        cvxDepositorPTokenId = _cvxDepositorPTokenId;\n        pTokenAddress = _pTokens[0];\n\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n        _approveBase();\n    }\n\n    function _lpDepositAll() internal override {\n        IERC20 pToken = IERC20(pTokenAddress);\n        // Deposit with staking\n        bool success = IConvexDeposits(cvxDepositorAddress).deposit(\n            cvxDepositorPTokenId,\n            pToken.balanceOf(address(this)),\n            true\n        );\n        require(success, \"Failed to deposit to Convex\");\n    }\n\n    function _lpWithdraw(uint256 numCrvTokens) internal override {\n        uint256 gaugePTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n\n        // Not enough in this contract or in the Gauge, can't proceed\n        require(numCrvTokens > gaugePTokens, \"Insufficient 3CRV balance\");\n\n        // withdraw and unwrap with claim takes back the lpTokens and also collects the rewards to this\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            numCrvTokens,\n            true\n        );\n    }\n\n    function _lpWithdrawAll() internal override {\n        // withdraw and unwrap with claim takes back the lpTokens and also collects the rewards to this\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            IRewardStaking(cvxRewardStakerAddress).balanceOf(address(this)),\n            true\n        );\n    }\n\n    function _approveBase() internal override {\n        IERC20 pToken = IERC20(pTokenAddress);\n        // 3Pool for LP token (required for removing liquidity)\n        pToken.safeApprove(platformAddress, 0);\n        pToken.safeApprove(platformAddress, type(uint256).max);\n        // Gauge for LP token\n        pToken.safeApprove(cvxDepositorAddress, 0);\n        pToken.safeApprove(cvxDepositorAddress, type(uint256).max);\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(assetToPToken[_asset] != address(0), \"Unsupported asset\");\n        // LP tokens in this contract. This should generally be nothing as we\n        // should always stake the full balance in the Gauge, but include for\n        // safety\n        uint256 contractPTokens = IERC20(pTokenAddress).balanceOf(\n            address(this)\n        );\n        uint256 gaugePTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n        uint256 totalPTokens = contractPTokens + gaugePTokens;\n\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        if (totalPTokens > 0) {\n            uint256 virtual_price = curvePool.get_virtual_price();\n            uint256 value = (totalPTokens * virtual_price) / 1e18;\n            uint256 assetDecimals = Helpers.getDecimals(_asset);\n            balance = value.scaleBy(assetDecimals, 18) / 3;\n        }\n    }\n\n    /**\n     * @dev Collect accumulated CRV and CVX and send to Vault.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Collect CRV and CVX\n        IRewardStaking(cvxRewardStakerAddress).getReward();\n        _collectRewardTokens();\n    }\n}\n"
    },
    "contracts/strategies/FluxStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Flux Strategy\n * @notice Investment strategy for investing stablecoins via Flux\n * @author Origin Protocol Inc\n */\n\nimport { CompoundStrategy } from \"./CompoundStrategy.sol\";\n\ncontract FluxStrategy is CompoundStrategy {\n    constructor(BaseStrategyConfig memory _stratConfig)\n        CompoundStrategy(_stratConfig)\n    {}\n\n    /**\n     * @inheritdoc CompoundStrategy\n     */\n    function collectRewardTokens() external override {\n        // Intentionally not adding any modifiers to not increase contract size\n        // Flux strategy has no reward tokens\n    }\n}\n"
    },
    "contracts/strategies/FraxETHStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OETH FraxETH Strategy\n * @notice Investment WETH and FraxETH into the sFraxETH staking contract\n * @author Origin Protocol Inc\n */\nimport { IERC4626 } from \"../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { IFraxETHMinter } from \"../interfaces/IFraxETHMinter.sol\";\nimport { Generalized4626Strategy, IERC20, InitializableAbstractStrategy } from \"./Generalized4626Strategy.sol\";\n\ncontract FraxETHStrategy is Generalized4626Strategy {\n    using SafeERC20 for IERC20;\n\n    address public constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    IFraxETHMinter public constant fraxETHMinter =\n        IFraxETHMinter(0xbAFA44EFE7901E04E39Dad13167D089C559c1138);\n\n    /**\n     * @param _baseConfig Base strategy config with platformAddress (sfrxETH) and vaultAddress (OETHVaultProxy)\n     * @param _assetToken Address of the ERC-4626 asset token (frxETH)\n     */\n    constructor(BaseStrategyConfig memory _baseConfig, address _assetToken)\n        Generalized4626Strategy(_baseConfig, _assetToken)\n    {}\n\n    function initialize() external override onlyGovernor initializer {\n        address[] memory rewardTokens = new address[](0);\n        address[] memory assets = new address[](2);\n        address[] memory pTokens = new address[](2);\n\n        assets[0] = address(assetToken);\n        assets[1] = address(weth);\n        pTokens[0] = address(platformAddress);\n        pTokens[1] = address(platformAddress);\n\n        InitializableAbstractStrategy._initialize(\n            rewardTokens,\n            assets,\n            pTokens\n        );\n    }\n\n    function _deposit(address _asset, uint256 _amount) internal override {\n        require(_amount > 0, \"Must deposit something\");\n\n        if (_asset == weth) {\n            // Unwrap WETH\n            IWETH9(weth).withdraw(_amount);\n\n            // Deposit ETH for frxETH and stake it\n            // slither-disable-next-line unused-return\n            fraxETHMinter.submitAndDeposit{ value: _amount }(address(this));\n        } else if (_asset == address(assetToken)) {\n            // Stake frxETH\n            // slither-disable-next-line unused-return\n            IERC4626(platformAddress).deposit(_amount, address(this));\n        } else {\n            revert(\"Unexpected asset address\");\n        }\n\n        emit Deposit(_asset, address(shareToken), _amount);\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == address(assetToken) || _asset == weth;\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        virtual\n        override\n        returns (uint256 balance)\n    {\n        if (_asset == weth) {\n            // For WETH, it's always 0\n            return 0;\n        }\n\n        // If it's not WETH, it has to be frxETH\n        require(_asset == address(assetToken), \"Unexpected asset address\");\n\n        /* We are intentionally not counting the amount of assetToken parked on the\n         * contract toward the checkBalance. The deposit and withdraw functions\n         * should not result in assetToken being unused and owned by this strategy\n         * contract.\n         */\n        return IERC4626(platformAddress).maxWithdraw(address(this));\n    }\n\n    /**\n     * @dev Deposit the entire balance of assetToken to gain shareToken\n     */\n    function depositAll() external virtual override onlyVault nonReentrant {\n        uint256 balance = assetToken.balanceOf(address(this));\n        if (balance > 0) {\n            _deposit(address(assetToken), balance);\n        }\n\n        uint256 wethBalance = IWETH9(weth).balanceOf(address(this));\n        if (wethBalance > 0) {\n            _deposit(weth, wethBalance);\n        }\n    }\n\n    /**\n     * @dev Accept ETH\n     */\n    receive() external payable {}\n}\n"
    },
    "contracts/strategies/FrxEthRedeemStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC721Receiver } from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ninterface IFraxEtherRedemptionQueue {\n    function burnRedemptionTicketNft(uint256 _nftId, address payable _recipient)\n        external;\n\n    function enterRedemptionQueue(address _recipient, uint120 _amountToRedeem)\n        external\n        returns (uint256 _nftId);\n}\n\n/**\n * @title Frax ETH Redeem Strategy\n * @notice This strategy redeems Frax ETH for ETH via the Frax Eth Redemption Queue contract\n * @author Origin Protocol Inc\n */\ncontract FrxEthRedeemStrategy is InitializableAbstractStrategy {\n    IWETH9 private constant weth =\n        IWETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20 private constant frxETH =\n        IERC20(0x5E8422345238F34275888049021821E8E08CAa1f);\n    IFraxEtherRedemptionQueue private constant redemptionQueue =\n        IFraxEtherRedemptionQueue(0x82bA8da44Cd5261762e629dd5c605b17715727bd);\n    uint256 public constant maxRedeemTicket = 250e18;\n    uint256 public outstandingRedeems;\n\n    event RedeemNFTMinted(uint256 _nftId, uint256 _amount);\n    event RedeemNFTBurned(uint256 _nftId);\n\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {\n        require(maxRedeemTicket < type(uint120).max);\n    }\n\n    /**\n     * @notice initialize function, to set up initial internal state\n     * @param _rewardTokenAddresses Address of reward token for platform\n     * @param _assets Addresses of initial supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function initialize(\n        address[] memory _rewardTokenAddresses,\n        address[] memory _assets,\n        address[] memory _pTokens\n    ) external onlyGovernor initializer {\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n        safeApproveAllTokens();\n    }\n\n    /**\n     * @notice deposit() function not used for this strategy. Use depositAll() instead.\n     */\n    function deposit(address, uint256) public override onlyVault nonReentrant {\n        // This method no longer used by the VaultAdmin, and we don't want it\n        // to be used by VaultCore.\n        require(false, \"use depositAll() instead\");\n    }\n\n    /**\n     * @notice Takes all given frxETH and creates new redeem tickets\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 frxETHStart = frxETH.balanceOf(address(this));\n        require(frxETHStart > 0, \"No frxETH to redeem\");\n        uint256 frxETHRemaining = frxETHStart;\n\n        while (frxETHRemaining > 0) {\n            uint256 amount = frxETHRemaining > maxRedeemTicket\n                ? maxRedeemTicket\n                : frxETHRemaining;\n            uint256 nftId = redemptionQueue.enterRedemptionQueue(\n                address(this),\n                uint120(amount)\n            );\n            frxETHRemaining -= amount;\n            emit RedeemNFTMinted(nftId, amount);\n        }\n\n        require(\n            frxETH.balanceOf(address(this)) == 0,\n            \"Not all FraxEth sent to redemption queue\"\n        );\n        outstandingRedeems += frxETHStart; // Single set for gas reasons\n\n        // This strategy claims to support WETH, so it is posible for\n        // the vault to transfer WETH to it. This returns any deposited WETH\n        // to the vault so that it is not lost for balance tracking purposes.\n        uint256 wethBalance = weth.balanceOf(address(this));\n        if (wethBalance > 0) {\n            // slither-disable-next-line unchecked-transfer\n            weth.transfer(vaultAddress, wethBalance);\n        }\n\n        emit Deposit(address(frxETH), address(redemptionQueue), frxETHStart);\n    }\n\n    /**\n     * @notice Withdraw an asset from the underlying platform\n     * @param _recipient Address to receive withdrawn assets\n     * @param _asset Address of the asset to withdraw\n     * @param _amount Amount of assets to withdraw\n     */\n    function withdraw(\n        // solhint-disable-next-line no-unused-vars\n        address _recipient,\n        // solhint-disable-next-line no-unused-vars\n        address _asset,\n        // solhint-disable-next-line no-unused-vars\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        // Does nothing - all redeems need to be called manually by the\n        // strategist via redeemTickets\n        require(false, \"use redeemTickets() instead\");\n    }\n\n    /**\n     * @notice Redeem specific tickets from the Queue.\n     * Called by the strategist.\n     * @param _nftIds Array of NFT IDs to redeem\n     */\n    function redeemTickets(uint256[] memory _nftIds, uint256 expectedAmount)\n        external\n        nonReentrant\n    {\n        require(\n            msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Strategist\"\n        );\n        uint256 startingBalance = payable(address(this)).balance;\n        for (uint256 i = 0; i < _nftIds.length; i++) {\n            uint256 nftId = _nftIds[i];\n            redemptionQueue.burnRedemptionTicketNft(\n                nftId,\n                payable(address(this))\n            );\n            emit RedeemNFTBurned(nftId);\n        }\n\n        uint256 currentBalance = payable(address(this)).balance;\n        uint256 redeemedAmount = currentBalance - startingBalance;\n        require(\n            expectedAmount == redeemedAmount,\n            \"Redeemed amount does not match expected amount\"\n        );\n        outstandingRedeems -= redeemedAmount;\n        weth.deposit{ value: currentBalance }();\n        // slither-disable-next-line unchecked-transfer\n        weth.transfer(vaultAddress, currentBalance);\n        emit Withdrawal(\n            address(weth),\n            address(redemptionQueue),\n            currentBalance\n        );\n    }\n\n    function _abstractSetPToken(address, address) internal override {\n        revert(\"No pTokens are used\");\n    }\n\n    /**\n     * @notice Withdraw all assets from this strategy, and transfer to the Vault.\n     * In correct operation, this strategy should never hold any assets.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        if (payable(address(this)).balance > 0) {\n            weth.deposit{ value: payable(address(this)).balance }();\n        }\n        uint256 wethBalance = weth.balanceOf(address(this));\n        if (wethBalance > 0) {\n            // slither-disable-next-line unchecked-transfer\n            weth.transfer(vaultAddress, wethBalance);\n            emit Withdrawal(address(weth), address(0), wethBalance);\n        }\n        uint256 fraxEthBalance = frxETH.balanceOf(address(this));\n        if (fraxEthBalance > 0) {\n            // slither-disable-next-line unchecked-transfer\n            frxETH.transfer(vaultAddress, fraxEthBalance);\n            emit Withdrawal(address(frxETH), address(0), fraxEthBalance);\n        }\n    }\n\n    /**\n     * @notice Returns the amount of queued FraxEth that will be returned as WETH.\n     * We return this as a WETH asset, since that is what it will eventually be returned as.\n     * We only return the outstandingRedeems, because the contract itself should never hold any funds.\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        if (_asset == address(weth)) {\n            return outstandingRedeems;\n        } else if (_asset == address(frxETH)) {\n            return 0;\n        } else {\n            revert(\"Unexpected asset address\");\n        }\n    }\n\n    /**\n     * @notice Approve the spending of all assets by their corresponding cToken,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens() public override {\n        // slither-disable-next-line unused-return\n        frxETH.approve(address(redemptionQueue), type(uint256).max);\n    }\n\n    /**\n     * @notice Check if an asset is supported.\n     * @param _asset    Address of the asset\n     * @return bool     Whether asset is supported\n     */\n    function supportsAsset(address _asset) public pure override returns (bool) {\n        // frxETH can be deposited by the vault and balances are reported in weth\n        return _asset == address(frxETH) || _asset == address(weth);\n    }\n\n    function onERC721Received(\n        // solhint-disable-next-line no-unused-vars\n        address operator,\n        // solhint-disable-next-line no-unused-vars\n        address from,\n        // solhint-disable-next-line no-unused-vars\n        uint256 tokenId,\n        // solhint-disable-next-line no-unused-vars\n        bytes calldata data\n    ) external returns (bytes4) {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/strategies/Generalized4626Strategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Generalized 4626 Strategy\n * @notice Investment strategy for ERC-4626 Tokenized Vaults\n * @author Origin Protocol Inc\n */\nimport { IERC4626 } from \"../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\n\ncontract Generalized4626Strategy is InitializableAbstractStrategy {\n    using SafeERC20 for IERC20;\n\n    /// @dev Replaced with an immutable variable\n    // slither-disable-next-line constable-states\n    address private _deprecate_shareToken;\n    /// @dev Replaced with an immutable variable\n    // slither-disable-next-line constable-states\n    address private _deprecate_assetToken;\n\n    IERC20 public immutable shareToken;\n    IERC20 public immutable assetToken;\n\n    // For future use\n    uint256[50] private __gap;\n\n    /**\n     * @param _baseConfig Base strategy config with platformAddress (ERC-4626 Vault contract), eg sfrxETH or sDAI,\n     * and vaultAddress (OToken Vault contract), eg VaultProxy or OETHVaultProxy\n     * @param _assetToken Address of the ERC-4626 asset token. eg frxETH or DAI\n     */\n    constructor(BaseStrategyConfig memory _baseConfig, address _assetToken)\n        InitializableAbstractStrategy(_baseConfig)\n    {\n        shareToken = IERC20(_baseConfig.platformAddress);\n        assetToken = IERC20(_assetToken);\n    }\n\n    function initialize() external virtual onlyGovernor initializer {\n        address[] memory rewardTokens = new address[](0);\n        address[] memory assets = new address[](1);\n        address[] memory pTokens = new address[](1);\n\n        assets[0] = address(assetToken);\n        pTokens[0] = address(platformAddress);\n\n        InitializableAbstractStrategy._initialize(\n            rewardTokens,\n            assets,\n            pTokens\n        );\n    }\n\n    /**\n     * @dev Deposit assets by converting them to shares\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @dev Deposit assets by converting them to shares\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal virtual {\n        require(_amount > 0, \"Must deposit something\");\n        require(_asset == address(assetToken), \"Unexpected asset address\");\n\n        // slither-disable-next-line unused-return\n        IERC4626(platformAddress).deposit(_amount, address(this));\n        emit Deposit(_asset, address(shareToken), _amount);\n    }\n\n    /**\n     * @dev Deposit the entire balance of assetToken to gain shareToken\n     */\n    function depositAll() external virtual override onlyVault nonReentrant {\n        uint256 balance = assetToken.balanceOf(address(this));\n        if (balance > 0) {\n            _deposit(address(assetToken), balance);\n        }\n    }\n\n    /**\n     * @dev Withdraw asset by burning shares\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external virtual override onlyVault nonReentrant {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n        require(_asset == address(assetToken), \"Unexpected asset address\");\n\n        // slither-disable-next-line unused-return\n        IERC4626(platformAddress).withdraw(_amount, _recipient, address(this));\n        emit Withdrawal(_asset, address(shareToken), _amount);\n    }\n\n    /**\n     * @dev Internal method to respond to the addition of new asset / share tokens\n     */\n    function _abstractSetPToken(address, address) internal virtual override {\n        _approveBase();\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll()\n        external\n        virtual\n        override\n        onlyVaultOrGovernor\n        nonReentrant\n    {\n        uint256 shareBalance = shareToken.balanceOf(address(this));\n        uint256 assetAmount = 0;\n        if (shareBalance > 0) {\n            assetAmount = IERC4626(platformAddress).redeem(\n                shareBalance,\n                vaultAddress,\n                address(this)\n            );\n            emit Withdrawal(\n                address(assetToken),\n                address(shareToken),\n                assetAmount\n            );\n        }\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        virtual\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == address(assetToken), \"Unexpected asset address\");\n        /* We are intentionally not counting the amount of assetToken parked on the\n         * contract toward the checkBalance. The deposit and withdraw functions\n         * should not result in assetToken being unused and owned by this strategy\n         * contract.\n         */\n        return IERC4626(platformAddress).maxWithdraw(address(this));\n    }\n\n    /**\n     * @notice Governor approves the the ERC-4626 Tokenized Vault to spend the asset.\n     */\n    function safeApproveAllTokens() external override onlyGovernor {\n        _approveBase();\n    }\n\n    function _approveBase() internal virtual {\n        // Approval the asset to be trasferred to the ERC-4626 Tokenized Vualt.\n        // Used by the ERC-4626 deposit() and mint() functions\n        // slither-disable-next-line unused-return\n        assetToken.approve(platformAddress, type(uint256).max);\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _asset == address(assetToken);\n    }\n\n    /**\n     * @notice is not supported for this strategy as the asset and\n     * ERC-4626 Tokenized Vault are set at deploy time.\n     * @dev If the ERC-4626 Tokenized Vault needed to be changed, a new\n     * contract would need to be deployed and the proxy updated.\n     */\n    function setPTokenAddress(address, address) external override onlyGovernor {\n        revert(\"unsupported function\");\n    }\n\n    /**\n     * @notice is not supported for this strategy as the asset and\n     * ERC-4626 Tokenized Vault are set at deploy time.\n     * @dev If the ERC-4626 Tokenized Vault needed to be changed, a new\n     * contract would need to be deployed and the proxy updated.\n     */\n    function removePToken(uint256) external override onlyGovernor {\n        revert(\"unsupported function\");\n    }\n}\n"
    },
    "contracts/strategies/IAave.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface for Aaves Lending Pool\n * Documentation: https://developers.aave.com/#lendingpool\n */\ninterface IAaveLendingPool {\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n}\n\n/**\n * @dev Interface for Aaves Lending Pool\n * Documentation: https://developers.aave.com/#lendingpooladdressesprovider\n */\ninterface ILendingPoolAddressesProvider {\n    /**\n     * @notice Get the current address for Aave LendingPool\n     * @dev Lending pool is the core contract on which to call deposit\n     */\n    function getLendingPool() external view returns (address);\n}\n"
    },
    "contracts/strategies/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IAaveIncentivesController {\n    event RewardsAccrued(address indexed user, uint256 amount);\n\n    event RewardsClaimed(\n        address indexed user,\n        address indexed to,\n        uint256 amount\n    );\n\n    event RewardsClaimed(\n        address indexed user,\n        address indexed to,\n        address indexed claimer,\n        uint256 amount\n    );\n\n    event ClaimerSet(address indexed user, address indexed claimer);\n\n    /*\n     * @dev Returns the configuration of the distribution for a certain asset\n     * @param asset The address of the reference asset of the distribution\n     * @return The asset index, the emission per second and the last updated timestamp\n     **/\n    function getAssetData(address asset)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    /**\n     * @dev Whitelists an address to claim the rewards on behalf of another address\n     * @param user The address of the user\n     * @param claimer The address of the claimer\n     */\n    function setClaimer(address user, address claimer) external;\n\n    /**\n     * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\n     * @param user The address of the user\n     * @return The claimer address\n     */\n    function getClaimer(address user) external view returns (address);\n\n    /**\n     * @dev Configure assets for a certain rewards emission\n     * @param assets The assets to incentivize\n     * @param emissionsPerSecond The emission for each asset\n     */\n    function configureAssets(\n        address[] calldata assets,\n        uint256[] calldata emissionsPerSecond\n    ) external;\n\n    /**\n     * @dev Called by the corresponding asset on any update that affects the rewards distribution\n     * @param asset The address of the user\n     * @param userBalance The balance of the user of the asset in the lending pool\n     * @param totalSupply The total supply of the asset in the lending pool\n     **/\n    function handleAction(\n        address asset,\n        uint256 userBalance,\n        uint256 totalSupply\n    ) external;\n\n    /**\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n     * @param user The address of the user\n     * @return The rewards\n     **/\n    function getRewardsBalance(address[] calldata assets, address user)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Claims reward for an user, on all the assets of the lending pool,\n     * accumulating the pending rewards\n     * @param amount Amount of rewards to claim\n     * @param to Address that will be receiving the rewards\n     * @return Rewards claimed\n     **/\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Claims reward for an user on behalf, on all the assets of the\n     * lending pool, accumulating the pending rewards. The caller must\n     * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n     * @param amount Amount of rewards to claim\n     * @param user Address to check and claim rewards\n     * @param to Address that will be receiving the rewards\n     * @return Rewards claimed\n     **/\n    function claimRewardsOnBehalf(\n        address[] calldata assets,\n        uint256 amount,\n        address user,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev returns the unclaimed rewards of the user\n     * @param user the address of the user\n     * @return the unclaimed user rewards\n     */\n    function getUserUnclaimedRewards(address user)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev returns the unclaimed rewards of the user\n     * @param user the address of the user\n     * @param asset The asset to incentivize\n     * @return the user index for the asset\n     */\n    function getUserAssetData(address user, address asset)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev for backward compatibility with previous implementation of the Incentives controller\n     */\n    function REWARD_TOKEN() external view returns (address);\n\n    /**\n     * @dev for backward compatibility with previous implementation of the Incentives controller\n     */\n    function PRECISION() external view returns (uint8);\n\n    /**\n     * @dev Gets the distribution end timestamp of the emissions\n     */\n    function DISTRIBUTION_END() external view returns (uint256);\n}\n"
    },
    "contracts/strategies/IAaveStakeToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IAaveStakedToken {\n    function COOLDOWN_SECONDS() external returns (uint256);\n\n    function UNSTAKE_WINDOW() external returns (uint256);\n\n    function balanceOf(address addr) external returns (uint256);\n\n    function redeem(address to, uint256 amount) external;\n\n    function stakersCooldowns(address addr) external returns (uint256);\n\n    function cooldown() external;\n}\n"
    },
    "contracts/strategies/ICompound.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev Compound C Token interface\n * Documentation: https://compound.finance/developers/ctokens\n */\ninterface ICERC20 {\n    /**\n     * @notice The mint function transfers an asset into the protocol, which begins accumulating\n     * interest based on the current Supply Rate for the asset. The user receives a quantity of\n     * cTokens equal to the underlying tokens supplied, divided by the current Exchange Rate.\n     * @param mintAmount The amount of the asset to be supplied, in units of the underlying asset.\n     * @return 0 on success, otherwise an Error codes\n     */\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise an error code.\n     */\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    /**\n     * @notice The redeem underlying function converts cTokens into a specified quantity of the underlying\n     * asset, and returns them to the user. The amount of cTokens redeemed is equal to the quantity of\n     * underlying tokens received, divided by the current Exchange Rate. The amount redeemed must be less\n     * than the user's Account Liquidity and the market's available liquidity.\n     * @param redeemAmount The amount of underlying to be redeemed.\n     * @return 0 on success, otherwise an error code.\n     */\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    /**\n     * @notice The user's underlying balance, representing their assets in the protocol, is equal to\n     * the user's cToken balance multiplied by the Exchange Rate.\n     * @param owner The account to get the underlying balance of.\n     * @return The amount of underlying currently owned by the account.\n     */\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() external view returns (uint256);\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @notice Get the supply rate per block for supplying the token to Compound.\n     */\n    function supplyRatePerBlock() external view returns (uint256);\n\n    /**\n     * @notice Address of the Compound Comptroller.\n     */\n    function comptroller() external view returns (address);\n}\n"
    },
    "contracts/strategies/IConvexDeposits.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IConvexDeposits {\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool _stake\n    ) external returns (bool);\n\n    function deposit(\n        uint256 _amount,\n        bool _lock,\n        address _stakeAddress\n    ) external;\n}\n"
    },
    "contracts/strategies/ICRVMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ICRVMinter {\n    function mint(address gaugeAddress) external;\n}\n"
    },
    "contracts/strategies/ICurveETHPoolV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ICurveETHPoolV1 {\n    event AddLiquidity(\n        address indexed provider,\n        uint256[2] token_amounts,\n        uint256[2] fees,\n        uint256 invariant,\n        uint256 token_supply\n    );\n    event ApplyNewFee(uint256 fee);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event CommitNewFee(uint256 new_fee);\n    event RampA(\n        uint256 old_A,\n        uint256 new_A,\n        uint256 initial_time,\n        uint256 future_time\n    );\n    event RemoveLiquidity(\n        address indexed provider,\n        uint256[2] token_amounts,\n        uint256[2] fees,\n        uint256 token_supply\n    );\n    event RemoveLiquidityImbalance(\n        address indexed provider,\n        uint256[2] token_amounts,\n        uint256[2] fees,\n        uint256 invariant,\n        uint256 token_supply\n    );\n    event RemoveLiquidityOne(\n        address indexed provider,\n        uint256 token_amount,\n        uint256 coin_amount,\n        uint256 token_supply\n    );\n    event StopRampA(uint256 A, uint256 t);\n    event TokenExchange(\n        address indexed buyer,\n        int128 sold_id,\n        uint256 tokens_sold,\n        int128 bought_id,\n        uint256 tokens_bought\n    );\n    event Transfer(\n        address indexed sender,\n        address indexed receiver,\n        uint256 value\n    );\n\n    function A() external view returns (uint256);\n\n    function A_precise() external view returns (uint256);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function add_liquidity(uint256[2] memory _amounts, uint256 _min_mint_amount)\n        external\n        payable\n        returns (uint256);\n\n    function add_liquidity(\n        uint256[2] memory _amounts,\n        uint256 _min_mint_amount,\n        address _receiver\n    ) external payable returns (uint256);\n\n    function admin_action_deadline() external view returns (uint256);\n\n    function admin_balances(uint256 i) external view returns (uint256);\n\n    function admin_fee() external view returns (uint256);\n\n    function allowance(address arg0, address arg1)\n        external\n        view\n        returns (uint256);\n\n    function apply_new_fee() external;\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function balanceOf(address arg0) external view returns (uint256);\n\n    function balances(uint256 arg0) external view returns (uint256);\n\n    function calc_token_amount(uint256[2] memory _amounts, bool _is_deposit)\n        external\n        view\n        returns (uint256);\n\n    function calc_withdraw_one_coin(uint256 _burn_amount, int128 i)\n        external\n        view\n        returns (uint256);\n\n    function coins(uint256 arg0) external view returns (address);\n\n    function commit_new_fee(uint256 _new_fee) external;\n\n    function decimals() external view returns (uint256);\n\n    function ema_price() external view returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy\n    ) external payable returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy,\n        address _receiver\n    ) external payable returns (uint256);\n\n    function fee() external view returns (uint256);\n\n    function future_A() external view returns (uint256);\n\n    function future_A_time() external view returns (uint256);\n\n    function future_fee() external view returns (uint256);\n\n    function get_balances() external view returns (uint256[2] memory);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function get_p() external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function initial_A() external view returns (uint256);\n\n    function initial_A_time() external view returns (uint256);\n\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address[4] memory _coins,\n        uint256[4] memory _rate_multipliers,\n        uint256 _A,\n        uint256 _fee\n    ) external;\n\n    function last_price() external view returns (uint256);\n\n    function ma_exp_time() external view returns (uint256);\n\n    function ma_last_time() external view returns (uint256);\n\n    function name() external view returns (string memory);\n\n    function nonces(address arg0) external view returns (uint256);\n\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (bool);\n\n    function price_oracle() external view returns (uint256);\n\n    function ramp_A(uint256 _future_A, uint256 _future_time) external;\n\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[2] memory _min_amounts\n    ) external returns (uint256[2] memory);\n\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[2] memory _min_amounts,\n        address _receiver\n    ) external returns (uint256[2] memory);\n\n    function remove_liquidity_imbalance(\n        uint256[2] memory _amounts,\n        uint256 _max_burn_amount\n    ) external returns (uint256);\n\n    function remove_liquidity_imbalance(\n        uint256[2] memory _amounts,\n        uint256 _max_burn_amount,\n        address _receiver\n    ) external returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_received\n    ) external returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_received,\n        address _receiver\n    ) external returns (uint256);\n\n    function set_ma_exp_time(uint256 _ma_exp_time) external;\n\n    function stop_ramp_A() external;\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function version() external view returns (string memory);\n\n    function withdraw_admin_fees() external;\n}\n"
    },
    "contracts/strategies/ICurveGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ICurveGauge {\n    function balanceOf(address account) external view returns (uint256);\n\n    function deposit(uint256 value, address account) external;\n\n    function withdraw(uint256 value) external;\n}\n"
    },
    "contracts/strategies/ICurveMetaPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface ICurveMetaPool {\n    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount)\n        external\n        returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function remove_liquidity(uint256 _amount, uint256[2] calldata min_amounts)\n        external\n        returns (uint256[2] calldata);\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 min_amount\n    ) external returns (uint256);\n\n    function remove_liquidity_imbalance(\n        uint256[2] calldata amounts,\n        uint256 max_burn_amount\n    ) external returns (uint256);\n\n    function calc_withdraw_one_coin(uint256 _token_amount, int128 i)\n        external\n        view\n        returns (uint256);\n\n    function balances(uint256 i) external view returns (uint256);\n\n    function calc_token_amount(uint256[2] calldata amounts, bool deposit)\n        external\n        view\n        returns (uint256);\n\n    function base_pool() external view returns (address);\n\n    function fee() external view returns (uint256);\n\n    function coins(uint256 i) external view returns (address);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/strategies/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ICurvePool {\n    function get_virtual_price() external view returns (uint256);\n\n    function add_liquidity(uint256[3] calldata _amounts, uint256 _min) external;\n\n    function balances(uint256) external view returns (uint256);\n\n    function calc_token_amount(uint256[3] calldata _amounts, bool _deposit)\n        external\n        returns (uint256);\n\n    function fee() external view returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _amount,\n        int128 _index,\n        uint256 _minAmount\n    ) external;\n\n    function remove_liquidity(\n        uint256 _amount,\n        uint256[3] calldata _minWithdrawAmounts\n    ) external;\n\n    function calc_withdraw_one_coin(uint256 _amount, int128 _index)\n        external\n        view\n        returns (uint256);\n\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n\n    function coins(uint256 _index) external view returns (address);\n\n    function remove_liquidity_imbalance(\n        uint256[3] calldata _amounts,\n        uint256 maxBurnAmount\n    ) external;\n}\n"
    },
    "contracts/strategies/IRewardStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IRewardStaking {\n    function stakeFor(address, uint256) external;\n\n    function stake(uint256) external;\n\n    function withdraw(uint256 amount, bool claim) external;\n\n    function withdrawAndUnwrap(uint256 amount, bool claim) external;\n\n    function earned(address account) external view returns (uint256);\n\n    function getReward() external;\n\n    function getReward(address _account, bool _claimExtras) external;\n\n    function extraRewardsLength() external returns (uint256);\n\n    function extraRewards(uint256 _pid) external returns (address);\n\n    function rewardToken() external returns (address);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "contracts/strategies/LidoWithdrawalStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ninterface IStETHWithdrawal {\n    event WithdrawalRequested(\n        uint256 indexed requestId,\n        address indexed requestor,\n        address indexed owner,\n        uint256 amountOfStETH,\n        uint256 amountOfShares\n    );\n    event WithdrawalsFinalized(\n        uint256 indexed from,\n        uint256 indexed to,\n        uint256 amountOfETHLocked,\n        uint256 sharesToBurn,\n        uint256 timestamp\n    );\n    event WithdrawalClaimed(\n        uint256 indexed requestId,\n        address indexed owner,\n        address indexed receiver,\n        uint256 amountOfETH\n    );\n\n    struct WithdrawalRequestStatus {\n        /// @notice stETH token amount that was locked on withdrawal queue for this request\n        uint256 amountOfStETH;\n        /// @notice amount of stETH shares locked on withdrawal queue for this request\n        uint256 amountOfShares;\n        /// @notice address that can claim or transfer this request\n        address owner;\n        /// @notice timestamp of when the request was created, in seconds\n        uint256 timestamp;\n        /// @notice true, if request is finalized\n        bool isFinalized;\n        /// @notice true, if request is claimed. Request is claimable if (isFinalized && !isClaimed)\n        bool isClaimed;\n    }\n\n    function requestWithdrawals(uint256[] calldata _amounts, address _owner)\n        external\n        returns (uint256[] memory requestIds);\n\n    function getLastCheckpointIndex() external view returns (uint256);\n\n    function findCheckpointHints(\n        uint256[] calldata _requestIds,\n        uint256 _firstIndex,\n        uint256 _lastIndex\n    ) external view returns (uint256[] memory hintIds);\n\n    function claimWithdrawals(\n        uint256[] calldata _requestIds,\n        uint256[] calldata _hints\n    ) external;\n\n    function getWithdrawalStatus(uint256[] calldata _requestIds)\n        external\n        view\n        returns (WithdrawalRequestStatus[] memory statuses);\n\n    function getWithdrawalRequests(address _owner)\n        external\n        view\n        returns (uint256[] memory requestsIds);\n\n    function finalize(\n        uint256 _lastRequestIdToBeFinalized,\n        uint256 _maxShareRate\n    ) external payable;\n}\n\n/**\n * @title Lido Withdrawal Strategy\n * @notice This strategy withdraws ETH from stETH via the Lido Withdrawal Queue contract\n * @author Origin Protocol Inc\n */\ncontract LidoWithdrawalStrategy is InitializableAbstractStrategy {\n    /// @notice Address of the WETH token\n    IWETH9 private constant weth =\n        IWETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    /// @notice Address of the stETH token\n    IERC20 private constant stETH =\n        IERC20(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\n    /// @notice Address of the Lido Withdrawal Queue contract\n    IStETHWithdrawal private constant withdrawalQueue =\n        IStETHWithdrawal(0x889edC2eDab5f40e902b864aD4d7AdE8E412F9B1);\n    /// @notice Maximum amount of stETH that can be withdrawn in a single request\n    uint256 public constant MaxWithdrawalAmount = 1000 ether;\n    /// @notice Total amount of stETH that has been requested to be withdrawn for ETH\n    uint256 public outstandingWithdrawals;\n\n    event WithdrawalRequests(uint256[] requestIds, uint256[] amounts);\n    event WithdrawalClaims(uint256[] requestIds, uint256 amount);\n\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /**\n     * @notice initialize function, to set up initial internal state\n     * @param _rewardTokenAddresses Address of reward token for platform\n     * @param _assets Addresses of initial supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function initialize(\n        address[] memory _rewardTokenAddresses,\n        address[] memory _assets,\n        address[] memory _pTokens\n    ) external onlyGovernor initializer {\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n        safeApproveAllTokens();\n    }\n\n    /**\n     * @notice deposit() function not used for this strategy. Use depositAll() instead.\n     */\n    function deposit(address, uint256) public override onlyVault nonReentrant {\n        // This method no longer used by the VaultAdmin, and we don't want it\n        // to be used by VaultCore.\n        require(false, \"use depositAll() instead\");\n    }\n\n    /**\n     * @notice Takes all given stETH and creates Lido withdrawal request\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 stETHStart = stETH.balanceOf(address(this));\n        require(stETHStart > 0, \"No stETH to withdraw\");\n\n        uint256 withdrawalLength = (stETHStart / MaxWithdrawalAmount) + 1;\n        uint256[] memory amounts = new uint256[](withdrawalLength);\n\n        uint256 stETHRemaining = stETHStart;\n        uint256 i = 0;\n        while (stETHRemaining > MaxWithdrawalAmount) {\n            amounts[i++] = MaxWithdrawalAmount;\n            stETHRemaining -= MaxWithdrawalAmount;\n        }\n        amounts[i] = stETHRemaining;\n\n        uint256[] memory requestIds = withdrawalQueue.requestWithdrawals(\n            amounts,\n            address(this)\n        );\n\n        emit WithdrawalRequests(requestIds, amounts);\n\n        // Is there any stETH left except 1 wei from each request?\n        // This is because stETH does not transfer all the transfer amount.\n        uint256 stEthDust = stETH.balanceOf(address(this));\n        require(\n            stEthDust <= withdrawalLength,\n            \"Not all stEth in withdraw queue\"\n        );\n        outstandingWithdrawals += stETHStart;\n\n        // This strategy claims to support WETH, so it is possible for\n        // the vault to transfer WETH to it. This returns any deposited WETH\n        // to the vault so that it is not lost for balance tracking purposes.\n        uint256 wethBalance = weth.balanceOf(address(this));\n        if (wethBalance > 0) {\n            // slither-disable-next-line unchecked-transfer\n            weth.transfer(vaultAddress, wethBalance);\n        }\n\n        emit Deposit(address(stETH), address(withdrawalQueue), stETHStart);\n    }\n\n    /**\n     * @notice Withdraw an asset from the underlying platform\n     * @param _recipient Address to receive withdrawn assets\n     * @param _asset Address of the asset to withdraw\n     * @param _amount Amount of assets to withdraw\n     */\n    function withdraw(\n        // solhint-disable-next-line no-unused-vars\n        address _recipient,\n        // solhint-disable-next-line no-unused-vars\n        address _asset,\n        // solhint-disable-next-line no-unused-vars\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        // Does nothing - all withdrawals need to be called manually using the\n        // Strategist calling claimWithdrawals\n        revert(\"use claimWithdrawals()\");\n    }\n\n    /**\n     * @notice Claim previously requested withdrawals that have now finalized.\n     * Called by the Strategist.\n     * @param _requestIds Array of withdrawal request identifiers\n     * @param _expectedAmount Total amount of ETH expect to be withdrawn\n     */\n    function claimWithdrawals(\n        uint256[] memory _requestIds,\n        uint256 _expectedAmount\n    ) external nonReentrant {\n        require(\n            msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Strategist\"\n        );\n        uint256 startingBalance = payable(address(this)).balance;\n        uint256 lastIndex = withdrawalQueue.getLastCheckpointIndex();\n        uint256[] memory hintIds = withdrawalQueue.findCheckpointHints(\n            _requestIds,\n            1,\n            lastIndex\n        );\n        withdrawalQueue.claimWithdrawals(_requestIds, hintIds);\n\n        uint256 currentBalance = payable(address(this)).balance;\n        uint256 withdrawalAmount = currentBalance - startingBalance;\n        // Withdrawal amount should be within 2 wei of expected amount\n        require(\n            withdrawalAmount + 2 >= _expectedAmount &&\n                withdrawalAmount <= _expectedAmount,\n            \"Withdrawal amount not expected\"\n        );\n\n        emit WithdrawalClaims(_requestIds, withdrawalAmount);\n\n        outstandingWithdrawals -= withdrawalAmount;\n        weth.deposit{ value: currentBalance }();\n        // slither-disable-next-line unchecked-transfer\n        weth.transfer(vaultAddress, currentBalance);\n        emit Withdrawal(\n            address(weth),\n            address(withdrawalQueue),\n            currentBalance\n        );\n    }\n\n    /**\n     * @notice Withdraw all assets from this strategy, and transfer to the Vault.\n     * In correct operation, this strategy should never hold any assets.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        if (payable(address(this)).balance > 0) {\n            weth.deposit{ value: payable(address(this)).balance }();\n        }\n        uint256 wethBalance = weth.balanceOf(address(this));\n        if (wethBalance > 0) {\n            // slither-disable-next-line unchecked-transfer\n            weth.transfer(vaultAddress, wethBalance);\n            emit Withdrawal(address(weth), address(0), wethBalance);\n        }\n        uint256 stEthBalance = stETH.balanceOf(address(this));\n        if (stEthBalance > 0) {\n            // slither-disable-next-line unchecked-transfer\n            stETH.transfer(vaultAddress, stEthBalance);\n            emit Withdrawal(address(stETH), address(0), stEthBalance);\n        }\n    }\n\n    /**\n     * @notice Returns the amount of queued stETH that will be returned as WETH.\n     * We return this as a WETH asset, since that is what it will eventually be returned as.\n     * We only return the outstandingWithdrawals, because the contract itself should never hold any funds.\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        if (_asset == address(weth)) {\n            return outstandingWithdrawals;\n        } else if (_asset == address(stETH)) {\n            return 0;\n        } else {\n            revert(\"Unexpected asset address\");\n        }\n    }\n\n    /**\n     * @notice Approve the spending of all assets by their corresponding cToken,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens() public override {\n        // slither-disable-next-line unused-return\n        stETH.approve(address(withdrawalQueue), type(uint256).max);\n    }\n\n    /**\n     * @notice Check if an asset is supported.\n     * @param _asset    Address of the asset\n     * @return bool     Whether asset is supported\n     */\n    function supportsAsset(address _asset) public pure override returns (bool) {\n        // stETH can be deposited by the vault and balances are reported in WETH\n        return _asset == address(stETH) || _asset == address(weth);\n    }\n\n    /// @notice Needed to receive ETH when withdrawal requests are claimed\n    receive() external payable {}\n\n    function _abstractSetPToken(address, address) internal pure override {\n        revert(\"No pTokens are used\");\n    }\n}\n"
    },
    "contracts/strategies/MorphoAaveStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD Morpho Aave Strategy\n * @notice Investment strategy for investing stablecoins via Morpho (Aave)\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { IMorpho } from \"../interfaces/morpho/IMorpho.sol\";\nimport { ILens } from \"../interfaces/morpho/ILens.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\ncontract MorphoAaveStrategy is InitializableAbstractStrategy {\n    address public constant MORPHO = 0x777777c9898D384F785Ee44Acfe945efDFf5f3E0;\n    address public constant LENS = 0x507fA343d0A90786d86C7cd885f5C49263A91FF4;\n\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /**\n     * @dev Initialize function, to set up initial internal state\n     * @param _rewardTokenAddresses Address of reward token for platform\n     * @param _assets Addresses of initial supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses,\n        address[] calldata _assets,\n        address[] calldata _pTokens\n    ) external onlyGovernor initializer {\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n    }\n\n    /**\n     * @dev Approve the spending of all assets by main Morpho contract,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; i++) {\n            address asset = assetsMapped[i];\n\n            // Safe approval\n            IERC20(asset).safeApprove(MORPHO, 0);\n            IERC20(asset).safeApprove(MORPHO, type(uint256).max);\n        }\n    }\n\n    /**\n     * @dev Internal method to respond to the addition of new asset\n     *      We need to approve and allow Morpho to move them\n     * @param _asset Address of the asset to approve\n     * @param _pToken The pToken for the approval\n     */\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        override\n    {\n        IERC20(_asset).safeApprove(MORPHO, 0);\n        IERC20(_asset).safeApprove(MORPHO, type(uint256).max);\n    }\n\n    /**\n     * @dev Collect accumulated rewards and send them to Harvester.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Morpho Aave-v2 doesn't distribute reward tokens\n        // solhint-disable-next-line max-line-length\n        // Ref: https://developers.morpho.xyz/interact-with-morpho/get-started/interact-with-morpho/claim-rewards#morpho-aave-v2\n    }\n\n    /**\n     * @dev Get the amount of rewards pending to be collected from the protocol\n     */\n    function getPendingRewards() external view returns (uint256 balance) {\n        // Morpho Aave-v2 doesn't distribute reward tokens\n        // solhint-disable-next-line max-line-length\n        // Ref: https://developers.morpho.xyz/interact-with-morpho/get-started/interact-with-morpho/claim-rewards#morpho-aave-v2\n        return 0;\n    }\n\n    /**\n     * @dev Deposit asset into Morpho\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @dev Deposit asset into Morpho\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_amount > 0, \"Must deposit something\");\n\n        address pToken = address(_getPTokenFor(_asset));\n\n        IMorpho(MORPHO).supply(\n            pToken,\n            address(this), // the address of the user you want to supply on behalf of\n            _amount\n        );\n        emit Deposit(_asset, pToken, _amount);\n    }\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into Morpho\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            uint256 balance = IERC20(assetsMapped[i]).balanceOf(address(this));\n            if (balance > 0) {\n                _deposit(assetsMapped[i], balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw asset from Morpho\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        _withdraw(_recipient, _asset, _amount);\n    }\n\n    function _withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) internal {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        address pToken = address(_getPTokenFor(_asset));\n\n        IMorpho(MORPHO).withdraw(pToken, _amount);\n        emit Withdrawal(_asset, pToken, _amount);\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            uint256 balance = _checkBalance(assetsMapped[i]);\n            if (balance > 0) {\n                _withdraw(vaultAddress, assetsMapped[i], balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Return total value of an asset held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        return _checkBalance(_asset);\n    }\n\n    function _checkBalance(address _asset)\n        internal\n        view\n        returns (uint256 balance)\n    {\n        address pToken = address(_getPTokenFor(_asset));\n\n        // Total value represented by decimal position of underlying token\n        (, , balance) = ILens(LENS).getCurrentSupplyBalanceInOf(\n            pToken,\n            address(this)\n        );\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @dev Get the pToken wrapped in the IERC20 interface for this asset.\n     *      Fails if the pToken doesn't exist in our mappings.\n     * @param _asset Address of the asset\n     * @return pToken Corresponding pToken to this asset\n     */\n    function _getPTokenFor(address _asset) internal view returns (IERC20) {\n        address pToken = assetToPToken[_asset];\n        require(pToken != address(0), \"pToken does not exist\");\n        return IERC20(pToken);\n    }\n}\n"
    },
    "contracts/strategies/MorphoCompoundStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD Morpho Compound Strategy\n * @notice Investment strategy for investing stablecoins via Morpho (Compound)\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20, AbstractCompoundStrategy, InitializableAbstractStrategy } from \"./AbstractCompoundStrategy.sol\";\nimport { IMorpho } from \"../interfaces/morpho/IMorpho.sol\";\nimport { ILens } from \"../interfaces/morpho/ILens.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport \"../utils/Helpers.sol\";\n\ncontract MorphoCompoundStrategy is AbstractCompoundStrategy {\n    address public constant MORPHO = 0x8888882f8f843896699869179fB6E4f7e3B58888;\n    address public constant LENS = 0x930f1b46e1D081Ec1524efD95752bE3eCe51EF67;\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /**\n     * @dev Initialize function, to set up initial internal state\n     * @param _rewardTokenAddresses Address of reward token for platform\n     * @param _assets Addresses of initial supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses,\n        address[] calldata _assets,\n        address[] calldata _pTokens\n    ) external onlyGovernor initializer {\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n    }\n\n    /**\n     * @dev Approve the spending of all assets by main Morpho contract,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; i++) {\n            address asset = assetsMapped[i];\n\n            // Safe approval\n            IERC20(asset).safeApprove(MORPHO, 0);\n            IERC20(asset).safeApprove(MORPHO, type(uint256).max);\n        }\n    }\n\n    /**\n     * @dev Internal method to respond to the addition of new asset\n     *      We need to approve and allow Morpho to move them\n     * @param _asset Address of the asset to approve\n     * @param _pToken The pToken for the approval\n     */\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        override\n    {\n        IERC20(_asset).safeApprove(MORPHO, 0);\n        IERC20(_asset).safeApprove(MORPHO, type(uint256).max);\n    }\n\n    /**\n     * @dev Collect accumulated rewards and send them to Harvester.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        /**\n         * Gas considerations. We could query Morpho LENS's `getUserUnclaimedRewards` for each\n         * cToken separately and only claimRewards where it is economically feasible. Each call\n         * (out of 3) costs ~60k gas extra.\n         *\n         * Each extra cToken in the `poolTokens` of `claimRewards` function makes that call\n         * 89-120k more expensive gas wise.\n         *\n         * With Lens query in case where:\n         *  - there is only 1 reward token to collect. Net gas usage in best case would be\n         *    3*60 - 2*120 = -60k -> saving 60k gas\n         *  - there are 2 reward tokens to collect. Net gas usage in best case would be\n         *    3*60 - 120 = 60k -> more expensive for 60k gas\n         *  - there are 3 reward tokens to collect. Net gas usage in best case would be\n         *    3*60 = 180k -> more expensive for 180k gas\n         *\n         * For the above reasoning such \"optimization\" is not implemented\n         */\n\n        address[] memory poolTokens = new address[](assetsMapped.length);\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            poolTokens[i] = assetToPToken[assetsMapped[i]];\n        }\n\n        // slither-disable-next-line unused-return\n        IMorpho(MORPHO).claimRewards(\n            poolTokens, // The addresses of the underlying protocol's pools to claim rewards from\n            false // Whether to trade the accrued rewards for MORPHO token, with a premium\n        );\n\n        // Transfer COMP to Harvester\n        IERC20 rewardToken = IERC20(rewardTokenAddresses[0]);\n        uint256 balance = rewardToken.balanceOf(address(this));\n        emit RewardTokenCollected(\n            harvesterAddress,\n            rewardTokenAddresses[0],\n            balance\n        );\n        rewardToken.safeTransfer(harvesterAddress, balance);\n    }\n\n    /**\n     * @dev Get the amount of rewards pending to be collected from the protocol\n     */\n    function getPendingRewards() external view returns (uint256 balance) {\n        address[] memory poolTokens = new address[](assetsMapped.length);\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            poolTokens[i] = assetToPToken[assetsMapped[i]];\n        }\n\n        return ILens(LENS).getUserUnclaimedRewards(poolTokens, address(this));\n    }\n\n    /**\n     * @dev Deposit asset into Morpho\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @dev Deposit asset into Morpho\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_amount > 0, \"Must deposit something\");\n\n        IMorpho(MORPHO).supply(\n            address(_getCTokenFor(_asset)),\n            address(this), // the address of the user you want to supply on behalf of\n            _amount\n        );\n        emit Deposit(_asset, address(_getCTokenFor(_asset)), _amount);\n    }\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into Morpho\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            uint256 balance = IERC20(assetsMapped[i]).balanceOf(address(this));\n            if (balance > 0) {\n                _deposit(assetsMapped[i], balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw asset from Morpho\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        _withdraw(_recipient, _asset, _amount);\n    }\n\n    function _withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) internal {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        address pToken = assetToPToken[_asset];\n\n        IMorpho(MORPHO).withdraw(pToken, _amount);\n        emit Withdrawal(_asset, address(_getCTokenFor(_asset)), _amount);\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            uint256 balance = _checkBalance(assetsMapped[i]);\n            if (balance > 0) {\n                _withdraw(vaultAddress, assetsMapped[i], balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Return total value of an asset held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        return _checkBalance(_asset);\n    }\n\n    function _checkBalance(address _asset)\n        internal\n        view\n        returns (uint256 balance)\n    {\n        address pToken = assetToPToken[_asset];\n\n        // Total value represented by decimal position of underlying token\n        (, , balance) = ILens(LENS).getCurrentSupplyBalanceInOf(\n            pToken,\n            address(this)\n        );\n    }\n}\n"
    },
    "contracts/strategies/NativeStaking/FeeAccumulator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title Fee Accumulator for Native Staking SSV Strategy\n * @notice Receives execution rewards which includes tx fees and\n * MEV rewards like tx priority and tx ordering.\n * It does NOT include swept ETH from beacon chain consensus rewards or full validator withdrawals.\n * @author Origin Protocol Inc\n */\ncontract FeeAccumulator {\n    /// @notice The address of the Native Staking Strategy\n    address public immutable STRATEGY;\n\n    event ExecutionRewardsCollected(address indexed strategy, uint256 amount);\n\n    /**\n     * @param _strategy Address of the Native Staking Strategy\n     */\n    constructor(address _strategy) {\n        STRATEGY = _strategy;\n    }\n\n    /**\n     * @notice sends all ETH in this FeeAccumulator contract to the Native Staking Strategy.\n     * @return eth The amount of execution rewards that were sent to the Native Staking Strategy\n     */\n    function collect() external returns (uint256 eth) {\n        require(msg.sender == STRATEGY, \"Caller is not the Strategy\");\n\n        eth = address(this).balance;\n        if (eth > 0) {\n            // Send the ETH to the Native Staking Strategy\n            Address.sendValue(payable(STRATEGY), eth);\n\n            emit ExecutionRewardsCollected(STRATEGY, eth);\n        }\n    }\n\n    /**\n     * @dev Accept ETH\n     */\n    receive() external payable {}\n}\n"
    },
    "contracts/strategies/NativeStaking/NativeStakingSSVStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { IWETH9 } from \"../../interfaces/IWETH9.sol\";\nimport { FeeAccumulator } from \"./FeeAccumulator.sol\";\nimport { ValidatorAccountant } from \"./ValidatorAccountant.sol\";\nimport { ISSVNetwork } from \"../../interfaces/ISSVNetwork.sol\";\n\nstruct ValidatorStakeData {\n    bytes pubkey;\n    bytes signature;\n    bytes32 depositDataRoot;\n}\n\n/// @title Native Staking SSV Strategy\n/// @notice Strategy to deploy funds into DVT validators powered by the SSV Network\n/// @author Origin Protocol Inc\n/// @dev This contract handles WETH and ETH and in some operations interchanges between the two. Any WETH that\n/// is on the contract across multiple blocks (and not just transitory within a transaction) is considered an\n/// asset. Meaning deposits increase the balance of the asset and withdrawal decrease it. As opposed to all\n/// our other strategies the WETH doesn't immediately get deposited into an underlying strategy and can be present\n/// across multiple blocks waiting to be unwrapped to ETH and staked to validators. This separation of WETH and ETH is\n/// required since the rewards (reward token) is also in ETH.\n///\n/// To simplify the accounting of WETH there is another difference in behavior compared to the other strategies.\n/// To withdraw WETH asset - exit message is posted to validators and the ETH hits this contract with multiple days\n/// delay. In order to simplify the WETH accounting upon detection of such an event the ValidatorAccountant\n/// immediately wraps ETH to WETH and sends it to the Vault.\n///\n/// On the other hand any ETH on the contract (across multiple blocks) is there either:\n///  - as a result of already accounted for consensus rewards\n///  - as a result of not yet accounted for consensus rewards\n///  - as a results of not yet accounted for full validator withdrawals (or validator slashes)\n///\n/// Even though the strategy assets and rewards are a very similar asset the consensus layer rewards and the\n/// execution layer rewards are considered rewards and those are dripped to the Vault over a configurable time\n/// interval and not immediately.\ncontract NativeStakingSSVStrategy is\n    ValidatorAccountant,\n    InitializableAbstractStrategy\n{\n    using SafeERC20 for IERC20;\n\n    /// @notice SSV ERC20 token that serves as a payment for operating SSV validators\n    address public immutable SSV_TOKEN;\n    /// @notice Fee collector address\n    /// @dev this address will receive maximal extractable value (MEV) rewards. These are\n    /// rewards for arranging transactions in a way that benefits the validator.\n    address payable public immutable FEE_ACCUMULATOR_ADDRESS;\n\n    /// @dev This contract receives WETH as the deposit asset, but unlike other strategies doesn't immediately\n    /// deposit it to an underlying platform. Rather a special privilege account stakes it to the validators.\n    /// For that reason calling WETH.balanceOf(this) in a deposit function can contain WETH that has just been\n    /// deposited and also WETH that has previously been deposited. To keep a correct count we need to keep track\n    /// of WETH that has already been accounted for.\n    /// This value represents the amount of WETH balance of this contract that has already been accounted for by the\n    /// deposit events.\n    /// It is important to note that this variable is not concerned with WETH that is a result of full/partial\n    /// withdrawal of the validators. It is strictly concerned with WETH that has been deposited and is waiting to\n    /// be staked.\n    uint256 public depositedWethAccountedFor;\n\n    // For future use\n    uint256[49] private __gap;\n\n    /// @param _baseConfig Base strategy config with platformAddress (ERC-4626 Vault contract), eg sfrxETH or sDAI,\n    /// and vaultAddress (OToken Vault contract), eg VaultProxy or OETHVaultProxy\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\n    /// @param _ssvToken Address of the Erc20 SSV Token contract\n    /// @param _ssvNetwork Address of the SSV Network contract\n    /// @param _maxValidators Maximum number of validators that can be registered in the strategy\n    /// @param _feeAccumulator Address of the fee accumulator receiving execution layer validator rewards\n    /// @param _beaconChainDepositContract Address of the beacon chain deposit contract\n    constructor(\n        BaseStrategyConfig memory _baseConfig,\n        address _wethAddress,\n        address _ssvToken,\n        address _ssvNetwork,\n        uint256 _maxValidators,\n        address _feeAccumulator,\n        address _beaconChainDepositContract\n    )\n        InitializableAbstractStrategy(_baseConfig)\n        ValidatorAccountant(\n            _wethAddress,\n            _baseConfig.vaultAddress,\n            _beaconChainDepositContract,\n            _ssvNetwork,\n            _maxValidators\n        )\n    {\n        SSV_TOKEN = _ssvToken;\n        FEE_ACCUMULATOR_ADDRESS = payable(_feeAccumulator);\n    }\n\n    /// @notice Set up initial internal state including\n    /// 1. approving the SSVNetwork to transfer SSV tokens from this strategy contract\n    /// 2. setting the recipient of SSV validator MEV rewards to the FeeAccumulator contract.\n    /// @param _rewardTokenAddresses Address of reward token for platform\n    /// @param _assets Addresses of initial supported assets\n    /// @param _pTokens Platform Token corresponding addresses\n    function initialize(\n        address[] memory _rewardTokenAddresses,\n        address[] memory _assets,\n        address[] memory _pTokens\n    ) external onlyGovernor initializer {\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n\n        // Approves the SSV Network contract to transfer SSV tokens for deposits\n        IERC20(SSV_TOKEN).approve(SSV_NETWORK, type(uint256).max);\n\n        // Set the FeeAccumulator as the address for SSV validators to send MEV rewards to\n        ISSVNetwork(SSV_NETWORK).setFeeRecipientAddress(\n            FEE_ACCUMULATOR_ADDRESS\n        );\n    }\n\n    /// @notice Unlike other strategies, this does not deposit assets into the underlying platform.\n    /// It just checks the asset is WETH and emits the Deposit event.\n    /// To deposit WETH into validators `registerSsvValidator` and `stakeEth` must be used.\n    /// Will NOT revert if the strategy is paused from an accounting failure.\n    /// @param _asset Address of asset to deposit. Has to be WETH.\n    /// @param _amount Amount of assets that were transferred to the strategy by the vault.\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        require(_asset == WETH, \"Unsupported asset\");\n        depositedWethAccountedFor += _amount;\n        _deposit(_asset, _amount);\n    }\n\n    /// @dev Deposit WETH to this strategy so it can later be staked into a validator.\n    /// @param _asset Address of WETH\n    /// @param _amount Amount of WETH to deposit\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_amount > 0, \"Must deposit something\");\n        /*\n         * We could do a check here that would revert when \"_amount % 32 ether != 0\". With the idea of\n         * not allowing deposits that will result in WETH sitting on the strategy after all the possible batches\n         * of 32ETH have been staked.\n         * But someone could mess with our strategy by sending some WETH to it. And we might want to deposit just\n         * enough WETH to add it up to 32 so it can be staked. For that reason the check is left out.\n         *\n         * WETH sitting on the strategy won't interfere with the accounting since accounting only operates on ETH.\n         */\n        emit Deposit(_asset, address(0), _amount);\n    }\n\n    /// @notice Unlike other strategies, this does not deposit assets into the underlying platform.\n    /// It just emits the Deposit event.\n    /// To deposit WETH into validators `registerSsvValidator` and `stakeEth` must be used.\n    /// Will NOT revert if the strategy is paused from an accounting failure.\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 wethBalance = IERC20(WETH).balanceOf(address(this));\n        uint256 newWeth = wethBalance - depositedWethAccountedFor;\n\n        if (newWeth > 0) {\n            depositedWethAccountedFor = wethBalance;\n\n            _deposit(WETH, newWeth);\n        }\n    }\n\n    /// @notice Withdraw WETH from this contract. Used only if some WETH for is lingering on the contract.\n    /// That can happen when:\n    ///   - after mints if the strategy is the default\n    ///   - time between depositToStrategy and stakeEth\n    ///   - the deposit was not a multiple of 32 WETH\n    ///   - someone sent WETH directly to this contract\n    /// Will NOT revert if the strategy is paused from an accounting failure.\n    /// @param _recipient Address to receive withdrawn assets\n    /// @param _asset WETH to withdraw\n    /// @param _amount Amount of WETH to withdraw\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_asset == WETH, \"Unsupported asset\");\n        _withdraw(_recipient, _asset, _amount);\n    }\n\n    function _withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) internal {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        _wethWithdrawn(_amount);\n\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n        emit Withdrawal(_asset, address(0), _amount);\n    }\n\n    /// @notice transfer all WETH deposits back to the vault.\n    /// This does not withdraw from the validators. That has to be done separately with the\n    /// `exitSsvValidator` and `removeSsvValidator` operations.\n    /// This does not withdraw any execution rewards from the FeeAccumulator or\n    /// consensus rewards in this strategy.\n    /// Any ETH in this strategy that was swept from a full validator withdrawal will not be withdrawn.\n    /// ETH from full validator withdrawals is sent to the Vault using `doAccounting`.\n    /// Will NOT revert if the strategy is paused from an accounting failure.\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        uint256 wethBalance = IERC20(WETH).balanceOf(address(this));\n        if (wethBalance > 0) {\n            _withdraw(vaultAddress, WETH, wethBalance);\n        }\n    }\n\n    /// @notice Returns the total value of (W)ETH that is staked to the validators\n    /// and WETH deposits that are still to be staked.\n    /// This does not include ETH from consensus rewards sitting in this strategy\n    /// or ETH from MEV rewards in the FeeAccumulator. These rewards are harvested\n    /// and sent to the Dripper so will eventually be sent to the Vault as WETH.\n    /// @param _asset      Address of weth asset\n    /// @return balance    Total value of (W)ETH\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == WETH, \"Unsupported asset\");\n\n        balance =\n            // add the ETH that has been staked in validators\n            activeDepositedValidators *\n            FULL_STAKE +\n            // add the WETH in the strategy from deposits that are still to be staked\n            IERC20(WETH).balanceOf(address(this));\n    }\n\n    function pause() external onlyStrategist {\n        _pause();\n    }\n\n    /// @notice Returns bool indicating whether asset is supported by strategy.\n    /// @param _asset The address of the asset token.\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == WETH;\n    }\n\n    /// @notice Approves the SSV Network contract to transfer SSV tokens for deposits\n    function safeApproveAllTokens() external override {\n        // Approves the SSV Network contract to transfer SSV tokens for deposits\n        IERC20(SSV_TOKEN).approve(SSV_NETWORK, type(uint256).max);\n    }\n\n    /// @notice Set the FeeAccumulator as the address for SSV validators to send MEV rewards to\n    function setFeeRecipient() external {\n        ISSVNetwork(SSV_NETWORK).setFeeRecipientAddress(\n            FEE_ACCUMULATOR_ADDRESS\n        );\n    }\n\n    /**\n     * @notice Only accept ETH from the FeeAccumulator and the WETH contract - required when\n     * unwrapping WETH just before staking it to the validator.\n     * The strategy will also receive ETH from the priority fees of transactions when producing blocks\n     * as defined in EIP-1559.\n     * The tx fees come from the Beacon chain so do not need any EVM level permissions to receive ETH.\n     * The tx fees are paid with each block produced. They are not included in the consensus rewards\n     * which are periodically swept from the validators to this strategy.\n     * For accounting purposes, the priority fees of transactions will be considered consensus rewards\n     * and will be included in the AccountingConsensusRewards event.\n     * @dev don't want to receive donations from anyone else as donations over the fuse limits will\n     * mess with the accounting of the consensus rewards and validator full withdrawals.\n     */\n    receive() external payable {\n        require(\n            msg.sender == FEE_ACCUMULATOR_ADDRESS || msg.sender == WETH,\n            \"Eth not from allowed contracts\"\n        );\n    }\n\n    /***************************************\n                Internal functions\n    ****************************************/\n\n    function _abstractSetPToken(address _asset, address) internal override {}\n\n    /// @dev Convert accumulated ETH to WETH and send to the Harvester.\n    /// Will revert if the strategy is paused for accounting.\n    function _collectRewardTokens() internal override whenNotPaused {\n        // collect ETH from execution rewards from the fee accumulator\n        uint256 executionRewards = FeeAccumulator(FEE_ACCUMULATOR_ADDRESS)\n            .collect();\n\n        // total ETH rewards to be harvested = execution rewards + consensus rewards\n        uint256 ethRewards = executionRewards + consensusRewards;\n\n        require(\n            address(this).balance >= ethRewards,\n            \"Insufficient eth balance\"\n        );\n\n        if (ethRewards > 0) {\n            // reset the counter keeping track of beacon chain consensus rewards\n            consensusRewards = 0;\n\n            // Convert ETH rewards to WETH\n            IWETH9(WETH).deposit{ value: ethRewards }();\n\n            IERC20(WETH).safeTransfer(harvesterAddress, ethRewards);\n            emit RewardTokenCollected(harvesterAddress, WETH, ethRewards);\n        }\n    }\n\n    /// @dev emits Withdrawal event from NativeStakingSSVStrategy\n    function _wethWithdrawnToVault(uint256 _amount) internal override {\n        emit Withdrawal(WETH, address(0), _amount);\n    }\n\n    /// @dev Called when WETH is withdrawn from the strategy or staked to a validator so\n    /// the strategy knows how much WETH it has on deposit.\n    /// This is so it can emit the correct amount in the Deposit event in depositAll().\n    function _wethWithdrawn(uint256 _amount) internal override {\n        /* In an ideal world we wouldn't need to reduce the deduction amount when the\n         * depositedWethAccountedFor is smaller than the _amount.\n         *\n         * The reason this is required is that a malicious actor could sent WETH directly\n         * to this contract and that would circumvent the increase of depositedWethAccountedFor\n         * property. When the ETH would be staked the depositedWethAccountedFor amount could\n         * be deducted so much that it would be negative.\n         */\n        uint256 deductAmount = Math.min(_amount, depositedWethAccountedFor);\n        depositedWethAccountedFor -= deductAmount;\n    }\n}\n"
    },
    "contracts/strategies/NativeStaking/ValidatorAccountant.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ValidatorRegistrator } from \"./ValidatorRegistrator.sol\";\nimport { IWETH9 } from \"../../interfaces/IWETH9.sol\";\n\n/// @title Validator Accountant\n/// @notice Attributes the ETH swept from beacon chain validators to this strategy contract\n/// as either full or partial withdrawals. Partial withdrawals being consensus rewards.\n/// Full withdrawals are from exited validators.\n/// @author Origin Protocol Inc\nabstract contract ValidatorAccountant is ValidatorRegistrator {\n    /// @notice The minimum amount of blocks that need to pass between two calls to manuallyFixAccounting\n    uint256 public constant MIN_FIX_ACCOUNTING_CADENCE = 7200; // 1 day\n\n    /// @notice Keeps track of the total consensus rewards swept from the beacon chain\n    uint256 public consensusRewards;\n\n    /// @notice start of fuse interval\n    uint256 public fuseIntervalStart;\n    /// @notice end of fuse interval\n    uint256 public fuseIntervalEnd;\n    /// @notice last block number manuallyFixAccounting has been called\n    uint256 public lastFixAccountingBlockNumber;\n\n    uint256[49] private __gap;\n\n    event FuseIntervalUpdated(uint256 start, uint256 end);\n    event AccountingFullyWithdrawnValidator(\n        uint256 noOfValidators,\n        uint256 remainingValidators,\n        uint256 wethSentToVault\n    );\n    event AccountingValidatorSlashed(\n        uint256 remainingValidators,\n        uint256 wethSentToVault\n    );\n    event AccountingConsensusRewards(uint256 amount);\n\n    event AccountingManuallyFixed(\n        int256 validatorsDelta,\n        int256 consensusRewardsDelta,\n        uint256 wethToVault\n    );\n\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\n    /// @param _vaultAddress Address of the Vault\n    /// @param _beaconChainDepositContract Address of the beacon chain deposit contract\n    /// @param _ssvNetwork Address of the SSV Network contract\n    /// @param _maxValidators Maximum number of validators that can be registered in the strategy\n    constructor(\n        address _wethAddress,\n        address _vaultAddress,\n        address _beaconChainDepositContract,\n        address _ssvNetwork,\n        uint256 _maxValidators\n    )\n        ValidatorRegistrator(\n            _wethAddress,\n            _vaultAddress,\n            _beaconChainDepositContract,\n            _ssvNetwork,\n            _maxValidators\n        )\n    {}\n\n    /// @notice set fuse interval values\n    function setFuseInterval(\n        uint256 _fuseIntervalStart,\n        uint256 _fuseIntervalEnd\n    ) external onlyGovernor {\n        require(\n            _fuseIntervalStart < _fuseIntervalEnd &&\n                _fuseIntervalEnd < 32 ether &&\n                _fuseIntervalEnd - _fuseIntervalStart >= 4 ether,\n            \"Incorrect fuse interval\"\n        );\n\n        fuseIntervalStart = _fuseIntervalStart;\n        fuseIntervalEnd = _fuseIntervalEnd;\n\n        emit FuseIntervalUpdated(_fuseIntervalStart, _fuseIntervalEnd);\n    }\n\n    /* solhint-disable max-line-length */\n    /// This notion page offers a good explanation of how the accounting functions\n    /// https://www.notion.so/originprotocol/Limited-simplified-native-staking-accounting-67a217c8420d40678eb943b9da0ee77d\n    /// In short, after dividing by 32, if the ETH remaining on the contract falls between 0 and fuseIntervalStart,\n    /// the accounting function will treat that ETH as Beacon chain consensus rewards.\n    /// On the contrary, if after dividing by 32, the ETH remaining on the contract falls between fuseIntervalEnd and 32,\n    /// the accounting function will treat that as a validator slashing.\n    /// @notice Perform the accounting attributing beacon chain ETH to either full or partial withdrawals. Returns true when\n    /// accounting is valid and fuse isn't \"blown\". Returns false when fuse is blown.\n    /// @dev This function could in theory be permission-less but lets allow only the Registrator (Defender Action) to call it\n    /// for now.\n    /// @return accountingValid true if accounting was successful, false if fuse is blown\n    /* solhint-enable max-line-length */\n    function doAccounting()\n        external\n        onlyRegistrator\n        whenNotPaused\n        nonReentrant\n        returns (bool accountingValid)\n    {\n        // pause the accounting on failure\n        accountingValid = _doAccounting(true);\n    }\n\n    // slither-disable-start reentrancy-eth\n    function _doAccounting(bool pauseOnFail)\n        internal\n        returns (bool accountingValid)\n    {\n        if (address(this).balance < consensusRewards) {\n            return _failAccounting(pauseOnFail);\n        }\n\n        // Calculate all the new ETH that has been swept to the contract since the last accounting\n        uint256 newSweptETH = address(this).balance - consensusRewards;\n        accountingValid = true;\n\n        // send the ETH that is from fully withdrawn validators to the Vault\n        if (newSweptETH >= FULL_STAKE) {\n            uint256 fullyWithdrawnValidators;\n            // explicitly cast to uint256 as we want to round to a whole number of validators\n            fullyWithdrawnValidators = uint256(newSweptETH / FULL_STAKE);\n            activeDepositedValidators -= fullyWithdrawnValidators;\n\n            uint256 wethToVault = FULL_STAKE * fullyWithdrawnValidators;\n            IWETH9(WETH).deposit{ value: wethToVault }();\n            // slither-disable-next-line unchecked-transfer\n            IWETH9(WETH).transfer(VAULT_ADDRESS, wethToVault);\n            _wethWithdrawnToVault(wethToVault);\n\n            emit AccountingFullyWithdrawnValidator(\n                fullyWithdrawnValidators,\n                activeDepositedValidators,\n                wethToVault\n            );\n        }\n\n        uint256 ethRemaining = address(this).balance - consensusRewards;\n        // should be less than a whole validator stake\n        require(ethRemaining < FULL_STAKE, \"Unexpected accounting\");\n\n        // If no Beacon chain consensus rewards swept\n        if (ethRemaining == 0) {\n            // do nothing\n            return accountingValid;\n        } else if (ethRemaining < fuseIntervalStart) {\n            // Beacon chain consensus rewards swept (partial validator withdrawals)\n            // solhint-disable-next-line reentrancy\n            consensusRewards += ethRemaining;\n            emit AccountingConsensusRewards(ethRemaining);\n        } else if (ethRemaining > fuseIntervalEnd) {\n            // Beacon chain consensus rewards swept but also a slashed validator fully exited\n            IWETH9(WETH).deposit{ value: ethRemaining }();\n            // slither-disable-next-line unchecked-transfer\n            IWETH9(WETH).transfer(VAULT_ADDRESS, ethRemaining);\n            activeDepositedValidators -= 1;\n\n            _wethWithdrawnToVault(ethRemaining);\n\n            emit AccountingValidatorSlashed(\n                activeDepositedValidators,\n                ethRemaining\n            );\n        }\n        // Oh no... Fuse is blown. The Strategist needs to adjust the accounting values.\n        else {\n            return _failAccounting(pauseOnFail);\n        }\n    }\n\n    // slither-disable-end reentrancy-eth\n\n    /// @dev pause any further accounting if required and return false\n    function _failAccounting(bool pauseOnFail)\n        internal\n        returns (bool accountingValid)\n    {\n        // pause if not already\n        if (pauseOnFail) {\n            _pause();\n        }\n        // fail the accounting\n        accountingValid = false;\n    }\n\n    /// @notice Allow the Strategist to fix the accounting of this strategy and unpause.\n    /// @param _validatorsDelta adjust the active validators by up to plus three or minus three\n    /// @param _consensusRewardsDelta adjust the accounted for consensus rewards up or down\n    /// @param _ethToVaultAmount the amount of ETH that gets wrapped into WETH and sent to the Vault\n    /// @dev There is a case when a validator(s) gets slashed so much that the eth swept from\n    /// the beacon chain enters the fuse area and there are no consensus rewards on the contract\n    /// to \"dip into\"/use. To increase the amount of unaccounted ETH over the fuse end interval\n    /// we need to reduce the amount of active deposited validators and immediately send WETH\n    /// to the vault, so it doesn't interfere with further accounting.\n    function manuallyFixAccounting(\n        int256 _validatorsDelta,\n        int256 _consensusRewardsDelta,\n        uint256 _ethToVaultAmount\n    ) external onlyStrategist whenPaused nonReentrant {\n        require(\n            lastFixAccountingBlockNumber + MIN_FIX_ACCOUNTING_CADENCE <\n                block.number,\n            \"Fix accounting called too soon\"\n        );\n        require(\n            _validatorsDelta >= -3 &&\n                _validatorsDelta <= 3 &&\n                // new value must be positive\n                int256(activeDepositedValidators) + _validatorsDelta >= 0,\n            \"Invalid validatorsDelta\"\n        );\n        require(\n            _consensusRewardsDelta >= -332 ether &&\n                _consensusRewardsDelta <= 332 ether &&\n                // new value must be positive\n                int256(consensusRewards) + _consensusRewardsDelta >= 0,\n            \"Invalid consensusRewardsDelta\"\n        );\n        require(_ethToVaultAmount <= 32 ether * 3, \"Invalid wethToVaultAmount\");\n\n        activeDepositedValidators = uint256(\n            int256(activeDepositedValidators) + _validatorsDelta\n        );\n        consensusRewards = uint256(\n            int256(consensusRewards) + _consensusRewardsDelta\n        );\n        lastFixAccountingBlockNumber = block.number;\n        if (_ethToVaultAmount > 0) {\n            IWETH9(WETH).deposit{ value: _ethToVaultAmount }();\n            // slither-disable-next-line unchecked-transfer\n            IWETH9(WETH).transfer(VAULT_ADDRESS, _ethToVaultAmount);\n            _wethWithdrawnToVault(_ethToVaultAmount);\n        }\n\n        emit AccountingManuallyFixed(\n            _validatorsDelta,\n            _consensusRewardsDelta,\n            _ethToVaultAmount\n        );\n\n        // rerun the accounting to see if it has now been fixed.\n        // Do not pause the accounting on failure as it is already paused\n        require(_doAccounting(false), \"Fuse still blown\");\n\n        // unpause since doAccounting was successful\n        _unpause();\n    }\n\n    /***************************************\n                 Abstract\n    ****************************************/\n\n    /// @dev allows for NativeStakingSSVStrategy contract to emit the Withdrawal event\n    function _wethWithdrawnToVault(uint256 _amount) internal virtual;\n}\n"
    },
    "contracts/strategies/NativeStaking/ValidatorRegistrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { Governable } from \"../../governance/Governable.sol\";\nimport { IDepositContract } from \"../../interfaces/IDepositContract.sol\";\nimport { IVault } from \"../../interfaces/IVault.sol\";\nimport { IWETH9 } from \"../../interfaces/IWETH9.sol\";\nimport { ISSVNetwork, Cluster } from \"../../interfaces/ISSVNetwork.sol\";\n\nstruct ValidatorStakeData {\n    bytes pubkey;\n    bytes signature;\n    bytes32 depositDataRoot;\n}\n\n/**\n * @title Registrator of the validators\n * @notice This contract implements all the required functionality to register, exit and remove validators.\n * @author Origin Protocol Inc\n */\nabstract contract ValidatorRegistrator is Governable, Pausable {\n    /// @notice The maximum amount of ETH that can be staked by a validator\n    /// @dev this can change in the future with EIP-7251, Increase the MAX_EFFECTIVE_BALANCE\n    uint256 public constant FULL_STAKE = 32 ether;\n\n    /// @notice The address of the Wrapped ETH (WETH) token contract\n    address public immutable WETH;\n    /// @notice The address of the beacon chain deposit contract\n    address public immutable BEACON_CHAIN_DEPOSIT_CONTRACT;\n    /// @notice The address of the SSV Network contract used to interface with\n    address public immutable SSV_NETWORK;\n    /// @notice Address of the OETH Vault proxy contract\n    address public immutable VAULT_ADDRESS;\n    /// @notice Maximum number of validators that can be registered in this strategy\n    uint256 public immutable MAX_VALIDATORS;\n\n    /// @notice Address of the registrator - allowed to register, exit and remove validators\n    address public validatorRegistrator;\n    /// @notice The number of validators that have 32 (!) ETH actively deposited. When a new deposit\n    /// to a validator happens this number increases, when a validator exit is detected this number\n    /// decreases.\n    uint256 public activeDepositedValidators;\n    /// @notice State of the validators keccak256(pubKey) => state\n    mapping(bytes32 => VALIDATOR_STATE) public validatorsStates;\n    /// @notice The account that is allowed to modify stakeETHThreshold and reset stakeETHTally\n    address public stakingMonitor;\n    /// @notice Amount of ETH that can be staked before staking on the contract is suspended\n    /// and the `stakingMonitor` needs to approve further staking by calling `resetStakeETHTally`\n    uint256 public stakeETHThreshold;\n    /// @notice Amount of ETH that has been staked since the `stakingMonitor` last called `resetStakeETHTally`.\n    /// This can not go above `stakeETHThreshold`.\n    uint256 public stakeETHTally;\n    // For future use\n    uint256[47] private __gap;\n\n    enum VALIDATOR_STATE {\n        NON_REGISTERED, // validator is not registered on the SSV network\n        REGISTERED, // validator is registered on the SSV network\n        STAKED, // validator has funds staked\n        EXITING, // exit message has been posted and validator is in the process of exiting\n        EXIT_COMPLETE // validator has funds withdrawn to the EigenPod and is removed from the SSV\n    }\n\n    event RegistratorChanged(address indexed newAddress);\n    event StakingMonitorChanged(address indexed newAddress);\n    event ETHStaked(bytes32 indexed pubKeyHash, bytes pubKey, uint256 amount);\n    event SSVValidatorRegistered(\n        bytes32 indexed pubKeyHash,\n        bytes pubKey,\n        uint64[] operatorIds\n    );\n    event SSVValidatorExitInitiated(\n        bytes32 indexed pubKeyHash,\n        bytes pubKey,\n        uint64[] operatorIds\n    );\n    event SSVValidatorExitCompleted(\n        bytes32 indexed pubKeyHash,\n        bytes pubKey,\n        uint64[] operatorIds\n    );\n    event StakeETHThresholdChanged(uint256 amount);\n    event StakeETHTallyReset();\n\n    /// @dev Throws if called by any account other than the Registrator\n    modifier onlyRegistrator() {\n        require(\n            msg.sender == validatorRegistrator,\n            \"Caller is not the Registrator\"\n        );\n        _;\n    }\n\n    /// @dev Throws if called by any account other than the Staking monitor\n    modifier onlyStakingMonitor() {\n        require(msg.sender == stakingMonitor, \"Caller is not the Monitor\");\n        _;\n    }\n\n    /// @dev Throws if called by any account other than the Strategist\n    modifier onlyStrategist() {\n        require(\n            msg.sender == IVault(VAULT_ADDRESS).strategistAddr(),\n            \"Caller is not the Strategist\"\n        );\n        _;\n    }\n\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\n    /// @param _vaultAddress Address of the Vault\n    /// @param _beaconChainDepositContract Address of the beacon chain deposit contract\n    /// @param _ssvNetwork Address of the SSV Network contract\n    /// @param _maxValidators Maximum number of validators that can be registered in the strategy\n    constructor(\n        address _wethAddress,\n        address _vaultAddress,\n        address _beaconChainDepositContract,\n        address _ssvNetwork,\n        uint256 _maxValidators\n    ) {\n        WETH = _wethAddress;\n        BEACON_CHAIN_DEPOSIT_CONTRACT = _beaconChainDepositContract;\n        SSV_NETWORK = _ssvNetwork;\n        VAULT_ADDRESS = _vaultAddress;\n        MAX_VALIDATORS = _maxValidators;\n    }\n\n    /// @notice Set the address of the registrator which can register, exit and remove validators\n    function setRegistrator(address _address) external onlyGovernor {\n        validatorRegistrator = _address;\n        emit RegistratorChanged(_address);\n    }\n\n    /// @notice Set the address of the staking monitor that is allowed to reset stakeETHTally\n    function setStakingMonitor(address _address) external onlyGovernor {\n        stakingMonitor = _address;\n        emit StakingMonitorChanged(_address);\n    }\n\n    /// @notice Set the amount of ETH that can be staked before staking monitor\n    // needs to a approve further staking by resetting the stake ETH tally\n    function setStakeETHThreshold(uint256 _amount) external onlyGovernor {\n        stakeETHThreshold = _amount;\n        emit StakeETHThresholdChanged(_amount);\n    }\n\n    /// @notice Reset the stakeETHTally\n    function resetStakeETHTally() external onlyStakingMonitor {\n        stakeETHTally = 0;\n        emit StakeETHTallyReset();\n    }\n\n    /// @notice Stakes WETH to the node validators\n    /// @param validators A list of validator data needed to stake.\n    /// The `ValidatorStakeData` struct contains the pubkey, signature and depositDataRoot.\n    /// Only the registrator can call this function.\n    // slither-disable-start reentrancy-eth\n    function stakeEth(ValidatorStakeData[] calldata validators)\n        external\n        onlyRegistrator\n        whenNotPaused\n        nonReentrant\n    {\n        uint256 requiredETH = validators.length * FULL_STAKE;\n\n        // Check there is enough WETH from the deposits sitting in this strategy contract\n        require(\n            requiredETH <= IWETH9(WETH).balanceOf(address(this)),\n            \"Insufficient WETH\"\n        );\n        require(\n            activeDepositedValidators + validators.length <= MAX_VALIDATORS,\n            \"Max validators reached\"\n        );\n\n        require(\n            stakeETHTally + requiredETH <= stakeETHThreshold,\n            \"Staking ETH over threshold\"\n        );\n        stakeETHTally += requiredETH;\n\n        // Convert required ETH from WETH\n        IWETH9(WETH).withdraw(requiredETH);\n        _wethWithdrawn(requiredETH);\n\n        /* 0x01 to indicate that withdrawal credentials will contain an EOA address that the sweeping function\n         * can sweep funds to.\n         * bytes11(0) to fill up the required zeros\n         * remaining bytes20 are for the address\n         */\n        bytes memory withdrawalCredentials = abi.encodePacked(\n            bytes1(0x01),\n            bytes11(0),\n            address(this)\n        );\n\n        // For each validator\n        for (uint256 i = 0; i < validators.length; ++i) {\n            bytes32 pubKeyHash = keccak256(validators[i].pubkey);\n\n            require(\n                validatorsStates[pubKeyHash] == VALIDATOR_STATE.REGISTERED,\n                \"Validator not registered\"\n            );\n\n            IDepositContract(BEACON_CHAIN_DEPOSIT_CONTRACT).deposit{\n                value: FULL_STAKE\n            }(\n                validators[i].pubkey,\n                withdrawalCredentials,\n                validators[i].signature,\n                validators[i].depositDataRoot\n            );\n\n            validatorsStates[pubKeyHash] = VALIDATOR_STATE.STAKED;\n\n            emit ETHStaked(pubKeyHash, validators[i].pubkey, FULL_STAKE);\n        }\n        // save gas by changing this storage variable only once rather each time in the loop.\n        activeDepositedValidators += validators.length;\n    }\n\n    // slither-disable-end reentrancy-eth\n\n    /// @notice Registers a new validator in the SSV Cluster.\n    /// Only the registrator can call this function.\n    /// @param publicKeys The public keys of the validators\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param sharesData The shares data for each validator\n    /// @param ssvAmount The amount of SSV tokens to be deposited to the SSV cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    // slither-disable-start reentrancy-no-eth\n    function registerSsvValidators(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds,\n        bytes[] calldata sharesData,\n        uint256 ssvAmount,\n        Cluster calldata cluster\n    ) external onlyRegistrator whenNotPaused {\n        require(\n            publicKeys.length == sharesData.length,\n            \"Pubkey sharesData mismatch\"\n        );\n        // Check each public key has not already been used\n        bytes32 pubKeyHash;\n        VALIDATOR_STATE currentState;\n        for (uint256 i = 0; i < publicKeys.length; ++i) {\n            pubKeyHash = keccak256(publicKeys[i]);\n            currentState = validatorsStates[pubKeyHash];\n            require(\n                currentState == VALIDATOR_STATE.NON_REGISTERED,\n                \"Validator already registered\"\n            );\n\n            validatorsStates[pubKeyHash] = VALIDATOR_STATE.REGISTERED;\n\n            emit SSVValidatorRegistered(pubKeyHash, publicKeys[i], operatorIds);\n        }\n\n        ISSVNetwork(SSV_NETWORK).bulkRegisterValidator(\n            publicKeys,\n            operatorIds,\n            sharesData,\n            ssvAmount,\n            cluster\n        );\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice Exit a validator from the Beacon chain.\n    /// The staked ETH will eventually swept to this native staking strategy.\n    /// Only the registrator can call this function.\n    /// @param publicKey The public key of the validator\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    // slither-disable-start reentrancy-no-eth\n    function exitSsvValidator(\n        bytes calldata publicKey,\n        uint64[] calldata operatorIds\n    ) external onlyRegistrator whenNotPaused {\n        bytes32 pubKeyHash = keccak256(publicKey);\n        VALIDATOR_STATE currentState = validatorsStates[pubKeyHash];\n        require(currentState == VALIDATOR_STATE.STAKED, \"Validator not staked\");\n\n        ISSVNetwork(SSV_NETWORK).exitValidator(publicKey, operatorIds);\n\n        validatorsStates[pubKeyHash] = VALIDATOR_STATE.EXITING;\n\n        emit SSVValidatorExitInitiated(pubKeyHash, publicKey, operatorIds);\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice Remove a validator from the SSV Cluster.\n    /// Make sure `exitSsvValidator` is called before and the validate has exited the Beacon chain.\n    /// If removed before the validator has exited the beacon chain will result in the validator being slashed.\n    /// Only the registrator can call this function.\n    /// @param publicKey The public key of the validator\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    // slither-disable-start reentrancy-no-eth\n    function removeSsvValidator(\n        bytes calldata publicKey,\n        uint64[] calldata operatorIds,\n        Cluster calldata cluster\n    ) external onlyRegistrator whenNotPaused {\n        bytes32 pubKeyHash = keccak256(publicKey);\n        VALIDATOR_STATE currentState = validatorsStates[pubKeyHash];\n        // Can remove SSV validators that were incorrectly registered and can not be deposited to.\n        require(\n            currentState == VALIDATOR_STATE.EXITING ||\n                currentState == VALIDATOR_STATE.REGISTERED,\n            \"Validator not regd or exiting\"\n        );\n\n        ISSVNetwork(SSV_NETWORK).removeValidator(\n            publicKey,\n            operatorIds,\n            cluster\n        );\n\n        validatorsStates[pubKeyHash] = VALIDATOR_STATE.EXIT_COMPLETE;\n\n        emit SSVValidatorExitCompleted(pubKeyHash, publicKey, operatorIds);\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice Deposits more SSV Tokens to the SSV Network contract which is used to pay the SSV Operators.\n    /// @dev A SSV cluster is defined by the SSVOwnerAddress and the set of operatorIds.\n    /// uses \"onlyStrategist\" modifier so continuous front-running can't DOS our maintenance service\n    /// that tries to top up SSV tokens.\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param ssvAmount The amount of SSV tokens to be deposited to the SSV cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    function depositSSV(\n        uint64[] memory operatorIds,\n        uint256 ssvAmount,\n        Cluster memory cluster\n    ) external onlyStrategist {\n        ISSVNetwork(SSV_NETWORK).deposit(\n            address(this),\n            operatorIds,\n            ssvAmount,\n            cluster\n        );\n    }\n\n    /***************************************\n                 Abstract\n    ****************************************/\n\n    /// @dev Called when WETH is withdrawn from the strategy or staked to a validator so\n    /// the strategy knows how much WETH it has on deposit.\n    /// This is so it can emit the correct amount in the Deposit event in depositAll().\n    function _wethWithdrawn(uint256 _amount) internal virtual;\n}\n"
    },
    "contracts/strategies/ThreePoolStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Curve 3Pool Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ICurveGauge } from \"./ICurveGauge.sol\";\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { ICRVMinter } from \"./ICRVMinter.sol\";\nimport { IERC20, AbstractCurveStrategy, InitializableAbstractStrategy } from \"./AbstractCurveStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\n\n/*\n * IMPORTANT(!) If ThreePoolStrategy needs to be re-deployed, it requires new\n * proxy contract with fresh storage slots. Changes in `AbstractCurveStrategy`\n * storage slots would break existing implementation.\n *\n * Remove this notice if ThreePoolStrategy is re-deployed\n */\ncontract ThreePoolStrategy is AbstractCurveStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address internal crvGaugeAddress;\n    address internal crvMinterAddress;\n\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Curve strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddress Address of CRV\n     * @param _assets Addresses of supported assets. MUST be passed in the same\n     *                order as returned by coins on the pool contract, i.e.\n     *                DAI, USDC, USDT\n     * @param _pTokens Platform Token corresponding addresses\n     * @param _crvGaugeAddress Address of the Curve DAO gauge for this pool\n     * @param _crvMinterAddress Address of the CRV minter for rewards\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddress, // CRV\n        address[] calldata _assets,\n        address[] calldata _pTokens,\n        address _crvGaugeAddress,\n        address _crvMinterAddress\n    ) external onlyGovernor initializer {\n        require(_assets.length == 3, \"Must have exactly three assets\");\n        // Should be set prior to abstract initialize call otherwise\n        // abstractSetPToken calls will fail\n        crvGaugeAddress = _crvGaugeAddress;\n        crvMinterAddress = _crvMinterAddress;\n        pTokenAddress = _pTokens[0];\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddress,\n            _assets,\n            _pTokens\n        );\n        _approveBase();\n    }\n\n    function _lpDepositAll() internal override {\n        IERC20 pToken = IERC20(pTokenAddress);\n        // Deposit into Gauge\n        ICurveGauge(crvGaugeAddress).deposit(\n            pToken.balanceOf(address(this)),\n            address(this)\n        );\n    }\n\n    function _lpWithdraw(uint256 numPTokens) internal override {\n        // Not enough of pool token exists on this contract, some must be\n        // staked in Gauge, unstake difference\n        ICurveGauge(crvGaugeAddress).withdraw(numPTokens);\n    }\n\n    function _lpWithdrawAll() internal override {\n        ICurveGauge gauge = ICurveGauge(crvGaugeAddress);\n        gauge.withdraw(gauge.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(assetToPToken[_asset] != address(0), \"Unsupported asset\");\n        // LP tokens in this contract. This should generally be nothing as we\n        // should always stake the full balance in the Gauge, but include for\n        // safety\n\n        uint256 contractPTokens = IERC20(pTokenAddress).balanceOf(\n            address(this)\n        );\n        ICurveGauge gauge = ICurveGauge(crvGaugeAddress);\n        uint256 gaugePTokens = gauge.balanceOf(address(this));\n        uint256 totalPTokens = contractPTokens + gaugePTokens;\n\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        if (totalPTokens > 0) {\n            uint256 virtual_price = curvePool.get_virtual_price();\n            uint256 value = (totalPTokens * virtual_price) / 1e18;\n            uint256 assetDecimals = Helpers.getDecimals(_asset);\n            balance = value.scaleBy(assetDecimals, 18) / 3;\n        }\n    }\n\n    function _approveBase() internal override {\n        IERC20 pToken = IERC20(pTokenAddress);\n        // 3Pool for LP token (required for removing liquidity)\n        pToken.safeApprove(platformAddress, 0);\n        pToken.safeApprove(platformAddress, type(uint256).max);\n        // Gauge for LP token\n        pToken.safeApprove(crvGaugeAddress, 0);\n        pToken.safeApprove(crvGaugeAddress, type(uint256).max);\n    }\n\n    /**\n     * @dev Collect accumulated CRV and send to Vault.\n     */\n    function collectRewardTokens() public override onlyHarvester nonReentrant {\n        // Collect\n        ICRVMinter(crvMinterAddress).mint(crvGaugeAddress);\n        // Send\n        IERC20 crvToken = IERC20(rewardTokenAddresses[0]);\n        uint256 balance = crvToken.balanceOf(address(this));\n        emit RewardTokenCollected(\n            harvesterAddress,\n            rewardTokenAddresses[0],\n            balance\n        );\n        crvToken.safeTransfer(harvesterAddress, balance);\n    }\n}\n"
    },
    "contracts/strategies/VaultValueChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IOUSD } from \"../interfaces/IOUSD.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract VaultValueChecker {\n    IVault public immutable vault;\n    IOUSD public immutable ousd;\n    // Snapshot expiration time in seconds.\n    // Used to prevent accidental use of an old snapshot, but\n    // is not zero to allow easy testing of strategist actions in fork testing\n    uint256 constant SNAPSHOT_EXPIRES = 5 * 60;\n\n    struct Snapshot {\n        uint256 vaultValue;\n        uint256 totalSupply;\n        uint256 time;\n    }\n    // By doing per user snapshots, we prevent a reentrancy attack\n    // from a third party that updates the snapshot in the middle\n    // of an allocation process\n\n    mapping(address => Snapshot) public snapshots;\n\n    constructor(address _vault, address _ousd) {\n        vault = IVault(_vault);\n        ousd = IOUSD(_ousd);\n    }\n\n    function takeSnapshot() external {\n        snapshots[msg.sender] = Snapshot({\n            vaultValue: vault.totalValue(),\n            totalSupply: ousd.totalSupply(),\n            time: block.timestamp\n        });\n    }\n\n    function checkDelta(\n        int256 expectedProfit,\n        int256 profitVariance,\n        int256 expectedVaultChange,\n        int256 vaultChangeVariance\n    ) external {\n        // Intentionaly not view so that this method shows up in TX builders\n        Snapshot memory snapshot = snapshots[msg.sender];\n        int256 vaultChange = toInt256(vault.totalValue()) -\n            toInt256(snapshot.vaultValue);\n        int256 supplyChange = toInt256(ousd.totalSupply()) -\n            toInt256(snapshot.totalSupply);\n        int256 profit = vaultChange - supplyChange;\n\n        require(\n            snapshot.time >= block.timestamp - SNAPSHOT_EXPIRES,\n            \"Snapshot too old\"\n        );\n        require(snapshot.time <= block.timestamp, \"Snapshot too new\");\n        require(profit >= expectedProfit - profitVariance, \"Profit too low\");\n        require(profit <= expectedProfit + profitVariance, \"Profit too high\");\n        require(\n            vaultChange >= expectedVaultChange - vaultChangeVariance,\n            \"Vault value change too low\"\n        );\n        require(\n            vaultChange <= expectedVaultChange + vaultChangeVariance,\n            \"Vault value change too high\"\n        );\n    }\n\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // From openzeppelin math/SafeCast.sol\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(\n            value <= uint256(type(int256).max),\n            \"SafeCast: value doesn't fit in an int256\"\n        );\n        return int256(value);\n    }\n}\n\ncontract OETHVaultValueChecker is VaultValueChecker {\n    constructor(address _vault, address _ousd)\n        VaultValueChecker(_vault, _ousd)\n    {}\n}\n"
    },
    "contracts/swapper/Swapper1InchV5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @notice 1Inch Pathfinder V5 implementation of the general ISwapper interface.\n * @author Origin Protocol Inc\n * @dev It is possible that dust token amounts are left in this contract after a swap.\n * This can happen with some tokens that don't send the full transfer amount.\n * These dust amounts can build up over time and be used by anyone who calls the `swap` function.\n */\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IAggregationExecutor, IOneInchRouter, SwapDescription } from \"../interfaces/IOneInch.sol\";\nimport { ISwapper } from \"../interfaces/ISwapper.sol\";\n\ncontract Swapper1InchV5 is ISwapper {\n    using SafeERC20 for IERC20;\n\n    /// @notice 1Inch router contract to give allowance to perform swaps\n    address public constant SWAP_ROUTER =\n        0x1111111254EEB25477B68fb85Ed929f73A960582;\n\n    // swap(address,(address,address,address,address,uint256,uint256,uint256),bytes,bytes)\n    bytes4 internal constant SWAP_SELECTOR = 0x12aa3caf;\n    // unoswapTo(address,address,uint256,uint256,uint256[])\n    bytes4 internal constant UNISWAP_SELECTOR = 0xf78dc253;\n    // uniswapV3SwapTo(address,uint256,uint256,uint256[])\n    bytes4 internal constant UNISWAPV3_SELECTOR = 0xbc80f1a8;\n\n    /**\n     * @notice Strategist swaps assets sitting in the contract of the `assetHolder`.\n     * @param _fromAsset The token address of the asset being sold by the vault.\n     * @param _toAsset The token address of the asset being purchased by the vault.\n     * @param _fromAssetAmount The amount of assets being sold by the vault.\n     * @param _minToAssetAmount The minimum amount of assets to be purchased.\n     * @param _data RLP encoded executer address and bytes data. This is re-encoded tx.data from 1Inch swap API\n     */\n    function swap(\n        address _fromAsset,\n        address _toAsset,\n        uint256 _fromAssetAmount,\n        uint256 _minToAssetAmount,\n        bytes calldata _data\n    ) external override returns (uint256 toAssetAmount) {\n        // Decode the function selector from the RLP encoded _data param\n        bytes4 swapSelector = bytes4(_data[:4]);\n\n        if (swapSelector == SWAP_SELECTOR) {\n            // Decode the executer address and data from the RLP encoded _data param\n            (, address executer, bytes memory executerData) = abi.decode(\n                _data,\n                (bytes4, address, bytes)\n            );\n            SwapDescription memory swapDesc = SwapDescription({\n                srcToken: IERC20(_fromAsset),\n                dstToken: IERC20(_toAsset),\n                srcReceiver: payable(executer),\n                dstReceiver: payable(msg.sender),\n                amount: _fromAssetAmount,\n                minReturnAmount: _minToAssetAmount,\n                flags: 4 // 1st bit _PARTIAL_FILL, 2nd bit _REQUIRES_EXTRA_ETH, 3rd bit _SHOULD_CLAIM\n            });\n            (toAssetAmount, ) = IOneInchRouter(SWAP_ROUTER).swap(\n                IAggregationExecutor(executer),\n                swapDesc,\n                hex\"\",\n                executerData\n            );\n        } else if (swapSelector == UNISWAP_SELECTOR) {\n            // Need to get the Uniswap pools data from the _data param\n            (, uint256[] memory pools) = abi.decode(_data, (bytes4, uint256[]));\n            toAssetAmount = IOneInchRouter(SWAP_ROUTER).unoswapTo(\n                payable(msg.sender),\n                IERC20(_fromAsset),\n                _fromAssetAmount,\n                _minToAssetAmount,\n                pools\n            );\n        } else if (swapSelector == UNISWAPV3_SELECTOR) {\n            // Need to get the Uniswap pools data from the _data param\n            // slither-disable-next-line uninitialized-storage\n            (, uint256[] memory pools) = abi.decode(_data, (bytes4, uint256[]));\n            toAssetAmount = IOneInchRouter(SWAP_ROUTER).uniswapV3SwapTo(\n                payable(msg.sender),\n                _fromAssetAmount,\n                _minToAssetAmount,\n                pools\n            );\n        } else {\n            revert(\"Unsupported swap function\");\n        }\n    }\n\n    /**\n     * @notice Approve assets for swapping.\n     * @param _assets Array of token addresses to approve.\n     * @dev unlimited approval is used as no tokens sit in this contract outside a transaction.\n     */\n    function approveAssets(address[] memory _assets) external {\n        for (uint256 i = 0; i < _assets.length; ++i) {\n            // Give the 1Inch router approval to transfer unlimited assets\n            IERC20(_assets[i]).safeApprove(SWAP_ROUTER, type(uint256).max);\n        }\n    }\n}\n"
    },
    "contracts/timelock/Timelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD Timelock Contract\n * @author Origin Protocol Inc\n */\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ninterface CapitalPausable {\n    function pauseCapital() external;\n\n    function unpauseCapital() external;\n}\n\ncontract Timelock {\n    using SafeMath for uint256;\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint256 indexed newDelay);\n    event CancelTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event ExecuteTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event QueueTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n\n    uint256 public constant GRACE_PERIOD = 3 days;\n    uint256 public constant MINIMUM_DELAY = 1 minutes;\n    uint256 public constant MAXIMUM_DELAY = 2 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint256 public delay;\n\n    mapping(bytes32 => bool) public queuedTransactions;\n\n    /**\n     * @dev Throws if called by any account other than the Admin.\n     */\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Caller is not the admin\");\n        _;\n    }\n\n    constructor(address admin_, uint256 delay_) {\n        require(\n            delay_ >= MINIMUM_DELAY,\n            \"Timelock::constructor: Delay must exceed minimum delay.\"\n        );\n        require(\n            delay_ <= MAXIMUM_DELAY,\n            \"Timelock::setDelay: Delay must not exceed maximum delay.\"\n        );\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    function setDelay(uint256 delay_) public {\n        require(\n            msg.sender == address(this),\n            \"Timelock::setDelay: Call must come from Timelock.\"\n        );\n        require(\n            delay_ >= MINIMUM_DELAY,\n            \"Timelock::setDelay: Delay must exceed minimum delay.\"\n        );\n        require(\n            delay_ <= MAXIMUM_DELAY,\n            \"Timelock::setDelay: Delay must not exceed maximum delay.\"\n        );\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(\n            msg.sender == pendingAdmin,\n            \"Timelock::acceptAdmin: Call must come from pendingAdmin.\"\n        );\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public onlyAdmin {\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(\n        address target,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal returns (bytes32) {\n        require(\n            msg.sender == admin,\n            \"Timelock::queueTransaction: Call must come from admin.\"\n        );\n        require(\n            eta >= getBlockTimestamp().add(delay),\n            \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\n        );\n\n        bytes32 txHash = keccak256(\n            abi.encode(target, signature, keccak256(data), eta)\n        );\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(\n        address target,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            msg.sender == admin,\n            \"Timelock::cancelTransaction: Call must come from admin.\"\n        );\n\n        bytes32 txHash = keccak256(\n            abi.encode(target, signature, keccak256(data), eta)\n        );\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, signature, data, eta);\n    }\n\n    function _getRevertMsg(bytes memory _returnData)\n        internal\n        pure\n        returns (string memory)\n    {\n        // If the _res length is less than 68, then the transaction failed\n        // silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string));\n    }\n\n    function executeTransaction(\n        address target,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal returns (bytes memory) {\n        require(\n            msg.sender == admin,\n            \"Timelock::executeTransaction: Call must come from admin.\"\n        );\n\n        bytes32 txHash = keccak256(\n            abi.encode(target, signature, keccak256(data), eta)\n        );\n        require(\n            queuedTransactions[txHash],\n            \"Timelock::executeTransaction: Transaction hasn't been queued.\"\n        );\n        require(\n            getBlockTimestamp() >= eta,\n            \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\"\n        );\n        require(\n            getBlockTimestamp() <= eta.add(GRACE_PERIOD),\n            \"Timelock::executeTransaction: Transaction is stale.\"\n        );\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(\n                bytes4(keccak256(bytes(signature))),\n                data\n            );\n        }\n\n        (bool success, bytes memory returnData) = target.call(callData);\n\n        if (!success) {\n            revert(_getRevertMsg(returnData));\n        }\n\n        emit ExecuteTransaction(txHash, target, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint256) {\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    }\n\n    function pauseCapital(address target) external {\n        require(\n            msg.sender == admin,\n            \"Timelock::pauseCapital: Call must come from admin.\"\n        );\n        CapitalPausable(target).pauseCapital();\n    }\n\n    function unpauseCapital(address target) external {\n        require(\n            msg.sender == admin,\n            \"Timelock::unpauseCapital: Call must come from admin.\"\n        );\n        CapitalPausable(target).unpauseCapital();\n    }\n}\n"
    },
    "contracts/token/BridgedWOETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { AccessControlEnumerable } from \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { Initializable } from \"../utils/Initializable.sol\";\n\ncontract BridgedWOETH is\n    Governable,\n    AccessControlEnumerable,\n    Initializable,\n    ERC20\n{\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n\n    constructor() ERC20(\"Wrapped OETH\", \"wOETH\") {\n        // Nobody owns the implementation\n        _setGovernor(address(0));\n    }\n\n    /**\n     * @dev Initialize the proxy and set the Governor\n     */\n    function initialize() external initializer {\n        // Governor can grant Minter/Burner roles\n        _setupRole(DEFAULT_ADMIN_ROLE, _governor());\n    }\n\n    /**\n     * @dev Mint tokens for `account`\n     * @param account Address to mint tokens for\n     * @param amount Amount of tokens to mint\n     */\n    function mint(address account, uint256 amount)\n        external\n        onlyRole(MINTER_ROLE)\n        nonReentrant\n    {\n        _mint(account, amount);\n    }\n\n    /**\n     * @dev Burns tokens from `account`\n     * @param account Address to burn tokens from\n     * @param amount Amount of tokens to burn\n     */\n    function burn(address account, uint256 amount)\n        external\n        onlyRole(BURNER_ROLE)\n        nonReentrant\n    {\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev Burns tokens from `msg.sender`\n     * @param amount Amount of tokens to burn\n     */\n    function burn(uint256 amount) external onlyRole(BURNER_ROLE) nonReentrant {\n        _burn(msg.sender, amount);\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return \"Wrapped OETH\";\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return \"wOETH\";\n    }\n\n    /**\n     * @dev Returns the decimals of the token\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n}\n"
    },
    "contracts/token/OETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { OUSD } from \"./OUSD.sol\";\n\n/**\n * @title OETH Token Contract\n * @author Origin Protocol Inc\n */\ncontract OETH is OUSD {\n\n}\n"
    },
    "contracts/token/OETHBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { OUSD } from \"./OUSD.sol\";\nimport { InitializableERC20Detailed } from \"../utils/InitializableERC20Detailed.sol\";\n\n/**\n * @title OETH Token Contract\n * @author Origin Protocol Inc\n */\ncontract OETHBase is OUSD {\n    /**\n     * @dev OETHb is already intialized on Base. So `initialize`\n     *      cannot be used again. And the `name` and `symbol`\n     *      methods aren't `virtual`. That's the reason this\n     *      function exists.\n     */\n    function initialize2() external onlyGovernor {\n        InitializableERC20Detailed._initialize(\"Super OETH\", \"superOETHb\", 18);\n    }\n}\n"
    },
    "contracts/token/OUSD.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD Token Contract\n * @dev ERC20 compatible contract for OUSD\n * @dev Implements an elastic supply\n * @author Origin Protocol Inc\n */\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { InitializableERC20Detailed } from \"../utils/InitializableERC20Detailed.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\n\n/**\n * NOTE that this is an ERC20 token but the invariant that the sum of\n * balanceOf(x) for all x is not >= totalSupply(). This is a consequence of the\n * rebasing design. Any integrations with OUSD should be aware.\n */\n\ncontract OUSD is Initializable, InitializableERC20Detailed, Governable {\n    using SafeMath for uint256;\n    using StableMath for uint256;\n\n    event TotalSupplyUpdatedHighres(\n        uint256 totalSupply,\n        uint256 rebasingCredits,\n        uint256 rebasingCreditsPerToken\n    );\n    event AccountRebasingEnabled(address account);\n    event AccountRebasingDisabled(address account);\n\n    enum RebaseOptions {\n        NotSet,\n        OptOut,\n        OptIn\n    }\n\n    uint256 private constant MAX_SUPPLY = ~uint128(0); // (2^128) - 1\n    uint256 public _totalSupply;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    address public vaultAddress = address(0);\n    mapping(address => uint256) private _creditBalances;\n    uint256 private _rebasingCredits;\n    uint256 private _rebasingCreditsPerToken;\n    // Frozen address/credits are non rebasing (value is held in contracts which\n    // do not receive yield unless they explicitly opt in)\n    uint256 public nonRebasingSupply;\n    mapping(address => uint256) public nonRebasingCreditsPerToken;\n    mapping(address => RebaseOptions) public rebaseState;\n    mapping(address => uint256) public isUpgraded;\n\n    uint256 private constant RESOLUTION_INCREASE = 1e9;\n\n    function initialize(\n        string calldata _nameArg,\n        string calldata _symbolArg,\n        address _vaultAddress,\n        uint256 _initialCreditsPerToken\n    ) external onlyGovernor initializer {\n        InitializableERC20Detailed._initialize(_nameArg, _symbolArg, 18);\n        _rebasingCreditsPerToken = _initialCreditsPerToken;\n        vaultAddress = _vaultAddress;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault contract\n     */\n    modifier onlyVault() {\n        require(vaultAddress == msg.sender, \"Caller is not the Vault\");\n        _;\n    }\n\n    /**\n     * @return The total supply of OUSD.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @return Low resolution rebasingCreditsPerToken\n     */\n    function rebasingCreditsPerToken() public view returns (uint256) {\n        return _rebasingCreditsPerToken / RESOLUTION_INCREASE;\n    }\n\n    /**\n     * @return Low resolution total number of rebasing credits\n     */\n    function rebasingCredits() public view returns (uint256) {\n        return _rebasingCredits / RESOLUTION_INCREASE;\n    }\n\n    /**\n     * @return High resolution rebasingCreditsPerToken\n     */\n    function rebasingCreditsPerTokenHighres() public view returns (uint256) {\n        return _rebasingCreditsPerToken;\n    }\n\n    /**\n     * @return High resolution total number of rebasing credits\n     */\n    function rebasingCreditsHighres() public view returns (uint256) {\n        return _rebasingCredits;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param _account Address to query the balance of.\n     * @return A uint256 representing the amount of base units owned by the\n     *         specified address.\n     */\n    function balanceOf(address _account)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (_creditBalances[_account] == 0) return 0;\n        return\n            _creditBalances[_account].divPrecisely(_creditsPerToken(_account));\n    }\n\n    /**\n     * @dev Gets the credits balance of the specified address.\n     * @dev Backwards compatible with old low res credits per token.\n     * @param _account The address to query the balance of.\n     * @return (uint256, uint256) Credit balance and credits per token of the\n     *         address\n     */\n    function creditsBalanceOf(address _account)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        uint256 cpt = _creditsPerToken(_account);\n        if (cpt == 1e27) {\n            // For a period before the resolution upgrade, we created all new\n            // contract accounts at high resolution. Since they are not changing\n            // as a result of this upgrade, we will return their true values\n            return (_creditBalances[_account], cpt);\n        } else {\n            return (\n                _creditBalances[_account] / RESOLUTION_INCREASE,\n                cpt / RESOLUTION_INCREASE\n            );\n        }\n    }\n\n    /**\n     * @dev Gets the credits balance of the specified address.\n     * @param _account The address to query the balance of.\n     * @return (uint256, uint256, bool) Credit balance, credits per token of the\n     *         address, and isUpgraded\n     */\n    function creditsBalanceOfHighres(address _account)\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        return (\n            _creditBalances[_account],\n            _creditsPerToken(_account),\n            isUpgraded[_account] == 1\n        );\n    }\n\n    /**\n     * @dev Transfer tokens to a specified address.\n     * @param _to the address to transfer to.\n     * @param _value the amount to be transferred.\n     * @return true on success.\n     */\n    function transfer(address _to, uint256 _value)\n        public\n        override\n        returns (bool)\n    {\n        require(_to != address(0), \"Transfer to zero address\");\n        require(\n            _value <= balanceOf(msg.sender),\n            \"Transfer greater than balance\"\n        );\n\n        _executeTransfer(msg.sender, _to, _value);\n\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another.\n     * @param _from The address you want to send tokens from.\n     * @param _to The address you want to transfer to.\n     * @param _value The amount of tokens to be transferred.\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public override returns (bool) {\n        require(_to != address(0), \"Transfer to zero address\");\n        require(_value <= balanceOf(_from), \"Transfer greater than balance\");\n\n        _allowances[_from][msg.sender] = _allowances[_from][msg.sender].sub(\n            _value\n        );\n\n        _executeTransfer(_from, _to, _value);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /**\n     * @dev Update the count of non rebasing credits in response to a transfer\n     * @param _from The address you want to send tokens from.\n     * @param _to The address you want to transfer to.\n     * @param _value Amount of OUSD to transfer\n     */\n    function _executeTransfer(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal {\n        bool isNonRebasingTo = _isNonRebasingAccount(_to);\n        bool isNonRebasingFrom = _isNonRebasingAccount(_from);\n\n        // Credits deducted and credited might be different due to the\n        // differing creditsPerToken used by each account\n        uint256 creditsCredited = _value.mulTruncate(_creditsPerToken(_to));\n        uint256 creditsDeducted = _value.mulTruncate(_creditsPerToken(_from));\n\n        _creditBalances[_from] = _creditBalances[_from].sub(\n            creditsDeducted,\n            \"Transfer amount exceeds balance\"\n        );\n        _creditBalances[_to] = _creditBalances[_to].add(creditsCredited);\n\n        if (isNonRebasingTo && !isNonRebasingFrom) {\n            // Transfer to non-rebasing account from rebasing account, credits\n            // are removed from the non rebasing tally\n            nonRebasingSupply = nonRebasingSupply.add(_value);\n            // Update rebasingCredits by subtracting the deducted amount\n            _rebasingCredits = _rebasingCredits.sub(creditsDeducted);\n        } else if (!isNonRebasingTo && isNonRebasingFrom) {\n            // Transfer to rebasing account from non-rebasing account\n            // Decreasing non-rebasing credits by the amount that was sent\n            nonRebasingSupply = nonRebasingSupply.sub(_value);\n            // Update rebasingCredits by adding the credited amount\n            _rebasingCredits = _rebasingCredits.add(creditsCredited);\n        }\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that _owner has allowed to\n     *      `_spender`.\n     * @param _owner The address which owns the funds.\n     * @param _spender The address which will spend the funds.\n     * @return The number of tokens still available for the _spender.\n     */\n    function allowance(address _owner, address _spender)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _allowances[_owner][_spender];\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens\n     *      on behalf of msg.sender. This method is included for ERC20\n     *      compatibility. `increaseAllowance` and `decreaseAllowance` should be\n     *      used instead.\n     *\n     *      Changing an allowance with this method brings the risk that someone\n     *      may transfer both the old and the new allowance - if they are both\n     *      greater than zero - if a transfer transaction is mined before the\n     *      later approve() call is mined.\n     * @param _spender The address which will spend the funds.\n     * @param _value The amount of tokens to be spent.\n     */\n    function approve(address _spender, uint256 _value)\n        public\n        override\n        returns (bool)\n    {\n        _allowances[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner has allowed to\n     *      `_spender`.\n     *      This method should be used instead of approve() to avoid the double\n     *      approval vulnerability described above.\n     * @param _spender The address which will spend the funds.\n     * @param _addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue)\n        public\n        returns (bool)\n    {\n        _allowances[msg.sender][_spender] = _allowances[msg.sender][_spender]\n            .add(_addedValue);\n        emit Approval(msg.sender, _spender, _allowances[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner has allowed to\n            `_spender`.\n     * @param _spender The address which will spend the funds.\n     * @param _subtractedValue The amount of tokens to decrease the allowance\n     *        by.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue)\n        public\n        returns (bool)\n    {\n        uint256 oldValue = _allowances[msg.sender][_spender];\n        if (_subtractedValue >= oldValue) {\n            _allowances[msg.sender][_spender] = 0;\n        } else {\n            _allowances[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, _allowances[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Mints new tokens, increasing totalSupply.\n     */\n    function mint(address _account, uint256 _amount) external onlyVault {\n        _mint(_account, _amount);\n    }\n\n    /**\n     * @dev Creates `_amount` tokens and assigns them to `_account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address _account, uint256 _amount) internal nonReentrant {\n        require(_account != address(0), \"Mint to the zero address\");\n\n        bool isNonRebasingAccount = _isNonRebasingAccount(_account);\n\n        uint256 creditAmount = _amount.mulTruncate(_creditsPerToken(_account));\n        _creditBalances[_account] = _creditBalances[_account].add(creditAmount);\n\n        // If the account is non rebasing and doesn't have a set creditsPerToken\n        // then set it i.e. this is a mint from a fresh contract\n        if (isNonRebasingAccount) {\n            nonRebasingSupply = nonRebasingSupply.add(_amount);\n        } else {\n            _rebasingCredits = _rebasingCredits.add(creditAmount);\n        }\n\n        _totalSupply = _totalSupply.add(_amount);\n\n        require(_totalSupply < MAX_SUPPLY, \"Max supply\");\n\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    /**\n     * @dev Burns tokens, decreasing totalSupply.\n     */\n    function burn(address account, uint256 amount) external onlyVault {\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev Destroys `_amount` tokens from `_account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must have at least `_amount` tokens.\n     */\n    function _burn(address _account, uint256 _amount) internal nonReentrant {\n        require(_account != address(0), \"Burn from the zero address\");\n        if (_amount == 0) {\n            return;\n        }\n\n        bool isNonRebasingAccount = _isNonRebasingAccount(_account);\n        uint256 creditAmount = _amount.mulTruncate(_creditsPerToken(_account));\n        uint256 currentCredits = _creditBalances[_account];\n\n        // Remove the credits, burning rounding errors\n        if (\n            currentCredits == creditAmount || currentCredits - 1 == creditAmount\n        ) {\n            // Handle dust from rounding\n            _creditBalances[_account] = 0;\n        } else if (currentCredits > creditAmount) {\n            _creditBalances[_account] = _creditBalances[_account].sub(\n                creditAmount\n            );\n        } else {\n            revert(\"Remove exceeds balance\");\n        }\n\n        // Remove from the credit tallies and non-rebasing supply\n        if (isNonRebasingAccount) {\n            nonRebasingSupply = nonRebasingSupply.sub(_amount);\n        } else {\n            _rebasingCredits = _rebasingCredits.sub(creditAmount);\n        }\n\n        _totalSupply = _totalSupply.sub(_amount);\n\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    /**\n     * @dev Get the credits per token for an account. Returns a fixed amount\n     *      if the account is non-rebasing.\n     * @param _account Address of the account.\n     */\n    function _creditsPerToken(address _account)\n        internal\n        view\n        returns (uint256)\n    {\n        if (nonRebasingCreditsPerToken[_account] != 0) {\n            return nonRebasingCreditsPerToken[_account];\n        } else {\n            return _rebasingCreditsPerToken;\n        }\n    }\n\n    /**\n     * @dev Is an account using rebasing accounting or non-rebasing accounting?\n     *      Also, ensure contracts are non-rebasing if they have not opted in.\n     * @param _account Address of the account.\n     */\n    function _isNonRebasingAccount(address _account) internal returns (bool) {\n        bool isContract = Address.isContract(_account);\n        if (isContract && rebaseState[_account] == RebaseOptions.NotSet) {\n            _ensureRebasingMigration(_account);\n        }\n        return nonRebasingCreditsPerToken[_account] > 0;\n    }\n\n    /**\n     * @dev Ensures internal account for rebasing and non-rebasing credits and\n     *      supply is updated following deployment of frozen yield change.\n     */\n    function _ensureRebasingMigration(address _account) internal {\n        if (nonRebasingCreditsPerToken[_account] == 0) {\n            emit AccountRebasingDisabled(_account);\n            if (_creditBalances[_account] == 0) {\n                // Since there is no existing balance, we can directly set to\n                // high resolution, and do not have to do any other bookkeeping\n                nonRebasingCreditsPerToken[_account] = 1e27;\n            } else {\n                // Migrate an existing account:\n\n                // Set fixed credits per token for this account\n                nonRebasingCreditsPerToken[_account] = _rebasingCreditsPerToken;\n                // Update non rebasing supply\n                nonRebasingSupply = nonRebasingSupply.add(balanceOf(_account));\n                // Update credit tallies\n                _rebasingCredits = _rebasingCredits.sub(\n                    _creditBalances[_account]\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Enable rebasing for an account.\n     * @dev Add a contract address to the non-rebasing exception list. The\n     * address's balance will be part of rebases and the account will be exposed\n     * to upside and downside.\n     * @param _account Address of the account.\n     */\n    function governanceRebaseOptIn(address _account)\n        public\n        nonReentrant\n        onlyGovernor\n    {\n        _rebaseOptIn(_account);\n    }\n\n    /**\n     * @dev Add a contract address to the non-rebasing exception list. The\n     * address's balance will be part of rebases and the account will be exposed\n     * to upside and downside.\n     */\n    function rebaseOptIn() public nonReentrant {\n        _rebaseOptIn(msg.sender);\n    }\n\n    function _rebaseOptIn(address _account) internal {\n        require(_isNonRebasingAccount(_account), \"Account has not opted out\");\n\n        // Convert balance into the same amount at the current exchange rate\n        uint256 newCreditBalance = _creditBalances[_account]\n            .mul(_rebasingCreditsPerToken)\n            .div(_creditsPerToken(_account));\n\n        // Decreasing non rebasing supply\n        nonRebasingSupply = nonRebasingSupply.sub(balanceOf(_account));\n\n        _creditBalances[_account] = newCreditBalance;\n\n        // Increase rebasing credits, totalSupply remains unchanged so no\n        // adjustment necessary\n        _rebasingCredits = _rebasingCredits.add(_creditBalances[_account]);\n\n        rebaseState[_account] = RebaseOptions.OptIn;\n\n        // Delete any fixed credits per token\n        delete nonRebasingCreditsPerToken[_account];\n        emit AccountRebasingEnabled(_account);\n    }\n\n    /**\n     * @dev Explicitly mark that an address is non-rebasing.\n     */\n    function rebaseOptOut() public nonReentrant {\n        require(!_isNonRebasingAccount(msg.sender), \"Account has not opted in\");\n\n        // Increase non rebasing supply\n        nonRebasingSupply = nonRebasingSupply.add(balanceOf(msg.sender));\n        // Set fixed credits per token\n        nonRebasingCreditsPerToken[msg.sender] = _rebasingCreditsPerToken;\n\n        // Decrease rebasing credits, total supply remains unchanged so no\n        // adjustment necessary\n        _rebasingCredits = _rebasingCredits.sub(_creditBalances[msg.sender]);\n\n        // Mark explicitly opted out of rebasing\n        rebaseState[msg.sender] = RebaseOptions.OptOut;\n        emit AccountRebasingDisabled(msg.sender);\n    }\n\n    /**\n     * @dev Modify the supply without minting new tokens. This uses a change in\n     *      the exchange rate between \"credits\" and OUSD tokens to change balances.\n     * @param _newTotalSupply New total supply of OUSD.\n     */\n    function changeSupply(uint256 _newTotalSupply)\n        external\n        onlyVault\n        nonReentrant\n    {\n        require(_totalSupply > 0, \"Cannot increase 0 supply\");\n\n        if (_totalSupply == _newTotalSupply) {\n            emit TotalSupplyUpdatedHighres(\n                _totalSupply,\n                _rebasingCredits,\n                _rebasingCreditsPerToken\n            );\n            return;\n        }\n\n        _totalSupply = _newTotalSupply > MAX_SUPPLY\n            ? MAX_SUPPLY\n            : _newTotalSupply;\n\n        _rebasingCreditsPerToken = _rebasingCredits.divPrecisely(\n            _totalSupply.sub(nonRebasingSupply)\n        );\n\n        require(_rebasingCreditsPerToken > 0, \"Invalid change in supply\");\n\n        _totalSupply = _rebasingCredits\n            .divPrecisely(_rebasingCreditsPerToken)\n            .add(nonRebasingSupply);\n\n        emit TotalSupplyUpdatedHighres(\n            _totalSupply,\n            _rebasingCredits,\n            _rebasingCreditsPerToken\n        );\n    }\n}\n"
    },
    "contracts/token/OUSDResolutionUpgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract OUSDResolutionUpgrade {\n    enum RebaseOptions {\n        NotSet,\n        OptOut,\n        OptIn\n    }\n\n    // From Initializable\n    bool private initialized;\n    bool private initializing;\n    uint256[50] private ______igap;\n\n    // From InitializableERC20Detailed\n    uint256[100] private _____ugap;\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    // From OUSD\n    uint256 private constant MAX_SUPPLY = ~uint128(0); // (2^128) - 1\n    uint256 public _totalSupply;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    address public vaultAddress = address(0);\n    mapping(address => uint256) private _creditBalances;\n    uint256 private _rebasingCredits;\n    uint256 private _rebasingCreditsPerToken;\n    uint256 public nonRebasingSupply;\n    mapping(address => uint256) public nonRebasingCreditsPerToken;\n    mapping(address => RebaseOptions) public rebaseState;\n    mapping(address => uint256) public isUpgraded;\n\n    uint256 private constant RESOLUTION_INCREASE = 1e9;\n\n    /**\n     * @return High resolution rebasingCreditsPerToken\n     */\n    function rebasingCreditsPerToken() public view returns (uint256) {\n        return _rebasingCreditsPerToken / RESOLUTION_INCREASE;\n    }\n\n    /**\n     * @return High resolution total number of rebasing credits\n     */\n    function rebasingCredits() public view returns (uint256) {\n        return _rebasingCredits / RESOLUTION_INCREASE;\n    }\n\n    /**\n     * @return High resolution rebasingCreditsPerToken\n     */\n    function rebasingCreditsPerTokenHighres() public view returns (uint256) {\n        return _rebasingCreditsPerToken;\n    }\n\n    /**\n     * @return High resolution total number of rebasing credits\n     */\n    function rebasingCreditsHighres() public view returns (uint256) {\n        return _rebasingCredits;\n    }\n\n    function upgradeGlobals() external {\n        require(isUpgraded[address(0)] == 0, \"Globals already upgraded\");\n        require(_rebasingCredits > 0, \"Sanity _rebasingCredits\");\n        require(\n            _rebasingCreditsPerToken > 0,\n            \"Sanity _rebasingCreditsPerToken\"\n        );\n        isUpgraded[address(0)] = 1;\n        _rebasingCredits = _rebasingCredits * RESOLUTION_INCREASE;\n        _rebasingCreditsPerToken =\n            _rebasingCreditsPerToken *\n            RESOLUTION_INCREASE;\n    }\n\n    function upgradeAccounts(address[] calldata accounts) external {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            address account = accounts[i];\n            require(account != address(0), \"Reserved\");\n            require(isUpgraded[account] == 0, \"Account already upgraded\");\n            isUpgraded[account] = 1;\n\n            // Handle special for non-rebasing accounts\n            uint256 nrc = nonRebasingCreditsPerToken[account];\n            if (nrc > 0) {\n                require(nrc < 1e18, \"Account already highres\");\n                nonRebasingCreditsPerToken[account] = nrc * RESOLUTION_INCREASE;\n            }\n            // Upgrade balance\n            uint256 balance = _creditBalances[account];\n            require(balance > 0, \"Will not upgrade zero balance\");\n            _creditBalances[account] = balance * RESOLUTION_INCREASE;\n        }\n    }\n\n    function creditsBalanceOfHighres(address _account)\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        return (\n            _creditBalances[_account],\n            _creditsPerToken(_account),\n            isUpgraded[_account] == 1\n        );\n    }\n\n    /**\n     * @dev Get the credits per token for an account. Returns a fixed amount\n     *      if the account is non-rebasing.\n     * @param _account Address of the account.\n     */\n    function _creditsPerToken(address _account)\n        internal\n        view\n        returns (uint256)\n    {\n        if (nonRebasingCreditsPerToken[_account] != 0) {\n            return nonRebasingCreditsPerToken[_account];\n        } else {\n            return _rebasingCreditsPerToken;\n        }\n    }\n}\n"
    },
    "contracts/token/WOETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ERC4626 } from \"../../lib/openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { Governable } from \"../governance/Governable.sol\";\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { OETH } from \"./OETH.sol\";\n\n/**\n * @title OETH Token Contract\n * @author Origin Protocol Inc\n */\n\ncontract WOETH is ERC4626, Governable, Initializable {\n    using SafeERC20 for IERC20;\n\n    constructor(\n        ERC20 underlying_,\n        string memory name_,\n        string memory symbol_\n    ) ERC20(name_, symbol_) ERC4626(underlying_) Governable() {}\n\n    /**\n     * @notice Enable OETH rebasing for this contract\n     */\n    function initialize() external onlyGovernor initializer {\n        OETH(address(asset())).rebaseOptIn();\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return \"Wrapped OETH\";\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return \"wOETH\";\n    }\n\n    /**\n     * @notice Transfer token to governor. Intended for recovering tokens stuck in\n     *      contract, i.e. mistaken sends. Cannot transfer OETH\n     * @param asset_ Address for the asset\n     * @param amount_ Amount of the asset to transfer\n     */\n    function transferToken(address asset_, uint256 amount_)\n        external\n        onlyGovernor\n    {\n        require(asset_ != address(asset()), \"Cannot collect OETH\");\n        IERC20(asset_).safeTransfer(governor(), amount_);\n    }\n}\n"
    },
    "contracts/token/WOETHBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { WOETH } from \"./WOETH.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title OETH Token Contract\n * @author Origin Protocol Inc\n */\n\ncontract WOETHBase is WOETH {\n    constructor(ERC20 underlying_)\n        WOETH(underlying_, \"Wrapped Super OETH\", \"wsuperOETHb\")\n    {}\n\n    function name() public view virtual override returns (string memory) {\n        return \"Wrapped Super OETH\";\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return \"wsuperOETHb\";\n    }\n}\n"
    },
    "contracts/token/WrappedOusd.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ERC4626 } from \"../../lib/openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { Governable } from \"../governance/Governable.sol\";\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { OUSD } from \"./OUSD.sol\";\n\ncontract WrappedOusd is ERC4626, Governable, Initializable {\n    using SafeERC20 for IERC20;\n\n    constructor(\n        ERC20 underlying_,\n        string memory name_,\n        string memory symbol_\n    ) ERC20(name_, symbol_) ERC4626(underlying_) Governable() {}\n\n    /**\n     * @notice Enable OUSD rebasing for this contract\n     */\n    function initialize() external onlyGovernor initializer {\n        OUSD(address(asset())).rebaseOptIn();\n    }\n\n    function name() public view override returns (string memory) {\n        return \"Wrapped OUSD\";\n    }\n\n    function symbol() public view override returns (string memory) {\n        return \"WOUSD\";\n    }\n\n    /**\n     * @notice Transfer token to governor. Intended for recovering tokens stuck in\n     *      contract, i.e. mistaken sends. Cannot transfer OUSD\n     * @param asset_ Address for the asset\n     * @param amount_ Amount of the asset to transfer\n     */\n    function transferToken(address asset_, uint256 amount_)\n        external\n        onlyGovernor\n    {\n        require(asset_ != address(asset()), \"Cannot collect OUSD\");\n        IERC20(asset_).safeTransfer(governor(), amount_);\n    }\n}\n"
    },
    "contracts/utils/BalancerErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.7.4 <0.9.0;\n\n// solhint-disable\n\n/**\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n * supported.\n * Uses the default 'BAL' prefix for the error code\n */\nfunction _require(bool condition, uint256 errorCode) pure {\n    if (!condition) _revert(errorCode);\n}\n\n/**\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n * supported.\n */\nfunction _require(\n    bool condition,\n    uint256 errorCode,\n    bytes3 prefix\n) pure {\n    if (!condition) _revert(errorCode, prefix);\n}\n\n/**\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n * Uses the default 'BAL' prefix for the error code\n */\nfunction _revert(uint256 errorCode) pure {\n    _revert(errorCode, 0x42414c); // This is the raw byte representation of \"BAL\"\n}\n\n/**\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n */\nfunction _revert(uint256 errorCode, bytes3 prefix) pure {\n    uint256 prefixUint = uint256(uint24(prefix));\n    // We're going to dynamically create a revert string based on the error code, with the following format:\n    // 'BAL#{errorCode}'\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\n    //\n    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\n    // number (8 to 16 bits) than the individual string characters.\n    //\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\n    assembly {\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\n        // the '0' character.\n\n        let units := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let tenths := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let hundreds := add(mod(errorCode, 10), 0x30)\n\n        // With the individual characters, we can now construct the full string.\n        // We first append the '#' character (0x23) to the prefix. In the case of 'BAL', it results in 0x42414c23 ('BAL#')\n        // Then, we shift this by 24 (to provide space for the 3 bytes of the error code), and add the\n        // characters to it, each shifted by a multiple of 8.\n        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\n        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\n        // array).\n        let formattedPrefix := shl(24, add(0x23, shl(8, prefixUint)))\n\n        let revertReason := shl(\n            200,\n            add(\n                formattedPrefix,\n                add(add(units, shl(8, tenths)), shl(16, hundreds))\n            )\n        )\n\n        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\n        // message will have the following layout:\n        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\n\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\n        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\n        mstore(\n            0x0,\n            0x08c379a000000000000000000000000000000000000000000000000000000000\n        )\n        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\n        mstore(\n            0x04,\n            0x0000000000000000000000000000000000000000000000000000000000000020\n        )\n        // The string length is fixed: 7 characters.\n        mstore(0x24, 7)\n        // Finally, the string itself is stored.\n        mstore(0x44, revertReason)\n\n        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\n        revert(0, 100)\n    }\n}\n\nlibrary Errors {\n    // Math\n    uint256 internal constant ADD_OVERFLOW = 0;\n    uint256 internal constant SUB_OVERFLOW = 1;\n    uint256 internal constant SUB_UNDERFLOW = 2;\n    uint256 internal constant MUL_OVERFLOW = 3;\n    uint256 internal constant ZERO_DIVISION = 4;\n    uint256 internal constant DIV_INTERNAL = 5;\n    uint256 internal constant X_OUT_OF_BOUNDS = 6;\n    uint256 internal constant Y_OUT_OF_BOUNDS = 7;\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\n    uint256 internal constant INVALID_EXPONENT = 9;\n\n    // Input\n    uint256 internal constant OUT_OF_BOUNDS = 100;\n    uint256 internal constant UNSORTED_ARRAY = 101;\n    uint256 internal constant UNSORTED_TOKENS = 102;\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\n    uint256 internal constant ZERO_TOKEN = 104;\n    uint256 internal constant INSUFFICIENT_DATA = 105;\n\n    // Shared pools\n    uint256 internal constant MIN_TOKENS = 200;\n    uint256 internal constant MAX_TOKENS = 201;\n    uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\n    uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\n    uint256 internal constant MINIMUM_BPT = 204;\n    uint256 internal constant CALLER_NOT_VAULT = 205;\n    uint256 internal constant UNINITIALIZED = 206;\n    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\n    uint256 internal constant EXPIRED_PERMIT = 209;\n    uint256 internal constant NOT_TWO_TOKENS = 210;\n    uint256 internal constant DISABLED = 211;\n\n    // Pools\n    uint256 internal constant MIN_AMP = 300;\n    uint256 internal constant MAX_AMP = 301;\n    uint256 internal constant MIN_WEIGHT = 302;\n    uint256 internal constant MAX_STABLE_TOKENS = 303;\n    uint256 internal constant MAX_IN_RATIO = 304;\n    uint256 internal constant MAX_OUT_RATIO = 305;\n    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\n    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\n    uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\n    uint256 internal constant INVALID_TOKEN = 309;\n    uint256 internal constant UNHANDLED_JOIN_KIND = 310;\n    uint256 internal constant ZERO_INVARIANT = 311;\n    uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;\n    uint256 internal constant ORACLE_NOT_INITIALIZED = 313;\n    uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;\n    uint256 internal constant ORACLE_INVALID_INDEX = 315;\n    uint256 internal constant ORACLE_BAD_SECS = 316;\n    uint256 internal constant AMP_END_TIME_TOO_CLOSE = 317;\n    uint256 internal constant AMP_ONGOING_UPDATE = 318;\n    uint256 internal constant AMP_RATE_TOO_HIGH = 319;\n    uint256 internal constant AMP_NO_ONGOING_UPDATE = 320;\n    uint256 internal constant STABLE_INVARIANT_DIDNT_CONVERGE = 321;\n    uint256 internal constant STABLE_GET_BALANCE_DIDNT_CONVERGE = 322;\n    uint256 internal constant RELAYER_NOT_CONTRACT = 323;\n    uint256 internal constant BASE_POOL_RELAYER_NOT_CALLED = 324;\n    uint256 internal constant REBALANCING_RELAYER_REENTERED = 325;\n    uint256 internal constant GRADUAL_UPDATE_TIME_TRAVEL = 326;\n    uint256 internal constant SWAPS_DISABLED = 327;\n    uint256 internal constant CALLER_IS_NOT_LBP_OWNER = 328;\n    uint256 internal constant PRICE_RATE_OVERFLOW = 329;\n    uint256 internal constant INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED = 330;\n    uint256 internal constant WEIGHT_CHANGE_TOO_FAST = 331;\n    uint256 internal constant LOWER_GREATER_THAN_UPPER_TARGET = 332;\n    uint256 internal constant UPPER_TARGET_TOO_HIGH = 333;\n    uint256 internal constant UNHANDLED_BY_LINEAR_POOL = 334;\n    uint256 internal constant OUT_OF_TARGET_RANGE = 335;\n    uint256 internal constant UNHANDLED_EXIT_KIND = 336;\n    uint256 internal constant UNAUTHORIZED_EXIT = 337;\n    uint256 internal constant MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE = 338;\n    uint256 internal constant UNHANDLED_BY_MANAGED_POOL = 339;\n    uint256 internal constant UNHANDLED_BY_PHANTOM_POOL = 340;\n    uint256 internal constant TOKEN_DOES_NOT_HAVE_RATE_PROVIDER = 341;\n    uint256 internal constant INVALID_INITIALIZATION = 342;\n    uint256 internal constant OUT_OF_NEW_TARGET_RANGE = 343;\n    uint256 internal constant FEATURE_DISABLED = 344;\n    uint256 internal constant UNINITIALIZED_POOL_CONTROLLER = 345;\n    uint256 internal constant SET_SWAP_FEE_DURING_FEE_CHANGE = 346;\n    uint256 internal constant SET_SWAP_FEE_PENDING_FEE_CHANGE = 347;\n    uint256 internal constant CHANGE_TOKENS_DURING_WEIGHT_CHANGE = 348;\n    uint256 internal constant CHANGE_TOKENS_PENDING_WEIGHT_CHANGE = 349;\n    uint256 internal constant MAX_WEIGHT = 350;\n    uint256 internal constant UNAUTHORIZED_JOIN = 351;\n    uint256 internal constant MAX_MANAGEMENT_AUM_FEE_PERCENTAGE = 352;\n    uint256 internal constant FRACTIONAL_TARGET = 353;\n    uint256 internal constant ADD_OR_REMOVE_BPT = 354;\n    uint256 internal constant INVALID_CIRCUIT_BREAKER_BOUNDS = 355;\n    uint256 internal constant CIRCUIT_BREAKER_TRIPPED = 356;\n    uint256 internal constant MALICIOUS_QUERY_REVERT = 357;\n    uint256 internal constant JOINS_EXITS_DISABLED = 358;\n\n    // Lib\n    uint256 internal constant REENTRANCY = 400;\n    uint256 internal constant SENDER_NOT_ALLOWED = 401;\n    uint256 internal constant PAUSED = 402;\n    uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\n    uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\n    uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\n    uint256 internal constant INSUFFICIENT_BALANCE = 406;\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\n    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\n    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\n    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\n    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\n    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\n    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\n    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\n    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\n    uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\n    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\n    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\n    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\n    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\n    uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\n    uint256 internal constant CALLER_IS_NOT_OWNER = 426;\n    uint256 internal constant NEW_OWNER_IS_ZERO = 427;\n    uint256 internal constant CODE_DEPLOYMENT_FAILED = 428;\n    uint256 internal constant CALL_TO_NON_CONTRACT = 429;\n    uint256 internal constant LOW_LEVEL_CALL_FAILED = 430;\n    uint256 internal constant NOT_PAUSED = 431;\n    uint256 internal constant ADDRESS_ALREADY_ALLOWLISTED = 432;\n    uint256 internal constant ADDRESS_NOT_ALLOWLISTED = 433;\n    uint256 internal constant ERC20_BURN_EXCEEDS_BALANCE = 434;\n    uint256 internal constant INVALID_OPERATION = 435;\n    uint256 internal constant CODEC_OVERFLOW = 436;\n    uint256 internal constant IN_RECOVERY_MODE = 437;\n    uint256 internal constant NOT_IN_RECOVERY_MODE = 438;\n    uint256 internal constant INDUCED_FAILURE = 439;\n    uint256 internal constant EXPIRED_SIGNATURE = 440;\n    uint256 internal constant MALFORMED_SIGNATURE = 441;\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_UINT64 = 442;\n    uint256 internal constant UNHANDLED_FEE_TYPE = 443;\n    uint256 internal constant BURN_FROM_ZERO = 444;\n\n    // Vault\n    uint256 internal constant INVALID_POOL_ID = 500;\n    uint256 internal constant CALLER_NOT_POOL = 501;\n    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\n    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\n    uint256 internal constant INVALID_SIGNATURE = 504;\n    uint256 internal constant EXIT_BELOW_MIN = 505;\n    uint256 internal constant JOIN_ABOVE_MAX = 506;\n    uint256 internal constant SWAP_LIMIT = 507;\n    uint256 internal constant SWAP_DEADLINE = 508;\n    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\n    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\n    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\n    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\n    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\n    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\n    uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\n    uint256 internal constant INSUFFICIENT_ETH = 516;\n    uint256 internal constant UNALLOCATED_ETH = 517;\n    uint256 internal constant ETH_TRANSFER = 518;\n    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\n    uint256 internal constant TOKENS_MISMATCH = 520;\n    uint256 internal constant TOKEN_NOT_REGISTERED = 521;\n    uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\n    uint256 internal constant TOKENS_ALREADY_SET = 523;\n    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\n    uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\n    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\n    uint256 internal constant POOL_NO_TOKENS = 527;\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\n\n    // Fees\n    uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\n    uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\n    uint256 internal constant AUM_FEE_PERCENTAGE_TOO_HIGH = 603;\n\n    // FeeSplitter\n    uint256 internal constant SPLITTER_FEE_PERCENTAGE_TOO_HIGH = 700;\n\n    // Misc\n    uint256 internal constant UNIMPLEMENTED = 998;\n    uint256 internal constant SHOULD_NOT_HAPPEN = 999;\n}\n"
    },
    "contracts/utils/DepositContractUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract DepositContractUtils {\n    function calculateDepositDataRoot(\n        bytes calldata pubkey,\n        bytes calldata withdrawal_credentials,\n        bytes calldata signature\n    ) public pure returns (bytes32 node) {\n        uint256 deposit_amount = 32 ether / 1 gwei;\n        bytes memory amount = to_little_endian_64(uint64(deposit_amount));\n\n        // Compute deposit data root (`DepositData` hash tree root)\n        bytes32 pubkey_root = sha256(abi.encodePacked(pubkey, bytes16(0)));\n        bytes32 signature_root = sha256(\n            abi.encodePacked(\n                sha256(abi.encodePacked(signature[:64])),\n                sha256(abi.encodePacked(signature[64:], bytes32(0)))\n            )\n        );\n        node = sha256(\n            abi.encodePacked(\n                sha256(abi.encodePacked(pubkey_root, withdrawal_credentials)),\n                sha256(abi.encodePacked(amount, bytes24(0), signature_root))\n            )\n        );\n    }\n\n    function to_little_endian_64(uint64 value)\n        internal\n        pure\n        returns (bytes memory ret)\n    {\n        ret = new bytes(8);\n        bytes8 bytesValue = bytes8(value);\n        // Byteswapping during copying to bytes.\n        ret[0] = bytesValue[7];\n        ret[1] = bytesValue[6];\n        ret[2] = bytesValue[5];\n        ret[3] = bytesValue[4];\n        ret[4] = bytesValue[3];\n        ret[5] = bytesValue[2];\n        ret[6] = bytesValue[1];\n        ret[7] = bytesValue[0];\n    }\n}\n"
    },
    "contracts/utils/Helpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IBasicToken } from \"../interfaces/IBasicToken.sol\";\n\nlibrary Helpers {\n    /**\n     * @notice Fetch the `symbol()` from an ERC20 token\n     * @dev Grabs the `symbol()` from a contract\n     * @param _token Address of the ERC20 token\n     * @return string Symbol of the ERC20 token\n     */\n    function getSymbol(address _token) internal view returns (string memory) {\n        string memory symbol = IBasicToken(_token).symbol();\n        return symbol;\n    }\n\n    /**\n     * @notice Fetch the `decimals()` from an ERC20 token\n     * @dev Grabs the `decimals()` from a contract and fails if\n     *      the decimal value does not live within a certain range\n     * @param _token Address of the ERC20 token\n     * @return uint256 Decimals of the ERC20 token\n     */\n    function getDecimals(address _token) internal view returns (uint256) {\n        uint256 decimals = IBasicToken(_token).decimals();\n        require(\n            decimals >= 4 && decimals <= 18,\n            \"Token must have sufficient decimal places\"\n        );\n\n        return decimals;\n    }\n}\n"
    },
    "contracts/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Base contract any contracts that need to initialize state after deployment.\n * @author Origin Protocol Inc\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(\n            initializing || !initialized,\n            \"Initializable: contract is already initialized\"\n        );\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/utils/InitializableAbstractStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Base contract for vault strategies.\n * @author Origin Protocol Inc\n */\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\nabstract contract InitializableAbstractStrategy is Initializable, Governable {\n    using SafeERC20 for IERC20;\n\n    event PTokenAdded(address indexed _asset, address _pToken);\n    event PTokenRemoved(address indexed _asset, address _pToken);\n    event Deposit(address indexed _asset, address _pToken, uint256 _amount);\n    event Withdrawal(address indexed _asset, address _pToken, uint256 _amount);\n    event RewardTokenCollected(\n        address recipient,\n        address rewardToken,\n        uint256 amount\n    );\n    event RewardTokenAddressesUpdated(\n        address[] _oldAddresses,\n        address[] _newAddresses\n    );\n    event HarvesterAddressesUpdated(\n        address _oldHarvesterAddress,\n        address _newHarvesterAddress\n    );\n\n    /// @notice Address of the underlying platform\n    address public immutable platformAddress;\n    /// @notice Address of the OToken vault\n    address public immutable vaultAddress;\n\n    /// @dev Replaced with an immutable variable\n    // slither-disable-next-line constable-states\n    address private _deprecated_platformAddress;\n\n    /// @dev Replaced with an immutable\n    // slither-disable-next-line constable-states\n    address private _deprecated_vaultAddress;\n\n    /// @notice asset => pToken (Platform Specific Token Address)\n    mapping(address => address) public assetToPToken;\n\n    /// @notice Full list of all assets supported by the strategy\n    address[] internal assetsMapped;\n\n    // Deprecated: Reward token address\n    // slither-disable-next-line constable-states\n    address private _deprecated_rewardTokenAddress;\n\n    // Deprecated: now resides in Harvester's rewardTokenConfigs\n    // slither-disable-next-line constable-states\n    uint256 private _deprecated_rewardLiquidationThreshold;\n\n    /// @notice Address of the Harvester contract allowed to collect reward tokens\n    address public harvesterAddress;\n\n    /// @notice Address of the reward tokens. eg CRV, BAL, CVX, AURA\n    address[] public rewardTokenAddresses;\n\n    /* Reserved for future expansion. Used to be 100 storage slots\n     * and has decreased to accommodate:\n     * - harvesterAddress\n     * - rewardTokenAddresses\n     */\n    int256[98] private _reserved;\n\n    struct BaseStrategyConfig {\n        address platformAddress; // Address of the underlying platform\n        address vaultAddress; // Address of the OToken's Vault\n    }\n\n    /**\n     * @param _config The platform and OToken vault addresses\n     */\n    constructor(BaseStrategyConfig memory _config) {\n        platformAddress = _config.platformAddress;\n        vaultAddress = _config.vaultAddress;\n    }\n\n    /**\n     * @dev Internal initialize function, to set up initial internal state\n     * @param _rewardTokenAddresses Address of reward token for platform\n     * @param _assets Addresses of initial supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function _initialize(\n        address[] memory _rewardTokenAddresses,\n        address[] memory _assets,\n        address[] memory _pTokens\n    ) internal {\n        rewardTokenAddresses = _rewardTokenAddresses;\n\n        uint256 assetCount = _assets.length;\n        require(assetCount == _pTokens.length, \"Invalid input arrays\");\n        for (uint256 i = 0; i < assetCount; ++i) {\n            _setPTokenAddress(_assets[i], _pTokens[i]);\n        }\n    }\n\n    /**\n     * @notice Collect accumulated reward token and send to Vault.\n     */\n    function collectRewardTokens() external virtual onlyHarvester nonReentrant {\n        _collectRewardTokens();\n    }\n\n    /**\n     * @dev Default implementation that transfers reward tokens to the Harvester\n     * Implementing strategies need to add custom logic to collect the rewards.\n     */\n    function _collectRewardTokens() internal virtual {\n        uint256 rewardTokenCount = rewardTokenAddresses.length;\n        for (uint256 i = 0; i < rewardTokenCount; ++i) {\n            IERC20 rewardToken = IERC20(rewardTokenAddresses[i]);\n            uint256 balance = rewardToken.balanceOf(address(this));\n            if (balance > 0) {\n                emit RewardTokenCollected(\n                    harvesterAddress,\n                    address(rewardToken),\n                    balance\n                );\n                rewardToken.safeTransfer(harvesterAddress, balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault.\n     */\n    modifier onlyVault() {\n        require(msg.sender == vaultAddress, \"Caller is not the Vault\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Harvester.\n     */\n    modifier onlyHarvester() {\n        require(msg.sender == harvesterAddress, \"Caller is not the Harvester\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault or Governor.\n     */\n    modifier onlyVaultOrGovernor() {\n        require(\n            msg.sender == vaultAddress || msg.sender == governor(),\n            \"Caller is not the Vault or Governor\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault, Governor, or Strategist.\n     */\n    modifier onlyVaultOrGovernorOrStrategist() {\n        require(\n            msg.sender == vaultAddress ||\n                msg.sender == governor() ||\n                msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Vault, Governor, or Strategist\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Set the reward token addresses. Any old addresses will be overwritten.\n     * @param _rewardTokenAddresses Array of reward token addresses\n     */\n    function setRewardTokenAddresses(address[] calldata _rewardTokenAddresses)\n        external\n        onlyGovernor\n    {\n        uint256 rewardTokenCount = _rewardTokenAddresses.length;\n        for (uint256 i = 0; i < rewardTokenCount; ++i) {\n            require(\n                _rewardTokenAddresses[i] != address(0),\n                \"Can not set an empty address as a reward token\"\n            );\n        }\n\n        emit RewardTokenAddressesUpdated(\n            rewardTokenAddresses,\n            _rewardTokenAddresses\n        );\n        rewardTokenAddresses = _rewardTokenAddresses;\n    }\n\n    /**\n     * @notice Get the reward token addresses.\n     * @return address[] the reward token addresses.\n     */\n    function getRewardTokenAddresses()\n        external\n        view\n        returns (address[] memory)\n    {\n        return rewardTokenAddresses;\n    }\n\n    /**\n     * @notice Provide support for asset by passing its pToken address.\n     *      This method can only be called by the system Governor\n     * @param _asset    Address for the asset\n     * @param _pToken   Address for the corresponding platform token\n     */\n    function setPTokenAddress(address _asset, address _pToken)\n        external\n        virtual\n        onlyGovernor\n    {\n        _setPTokenAddress(_asset, _pToken);\n    }\n\n    /**\n     * @notice Remove a supported asset by passing its index.\n     *      This method can only be called by the system Governor\n     * @param _assetIndex Index of the asset to be removed\n     */\n    function removePToken(uint256 _assetIndex) external virtual onlyGovernor {\n        require(_assetIndex < assetsMapped.length, \"Invalid index\");\n        address asset = assetsMapped[_assetIndex];\n        address pToken = assetToPToken[asset];\n\n        if (_assetIndex < assetsMapped.length - 1) {\n            assetsMapped[_assetIndex] = assetsMapped[assetsMapped.length - 1];\n        }\n        assetsMapped.pop();\n        assetToPToken[asset] = address(0);\n\n        emit PTokenRemoved(asset, pToken);\n    }\n\n    /**\n     * @notice Provide support for asset by passing its pToken address.\n     *      Add to internal mappings and execute the platform specific,\n     * abstract method `_abstractSetPToken`\n     * @param _asset    Address for the asset\n     * @param _pToken   Address for the corresponding platform token\n     */\n    function _setPTokenAddress(address _asset, address _pToken) internal {\n        require(assetToPToken[_asset] == address(0), \"pToken already set\");\n        require(\n            _asset != address(0) && _pToken != address(0),\n            \"Invalid addresses\"\n        );\n\n        assetToPToken[_asset] = _pToken;\n        assetsMapped.push(_asset);\n\n        emit PTokenAdded(_asset, _pToken);\n\n        _abstractSetPToken(_asset, _pToken);\n    }\n\n    /**\n     * @notice Transfer token to governor. Intended for recovering tokens stuck in\n     *      strategy contracts, i.e. mistaken sends.\n     * @param _asset Address for the asset\n     * @param _amount Amount of the asset to transfer\n     */\n    function transferToken(address _asset, uint256 _amount)\n        public\n        virtual\n        onlyGovernor\n    {\n        require(!supportsAsset(_asset), \"Cannot transfer supported asset\");\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /**\n     * @notice Set the Harvester contract that can collect rewards.\n     * @param _harvesterAddress Address of the harvester contract.\n     */\n    function setHarvesterAddress(address _harvesterAddress)\n        external\n        onlyGovernor\n    {\n        emit HarvesterAddressesUpdated(harvesterAddress, _harvesterAddress);\n        harvesterAddress = _harvesterAddress;\n    }\n\n    /***************************************\n                 Abstract\n    ****************************************/\n\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        virtual;\n\n    function safeApproveAllTokens() external virtual;\n\n    /**\n     * @notice Deposit an amount of assets into the platform\n     * @param _asset               Address for the asset\n     * @param _amount              Units of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount) external virtual;\n\n    /**\n     * @notice Deposit all supported assets in this strategy contract to the platform\n     */\n    function depositAll() external virtual;\n\n    /**\n     * @notice Withdraw an `amount` of assets from the platform and\n     * send to the `_recipient`.\n     * @param _recipient         Address to which the asset should be sent\n     * @param _asset             Address of the asset\n     * @param _amount            Units of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external virtual;\n\n    /**\n     * @notice Withdraw all supported assets from platform and\n     * sends to the OToken's Vault.\n     */\n    function withdrawAll() external virtual;\n\n    /**\n     * @notice Get the total asset value held in the platform.\n     *      This includes any interest that was generated since depositing.\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        virtual\n        returns (uint256 balance);\n\n    /**\n     * @notice Check if an asset is supported.\n     * @param _asset    Address of the asset\n     * @return bool     Whether asset is supported\n     */\n    function supportsAsset(address _asset) public view virtual returns (bool);\n}\n"
    },
    "contracts/utils/InitializableERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n * Converted from openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\n * @author Origin Protocol Inc\n */\nabstract contract InitializableERC20Detailed is IERC20 {\n    // Storage gap to skip storage from prior to OUSD reset\n    uint256[100] private _____gap;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     * @notice To avoid variable shadowing appended `Arg` after arguments name.\n     */\n    function _initialize(\n        string memory nameArg,\n        string memory symbolArg,\n        uint8 decimalsArg\n    ) internal {\n        _name = nameArg;\n        _symbol = symbolArg;\n        _decimals = decimalsArg;\n    }\n\n    /**\n     * @notice Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @notice Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @notice Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/utils/StableMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n// Based on StableMath from Stability Labs Pty. Ltd.\n// https://github.com/mstable/mStable-contracts/blob/master/contracts/shared/StableMath.sol\n\nlibrary StableMath {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Scaling unit for use in specific calculations,\n     * where 1 * 10**18, or 1e18 represents a unit '1'\n     */\n    uint256 private constant FULL_SCALE = 1e18;\n\n    /***************************************\n                    Helpers\n    ****************************************/\n\n    /**\n     * @dev Adjust the scale of an integer\n     * @param to Decimals to scale to\n     * @param from Decimals to scale from\n     */\n    function scaleBy(\n        uint256 x,\n        uint256 to,\n        uint256 from\n    ) internal pure returns (uint256) {\n        if (to > from) {\n            x = x.mul(10**(to - from));\n        } else if (to < from) {\n            // slither-disable-next-line divide-before-multiply\n            x = x.div(10**(from - to));\n        }\n        return x;\n    }\n\n    /***************************************\n               Precise Arithmetic\n    ****************************************/\n\n    /**\n     * @dev Multiplies two precise units, and then truncates by the full scale\n     * @param x Left hand input to multiplication\n     * @param y Right hand input to multiplication\n     * @return Result after multiplying the two inputs and then dividing by the shared\n     *         scale unit\n     */\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulTruncateScale(x, y, FULL_SCALE);\n    }\n\n    /**\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\n     * @param x Left hand input to multiplication\n     * @param y Right hand input to multiplication\n     * @param scale Scale unit\n     * @return Result after multiplying the two inputs and then dividing by the shared\n     *         scale unit\n     */\n    function mulTruncateScale(\n        uint256 x,\n        uint256 y,\n        uint256 scale\n    ) internal pure returns (uint256) {\n        // e.g. assume scale = fullScale\n        // z = 10e18 * 9e17 = 9e36\n        uint256 z = x.mul(y);\n        // return 9e36 / 1e18 = 9e18\n        return z.div(scale);\n    }\n\n    /**\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\n     * @param x Left hand input to multiplication\n     * @param y Right hand input to multiplication\n     * @return Result after multiplying the two inputs and then dividing by the shared\n     *          scale unit, rounded up to the closest base unit.\n     */\n    function mulTruncateCeil(uint256 x, uint256 y)\n        internal\n        pure\n        returns (uint256)\n    {\n        // e.g. 8e17 * 17268172638 = 138145381104e17\n        uint256 scaled = x.mul(y);\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\n        uint256 ceil = scaled.add(FULL_SCALE.sub(1));\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\n        return ceil.div(FULL_SCALE);\n    }\n\n    /**\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\n     * @param x Left hand input to division\n     * @param y Right hand input to division\n     * @return Result after multiplying the left operand by the scale, and\n     *         executing the division on the right hand input.\n     */\n    function divPrecisely(uint256 x, uint256 y)\n        internal\n        pure\n        returns (uint256)\n    {\n        // e.g. 8e18 * 1e18 = 8e36\n        uint256 z = x.mul(FULL_SCALE);\n        // e.g. 8e36 / 10e18 = 8e17\n        return z.div(y);\n    }\n}\n"
    },
    "contracts/vault/OETHBaseVaultAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { VaultAdmin } from \"./VaultAdmin.sol\";\n\n/**\n * @title OETH Base VaultAdmin Contract\n * @author Origin Protocol Inc\n */\ncontract OETHBaseVaultAdmin is VaultAdmin {\n    /**\n     * @notice Adds a strategy to the mint whitelist.\n     *          Reverts if strategy isn't approved on Vault.\n     * @param strategyAddr Strategy address\n     */\n    function addStrategyToMintWhitelist(address strategyAddr)\n        external\n        onlyGovernor\n    {\n        require(strategies[strategyAddr].isSupported, \"Strategy not approved\");\n\n        require(\n            !isMintWhitelistedStrategy[strategyAddr],\n            \"Already whitelisted\"\n        );\n\n        isMintWhitelistedStrategy[strategyAddr] = true;\n\n        emit StrategyAddedToMintWhitelist(strategistAddr);\n    }\n\n    /**\n     * @notice Removes a strategy from the mint whitelist.\n     * @param strategyAddr Strategy address\n     */\n    function removeStrategyFromMintWhitelist(address strategyAddr)\n        external\n        onlyGovernor\n    {\n        // Intentionally skipping `strategies.isSupported` check since\n        // we may wanna remove an address even after removing the strategy\n\n        require(isMintWhitelistedStrategy[strategyAddr], \"Not whitelisted\");\n\n        isMintWhitelistedStrategy[strategyAddr] = false;\n\n        emit StrategyRemovedFromMintWhitelist(strategistAddr);\n    }\n}\n"
    },
    "contracts/vault/OETHBaseVaultCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { OETHVaultCore } from \"./OETHVaultCore.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\n\n/**\n * @title OETH Base VaultCore Contract\n * @author Origin Protocol Inc\n */\ncontract OETHBaseVaultCore is OETHVaultCore {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    constructor(address _weth) OETHVaultCore(_weth) {}\n\n    // @inheritdoc VaultCore\n    function mintForStrategy(uint256 amount)\n        external\n        override\n        whenNotCapitalPaused\n    {\n        require(\n            strategies[msg.sender].isSupported == true,\n            \"Unsupported strategy\"\n        );\n        require(\n            isMintWhitelistedStrategy[msg.sender] == true,\n            \"Not whitelisted strategy\"\n        );\n\n        emit Mint(msg.sender, amount);\n\n        // Mint matching amount of OTokens\n        oUSD.mint(msg.sender, amount);\n    }\n\n    // @inheritdoc VaultCore\n    function burnForStrategy(uint256 amount)\n        external\n        override\n        whenNotCapitalPaused\n    {\n        require(\n            strategies[msg.sender].isSupported == true,\n            \"Unsupported strategy\"\n        );\n        require(\n            isMintWhitelistedStrategy[msg.sender] == true,\n            \"Not whitelisted strategy\"\n        );\n\n        emit Redeem(msg.sender, amount);\n\n        // Burn OTokens\n        oUSD.burn(msg.sender, amount);\n    }\n\n    // @inheritdoc OETHVaultCore\n    function _redeem(uint256 _amount, uint256 _minimumUnitAmount)\n        internal\n        virtual\n        override\n    {\n        // Only Strategist or Governor can redeem using the Vault for now.\n        // We don't have the onlyGovernorOrStrategist modifier on VaultCore.\n        // Since we won't be using that modifier anywhere in the VaultCore as well,\n        // the check has been added inline instead of moving it to VaultStorage.\n        require(\n            msg.sender == strategistAddr || isGovernor(),\n            \"Caller is not the Strategist or Governor\"\n        );\n\n        super._redeem(_amount, _minimumUnitAmount);\n    }\n}\n"
    },
    "contracts/vault/OETHBaseZapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { IERC4626 } from \"../../lib/openzeppelin/interfaces/IERC4626.sol\";\n\ncontract OETHBaseZapper {\n    IERC20 public immutable oethb;\n    IERC4626 public immutable woethb;\n    IVault public immutable vault;\n\n    IWETH9 public constant weth =\n        IWETH9(0x4200000000000000000000000000000000000006);\n    address private constant ETH_MARKER =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    event Zap(address indexed minter, address indexed asset, uint256 amount);\n\n    constructor(\n        address _oethb,\n        address _woethb,\n        address _vault\n    ) {\n        oethb = IERC20(_oethb);\n        woethb = IERC4626(_woethb);\n        vault = IVault(_vault);\n\n        weth.approve(address(_vault), type(uint256).max);\n        IERC20(_oethb).approve(_woethb, type(uint256).max);\n    }\n\n    /**\n     * @dev Deposit ETH and receive OETH in return.\n     * Will verify that the user is sent 1:1 for ETH.\n     */\n    receive() external payable {\n        deposit();\n    }\n\n    /**\n     * @dev Deposit ETH and receive superOETHb in return\n     * Will verify that the user is sent 1:1 for ETH.\n     * @return Amount of OETH sent to user\n     */\n    function deposit() public payable returns (uint256) {\n        uint256 balance = address(this).balance;\n\n        emit Zap(msg.sender, ETH_MARKER, balance);\n\n        // Wrap ETH\n        weth.deposit{ value: balance }();\n\n        // Mint with WETH\n        return _mint(balance, msg.sender);\n    }\n\n    /**\n     * @dev Deposit ETH and receive superOETHb in return\n     * @param minReceived min amount of wsuperOETHb to receive\n     * @return Amount of wsuperOETHb sent to user\n     */\n    function depositETHForWrappedTokens(uint256 minReceived)\n        external\n        payable\n        returns (uint256)\n    {\n        uint256 balance = address(this).balance;\n\n        emit Zap(msg.sender, ETH_MARKER, balance);\n\n        // Wrap ETH\n        weth.deposit{ value: balance }();\n\n        // Mint with WETH\n        uint256 mintedOethb = _mint(balance, address(this));\n\n        // Wrap superOETHb into wsuperOETHb\n        uint256 mintedWoethb = woethb.deposit(mintedOethb, msg.sender);\n\n        require(mintedWoethb >= minReceived, \"Zapper: not enough minted\");\n\n        return mintedWoethb;\n    }\n\n    /**\n     * @dev Deposit WETH and receive superOETHb in return\n     * @param wethAmount Amount of WETH to deposit\n     * @param minReceived min amount of wsuperOETHb to receive\n     * @return Amount of wsuperOETHb sent to user\n     */\n    function depositWETHForWrappedTokens(\n        uint256 wethAmount,\n        uint256 minReceived\n    ) external returns (uint256) {\n        // slither-disable-next-line unchecked-transfer unused-return\n        weth.transferFrom(msg.sender, address(this), wethAmount);\n\n        emit Zap(msg.sender, address(weth), wethAmount);\n\n        // Mint with WETH\n        uint256 mintedOethb = _mint(wethAmount, address(this));\n\n        // Wrap superOETHb into wsuperOETHb\n        uint256 mintedWoethb = woethb.deposit(mintedOethb, msg.sender);\n\n        require(mintedWoethb >= minReceived, \"Zapper: not enough minted\");\n\n        return mintedWoethb;\n    }\n\n    /**\n     * @dev Internal function to mint superOETHb with WETH\n     * @param minOETH Minimum amount of OETH to for user to receive\n     * @param recipient Address that receives the tokens\n     * @return Amount of OETH sent to user\n     */\n    function _mint(uint256 minOETH, address recipient)\n        internal\n        returns (uint256)\n    {\n        uint256 toMint = weth.balanceOf(address(this));\n        vault.mint(address(weth), toMint, minOETH);\n        uint256 mintedAmount = oethb.balanceOf(address(this));\n        require(mintedAmount >= minOETH, \"Zapper: not enough minted\");\n\n        if (recipient != address(this)) {\n            require(oethb.transfer(recipient, mintedAmount));\n        }\n\n        return mintedAmount;\n    }\n}\n"
    },
    "contracts/vault/OETHVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Vault } from \"./Vault.sol\";\n\n/**\n * @title OETH Vault Contract\n * @author Origin Protocol Inc\n */\ncontract OETHVault is Vault {\n\n}\n"
    },
    "contracts/vault/OETHVaultAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { VaultAdmin } from \"./VaultAdmin.sol\";\n\n/**\n * @title OETH VaultAdmin Contract\n * @author Origin Protocol Inc\n */\ncontract OETHVaultAdmin is VaultAdmin {\n    using SafeERC20 for IERC20;\n\n    address public immutable weth;\n\n    constructor(address _weth) {\n        weth = _weth;\n    }\n\n    /// @dev Simplified version of the deposit function as WETH is the only supported asset.\n    function _depositToStrategy(\n        address _strategyToAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) internal override {\n        require(\n            strategies[_strategyToAddress].isSupported,\n            \"Invalid to Strategy\"\n        );\n        require(\n            _assets.length == 1 && _amounts.length == 1 && _assets[0] == weth,\n            \"Only WETH is supported\"\n        );\n\n        // Check the there is enough WETH to transfer once the WETH reserved for the withdrawal queue is accounted for\n        require(_amounts[0] <= _wethAvailable(), \"Not enough WETH available\");\n\n        // Send required amount of funds to the strategy\n        IERC20(weth).safeTransfer(_strategyToAddress, _amounts[0]);\n\n        // Deposit all the funds that have been sent to the strategy\n        IStrategy(_strategyToAddress).depositAll();\n    }\n\n    function _withdrawFromStrategy(\n        address _recipient,\n        address _strategyFromAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) internal override {\n        super._withdrawFromStrategy(\n            _recipient,\n            _strategyFromAddress,\n            _assets,\n            _amounts\n        );\n\n        IVault(address(this)).addWithdrawalQueueLiquidity();\n    }\n\n    function _withdrawAllFromStrategy(address _strategyAddr) internal override {\n        super._withdrawAllFromStrategy(_strategyAddr);\n\n        IVault(address(this)).addWithdrawalQueueLiquidity();\n    }\n\n    function _withdrawAllFromStrategies() internal override {\n        super._withdrawAllFromStrategies();\n\n        IVault(address(this)).addWithdrawalQueueLiquidity();\n    }\n\n    /// @dev Calculate how much WETH in the vault is not reserved for the withdrawal queue.\n    // That is, it is available to be redeemed or deposited into a strategy.\n    function _wethAvailable() internal view returns (uint256 wethAvailable) {\n        WithdrawalQueueMetadata memory queue = withdrawalQueueMetadata;\n\n        // The amount of WETH that is still to be claimed in the withdrawal queue\n        uint256 outstandingWithdrawals = queue.queued - queue.claimed;\n\n        // The amount of sitting in WETH in the vault\n        uint256 wethBalance = IERC20(weth).balanceOf(address(this));\n\n        // If there is not enough WETH in the vault to cover the outstanding withdrawals\n        if (wethBalance <= outstandingWithdrawals) {\n            return 0;\n        }\n\n        return wethBalance - outstandingWithdrawals;\n    }\n\n    function _swapCollateral(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) internal pure override returns (uint256) {\n        revert(\"Collateral swap not supported\");\n    }\n}\n"
    },
    "contracts/vault/OETHVaultCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { VaultCore } from \"./VaultCore.sol\";\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\nimport { IDripper } from \"../interfaces/IDripper.sol\";\n\n/**\n * @title OETH VaultCore Contract\n * @author Origin Protocol Inc\n */\ncontract OETHVaultCore is VaultCore {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    uint256 public constant CLAIM_DELAY = 10 minutes;\n    address public immutable weth;\n    uint256 public wethAssetIndex;\n\n    // For future use (because OETHBaseVaultCore inherits from this)\n    uint256[50] private __gap;\n\n    constructor(address _weth) {\n        weth = _weth;\n    }\n\n    /**\n     * @dev Caches WETH's index in `allAssets` variable.\n     *      Reduces gas usage by redeem by caching that.\n     */\n    function cacheWETHAssetIndex() external onlyGovernor {\n        uint256 assetCount = allAssets.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            if (allAssets[i] == weth) {\n                wethAssetIndex = i;\n                break;\n            }\n        }\n\n        require(allAssets[wethAssetIndex] == weth, \"Invalid WETH Asset Index\");\n    }\n\n    // @inheritdoc VaultCore\n    // slither-disable-start reentrancy-no-eth\n    function _mint(\n        address _asset,\n        uint256 _amount,\n        uint256 _minimumOusdAmount\n    ) internal virtual override {\n        require(_asset == weth, \"Unsupported asset for minting\");\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(\n            _amount >= _minimumOusdAmount,\n            \"Mint amount lower than minimum\"\n        );\n\n        emit Mint(msg.sender, _amount);\n\n        // Rebase must happen before any transfers occur.\n        if (!rebasePaused && _amount >= rebaseThreshold) {\n            // Stream any harvested rewards (WETH) that are available to the Vault\n            IDripper(dripper).collect();\n\n            _rebase();\n        }\n\n        // Mint oTokens\n        oUSD.mint(msg.sender, _amount);\n\n        // Transfer the deposited coins to the vault\n        IERC20(_asset).safeTransferFrom(msg.sender, address(this), _amount);\n\n        // Give priority to the withdrawal queue for the new WETH liquidity\n        _addWithdrawalQueueLiquidity();\n\n        // Auto-allocate if necessary\n        if (_amount >= autoAllocateThreshold) {\n            _allocate();\n        }\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    // @inheritdoc VaultCore\n    function _calculateRedeemOutputs(uint256 _amount)\n        internal\n        view\n        virtual\n        override\n        returns (uint256[] memory outputs)\n    {\n        // Overrides `VaultCore._calculateRedeemOutputs` to redeem with only\n        // WETH instead of LST-mix. Doesn't change the function signature\n        // for backward compatibility\n\n        // Calculate redeem fee\n        if (redeemFeeBps > 0) {\n            uint256 redeemFee = _amount.mulTruncateScale(redeemFeeBps, 1e4);\n            _amount = _amount - redeemFee;\n        }\n\n        // Ensure that the WETH index is cached\n        uint256 _wethAssetIndex = wethAssetIndex;\n        require(\n            allAssets[_wethAssetIndex] == weth,\n            \"WETH Asset index not cached\"\n        );\n\n        outputs = new uint256[](allAssets.length);\n        outputs[_wethAssetIndex] = _amount;\n    }\n\n    // @inheritdoc VaultCore\n    function _redeem(uint256 _amount, uint256 _minimumUnitAmount)\n        internal\n        virtual\n        override\n    {\n        // Override `VaultCore._redeem` to simplify it. Gets rid of oracle\n        // usage and looping through all assets for LST-mix redeem. Instead\n        // does a simple WETH-only redeem.\n        emit Redeem(msg.sender, _amount);\n\n        if (_amount == 0) {\n            return;\n        }\n\n        // Amount excluding fees\n        uint256 amountMinusFee = _calculateRedeemOutputs(_amount)[\n            wethAssetIndex\n        ];\n\n        require(\n            amountMinusFee >= _minimumUnitAmount,\n            \"Redeem amount lower than minimum\"\n        );\n\n        // Is there enough WETH in the Vault available after accounting for the withdrawal queue\n        require(_wethAvailable() >= amountMinusFee, \"Liquidity error\");\n\n        // Transfer WETH minus the fee to the redeemer\n        IERC20(weth).safeTransfer(msg.sender, amountMinusFee);\n\n        // Burn OETH from user (including fees)\n        oUSD.burn(msg.sender, _amount);\n\n        // Prevent insolvency\n        _postRedeem(_amount);\n    }\n\n    /**\n     * @notice Request an asynchronous withdrawal of WETH in exchange for OETH.\n     * The OETH is burned on request and the WETH is transferred to the withdrawer on claim.\n     * This request can be claimed once the withdrawal queue's `claimable` amount\n     * is greater than or equal this request's `queued` amount.\n     * There is no minimum time or block number before a request can be claimed. It just needs\n     * enough WETH liquidity in the Vault to satisfy all the outstanding requests to that point in the queue.\n     * OETH is converted to WETH at 1:1.\n     * @param _amount Amount of OETH to burn.\n     * @param requestId Unique ID for the withdrawal request\n     * @param queued Cumulative total of all WETH queued including already claimed requests.\n     */\n    function requestWithdrawal(uint256 _amount)\n        external\n        whenNotCapitalPaused\n        nonReentrant\n        returns (uint256 requestId, uint256 queued)\n    {\n        // The check that the requester has enough OETH is done in to later burn call\n\n        requestId = withdrawalQueueMetadata.nextWithdrawalIndex;\n        queued = withdrawalQueueMetadata.queued + _amount;\n\n        // Store the next withdrawal request\n        withdrawalQueueMetadata.nextWithdrawalIndex = SafeCast.toUint128(\n            requestId + 1\n        );\n        // Store the updated queued amount which reserves WETH in the withdrawal queue\n        // and reduces the vault's total assets\n        withdrawalQueueMetadata.queued = SafeCast.toUint128(queued);\n        // Store the user's withdrawal request\n        withdrawalRequests[requestId] = WithdrawalRequest({\n            withdrawer: msg.sender,\n            claimed: false,\n            timestamp: uint40(block.timestamp),\n            amount: SafeCast.toUint128(_amount),\n            queued: SafeCast.toUint128(queued)\n        });\n\n        // Burn the user's OETH\n        oUSD.burn(msg.sender, _amount);\n\n        // Prevent withdrawal if the vault is solvent by more than the the allowed percentage\n        _postRedeem(_amount);\n\n        emit WithdrawalRequested(msg.sender, requestId, _amount, queued);\n    }\n\n    // slither-disable-start reentrancy-no-eth\n    /**\n     * @notice Claim a previously requested withdrawal once it is claimable.\n     * This request can be claimed once the withdrawal queue's `claimable` amount\n     * is greater than or equal this request's `queued` amount and 10 minutes has passed.\n     * If the requests is not claimable, the transaction will revert with `Queue pending liquidity`.\n     * If the request is not older than 10 minutes, the transaction will revert with `Claim delay not met`.\n     * OETH is converted to WETH at 1:1.\n     * @param _requestId Unique ID for the withdrawal request\n     * @return amount Amount of WETH transferred to the withdrawer\n     */\n    function claimWithdrawal(uint256 _requestId)\n        external\n        whenNotCapitalPaused\n        nonReentrant\n        returns (uint256 amount)\n    {\n        // Try and get more liquidity if there is not enough available\n        if (\n            withdrawalRequests[_requestId].queued >\n            withdrawalQueueMetadata.claimable\n        ) {\n            // Stream any harvested rewards (WETH) that are available to the Vault\n            IDripper(dripper).collect();\n\n            // Add any WETH from the Dripper to the withdrawal queue\n            _addWithdrawalQueueLiquidity();\n        }\n\n        amount = _claimWithdrawal(_requestId);\n\n        // transfer WETH from the vault to the withdrawer\n        IERC20(weth).safeTransfer(msg.sender, amount);\n\n        // Prevent insolvency\n        _postRedeem(amount);\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /**\n     * @notice Claim a previously requested withdrawals once they are claimable.\n     * This requests can be claimed once the withdrawal queue's `claimable` amount\n     * is greater than or equal each request's `queued` amount and 10 minutes has passed.\n     * If one of the requests is not claimable, the whole transaction will revert with `Queue pending liquidity`.\n     * If one of the requests is not older than 10 minutes,\n     * the whole transaction will revert with `Claim delay not met`.\n     * @param _requestIds Unique ID of each withdrawal request\n     * @return amounts Amount of WETH received for each request\n     * @return totalAmount Total amount of WETH transferred to the withdrawer\n     */\n    function claimWithdrawals(uint256[] memory _requestIds)\n        external\n        whenNotCapitalPaused\n        nonReentrant\n        returns (uint256[] memory amounts, uint256 totalAmount)\n    {\n        // Just call the Dripper instead of looping through _requestIds to find the highest id\n        // and checking it's queued amount is > the queue's claimable amount.\n\n        // Stream any harvested rewards (WETH) that are available to the Vault\n        IDripper(dripper).collect();\n\n        // Add any WETH from the Dripper to the withdrawal queue\n        _addWithdrawalQueueLiquidity();\n\n        amounts = new uint256[](_requestIds.length);\n        for (uint256 i = 0; i < _requestIds.length; ++i) {\n            amounts[i] = _claimWithdrawal(_requestIds[i]);\n            totalAmount += amounts[i];\n        }\n\n        // transfer all the claimed WETH from the vault to the withdrawer\n        IERC20(weth).safeTransfer(msg.sender, totalAmount);\n\n        // Prevent insolvency\n        _postRedeem(totalAmount);\n    }\n\n    function _claimWithdrawal(uint256 requestId)\n        internal\n        returns (uint256 amount)\n    {\n        // Load the structs from storage into memory\n        WithdrawalRequest memory request = withdrawalRequests[requestId];\n        WithdrawalQueueMetadata memory queue = withdrawalQueueMetadata;\n\n        require(\n            request.timestamp + CLAIM_DELAY <= block.timestamp,\n            \"Claim delay not met\"\n        );\n        // If there isn't enough reserved liquidity in the queue to claim\n        require(request.queued <= queue.claimable, \"Queue pending liquidity\");\n        require(request.withdrawer == msg.sender, \"Not requester\");\n        require(request.claimed == false, \"Already claimed\");\n\n        // Store the request as claimed\n        withdrawalRequests[requestId].claimed = true;\n        // Store the updated claimed amount\n        withdrawalQueueMetadata.claimed = queue.claimed + request.amount;\n\n        emit WithdrawalClaimed(msg.sender, requestId, request.amount);\n\n        return request.amount;\n    }\n\n    /// @notice Collects harvested rewards from the Dripper as WETH then\n    /// adds WETH to the withdrawal queue if there is a funding shortfall.\n    /// @dev is called from the Native Staking strategy when validator withdrawals are processed.\n    /// It also called before any WETH is allocated to a strategy.\n    function addWithdrawalQueueLiquidity() external {\n        // Stream any harvested rewards (WETH) that are available to the Vault\n        IDripper(dripper).collect();\n\n        _addWithdrawalQueueLiquidity();\n    }\n\n    /// @dev Adds WETH to the withdrawal queue if there is a funding shortfall.\n    /// This assumes 1 WETH equal 1 OETH.\n    function _addWithdrawalQueueLiquidity()\n        internal\n        returns (uint256 addedClaimable)\n    {\n        WithdrawalQueueMetadata memory queue = withdrawalQueueMetadata;\n\n        // Check if the claimable WETH is less than the queued amount\n        uint256 queueShortfall = queue.queued - queue.claimable;\n\n        // No need to do anything is the withdrawal queue is full funded\n        if (queueShortfall == 0) {\n            return 0;\n        }\n\n        uint256 wethBalance = IERC20(weth).balanceOf(address(this));\n\n        // Of the claimable withdrawal requests, how much is unclaimed?\n        // That is, the amount of WETH that is currently allocated for the withdrawal queue\n        uint256 allocatedWeth = queue.claimable - queue.claimed;\n\n        // If there is no unallocated WETH then there is nothing to add to the queue\n        if (wethBalance <= allocatedWeth) {\n            return 0;\n        }\n\n        uint256 unallocatedWeth = wethBalance - allocatedWeth;\n\n        // the new claimable amount is the smaller of the queue shortfall or unallocated weth\n        addedClaimable = queueShortfall < unallocatedWeth\n            ? queueShortfall\n            : unallocatedWeth;\n        uint256 newClaimable = queue.claimable + addedClaimable;\n\n        // Store the new claimable amount back to storage\n        withdrawalQueueMetadata.claimable = SafeCast.toUint128(newClaimable);\n\n        // emit a WithdrawalClaimable event\n        emit WithdrawalClaimable(newClaimable, addedClaimable);\n    }\n\n    /***************************************\n                View Functions\n    ****************************************/\n\n    /// @dev Calculate how much WETH in the vault is not reserved for the withdrawal queue.\n    // That is, it is available to be redeemed or deposited into a strategy.\n    function _wethAvailable() internal view returns (uint256 wethAvailable) {\n        WithdrawalQueueMetadata memory queue = withdrawalQueueMetadata;\n\n        // The amount of WETH that is still to be claimed in the withdrawal queue\n        uint256 outstandingWithdrawals = queue.queued - queue.claimed;\n\n        // The amount of sitting in WETH in the vault\n        uint256 wethBalance = IERC20(weth).balanceOf(address(this));\n\n        // If there is not enough WETH in the vault to cover the outstanding withdrawals\n        if (wethBalance <= outstandingWithdrawals) {\n            return 0;\n        }\n\n        return wethBalance - outstandingWithdrawals;\n    }\n\n    /// @dev Get the balance of an asset held in Vault and all strategies\n    /// less any WETH that is reserved for the withdrawal queue.\n    /// This will only return a non-zero balance for WETH.\n    /// All other assets will return 0 even if there is some dust amounts left in the Vault.\n    /// For example, there is 1 wei left of stETH in the OETH Vault but will return 0 in this function.\n    ///\n    /// If there is not enough WETH in the vault and all strategies to cover all outstanding\n    /// withdrawal requests then return a WETH balance of 0\n    function _checkBalance(address _asset)\n        internal\n        view\n        override\n        returns (uint256 balance)\n    {\n        if (_asset != weth) {\n            return 0;\n        }\n\n        // Get the WETH in the vault and the strategies\n        balance = super._checkBalance(_asset);\n\n        WithdrawalQueueMetadata memory queue = withdrawalQueueMetadata;\n\n        // If the vault becomes insolvent enough that the total value in the vault and all strategies\n        // is less than the outstanding withdrawals.\n        // For example, there was a mass slashing event and most users request a withdrawal.\n        if (balance + queue.claimed < queue.queued) {\n            return 0;\n        }\n\n        // Need to remove WETH that is reserved for the withdrawal queue\n        return balance + queue.claimed - queue.queued;\n    }\n\n    /**\n     * @notice Allocate unallocated funds on Vault to strategies.\n     **/\n    function allocate() external override whenNotCapitalPaused nonReentrant {\n        // Add any unallocated WETH to the withdrawal queue first\n        _addWithdrawalQueueLiquidity();\n\n        _allocate();\n    }\n\n    /// @dev Allocate WETH to the default WETH strategy if there is excess to the Vault buffer.\n    /// This is called from either `mint` or `allocate` and assumes `_addWithdrawalQueueLiquidity`\n    /// has been called before this function.\n    function _allocate() internal override {\n        // No need to do anything if no default strategy for WETH\n        address depositStrategyAddr = assetDefaultStrategies[weth];\n        if (depositStrategyAddr == address(0)) return;\n\n        uint256 wethAvailableInVault = _wethAvailable();\n        // No need to do anything if there isn't any WETH in the vault to allocate\n        if (wethAvailableInVault == 0) return;\n\n        // Calculate the target buffer for the vault using the total supply\n        uint256 totalSupply = oUSD.totalSupply();\n        uint256 targetBuffer = totalSupply.mulTruncate(vaultBuffer);\n\n        // If available WETH in the Vault is below or equal the target buffer then there's nothing to allocate\n        if (wethAvailableInVault <= targetBuffer) return;\n\n        // The amount of assets to allocate to the default strategy\n        uint256 allocateAmount = wethAvailableInVault - targetBuffer;\n\n        IStrategy strategy = IStrategy(depositStrategyAddr);\n        // Transfer WETH to the strategy and call the strategy's deposit function\n        IERC20(weth).safeTransfer(address(strategy), allocateAmount);\n        strategy.deposit(weth, allocateAmount);\n\n        emit AssetAllocated(weth, depositStrategyAddr, allocateAmount);\n    }\n\n    /// @dev The total value of all WETH held by the vault and all its strategies\n    /// less any WETH that is reserved for the withdrawal queue.\n    ///\n    // If there is not enough WETH in the vault and all strategies to cover all outstanding\n    // withdrawal requests then return a total value of 0.\n    function _totalValue() internal view override returns (uint256 value) {\n        // As WETH is the only asset, just return the WETH balance\n        return _checkBalance(weth);\n    }\n\n    /// @dev Only WETH is supported in the OETH Vault so return the WETH balance only\n    /// Any ETH balances in the Vault will be ignored.\n    /// Amounts from previously supported vault assets will also be ignored.\n    /// For example, there is 1 wei left of stETH in the OETH Vault but is will be ignored.\n    function _totalValueInVault()\n        internal\n        view\n        override\n        returns (uint256 value)\n    {\n        value = IERC20(weth).balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/vault/OETHZapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { ISfrxETH } from \"../interfaces/ISfrxETH.sol\";\n\ncontract OETHZapper {\n    IERC20 public immutable oeth;\n    IVault public immutable vault;\n\n    IWETH9 public constant weth =\n        IWETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20 public constant frxeth =\n        IERC20(0x5E8422345238F34275888049021821E8E08CAa1f);\n    ISfrxETH public constant sfrxeth =\n        ISfrxETH(0xac3E018457B222d93114458476f3E3416Abbe38F);\n    address private constant ETH_MARKER =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    event Zap(address indexed minter, address indexed asset, uint256 amount);\n\n    constructor(address _oeth, address _vault) {\n        oeth = IERC20(_oeth);\n        vault = IVault(_vault);\n\n        weth.approve(address(_vault), type(uint256).max);\n        frxeth.approve(address(_vault), type(uint256).max);\n    }\n\n    /**\n     * @dev Deposit ETH and receive OETH in return.\n     * Will verify that the user is sent 1:1 for ETH.\n     */\n    receive() external payable {\n        deposit();\n    }\n\n    /**\n     * @dev Deposit ETH and receive OETH in return\n     * Will verify that the user is sent 1:1 for ETH.\n     * @return Amount of OETH sent to user\n     */\n    function deposit() public payable returns (uint256) {\n        uint256 balance = address(this).balance;\n        weth.deposit{ value: balance }();\n        emit Zap(msg.sender, ETH_MARKER, balance);\n        return _mint(address(weth), balance);\n    }\n\n    /**\n     * @dev Deposit SFRXETH to the vault and receive OETH in return\n     * @param amount Amount of SFRXETH to deposit\n     * @param minOETH Minimum amount of OETH to receive\n     * @return Amount of OETH sent to user\n     */\n    function depositSFRXETH(uint256 amount, uint256 minOETH)\n        external\n        returns (uint256)\n    {\n        sfrxeth.redeem(amount, address(this), msg.sender);\n        emit Zap(msg.sender, address(sfrxeth), amount);\n        return _mint(address(frxeth), minOETH);\n    }\n\n    /**\n     * @dev Internal function to mint OETH from an asset\n     * @param asset Address of asset for the vault to mint from\n     * @param minOETH Minimum amount of OETH to for user to receive\n     * @return Amount of OETH sent to user\n     */\n    function _mint(address asset, uint256 minOETH) internal returns (uint256) {\n        uint256 toMint = IERC20(asset).balanceOf(address(this));\n        vault.mint(asset, toMint, minOETH);\n        uint256 mintedAmount = oeth.balanceOf(address(this));\n        require(mintedAmount >= minOETH, \"Zapper: not enough minted\");\n        require(oeth.transfer(msg.sender, mintedAmount));\n        return mintedAmount;\n    }\n}\n"
    },
    "contracts/vault/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD VaultInitializer Contract\n * @notice The VaultInitializer sets up the initial contract.\n * @author Origin Protocol Inc\n */\nimport { VaultInitializer } from \"./VaultInitializer.sol\";\nimport { VaultAdmin } from \"./VaultAdmin.sol\";\n\ncontract Vault is VaultInitializer, VaultAdmin {}\n"
    },
    "contracts/vault/VaultAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OToken VaultAdmin contract\n * @notice The VaultAdmin contract makes configuration and admin calls on the vault.\n * @author Origin Protocol Inc\n */\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { ISwapper } from \"../interfaces/ISwapper.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\nimport \"./VaultStorage.sol\";\n\ncontract VaultAdmin is VaultStorage {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    /**\n     * @dev Verifies that the caller is the Governor or Strategist.\n     */\n    modifier onlyGovernorOrStrategist() {\n        require(\n            msg.sender == strategistAddr || isGovernor(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    /***************************************\n                 Configuration\n    ****************************************/\n\n    /**\n     * @notice Set address of price provider.\n     * @param _priceProvider Address of price provider\n     */\n    function setPriceProvider(address _priceProvider) external onlyGovernor {\n        priceProvider = _priceProvider;\n        emit PriceProviderUpdated(_priceProvider);\n    }\n\n    /**\n     * @notice Set a fee in basis points to be charged for a redeem.\n     * @param _redeemFeeBps Basis point fee to be charged\n     */\n    function setRedeemFeeBps(uint256 _redeemFeeBps) external onlyGovernor {\n        require(_redeemFeeBps <= 1000, \"Redeem fee should not be over 10%\");\n        redeemFeeBps = _redeemFeeBps;\n        emit RedeemFeeUpdated(_redeemFeeBps);\n    }\n\n    /**\n     * @notice Set a buffer of assets to keep in the Vault to handle most\n     * redemptions without needing to spend gas unwinding assets from a Strategy.\n     * @param _vaultBuffer Percentage using 18 decimals. 100% = 1e18.\n     */\n    function setVaultBuffer(uint256 _vaultBuffer)\n        external\n        onlyGovernorOrStrategist\n    {\n        require(_vaultBuffer <= 1e18, \"Invalid value\");\n        vaultBuffer = _vaultBuffer;\n        emit VaultBufferUpdated(_vaultBuffer);\n    }\n\n    /**\n     * @notice Sets the minimum amount of OTokens in a mint to trigger an\n     * automatic allocation of funds afterwords.\n     * @param _threshold OToken amount with 18 fixed decimals.\n     */\n    function setAutoAllocateThreshold(uint256 _threshold)\n        external\n        onlyGovernor\n    {\n        autoAllocateThreshold = _threshold;\n        emit AllocateThresholdUpdated(_threshold);\n    }\n\n    /**\n     * @notice Set a minimum amount of OTokens in a mint or redeem that triggers a\n     * rebase\n     * @param _threshold OToken amount with 18 fixed decimals.\n     */\n    function setRebaseThreshold(uint256 _threshold) external onlyGovernor {\n        rebaseThreshold = _threshold;\n        emit RebaseThresholdUpdated(_threshold);\n    }\n\n    /**\n     * @notice Set address of Strategist\n     * @param _address Address of Strategist\n     */\n    function setStrategistAddr(address _address) external onlyGovernor {\n        strategistAddr = _address;\n        emit StrategistUpdated(_address);\n    }\n\n    /**\n     * @notice Set the default Strategy for an asset, i.e. the one which the asset\n            will be automatically allocated to and withdrawn from\n     * @param _asset Address of the asset\n     * @param _strategy Address of the Strategy\n     */\n    function setAssetDefaultStrategy(address _asset, address _strategy)\n        external\n        onlyGovernorOrStrategist\n    {\n        emit AssetDefaultStrategyUpdated(_asset, _strategy);\n        // If its a zero address being passed for the strategy we are removing\n        // the default strategy\n        if (_strategy != address(0)) {\n            // Make sure the strategy meets some criteria\n            require(strategies[_strategy].isSupported, \"Strategy not approved\");\n            IStrategy strategy = IStrategy(_strategy);\n            require(assets[_asset].isSupported, \"Asset is not supported\");\n            require(\n                strategy.supportsAsset(_asset),\n                \"Asset not supported by Strategy\"\n            );\n        }\n        assetDefaultStrategies[_asset] = _strategy;\n    }\n\n    /**\n     * @notice Set maximum amount of OTokens that can at any point be minted and deployed\n     * to strategy (used only by ConvexOUSDMetaStrategy for now).\n     * @param _threshold OToken amount with 18 fixed decimals.\n     */\n    function setNetOusdMintForStrategyThreshold(uint256 _threshold)\n        external\n        onlyGovernor\n    {\n        /**\n         * Because `netOusdMintedForStrategy` check in vault core works both ways\n         * (positive and negative) the actual impact of the amount of OToken minted\n         * could be double the threshold. E.g.:\n         *  - contract has threshold set to 100\n         *  - state of netOusdMinted is -90\n         *  - in effect it can mint 190 OToken and still be within limits\n         *\n         * We are somewhat mitigating this behaviour by resetting the netOusdMinted\n         * counter whenever new threshold is set. So it can only move one threshold\n         * amount in each direction. This also enables us to reduce the threshold\n         * amount and not have problems with current netOusdMinted being near\n         * limits on either side.\n         */\n        netOusdMintedForStrategy = 0;\n        netOusdMintForStrategyThreshold = _threshold;\n        emit NetOusdMintForStrategyThresholdChanged(_threshold);\n    }\n\n    /**\n     * @notice Set the Dripper contract that streams harvested rewards to the vault.\n     * @param _dripper Address of the Dripper contract.\n     */\n    function setDripper(address _dripper) external onlyGovernor {\n        dripper = _dripper;\n        emit DripperChanged(_dripper);\n    }\n\n    /***************************************\n                    Swaps\n    ****************************************/\n\n    /**\n     * @notice Strategist swaps collateral assets sitting in the vault.\n     * @param _fromAsset The token address of the asset being sold by the vault.\n     * @param _toAsset The token address of the asset being purchased by the vault.\n     * @param _fromAssetAmount The amount of assets being sold by the vault.\n     * @param _minToAssetAmount The minimum amount of assets to be purchased.\n     * @param _data implementation specific data. eg 1Inch swap data\n     * @return toAssetAmount The amount of toAssets that was received from the swap\n     */\n    function swapCollateral(\n        address _fromAsset,\n        address _toAsset,\n        uint256 _fromAssetAmount,\n        uint256 _minToAssetAmount,\n        bytes calldata _data\n    )\n        external\n        nonReentrant\n        onlyGovernorOrStrategist\n        returns (uint256 toAssetAmount)\n    {\n        toAssetAmount = _swapCollateral(\n            _fromAsset,\n            _toAsset,\n            _fromAssetAmount,\n            _minToAssetAmount,\n            _data\n        );\n    }\n\n    function _swapCollateral(\n        address _fromAsset,\n        address _toAsset,\n        uint256 _fromAssetAmount,\n        uint256 _minToAssetAmount,\n        bytes calldata _data\n    ) internal virtual returns (uint256 toAssetAmount) {\n        // Check fromAsset and toAsset are valid\n        Asset memory fromAssetConfig = assets[address(_fromAsset)];\n        Asset memory toAssetConfig = assets[_toAsset];\n        require(fromAssetConfig.isSupported, \"From asset is not supported\");\n        require(toAssetConfig.isSupported, \"To asset is not supported\");\n\n        // Load swap config into memory to avoid separate SLOADs\n        SwapConfig memory config = swapConfig;\n\n        // Scope a new block to remove toAssetBalBefore from the scope of swapCollateral.\n        // This avoids a stack too deep error.\n        {\n            uint256 toAssetBalBefore = IERC20(_toAsset).balanceOf(\n                address(this)\n            );\n\n            // Transfer from assets to the swapper contract\n            IERC20(_fromAsset).safeTransfer(config.swapper, _fromAssetAmount);\n\n            // Call to the Swapper contract to do the actual swap\n            // The -1 is required for stETH which sometimes transfers 1 wei less than what was specified.\n            // slither-disable-next-line unused-return\n            ISwapper(config.swapper).swap(\n                _fromAsset,\n                _toAsset,\n                _fromAssetAmount - 1,\n                _minToAssetAmount,\n                _data\n            );\n\n            // Compute the change in asset balance held by the Vault\n            toAssetAmount =\n                IERC20(_toAsset).balanceOf(address(this)) -\n                toAssetBalBefore;\n        }\n\n        // Check the to assets returned is above slippage amount specified by the strategist\n        require(\n            toAssetAmount >= _minToAssetAmount,\n            \"Strategist slippage limit\"\n        );\n\n        // Scope a new block to remove minOracleToAssetAmount from the scope of swapCollateral.\n        // This avoids a stack too deep error.\n        {\n            // Check the slippage against the Oracle in case the strategist made a mistake or has become malicious.\n            // to asset amount = from asset amount * from asset price / to asset price\n            uint256 minOracleToAssetAmount = (_fromAssetAmount *\n                (1e4 - fromAssetConfig.allowedOracleSlippageBps) *\n                IOracle(priceProvider).price(_fromAsset)) /\n                (IOracle(priceProvider).price(_toAsset) *\n                    (1e4 + toAssetConfig.allowedOracleSlippageBps));\n\n            // Scale both sides up to 18 decimals to compare\n            require(\n                toAssetAmount.scaleBy(18, toAssetConfig.decimals) >=\n                    minOracleToAssetAmount.scaleBy(\n                        18,\n                        fromAssetConfig.decimals\n                    ),\n                \"Oracle slippage limit exceeded\"\n            );\n        }\n\n        // Check the vault's total value hasn't gone below the OToken total supply\n        // by more than the allowed percentage.\n        require(\n            IVault(address(this)).totalValue() >=\n                (oUSD.totalSupply() * ((1e4 - config.allowedUndervalueBps))) /\n                    1e4,\n            \"Allowed value < supply\"\n        );\n\n        emit Swapped(_fromAsset, _toAsset, _fromAssetAmount, toAssetAmount);\n    }\n\n    /***************************************\n                    Swap Config\n    ****************************************/\n\n    /**\n     * @notice Set the contract the performs swaps of collateral assets.\n     * @param _swapperAddr Address of the Swapper contract that implements the ISwapper interface.\n     */\n    function setSwapper(address _swapperAddr) external onlyGovernor {\n        swapConfig.swapper = _swapperAddr;\n        emit SwapperChanged(_swapperAddr);\n    }\n\n    /// @notice Contract that swaps the vault's collateral assets\n    function swapper() external view returns (address swapper_) {\n        swapper_ = swapConfig.swapper;\n    }\n\n    /**\n     * @notice Set max allowed percentage the vault total value can drop below the OToken total supply in basis points\n     * when executing collateral swaps.\n     * @param _basis Percentage in basis points. eg 100 == 1%\n     */\n    function setSwapAllowedUndervalue(uint16 _basis) external onlyGovernor {\n        require(_basis < 10001, \"Invalid basis points\");\n        swapConfig.allowedUndervalueBps = _basis;\n        emit SwapAllowedUndervalueChanged(_basis);\n    }\n\n    /**\n     * @notice Max allowed percentage the vault total value can drop below the OToken total supply in basis points\n     * when executing a collateral swap.\n     * For example 100 == 1%\n     * @return value Percentage in basis points.\n     */\n    function allowedSwapUndervalue() external view returns (uint256 value) {\n        value = swapConfig.allowedUndervalueBps;\n    }\n\n    /**\n     * @notice Set the allowed slippage from the Oracle price for collateral asset swaps.\n     * @param _asset Address of the asset token.\n     * @param _allowedOracleSlippageBps allowed slippage from Oracle in basis points. eg 20 = 0.2%. Max 10%.\n     */\n    function setOracleSlippage(address _asset, uint16 _allowedOracleSlippageBps)\n        external\n        onlyGovernor\n    {\n        require(assets[_asset].isSupported, \"Asset not supported\");\n        require(_allowedOracleSlippageBps < 1000, \"Slippage too high\");\n\n        assets[_asset].allowedOracleSlippageBps = _allowedOracleSlippageBps;\n\n        emit SwapSlippageChanged(_asset, _allowedOracleSlippageBps);\n    }\n\n    /***************************************\n                Asset Config\n    ****************************************/\n\n    /**\n     * @notice Add a supported asset to the contract, i.e. one that can be\n     *         to mint OTokens.\n     * @param _asset Address of asset\n     */\n    function supportAsset(address _asset, uint8 _unitConversion)\n        external\n        onlyGovernor\n    {\n        require(!assets[_asset].isSupported, \"Asset already supported\");\n\n        assets[_asset] = Asset({\n            isSupported: true,\n            unitConversion: UnitConversion(_unitConversion),\n            decimals: 0, // will be overridden in _cacheDecimals\n            allowedOracleSlippageBps: 0 // 0% by default\n        });\n\n        _cacheDecimals(_asset);\n        allAssets.push(_asset);\n\n        // Verify that our oracle supports the asset\n        // slither-disable-next-line unused-return\n        IOracle(priceProvider).price(_asset);\n\n        emit AssetSupported(_asset);\n    }\n\n    /**\n     * @notice Remove a supported asset from the Vault\n     * @param _asset Address of asset\n     */\n    function removeAsset(address _asset) external onlyGovernor {\n        require(assets[_asset].isSupported, \"Asset not supported\");\n        require(\n            IVault(address(this)).checkBalance(_asset) <= 1e13,\n            \"Vault still holds asset\"\n        );\n\n        uint256 assetsCount = allAssets.length;\n        uint256 assetIndex = assetsCount; // initialize at invaid index\n        for (uint256 i = 0; i < assetsCount; ++i) {\n            if (allAssets[i] == _asset) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // Note: If asset is not found in `allAssets`, the following line\n        // will revert with an out-of-bound error. However, there's no\n        // reason why an asset would have `Asset.isSupported = true` but\n        // not exist in `allAssets`.\n\n        // Update allAssets array\n        allAssets[assetIndex] = allAssets[assetsCount - 1];\n        allAssets.pop();\n\n        // Reset default strategy\n        assetDefaultStrategies[_asset] = address(0);\n        emit AssetDefaultStrategyUpdated(_asset, address(0));\n\n        // Remove asset from storage\n        delete assets[_asset];\n\n        emit AssetRemoved(_asset);\n    }\n\n    /**\n     * @notice Cache decimals on OracleRouter for a particular asset. This action\n     *      is required before that asset's price can be accessed.\n     * @param _asset Address of asset token\n     */\n    function cacheDecimals(address _asset) external onlyGovernor {\n        _cacheDecimals(_asset);\n    }\n\n    /***************************************\n                Strategy Config\n    ****************************************/\n\n    /**\n     * @notice Add a strategy to the Vault.\n     * @param _addr Address of the strategy to add\n     */\n    function approveStrategy(address _addr) external onlyGovernor {\n        require(!strategies[_addr].isSupported, \"Strategy already approved\");\n        strategies[_addr] = Strategy({ isSupported: true, _deprecated: 0 });\n        allStrategies.push(_addr);\n        emit StrategyApproved(_addr);\n    }\n\n    /**\n     * @notice Remove a strategy from the Vault.\n     * @param _addr Address of the strategy to remove\n     */\n\n    function removeStrategy(address _addr) external onlyGovernor {\n        require(strategies[_addr].isSupported, \"Strategy not approved\");\n\n        uint256 assetCount = allAssets.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            require(\n                assetDefaultStrategies[allAssets[i]] != _addr,\n                \"Strategy is default for an asset\"\n            );\n        }\n\n        // Initialize strategyIndex with out of bounds result so function will\n        // revert if no valid index found\n        uint256 stratCount = allStrategies.length;\n        uint256 strategyIndex = stratCount;\n        for (uint256 i = 0; i < stratCount; ++i) {\n            if (allStrategies[i] == _addr) {\n                strategyIndex = i;\n                break;\n            }\n        }\n\n        if (strategyIndex < stratCount) {\n            allStrategies[strategyIndex] = allStrategies[stratCount - 1];\n            allStrategies.pop();\n\n            // Mark the strategy as not supported\n            strategies[_addr].isSupported = false;\n\n            // Withdraw all assets\n            IStrategy strategy = IStrategy(_addr);\n            strategy.withdrawAll();\n\n            emit StrategyRemoved(_addr);\n        }\n    }\n\n    /***************************************\n                Strategies\n    ****************************************/\n\n    /**\n     * @notice Deposit multiple assets from the vault into the strategy.\n     * @param _strategyToAddress Address of the Strategy to deposit assets into.\n     * @param _assets Array of asset address that will be deposited into the strategy.\n     * @param _amounts Array of amounts of each corresponding asset to deposit.\n     */\n    function depositToStrategy(\n        address _strategyToAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external onlyGovernorOrStrategist nonReentrant {\n        _depositToStrategy(_strategyToAddress, _assets, _amounts);\n    }\n\n    function _depositToStrategy(\n        address _strategyToAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) internal virtual {\n        require(\n            strategies[_strategyToAddress].isSupported,\n            \"Invalid to Strategy\"\n        );\n        require(_assets.length == _amounts.length, \"Parameter length mismatch\");\n\n        uint256 assetCount = _assets.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            address assetAddr = _assets[i];\n            require(\n                IStrategy(_strategyToAddress).supportsAsset(assetAddr),\n                \"Asset unsupported\"\n            );\n            // Send required amount of funds to the strategy\n            IERC20(assetAddr).safeTransfer(_strategyToAddress, _amounts[i]);\n        }\n\n        // Deposit all the funds that have been sent to the strategy\n        IStrategy(_strategyToAddress).depositAll();\n    }\n\n    /**\n     * @notice Withdraw multiple assets from the strategy to the vault.\n     * @param _strategyFromAddress Address of the Strategy to withdraw assets from.\n     * @param _assets Array of asset address that will be withdrawn from the strategy.\n     * @param _amounts Array of amounts of each corresponding asset to withdraw.\n     */\n    function withdrawFromStrategy(\n        address _strategyFromAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external onlyGovernorOrStrategist nonReentrant {\n        _withdrawFromStrategy(\n            address(this),\n            _strategyFromAddress,\n            _assets,\n            _amounts\n        );\n    }\n\n    /**\n     * @param _recipient can either be a strategy or the Vault\n     */\n    function _withdrawFromStrategy(\n        address _recipient,\n        address _strategyFromAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) internal virtual {\n        require(\n            strategies[_strategyFromAddress].isSupported,\n            \"Invalid from Strategy\"\n        );\n        require(_assets.length == _amounts.length, \"Parameter length mismatch\");\n\n        uint256 assetCount = _assets.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            // Withdraw from Strategy to the recipient\n            IStrategy(_strategyFromAddress).withdraw(\n                _recipient,\n                _assets[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /**\n     * @notice Sets the maximum allowable difference between\n     * total supply and backing assets' value.\n     */\n    function setMaxSupplyDiff(uint256 _maxSupplyDiff) external onlyGovernor {\n        maxSupplyDiff = _maxSupplyDiff;\n        emit MaxSupplyDiffChanged(_maxSupplyDiff);\n    }\n\n    /**\n     * @notice Sets the trusteeAddress that can receive a portion of yield.\n     *      Setting to the zero address disables this feature.\n     */\n    function setTrusteeAddress(address _address) external onlyGovernor {\n        trusteeAddress = _address;\n        emit TrusteeAddressChanged(_address);\n    }\n\n    /**\n     * @notice Sets the TrusteeFeeBps to the percentage of yield that should be\n     *      received in basis points.\n     */\n    function setTrusteeFeeBps(uint256 _basis) external onlyGovernor {\n        require(_basis <= 5000, \"basis cannot exceed 50%\");\n        trusteeFeeBps = _basis;\n        emit TrusteeFeeBpsChanged(_basis);\n    }\n\n    /**\n     * @notice Set OToken Metapool strategy\n     * @param _ousdMetaStrategy Address of OToken metapool strategy\n     */\n    function setOusdMetaStrategy(address _ousdMetaStrategy)\n        external\n        onlyGovernor\n    {\n        ousdMetaStrategy = _ousdMetaStrategy;\n        emit OusdMetaStrategyUpdated(_ousdMetaStrategy);\n    }\n\n    /***************************************\n                    Pause\n    ****************************************/\n\n    /**\n     * @notice Set the deposit paused flag to true to prevent rebasing.\n     */\n    function pauseRebase() external onlyGovernorOrStrategist {\n        rebasePaused = true;\n        emit RebasePaused();\n    }\n\n    /**\n     * @notice Set the deposit paused flag to true to allow rebasing.\n     */\n    function unpauseRebase() external onlyGovernorOrStrategist {\n        rebasePaused = false;\n        emit RebaseUnpaused();\n    }\n\n    /**\n     * @notice Set the deposit paused flag to true to prevent capital movement.\n     */\n    function pauseCapital() external onlyGovernorOrStrategist {\n        capitalPaused = true;\n        emit CapitalPaused();\n    }\n\n    /**\n     * @notice Set the deposit paused flag to false to enable capital movement.\n     */\n    function unpauseCapital() external onlyGovernorOrStrategist {\n        capitalPaused = false;\n        emit CapitalUnpaused();\n    }\n\n    /***************************************\n                    Utils\n    ****************************************/\n\n    /**\n     * @notice Transfer token to governor. Intended for recovering tokens stuck in\n     *      contract, i.e. mistaken sends.\n     * @param _asset Address for the asset\n     * @param _amount Amount of the asset to transfer\n     */\n    function transferToken(address _asset, uint256 _amount)\n        external\n        onlyGovernor\n    {\n        require(!assets[_asset].isSupported, \"Only unsupported assets\");\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /***************************************\n             Strategies Admin\n    ****************************************/\n\n    /**\n     * @notice Withdraws all assets from the strategy and sends assets to the Vault.\n     * @param _strategyAddr Strategy address.\n     */\n    function withdrawAllFromStrategy(address _strategyAddr)\n        external\n        onlyGovernorOrStrategist\n    {\n        _withdrawAllFromStrategy(_strategyAddr);\n    }\n\n    function _withdrawAllFromStrategy(address _strategyAddr) internal virtual {\n        require(\n            strategies[_strategyAddr].isSupported,\n            \"Strategy is not supported\"\n        );\n        IStrategy strategy = IStrategy(_strategyAddr);\n        strategy.withdrawAll();\n    }\n\n    /**\n     * @notice Withdraws all assets from all the strategies and sends assets to the Vault.\n     */\n    function withdrawAllFromStrategies() external onlyGovernorOrStrategist {\n        _withdrawAllFromStrategies();\n    }\n\n    function _withdrawAllFromStrategies() internal virtual {\n        uint256 stratCount = allStrategies.length;\n        for (uint256 i = 0; i < stratCount; ++i) {\n            IStrategy(allStrategies[i]).withdrawAll();\n        }\n    }\n\n    /***************************************\n                    Utils\n    ****************************************/\n\n    function _cacheDecimals(address token) internal {\n        Asset storage tokenAsset = assets[token];\n        if (tokenAsset.decimals != 0) {\n            return;\n        }\n        uint8 decimals = IBasicToken(token).decimals();\n        require(decimals >= 6 && decimals <= 18, \"Unexpected precision\");\n        tokenAsset.decimals = decimals;\n    }\n}\n"
    },
    "contracts/vault/VaultCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OToken VaultCore contract\n * @notice The Vault contract stores assets. On a deposit, OTokens will be minted\n           and sent to the depositor. On a withdrawal, OTokens will be burned and\n           assets will be sent to the withdrawer. The Vault accepts deposits of\n           interest from yield bearing strategies which will modify the supply\n           of OTokens.\n * @author Origin Protocol Inc\n */\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { IGetExchangeRateToken } from \"../interfaces/IGetExchangeRateToken.sol\";\nimport { IDripper } from \"../interfaces/IDripper.sol\";\n\nimport \"./VaultInitializer.sol\";\n\ncontract VaultCore is VaultInitializer {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n    // max signed int\n    uint256 internal constant MAX_INT = 2**255 - 1;\n    // max un-signed int\n    uint256 internal constant MAX_UINT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /**\n     * @dev Verifies that the rebasing is not paused.\n     */\n    modifier whenNotRebasePaused() {\n        require(!rebasePaused, \"Rebasing paused\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the deposits are not paused.\n     */\n    modifier whenNotCapitalPaused() {\n        require(!capitalPaused, \"Capital paused\");\n        _;\n    }\n\n    modifier onlyOusdMetaStrategy() {\n        require(\n            msg.sender == ousdMetaStrategy,\n            \"Caller is not the OUSD meta strategy\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Deposit a supported asset and mint OTokens.\n     * @param _asset Address of the asset being deposited\n     * @param _amount Amount of the asset being deposited\n     * @param _minimumOusdAmount Minimum OTokens to mint\n     */\n    function mint(\n        address _asset,\n        uint256 _amount,\n        uint256 _minimumOusdAmount\n    ) external whenNotCapitalPaused nonReentrant {\n        _mint(_asset, _amount, _minimumOusdAmount);\n    }\n\n    function _mint(\n        address _asset,\n        uint256 _amount,\n        uint256 _minimumOusdAmount\n    ) internal virtual {\n        require(assets[_asset].isSupported, \"Asset is not supported\");\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        uint256 units = _toUnits(_amount, _asset);\n        uint256 unitPrice = _toUnitPrice(_asset, true);\n        uint256 priceAdjustedDeposit = (units * unitPrice) / 1e18;\n\n        if (_minimumOusdAmount > 0) {\n            require(\n                priceAdjustedDeposit >= _minimumOusdAmount,\n                \"Mint amount lower than minimum\"\n            );\n        }\n\n        emit Mint(msg.sender, priceAdjustedDeposit);\n\n        // Rebase must happen before any transfers occur.\n        if (priceAdjustedDeposit >= rebaseThreshold && !rebasePaused) {\n            if (dripper != address(0)) {\n                // Stream any harvested rewards that are available\n                IDripper(dripper).collect();\n            }\n            _rebase();\n        }\n\n        // Mint matching amount of OTokens\n        oUSD.mint(msg.sender, priceAdjustedDeposit);\n\n        // Transfer the deposited coins to the vault\n        IERC20 asset = IERC20(_asset);\n        asset.safeTransferFrom(msg.sender, address(this), _amount);\n\n        if (priceAdjustedDeposit >= autoAllocateThreshold) {\n            _allocate();\n        }\n    }\n\n    /**\n     * @notice Mint OTokens for a Metapool Strategy\n     * @param _amount Amount of the asset being deposited\n     *\n     * Notice: can't use `nonReentrant` modifier since the `mint` function can\n     * call `allocate`, and that can trigger `ConvexOUSDMetaStrategy` to call this function\n     * while the execution of the `mint` has not yet completed -> causing a `nonReentrant` collision.\n     *\n     * Also important to understand is that this is a limitation imposed by the test suite.\n     * Production / mainnet contracts should never be configured in a way where mint/redeem functions\n     * that are moving funds between the Vault and end user wallets can influence strategies\n     * utilizing this function.\n     */\n    function mintForStrategy(uint256 _amount)\n        external\n        virtual\n        whenNotCapitalPaused\n        onlyOusdMetaStrategy\n    {\n        require(_amount < MAX_INT, \"Amount too high\");\n\n        emit Mint(msg.sender, _amount);\n\n        // safe to cast because of the require check at the beginning of the function\n        netOusdMintedForStrategy += int256(_amount);\n\n        require(\n            abs(netOusdMintedForStrategy) < netOusdMintForStrategyThreshold,\n            \"Minted ousd surpassed netOusdMintForStrategyThreshold.\"\n        );\n\n        // Mint matching amount of OTokens\n        oUSD.mint(msg.sender, _amount);\n    }\n\n    // In memoriam\n\n    /**\n     * @notice Withdraw a supported asset and burn OTokens.\n     * @param _amount Amount of OTokens to burn\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function redeem(uint256 _amount, uint256 _minimumUnitAmount)\n        external\n        whenNotCapitalPaused\n        nonReentrant\n    {\n        _redeem(_amount, _minimumUnitAmount);\n    }\n\n    /**\n     * @notice Withdraw a supported asset and burn OTokens.\n     * @param _amount Amount of OTokens to burn\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function _redeem(uint256 _amount, uint256 _minimumUnitAmount)\n        internal\n        virtual\n    {\n        // Calculate redemption outputs\n        uint256[] memory outputs = _calculateRedeemOutputs(_amount);\n\n        emit Redeem(msg.sender, _amount);\n\n        // Send outputs\n        uint256 assetCount = allAssets.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            if (outputs[i] == 0) continue;\n\n            address assetAddr = allAssets[i];\n\n            if (IERC20(assetAddr).balanceOf(address(this)) >= outputs[i]) {\n                // Use Vault funds first if sufficient\n                IERC20(assetAddr).safeTransfer(msg.sender, outputs[i]);\n            } else {\n                address strategyAddr = assetDefaultStrategies[assetAddr];\n                if (strategyAddr != address(0)) {\n                    // Nothing in Vault, but something in Strategy, send from there\n                    IStrategy strategy = IStrategy(strategyAddr);\n                    strategy.withdraw(msg.sender, assetAddr, outputs[i]);\n                } else {\n                    // Cant find funds anywhere\n                    revert(\"Liquidity error\");\n                }\n            }\n        }\n\n        if (_minimumUnitAmount > 0) {\n            uint256 unitTotal = 0;\n            for (uint256 i = 0; i < outputs.length; ++i) {\n                unitTotal += _toUnits(outputs[i], allAssets[i]);\n            }\n            require(\n                unitTotal >= _minimumUnitAmount,\n                \"Redeem amount lower than minimum\"\n            );\n        }\n\n        oUSD.burn(msg.sender, _amount);\n\n        _postRedeem(_amount);\n    }\n\n    function _postRedeem(uint256 _amount) internal {\n        // Until we can prove that we won't affect the prices of our assets\n        // by withdrawing them, this should be here.\n        // It's possible that a strategy was off on its asset total, perhaps\n        // a reward token sold for more or for less than anticipated.\n        uint256 totalUnits = 0;\n        if (_amount >= rebaseThreshold && !rebasePaused) {\n            totalUnits = _rebase();\n        } else {\n            totalUnits = _totalValue();\n        }\n\n        // Check that the OTokens are backed by enough assets\n        if (maxSupplyDiff > 0) {\n            // If there are more outstanding withdrawal requests than assets in the vault and strategies\n            // then the available assets will be negative and totalUnits will be rounded up to zero.\n            // As we don't know the exact shortfall amount, we will reject all redeem and withdrawals\n            require(totalUnits > 0, \"Too many outstanding requests\");\n\n            // Allow a max difference of maxSupplyDiff% between\n            // backing assets value and OUSD total supply\n            uint256 diff = oUSD.totalSupply().divPrecisely(totalUnits);\n            require(\n                (diff > 1e18 ? diff - 1e18 : 1e18 - diff) <= maxSupplyDiff,\n                \"Backing supply liquidity error\"\n            );\n        }\n    }\n\n    /**\n     * @notice Burn OTokens for Metapool Strategy\n     * @param _amount Amount of OUSD to burn\n     *\n     * @dev Notice: can't use `nonReentrant` modifier since the `redeem` function could\n     * require withdrawal on `ConvexOUSDMetaStrategy` and that one can call `burnForStrategy`\n     * while the execution of the `redeem` has not yet completed -> causing a `nonReentrant` collision.\n     *\n     * Also important to understand is that this is a limitation imposed by the test suite.\n     * Production / mainnet contracts should never be configured in a way where mint/redeem functions\n     * that are moving funds between the Vault and end user wallets can influence strategies\n     * utilizing this function.\n     */\n    function burnForStrategy(uint256 _amount)\n        external\n        virtual\n        whenNotCapitalPaused\n        onlyOusdMetaStrategy\n    {\n        require(_amount < MAX_INT, \"Amount too high\");\n\n        emit Redeem(msg.sender, _amount);\n\n        // safe to cast because of the require check at the beginning of the function\n        netOusdMintedForStrategy -= int256(_amount);\n\n        require(\n            abs(netOusdMintedForStrategy) < netOusdMintForStrategyThreshold,\n            \"Attempting to burn too much OUSD.\"\n        );\n\n        // Burn OTokens\n        oUSD.burn(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Withdraw a supported asset and burn all OTokens.\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function redeemAll(uint256 _minimumUnitAmount)\n        external\n        whenNotCapitalPaused\n        nonReentrant\n    {\n        _redeem(oUSD.balanceOf(msg.sender), _minimumUnitAmount);\n    }\n\n    /**\n     * @notice Allocate unallocated funds on Vault to strategies.\n     **/\n    function allocate() external virtual whenNotCapitalPaused nonReentrant {\n        _allocate();\n    }\n\n    /**\n     * @dev Allocate unallocated funds on Vault to strategies.\n     **/\n    function _allocate() internal virtual {\n        uint256 vaultValue = _totalValueInVault();\n        // Nothing in vault to allocate\n        if (vaultValue == 0) return;\n        uint256 strategiesValue = _totalValueInStrategies();\n        // We have a method that does the same as this, gas optimisation\n        uint256 calculatedTotalValue = vaultValue + strategiesValue;\n\n        // We want to maintain a buffer on the Vault so calculate a percentage\n        // modifier to multiply each amount being allocated by to enforce the\n        // vault buffer\n        uint256 vaultBufferModifier;\n        if (strategiesValue == 0) {\n            // Nothing in Strategies, allocate 100% minus the vault buffer to\n            // strategies\n            vaultBufferModifier = uint256(1e18) - vaultBuffer;\n        } else {\n            vaultBufferModifier =\n                (vaultBuffer * calculatedTotalValue) /\n                vaultValue;\n            if (1e18 > vaultBufferModifier) {\n                // E.g. 1e18 - (1e17 * 10e18)/5e18 = 8e17\n                // (5e18 * 8e17) / 1e18 = 4e18 allocated from Vault\n                vaultBufferModifier = uint256(1e18) - vaultBufferModifier;\n            } else {\n                // We need to let the buffer fill\n                return;\n            }\n        }\n        if (vaultBufferModifier == 0) return;\n\n        // Iterate over all assets in the Vault and allocate to the appropriate\n        // strategy\n        uint256 assetCount = allAssets.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            IERC20 asset = IERC20(allAssets[i]);\n            uint256 assetBalance = asset.balanceOf(address(this));\n            // No balance, nothing to do here\n            if (assetBalance == 0) continue;\n\n            // Multiply the balance by the vault buffer modifier and truncate\n            // to the scale of the asset decimals\n            uint256 allocateAmount = assetBalance.mulTruncate(\n                vaultBufferModifier\n            );\n\n            address depositStrategyAddr = assetDefaultStrategies[\n                address(asset)\n            ];\n\n            if (depositStrategyAddr != address(0) && allocateAmount > 0) {\n                IStrategy strategy = IStrategy(depositStrategyAddr);\n                // Transfer asset to Strategy and call deposit method to\n                // mint or take required action\n                asset.safeTransfer(address(strategy), allocateAmount);\n                strategy.deposit(address(asset), allocateAmount);\n                emit AssetAllocated(\n                    address(asset),\n                    depositStrategyAddr,\n                    allocateAmount\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Calculate the total value of assets held by the Vault and all\n     *      strategies and update the supply of OTokens.\n     */\n    function rebase() external virtual nonReentrant {\n        _rebase();\n    }\n\n    /**\n     * @dev Calculate the total value of assets held by the Vault and all\n     *      strategies and update the supply of OTokens, optionally sending a\n     *      portion of the yield to the trustee.\n     * @return totalUnits Total balance of Vault in units\n     */\n    function _rebase() internal whenNotRebasePaused returns (uint256) {\n        uint256 ousdSupply = oUSD.totalSupply();\n        uint256 vaultValue = _totalValue();\n        if (ousdSupply == 0) {\n            return vaultValue;\n        }\n\n        // Yield fee collection\n        address _trusteeAddress = trusteeAddress; // gas savings\n        if (_trusteeAddress != address(0) && (vaultValue > ousdSupply)) {\n            uint256 yield = vaultValue - ousdSupply;\n            uint256 fee = yield.mulTruncateScale(trusteeFeeBps, 1e4);\n            require(yield > fee, \"Fee must not be greater than yield\");\n            if (fee > 0) {\n                oUSD.mint(_trusteeAddress, fee);\n            }\n            emit YieldDistribution(_trusteeAddress, yield, fee);\n        }\n\n        // Only rachet OToken supply upwards\n        ousdSupply = oUSD.totalSupply(); // Final check should use latest value\n        if (vaultValue > ousdSupply) {\n            oUSD.changeSupply(vaultValue);\n        }\n        return vaultValue;\n    }\n\n    /**\n     * @notice Determine the total value of assets held by the vault and its\n     *         strategies.\n     * @return value Total value in USD/ETH (1e18)\n     */\n    function totalValue() external view virtual returns (uint256 value) {\n        value = _totalValue();\n    }\n\n    /**\n     * @dev Internal Calculate the total value of the assets held by the\n     *         vault and its strategies.\n     * @return value Total value in USD/ETH (1e18)\n     */\n    function _totalValue() internal view virtual returns (uint256 value) {\n        return _totalValueInVault() + _totalValueInStrategies();\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held in Vault.\n     * @return value Total value in USD/ETH (1e18)\n     */\n    function _totalValueInVault()\n        internal\n        view\n        virtual\n        returns (uint256 value)\n    {\n        uint256 assetCount = allAssets.length;\n        for (uint256 y = 0; y < assetCount; ++y) {\n            address assetAddr = allAssets[y];\n            uint256 balance = IERC20(assetAddr).balanceOf(address(this));\n            if (balance > 0) {\n                value += _toUnits(balance, assetAddr);\n            }\n        }\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held in Strategies.\n     * @return value Total value in USD/ETH (1e18)\n     */\n    function _totalValueInStrategies() internal view returns (uint256 value) {\n        uint256 stratCount = allStrategies.length;\n        for (uint256 i = 0; i < stratCount; ++i) {\n            value = value + _totalValueInStrategy(allStrategies[i]);\n        }\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held by strategy.\n     * @param _strategyAddr Address of the strategy\n     * @return value Total value in USD/ETH (1e18)\n     */\n    function _totalValueInStrategy(address _strategyAddr)\n        internal\n        view\n        returns (uint256 value)\n    {\n        IStrategy strategy = IStrategy(_strategyAddr);\n        uint256 assetCount = allAssets.length;\n        for (uint256 y = 0; y < assetCount; ++y) {\n            address assetAddr = allAssets[y];\n            if (strategy.supportsAsset(assetAddr)) {\n                uint256 balance = strategy.checkBalance(assetAddr);\n                if (balance > 0) {\n                    value += _toUnits(balance, assetAddr);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Get the balance of an asset held in Vault and all strategies.\n     * @param _asset Address of asset\n     * @return uint256 Balance of asset in decimals of asset\n     */\n    function checkBalance(address _asset) external view returns (uint256) {\n        return _checkBalance(_asset);\n    }\n\n    /**\n     * @notice Get the balance of an asset held in Vault and all strategies.\n     * @param _asset Address of asset\n     * @return balance Balance of asset in decimals of asset\n     */\n    function _checkBalance(address _asset)\n        internal\n        view\n        virtual\n        returns (uint256 balance)\n    {\n        IERC20 asset = IERC20(_asset);\n        balance = asset.balanceOf(address(this));\n        uint256 stratCount = allStrategies.length;\n        for (uint256 i = 0; i < stratCount; ++i) {\n            IStrategy strategy = IStrategy(allStrategies[i]);\n            if (strategy.supportsAsset(_asset)) {\n                balance = balance + strategy.checkBalance(_asset);\n            }\n        }\n    }\n\n    /**\n     * @notice Calculate the outputs for a redeem function, i.e. the mix of\n     * coins that will be returned\n     */\n    function calculateRedeemOutputs(uint256 _amount)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return _calculateRedeemOutputs(_amount);\n    }\n\n    /**\n     * @dev Calculate the outputs for a redeem function, i.e. the mix of\n     * coins that will be returned.\n     * @return outputs Array of amounts respective to the supported assets\n     */\n    function _calculateRedeemOutputs(uint256 _amount)\n        internal\n        view\n        virtual\n        returns (uint256[] memory outputs)\n    {\n        // We always give out coins in proportion to how many we have,\n        // Now if all coins were the same value, this math would easy,\n        // just take the percentage of each coin, and multiply by the\n        // value to be given out. But if coins are worth more than $1,\n        // then we would end up handing out too many coins. We need to\n        // adjust by the total value of coins.\n        //\n        // To do this, we total up the value of our coins, by their\n        // percentages. Then divide what we would otherwise give out by\n        // this number.\n        //\n        // Let say we have 100 DAI at $1.06  and 200 USDT at $1.00.\n        // So for every 1 DAI we give out, we'll be handing out 2 USDT\n        // Our total output ratio is: 33% * 1.06 + 66% * 1.00 = 1.02\n        //\n        // So when calculating the output, we take the percentage of\n        // each coin, times the desired output value, divided by the\n        // totalOutputRatio.\n        //\n        // For example, withdrawing: 30 OUSD:\n        // DAI 33% * 30 / 1.02 = 9.80 DAI\n        // USDT = 66 % * 30 / 1.02 = 19.60 USDT\n        //\n        // Checking these numbers:\n        // 9.80 DAI * 1.06 = $10.40\n        // 19.60 USDT * 1.00 = $19.60\n        //\n        // And so the user gets $10.40 + $19.60 = $30 worth of value.\n\n        uint256 assetCount = allAssets.length;\n        uint256[] memory assetUnits = new uint256[](assetCount);\n        uint256[] memory assetBalances = new uint256[](assetCount);\n        outputs = new uint256[](assetCount);\n\n        // Calculate redeem fee\n        if (redeemFeeBps > 0) {\n            uint256 redeemFee = _amount.mulTruncateScale(redeemFeeBps, 1e4);\n            _amount = _amount - redeemFee;\n        }\n\n        // Calculate assets balances and decimals once,\n        // for a large gas savings.\n        uint256 totalUnits = 0;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            address assetAddr = allAssets[i];\n            uint256 balance = _checkBalance(assetAddr);\n            assetBalances[i] = balance;\n            assetUnits[i] = _toUnits(balance, assetAddr);\n            totalUnits = totalUnits + assetUnits[i];\n        }\n        // Calculate totalOutputRatio\n        uint256 totalOutputRatio = 0;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            uint256 unitPrice = _toUnitPrice(allAssets[i], false);\n            uint256 ratio = (assetUnits[i] * unitPrice) / totalUnits;\n            totalOutputRatio = totalOutputRatio + ratio;\n        }\n        // Calculate final outputs\n        uint256 factor = _amount.divPrecisely(totalOutputRatio);\n        for (uint256 i = 0; i < assetCount; ++i) {\n            outputs[i] = (assetBalances[i] * factor) / totalUnits;\n        }\n    }\n\n    /***************************************\n                    Pricing\n    ****************************************/\n\n    /**\n     * @notice Returns the total price in 18 digit units for a given asset.\n     *      Never goes above 1, since that is how we price mints.\n     * @param asset address of the asset\n     * @return price uint256: unit (USD / ETH) price for 1 unit of the asset, in 18 decimal fixed\n     */\n    function priceUnitMint(address asset)\n        external\n        view\n        returns (uint256 price)\n    {\n        /* need to supply 1 asset unit in asset's decimals and can not just hard-code\n         * to 1e18 and ignore calling `_toUnits` since we need to consider assets\n         * with the exchange rate\n         */\n        uint256 units = _toUnits(\n            uint256(1e18).scaleBy(_getDecimals(asset), 18),\n            asset\n        );\n        price = (_toUnitPrice(asset, true) * units) / 1e18;\n    }\n\n    /**\n     * @notice Returns the total price in 18 digit unit for a given asset.\n     *      Never goes below 1, since that is how we price redeems\n     * @param asset Address of the asset\n     * @return price uint256: unit (USD / ETH) price for 1 unit of the asset, in 18 decimal fixed\n     */\n    function priceUnitRedeem(address asset)\n        external\n        view\n        returns (uint256 price)\n    {\n        /* need to supply 1 asset unit in asset's decimals and can not just hard-code\n         * to 1e18 and ignore calling `_toUnits` since we need to consider assets\n         * with the exchange rate\n         */\n        uint256 units = _toUnits(\n            uint256(1e18).scaleBy(_getDecimals(asset), 18),\n            asset\n        );\n        price = (_toUnitPrice(asset, false) * units) / 1e18;\n    }\n\n    /***************************************\n                    Utils\n    ****************************************/\n\n    /**\n     * @dev Convert a quantity of a token into 1e18 fixed decimal \"units\"\n     * in the underlying base (USD/ETH) used by the vault.\n     * Price is not taken into account, only quantity.\n     *\n     * Examples of this conversion:\n     *\n     * - 1e18 DAI becomes 1e18 units (same decimals)\n     * - 1e6 USDC becomes 1e18 units (decimal conversion)\n     * - 1e18 rETH becomes 1.2e18 units (exchange rate conversion)\n     *\n     * @param _raw Quantity of asset\n     * @param _asset Core Asset address\n     * @return value 1e18 normalized quantity of units\n     */\n    function _toUnits(uint256 _raw, address _asset)\n        internal\n        view\n        returns (uint256)\n    {\n        UnitConversion conversion = assets[_asset].unitConversion;\n        if (conversion == UnitConversion.DECIMALS) {\n            return _raw.scaleBy(18, _getDecimals(_asset));\n        } else if (conversion == UnitConversion.GETEXCHANGERATE) {\n            uint256 exchangeRate = IGetExchangeRateToken(_asset)\n                .getExchangeRate();\n            return (_raw * exchangeRate) / 1e18;\n        } else {\n            revert(\"Unsupported conversion type\");\n        }\n    }\n\n    /**\n     * @dev Returns asset's unit price accounting for different asset types\n     *      and takes into account the context in which that price exists -\n     *      - mint or redeem.\n     *\n     * Note: since we are returning the price of the unit and not the one of the\n     * asset (see comment above how 1 rETH exchanges for 1.2 units) we need\n     * to make the Oracle price adjustment as well since we are pricing the\n     * units and not the assets.\n     *\n     * The price also snaps to a \"full unit price\" in case a mint or redeem\n     * action would be unfavourable to the protocol.\n     *\n     */\n    function _toUnitPrice(address _asset, bool isMint)\n        internal\n        view\n        returns (uint256 price)\n    {\n        UnitConversion conversion = assets[_asset].unitConversion;\n        price = IOracle(priceProvider).price(_asset);\n\n        if (conversion == UnitConversion.GETEXCHANGERATE) {\n            uint256 exchangeRate = IGetExchangeRateToken(_asset)\n                .getExchangeRate();\n            price = (price * 1e18) / exchangeRate;\n        } else if (conversion != UnitConversion.DECIMALS) {\n            revert(\"Unsupported conversion type\");\n        }\n\n        /* At this stage the price is already adjusted to the unit\n         * so the price checks are agnostic to underlying asset being\n         * pegged to a USD or to an ETH or having a custom exchange rate.\n         */\n        require(price <= MAX_UNIT_PRICE_DRIFT, \"Vault: Price exceeds max\");\n        require(price >= MIN_UNIT_PRICE_DRIFT, \"Vault: Price under min\");\n\n        if (isMint) {\n            /* Never price a normalized unit price for more than one\n             * unit of OETH/OUSD when minting.\n             */\n            if (price > 1e18) {\n                price = 1e18;\n            }\n            require(price >= MINT_MINIMUM_UNIT_PRICE, \"Asset price below peg\");\n        } else {\n            /* Never give out more than 1 normalized unit amount of assets\n             * for one unit of OETH/OUSD when redeeming.\n             */\n            if (price < 1e18) {\n                price = 1e18;\n            }\n        }\n    }\n\n    function _getDecimals(address _asset)\n        internal\n        view\n        returns (uint256 decimals)\n    {\n        decimals = assets[_asset].decimals;\n        require(decimals > 0, \"Decimals not cached\");\n    }\n\n    /**\n     * @notice Return the number of assets supported by the Vault.\n     */\n    function getAssetCount() public view returns (uint256) {\n        return allAssets.length;\n    }\n\n    /**\n     * @notice Gets the vault configuration of a supported asset.\n     */\n    function getAssetConfig(address _asset)\n        public\n        view\n        returns (Asset memory config)\n    {\n        config = assets[_asset];\n    }\n\n    /**\n     * @notice Return all vault asset addresses in order\n     */\n    function getAllAssets() external view returns (address[] memory) {\n        return allAssets;\n    }\n\n    /**\n     * @notice Return the number of strategies active on the Vault.\n     */\n    function getStrategyCount() external view returns (uint256) {\n        return allStrategies.length;\n    }\n\n    /**\n     * @notice Return the array of all strategies\n     */\n    function getAllStrategies() external view returns (address[] memory) {\n        return allStrategies;\n    }\n\n    /**\n     * @notice Returns whether the vault supports the asset\n     * @param _asset address of the asset\n     * @return true if supported\n     */\n    function isSupportedAsset(address _asset) external view returns (bool) {\n        return assets[_asset].isSupported;\n    }\n\n    /**\n     * @dev Falldown to the admin implementation\n     * @notice This is a catch all for all functions not declared in core\n     */\n    // solhint-disable-next-line no-complex-fallback\n    fallback() external {\n        bytes32 slot = adminImplPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(\n                gas(),\n                sload(slot),\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    function abs(int256 x) private pure returns (uint256) {\n        require(x < int256(MAX_INT), \"Amount too high\");\n        return x >= 0 ? uint256(x) : uint256(-x);\n    }\n}\n"
    },
    "contracts/vault/VaultInitializer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OToken VaultInitializer contract\n * @notice The Vault contract initializes the vault.\n * @author Origin Protocol Inc\n */\n\nimport \"./VaultStorage.sol\";\n\ncontract VaultInitializer is VaultStorage {\n    function initialize(address _priceProvider, address _oToken)\n        external\n        onlyGovernor\n        initializer\n    {\n        require(_priceProvider != address(0), \"PriceProvider address is zero\");\n        require(_oToken != address(0), \"oToken address is zero\");\n\n        oUSD = OUSD(_oToken);\n\n        priceProvider = _priceProvider;\n\n        rebasePaused = false;\n        capitalPaused = true;\n\n        // Initial redeem fee of 0 basis points\n        redeemFeeBps = 0;\n        // Initial Vault buffer of 0%\n        vaultBuffer = 0;\n        // Initial allocate threshold of 25,000 OUSD\n        autoAllocateThreshold = 25000e18;\n        // Threshold for rebasing\n        rebaseThreshold = 1000e18;\n        // Initialize all strategies\n        allStrategies = new address[](0);\n    }\n}\n"
    },
    "contracts/vault/VaultStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OToken VaultStorage contract\n * @notice The VaultStorage contract defines the storage for the Vault contracts\n * @author Origin Protocol Inc\n */\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { OUSD } from \"../token/OUSD.sol\";\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport \"../utils/Helpers.sol\";\n\ncontract VaultStorage is Initializable, Governable {\n    using SafeERC20 for IERC20;\n\n    event AssetSupported(address _asset);\n    event AssetRemoved(address _asset);\n    event AssetDefaultStrategyUpdated(address _asset, address _strategy);\n    event AssetAllocated(address _asset, address _strategy, uint256 _amount);\n    event StrategyApproved(address _addr);\n    event StrategyRemoved(address _addr);\n    event Mint(address _addr, uint256 _value);\n    event Redeem(address _addr, uint256 _value);\n    event CapitalPaused();\n    event CapitalUnpaused();\n    event RebasePaused();\n    event RebaseUnpaused();\n    event VaultBufferUpdated(uint256 _vaultBuffer);\n    event OusdMetaStrategyUpdated(address _ousdMetaStrategy);\n    event RedeemFeeUpdated(uint256 _redeemFeeBps);\n    event PriceProviderUpdated(address _priceProvider);\n    event AllocateThresholdUpdated(uint256 _threshold);\n    event RebaseThresholdUpdated(uint256 _threshold);\n    event StrategistUpdated(address _address);\n    event MaxSupplyDiffChanged(uint256 maxSupplyDiff);\n    event YieldDistribution(address _to, uint256 _yield, uint256 _fee);\n    event TrusteeFeeBpsChanged(uint256 _basis);\n    event TrusteeAddressChanged(address _address);\n    event NetOusdMintForStrategyThresholdChanged(uint256 _threshold);\n    event SwapperChanged(address _address);\n    event SwapAllowedUndervalueChanged(uint256 _basis);\n    event SwapSlippageChanged(address _asset, uint256 _basis);\n    event Swapped(\n        address indexed _fromAsset,\n        address indexed _toAsset,\n        uint256 _fromAssetAmount,\n        uint256 _toAssetAmount\n    );\n    event StrategyAddedToMintWhitelist(address indexed strategy);\n    event StrategyRemovedFromMintWhitelist(address indexed strategy);\n    event DripperChanged(address indexed _dripper);\n    event WithdrawalRequested(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount,\n        uint256 _queued\n    );\n    event WithdrawalClaimed(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount\n    );\n    event WithdrawalClaimable(uint256 _claimable, uint256 _newClaimable);\n\n    // Assets supported by the Vault, i.e. Stablecoins\n    enum UnitConversion {\n        DECIMALS,\n        GETEXCHANGERATE\n    }\n    // Changed to fit into a single storage slot so the decimals needs to be recached\n    struct Asset {\n        // Note: OETHVaultCore doesn't use `isSupported` when minting,\n        // redeeming or checking balance of assets.\n        bool isSupported;\n        UnitConversion unitConversion;\n        uint8 decimals;\n        // Max allowed slippage from the Oracle price when swapping collateral assets in basis points.\n        // For example 40 == 0.4% slippage\n        uint16 allowedOracleSlippageBps;\n    }\n\n    /// @dev mapping of supported vault assets to their configuration\n    // slither-disable-next-line uninitialized-state\n    mapping(address => Asset) internal assets;\n    /// @dev list of all assets supported by the vault.\n    // slither-disable-next-line uninitialized-state\n    address[] internal allAssets;\n\n    // Strategies approved for use by the Vault\n    struct Strategy {\n        bool isSupported;\n        uint256 _deprecated; // Deprecated storage slot\n    }\n    /// @dev mapping of strategy contracts to their configuration\n    // slither-disable-next-line uninitialized-state\n    mapping(address => Strategy) internal strategies;\n    /// @dev list of all vault strategies\n    address[] internal allStrategies;\n\n    /// @notice Address of the Oracle price provider contract\n    // slither-disable-next-line uninitialized-state\n    address public priceProvider;\n    /// @notice pause rebasing if true\n    bool public rebasePaused = false;\n    /// @notice pause operations that change the OToken supply.\n    /// eg mint, redeem, allocate, mint/burn for strategy\n    bool public capitalPaused = true;\n    /// @notice Redemption fee in basis points. eg 50 = 0.5%\n    uint256 public redeemFeeBps;\n    /// @notice Percentage of assets to keep in Vault to handle (most) withdrawals. 100% = 1e18.\n    uint256 public vaultBuffer;\n    /// @notice OToken mints over this amount automatically allocate funds. 18 decimals.\n    uint256 public autoAllocateThreshold;\n    /// @notice OToken mints over this amount automatically rebase. 18 decimals.\n    uint256 public rebaseThreshold;\n\n    /// @dev Address of the OToken token. eg OUSD or OETH.\n    // slither-disable-next-line uninitialized-state\n    OUSD internal oUSD;\n\n    //keccak256(\"OUSD.vault.governor.admin.impl\");\n    bytes32 constant adminImplPosition =\n        0xa2bd3d3cf188a41358c8b401076eb59066b09dec5775650c0de4c55187d17bd9;\n\n    // Address of the contract responsible for post rebase syncs with AMMs\n    address private _deprecated_rebaseHooksAddr = address(0);\n\n    // Deprecated: Address of Uniswap\n    // slither-disable-next-line constable-states\n    address private _deprecated_uniswapAddr = address(0);\n\n    /// @notice Address of the Strategist\n    address public strategistAddr = address(0);\n\n    /// @notice Mapping of asset address to the Strategy that they should automatically\n    // be allocated to\n    // slither-disable-next-line uninitialized-state\n    mapping(address => address) public assetDefaultStrategies;\n\n    /// @notice Max difference between total supply and total value of assets. 18 decimals.\n    // slither-disable-next-line uninitialized-state\n    uint256 public maxSupplyDiff;\n\n    /// @notice Trustee contract that can collect a percentage of yield\n    address public trusteeAddress;\n\n    /// @notice Amount of yield collected in basis points. eg 2000 = 20%\n    uint256 public trusteeFeeBps;\n\n    /// @dev Deprecated: Tokens that should be swapped for stablecoins\n    address[] private _deprecated_swapTokens;\n\n    uint256 constant MINT_MINIMUM_UNIT_PRICE = 0.998e18;\n\n    /// @notice Metapool strategy that is allowed to mint/burn OTokens without changing collateral\n\n    // slither-disable-start constable-states\n    // slither-disable-next-line uninitialized-state\n    address public ousdMetaStrategy;\n\n    /// @notice How much OTokens are currently minted by the strategy\n    // slither-disable-next-line uninitialized-state\n    int256 public netOusdMintedForStrategy;\n\n    /// @notice How much net total OTokens are allowed to be minted by all strategies\n    // slither-disable-next-line uninitialized-state\n    uint256 public netOusdMintForStrategyThreshold;\n\n    // slither-disable-end constable-states\n\n    uint256 constant MIN_UNIT_PRICE_DRIFT = 0.7e18;\n    uint256 constant MAX_UNIT_PRICE_DRIFT = 1.3e18;\n\n    /// @notice Collateral swap configuration.\n    /// @dev is packed into a single storage slot to save gas.\n    struct SwapConfig {\n        // Contract that swaps the vault's collateral assets\n        address swapper;\n        // Max allowed percentage the total value can drop below the total supply in basis points.\n        // For example 100 == 1%\n        uint16 allowedUndervalueBps;\n    }\n    SwapConfig internal swapConfig = SwapConfig(address(0), 0);\n\n    // List of strategies that can mint oTokens directly\n    // Used in OETHBaseVaultCore\n    // slither-disable-next-line uninitialized-state\n    mapping(address => bool) public isMintWhitelistedStrategy;\n\n    /// @notice Address of the Dripper contract that streams harvested rewards to the Vault\n    /// @dev The vault is proxied so needs to be set with setDripper against the proxy contract.\n    // slither-disable-start constable-states\n    // slither-disable-next-line uninitialized-state\n    address public dripper;\n    // slither-disable-end constable-states\n\n    /// Withdrawal Queue Storage /////\n\n    struct WithdrawalQueueMetadata {\n        // cumulative total of all withdrawal requests included the ones that have already been claimed\n        uint128 queued;\n        // cumulative total of all the requests that can be claimed including the ones that have already been claimed\n        uint128 claimable;\n        // total of all the requests that have been claimed\n        uint128 claimed;\n        // index of the next withdrawal request starting at 0\n        uint128 nextWithdrawalIndex;\n    }\n\n    /// @notice Global metadata for the withdrawal queue including:\n    /// queued - cumulative total of all withdrawal requests included the ones that have already been claimed\n    /// claimable - cumulative total of all the requests that can be claimed including the ones already claimed\n    /// claimed - total of all the requests that have been claimed\n    /// nextWithdrawalIndex - index of the next withdrawal request starting at 0\n    // slither-disable-next-line uninitialized-state\n    WithdrawalQueueMetadata public withdrawalQueueMetadata;\n\n    struct WithdrawalRequest {\n        address withdrawer;\n        bool claimed;\n        uint40 timestamp; // timestamp of the withdrawal request\n        // Amount of oTokens to redeem. eg OETH\n        uint128 amount;\n        // cumulative total of all withdrawal requests including this one.\n        // this request can be claimed when this queued amount is less than or equal to the queue's claimable amount.\n        uint128 queued;\n    }\n\n    /// @notice Mapping of withdrawal request indices to the user withdrawal request data\n    mapping(uint256 => WithdrawalRequest) public withdrawalRequests;\n\n    // For future use\n    uint256[45] private __gap;\n\n    /**\n     * @notice set the implementation for the admin, this needs to be in a base class else we cannot set it\n     * @param newImpl address of the implementation\n     */\n    function setAdminImpl(address newImpl) external onlyGovernor {\n        require(\n            Address.isContract(newImpl),\n            \"new implementation is not a contract\"\n        );\n        bytes32 position = adminImplPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, newImpl)\n        }\n    }\n}\n"
    },
    "contracts/zapper/WOETHCCIPZapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IRouterClient } from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport { Client } from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\n// solhint-disable-next-line  max-line-length\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC4626 } from \"./../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { IOETHZapper } from \"./../interfaces/IOETHZapper.sol\";\n\n/**\n * @title WOETH CCIP Zapper Contract\n * @notice Helps to directly convert ETH on mainnet into WOETH on L2s.\n * @author Origin Protocol Inc\n */\n\ncontract WOETHCCIPZapper {\n    /**\n     * @dev Event emitted when a zap occurs\n     * @param messageId Unique message identifier for each zap\n     * @param sender Address initiating the zap\n     * @param recipient Recipient address at destination chain\n     * @param amount Amount of ETH zapped\n     */\n    event Zap(\n        bytes32 indexed messageId,\n        address sender,\n        address recipient,\n        uint256 amount\n    );\n\n    // @dev Thrown when Zap amount is less than fee.\n    error AmountLessThanFee();\n\n    /**\n     * @dev The destination chain selector\n     */\n    uint64 public immutable destinationChainSelector;\n\n    /**\n     * @dev The WOETH source chain (Mainnet)\n     */\n    IERC4626 public immutable woethOnSourceChain;\n\n    /**\n     * @dev The WOETH destination chain (Arbitrum)\n     */\n    IERC20 public immutable woethOnDestinationChain;\n\n    /**\n     * @dev The OETH zapper contract address\n     */\n    IOETHZapper public immutable oethZapper;\n\n    /**\n     * @dev The CCIP router contract address\n     */\n    IRouterClient public immutable ccipRouter;\n\n    /**\n     * @dev The OETH token contract address\n     */\n    IERC20 public immutable oeth;\n\n    constructor(\n        address _ccipRouter,\n        uint64 _destinationChainSelector,\n        IERC4626 _woethOnSourceChain,\n        IERC20 _woethOnDestinationChain,\n        IOETHZapper _oethZapper,\n        IERC20 _oeth\n    ) {\n        ccipRouter = IRouterClient(_ccipRouter);\n        destinationChainSelector = _destinationChainSelector;\n        woethOnSourceChain = _woethOnSourceChain;\n        woethOnDestinationChain = _woethOnDestinationChain;\n        oethZapper = _oethZapper;\n        oeth = _oeth;\n\n        // Max allowance for Router and WOETH contracts\n        _oeth.approve(address(_woethOnSourceChain), type(uint256).max); // for wrapping\n        _woethOnSourceChain.approve(address(_ccipRouter), type(uint256).max); // for zapping\n    }\n\n    /**\n     * @notice Accepts ETH, zaps for OETH, wraps it for WOETH and sends it to the destination chain (arbitrum)\n     * @param receiver The address of the EOA on the destination chain\n     * @return messageId The ID of the message that was sent\n     */\n    function zap(address receiver)\n        external\n        payable\n        returns (bytes32 messageId)\n    {\n        return _zap(receiver, msg.value);\n    }\n\n    /**\n     * @notice Used to estimate fee for CCIP transaction\n     * @param amount The amount of ETH to be zapped\n     * @param receiver The address of the EOA on the destination chain\n     * @return feeAmount The CCIP tx fee in ETH.\n     */\n\n    function getFee(uint256 amount, address receiver)\n        public\n        view\n        returns (uint256 feeAmount)\n    {\n        Client.EVMTokenAmount[]\n            memory tokenAmounts = new Client.EVMTokenAmount[](1);\n        Client.EVMTokenAmount memory tokenAmount = Client.EVMTokenAmount({\n            token: address(woethOnSourceChain),\n            amount: amount\n        });\n        tokenAmounts[0] = tokenAmount;\n\n        Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({\n            receiver: abi.encode(receiver), // ABI-encoded receiver address\n            data: abi.encode(\"\"),\n            tokenAmounts: tokenAmounts,\n            extraArgs: Client._argsToBytes(\n                Client.EVMExtraArgsV1({ gasLimit: 0 })\n            ),\n            feeToken: address(0)\n        });\n\n        feeAmount = ccipRouter.getFee(destinationChainSelector, message);\n    }\n\n    /**\n     * @dev Deposit ETH and receive WOETH in L2.\n     * @dev Note that the WOETH will be sent to the msg.sender at destination chain as well.\n     */\n    receive() external payable {\n        _zap(msg.sender, msg.value);\n    }\n\n    function _zap(address receiver, uint256 amount)\n        internal\n        returns (bytes32 messageId)\n    {\n        // Estimate fee for zapping.\n        uint256 feeAmount = getFee(amount, receiver);\n        if (amount < feeAmount) {\n            revert AmountLessThanFee();\n        }\n\n        // Convert only the msg.value - fees amount to WOETH.\n        amount -= feeAmount;\n\n        // 1.) Zap for OETH\n        uint256 oethReceived = oethZapper.deposit{ value: amount }();\n\n        // 2.) Wrap the received woeth\n        uint256 woethReceived = woethOnSourceChain.deposit(\n            oethReceived,\n            address(this)\n        );\n\n        // 3.) Setup params for CCIP transfer\n\n        Client.EVMTokenAmount[]\n            memory tokenAmounts = new Client.EVMTokenAmount[](1);\n        Client.EVMTokenAmount memory tokenAmount = Client.EVMTokenAmount({\n            token: address(woethOnSourceChain),\n            amount: woethReceived\n        });\n        tokenAmounts[0] = tokenAmount;\n\n        Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({\n            receiver: abi.encode(receiver), // ABI-encoded receiver address\n            data: abi.encode(\"\"),\n            tokenAmounts: tokenAmounts,\n            extraArgs: Client._argsToBytes(\n                // See: https://docs.chain.link/ccip/best-practices#setting-gaslimit\n                Client.EVMExtraArgsV1({ gasLimit: 0 })\n            ),\n            feeToken: address(0)\n        });\n\n        // ZAP \n        //slither-disable-next-line arbitrary-send-eth\n        messageId = ccipRouter.ccipSend{ value: feeAmount }(\n            destinationChainSelector,\n            message\n        );\n\n        // Emit Zap event with message details\n        emit Zap(messageId, msg.sender, receiver, amount);\n\n        // Return the message ID\n        return messageId;\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "lib/openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC4626 } from \"../../../../interfaces/IERC4626.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n// From Open Zeppelin draft PR commit:\n// fac43034dca85ff539db3fc8aa2a7084b843d454\n// https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3171\n\nabstract contract ERC4626 is ERC20, IERC4626 {\n    IERC20Metadata private immutable _asset;\n\n    constructor(IERC20Metadata __asset) {\n        _asset = __asset;\n    }\n\n    /** @dev See {IERC4262-asset} */\n    function asset() public view virtual override returns (address) {\n        return address(_asset);\n    }\n\n    /** @dev See {IERC4262-totalAssets} */\n    function totalAssets() public view virtual override returns (uint256) {\n        return _asset.balanceOf(address(this));\n    }\n\n    /**\n     * @dev See {IERC4262-convertToShares}\n     *\n     * Will revert if asserts > 0, totalSupply > 0 and totalAssets = 0. That corresponds to a case where any asset\n     * would represent an infinite amout of shares.\n     */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n\n        return\n            (assets == 0 || supply == 0)\n                ? (assets * 10**decimals()) / 10**_asset.decimals()\n                : (assets * supply) / totalAssets();\n    }\n\n    /** @dev See {IERC4262-convertToAssets} */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n\n        return (supply == 0) ? (shares * 10**_asset.decimals()) / 10**decimals() : (shares * totalAssets()) / supply;\n    }\n\n    /** @dev See {IERC4262-maxDeposit} */\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4262-maxMint} */\n    function maxMint(address) public view virtual override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4262-maxWithdraw} */\n    function maxWithdraw(address owner) public view virtual override returns (uint256) {\n        return convertToAssets(balanceOf(owner));\n    }\n\n    /** @dev See {IERC4262-maxRedeem} */\n    function maxRedeem(address owner) public view virtual override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4262-previewDeposit} */\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /** @dev See {IERC4262-previewMint} */\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        uint256 assets = convertToAssets(shares);\n        return assets + (convertToShares(assets) < shares ? 1 : 0);\n    }\n\n    /** @dev See {IERC4262-previewWithdraw} */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        uint256 shares = convertToShares(assets);\n        return shares + (convertToAssets(shares) < assets ? 1 : 0);\n    }\n\n    /** @dev See {IERC4262-previewRedeem} */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /** @dev See {IERC4262-deposit} */\n    function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {\n        require(assets <= maxDeposit(receiver), \"ERC4626: deposit more then max\");\n\n        address caller = _msgSender();\n        uint256 shares = previewDeposit(assets);\n\n        // if _asset is ERC777, transferFrom can call reenter BEFORE the transfer happens through\n        // the tokensToSend hook, so we need to transfer before we mint to keep the invariants.\n        SafeERC20.safeTransferFrom(_asset, caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4262-mint} */\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256) {\n        require(shares <= maxMint(receiver), \"ERC4626: mint more then max\");\n\n        address caller = _msgSender();\n        uint256 assets = previewMint(shares);\n\n        // if _asset is ERC777, transferFrom can call reenter BEFORE the transfer happens through\n        // the tokensToSend hook, so we need to transfer before we mint to keep the invariants.\n        SafeERC20.safeTransferFrom(_asset, caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n\n        return assets;\n    }\n\n    /** @dev See {IERC4262-withdraw} */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(assets <= maxWithdraw(owner), \"ERC4626: withdraw more then max\");\n\n        address caller = _msgSender();\n        uint256 shares = previewWithdraw(assets);\n\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // if _asset is ERC777, transfer can call reenter AFTER the transfer happens through\n        // the tokensReceived hook, so we need to transfer after we burn to keep the invariants.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(_asset, receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4262-redeem} */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(shares <= maxRedeem(owner), \"ERC4626: redeem more then max\");\n\n        address caller = _msgSender();\n        uint256 assets = previewRedeem(shares);\n\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // if _asset is ERC777, transfer can call reenter AFTER the transfer happens through\n        // the tokensReceived hook, so we need to transfer after we burn to keep the invariants.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(_asset, receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    // Included here, since this method was not yet present in\n    // the version of Open Zeppelin ERC20 code we use.\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n}"
    },
    "lib/openzeppelin/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is managed by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}