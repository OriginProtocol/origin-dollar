{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/governance/Governable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Base for contracts that are managed by the Origin Protocol's Governor.\n * @dev Copy of the openzeppelin Ownable.sol contract with nomenclature change\n *      from owner to governor and renounce methods removed. Does not use\n *      Context.sol like Ownable.sol does for simplification.\n * @author Origin Protocol Inc\n */\ncontract Governable {\n    // Storage position of the owner and pendingOwner of the contract\n    // keccak256(\"OUSD.governor\");\n    bytes32 private constant governorPosition =\n        0x7bea13895fa79d2831e0a9e28edede30099005a50d652d8957cf8a607ee6ca4a;\n\n    // keccak256(\"OUSD.pending.governor\");\n    bytes32 private constant pendingGovernorPosition =\n        0x44c4d30b2eaad5130ad70c3ba6972730566f3e6359ab83e800d905c61b1c51db;\n\n    // keccak256(\"OUSD.reentry.status\");\n    bytes32 private constant reentryStatusPosition =\n        0x53bf423e48ed90e97d02ab0ebab13b2a235a6bfbe9c321847d5c175333ac4535;\n\n    // See OpenZeppelin ReentrancyGuard implementation\n    uint256 constant _NOT_ENTERED = 1;\n    uint256 constant _ENTERED = 2;\n\n    event PendingGovernorshipTransfer(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    event GovernorshipTransferred(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial Governor.\n     */\n    constructor() {\n        _setGovernor(msg.sender);\n        emit GovernorshipTransferred(address(0), _governor());\n    }\n\n    /**\n     * @notice Returns the address of the current Governor.\n     */\n    function governor() public view returns (address) {\n        return _governor();\n    }\n\n    /**\n     * @dev Returns the address of the current Governor.\n     */\n    function _governor() internal view returns (address governorOut) {\n        bytes32 position = governorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            governorOut := sload(position)\n        }\n    }\n\n    /**\n     * @dev Returns the address of the pending Governor.\n     */\n    function _pendingGovernor()\n        internal\n        view\n        returns (address pendingGovernor)\n    {\n        bytes32 position = pendingGovernorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            pendingGovernor := sload(position)\n        }\n    }\n\n    /**\n     * @dev Throws if called by any account other than the Governor.\n     */\n    modifier onlyGovernor() {\n        require(isGovernor(), \"Caller is not the Governor\");\n        _;\n    }\n\n    /**\n     * @notice Returns true if the caller is the current Governor.\n     */\n    function isGovernor() public view returns (bool) {\n        return msg.sender == _governor();\n    }\n\n    function _setGovernor(address newGovernor) internal {\n        bytes32 position = governorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, newGovernor)\n        }\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        bytes32 position = reentryStatusPosition;\n        uint256 _reentry_status;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _reentry_status := sload(position)\n        }\n\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_reentry_status != _ENTERED, \"Reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, _ENTERED)\n        }\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, _NOT_ENTERED)\n        }\n    }\n\n    function _setPendingGovernor(address newGovernor) internal {\n        bytes32 position = pendingGovernorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, newGovernor)\n        }\n    }\n\n    /**\n     * @notice Transfers Governance of the contract to a new account (`newGovernor`).\n     * Can only be called by the current Governor. Must be claimed for this to complete\n     * @param _newGovernor Address of the new Governor\n     */\n    function transferGovernance(address _newGovernor) external onlyGovernor {\n        _setPendingGovernor(_newGovernor);\n        emit PendingGovernorshipTransfer(_governor(), _newGovernor);\n    }\n\n    /**\n     * @notice Claim Governance of the contract to a new account (`newGovernor`).\n     * Can only be called by the new Governor.\n     */\n    function claimGovernance() external {\n        require(\n            msg.sender == _pendingGovernor(),\n            \"Only the pending Governor can complete the claim\"\n        );\n        _changeGovernor(msg.sender);\n    }\n\n    /**\n     * @dev Change Governance of the contract to a new account (`newGovernor`).\n     * @param _newGovernor Address of the new Governor\n     */\n    function _changeGovernor(address _newGovernor) internal {\n        require(_newGovernor != address(0), \"New Governor is address(0)\");\n        emit GovernorshipTransferred(_governor(), _newGovernor);\n        _setGovernor(_newGovernor);\n    }\n}\n"
    },
    "contracts/interfaces/aerodrome/ICLGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface ICLGauge {\n    /// @notice Returns the claimable rewards for a given account and tokenId\n    /// @dev Throws if account is not the position owner\n    /// @dev pool.updateRewardsGrowthGlobal() needs to be called first, to return the correct claimable rewards\n    /// @param account The address of the user\n    /// @param tokenId The tokenId of the position\n    /// @return The amount of claimable reward\n    function earned(address account, uint256 tokenId)\n        external\n        view\n        returns (uint256);\n\n    /// @notice Retrieve rewards for all tokens owned by an account\n    /// @dev Throws if not called by the voter\n    /// @param account The account of the user\n    function getReward(address account) external;\n\n    /// @notice Retrieve rewards for a tokenId\n    /// @dev Throws if not called by the position owner\n    /// @param tokenId The tokenId of the position\n    function getReward(uint256 tokenId) external;\n\n    /// @notice Notifies gauge of gauge rewards.\n    /// @param amount Amount of gauge rewards (emissions) to notify. Must be greater than 604_800.\n    function notifyRewardAmount(uint256 amount) external;\n\n    /// @dev Notifies gauge of gauge rewards without distributing its fees.\n    ///      Assumes gauge reward tokens is 18 decimals.\n    ///      If not 18 decimals, rewardRate may have rounding issues.\n    /// @param amount Amount of gauge rewards (emissions) to notify. Must be greater than 604_800.\n    function notifyRewardWithoutClaim(uint256 amount) external;\n\n    /// @notice Used to deposit a CL position into the gauge\n    /// @notice Allows the user to receive emissions instead of fees\n    /// @param tokenId The tokenId of the position\n    function deposit(uint256 tokenId) external;\n\n    /// @notice Used to withdraw a CL position from the gauge\n    /// @notice Allows the user to receive fees instead of emissions\n    /// @notice Outstanding emissions will be collected on withdrawal\n    /// @param tokenId The tokenId of the position\n    function withdraw(uint256 tokenId) external;\n\n    // /// @notice Fetch all tokenIds staked by a given account\n    // /// @param depositor The address of the user\n    // /// @return The tokenIds of the staked positions\n    // function stakedValues(address depositor) external view returns (uint256[] memory);\n\n    // /// @notice Fetch a staked tokenId by index\n    // /// @param depositor The address of the user\n    // /// @param index The index of the staked tokenId\n    // /// @return The tokenId of the staked position\n    // function stakedByIndex(address depositor, uint256 index) external view returns (uint256);\n\n    // /// @notice Check whether a position is staked in the gauge by a certain user\n    // /// @param depositor The address of the user\n    // /// @param tokenId The tokenId of the position\n    // /// @return Whether the position is staked in the gauge\n    // function stakedContains(address depositor, uint256 tokenId) external view returns (bool);\n\n    // /// @notice The amount of positions staked in the gauge by a certain user\n    // /// @param depositor The address of the user\n    // /// @return The amount of positions staked in the gauge\n    // function stakedLength(address depositor) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/aerodrome/ICLPool.sol": {
      "content": "pragma solidity >=0.5.0;\n\n/// @title The interface for a CL Pool\n/// @notice A CL pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface ICLPool {\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            bool unlocked\n        );\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The gauge corresponding to this pool\n    /// @return The gauge contract address\n    function gauge() external view returns (address);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    /// @dev This value includes staked liquidity\n    function liquidity() external view returns (uint128);\n}\n"
    },
    "contracts/interfaces/aerodrome/INonfungiblePositionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Non-fungible token for positions\n/// @notice Wraps CL positions in a non-fungible token interface which allows for them to be transferred\n/// and authorized.\n// slither-disable-start erc20-interface\ninterface INonfungiblePositionManager {\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) external returns (address);\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    /// @notice Returns the position information associated with a given token ID.\n    /// @dev Throws if the token ID is not valid.\n    /// @param tokenId The ID of the token that represents the position\n    /// @return nonce The nonce for permits\n    /// @return operator The address that is approved for spending\n    /// @return token0 The address of the token0 for a specific pool\n    /// @return token1 The address of the token1 for a specific pool\n    /// @return tickSpacing The tick spacing associated with the pool\n    /// @return tickLower The lower end of the tick range for the position\n    /// @return tickUpper The higher end of the tick range for the position\n    /// @return liquidity The liquidity of the position\n    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\n    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\n    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\n    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            int24 tickSpacing,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    struct MintParams {\n        address token0;\n        address token1;\n        int24 tickSpacing;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n        uint160 sqrtPriceX96;\n    }\n\n    /// @notice Creates a new position wrapped in a NFT\n    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\n    /// a method does not exist, i.e. the pool is assumed to be initialized.\n    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\n    /// @return tokenId The ID of the token that represents the minted position\n    /// @return liquidity The amount of liquidity for this position\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function mint(MintParams calldata params)\n        external\n        payable\n        returns (\n            uint256 tokenId,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\n    /// @param params tokenId The ID of the token for which liquidity is being increased,\n    /// amount0Desired The desired amount of token0 to be spent,\n    /// amount1Desired The desired amount of token1 to be spent,\n    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\n    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return liquidity The new liquidity amount as a result of the increase\n    /// @return amount0 The amount of token0 to acheive resulting liquidity\n    /// @return amount1 The amount of token1 to acheive resulting liquidity\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Decreases the amount of liquidity in a position and accounts it to the position\n    /// @param params tokenId The ID of the token for which liquidity is being decreased,\n    /// amount The amount by which liquidity will be decreased,\n    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\n    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return amount0 The amount of token0 accounted to the position's tokens owed\n    /// @return amount1 The amount of token1 accounted to the position's tokens owed\n    /// @dev The use of this function can cause a loss to users of the NonfungiblePositionManager\n    /// @dev for tokens that have very high decimals.\n    /// @dev The amount of tokens necessary for the loss is: 3.4028237e+38.\n    /// @dev This is equivalent to 1e20 value with 18 decimals.\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\n    /// @notice Used to update staked positions before deposit and withdraw\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\n    /// recipient The account that should receive the tokens,\n    /// amount0Max The maximum amount of token0 to collect,\n    /// amount1Max The maximum amount of token1 to collect\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(CollectParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\n    /// must be collected first.\n    /// @param tokenId The ID of the token that is being burned\n    function burn(uint256 tokenId) external payable;\n\n    /// @notice Sets a new Token Descriptor\n    /// @param _tokenDescriptor Address of the new Token Descriptor to be chosen\n    function setTokenDescriptor(address _tokenDescriptor) external;\n\n    /// @notice Sets a new Owner address\n    /// @param _owner Address of the new Owner to be chosen\n    function setOwner(address _owner) external;\n}\n// slither-disable-end erc20-interface\n"
    },
    "contracts/interfaces/aerodrome/IQuoterV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title QuoterV2 Interface\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps.\n/// @notice For each pool also tells you the number of initialized ticks crossed and the sqrt price of the\n///         pool after the swap.\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\ninterface IQuoterV2 {\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool tick spacing\n    /// @param amountIn The amount of the first token to swap\n    /// @return amountOut The amount of the last token that would be received\n    /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\n    /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for\n    ///         each pool in the path\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactInput(bytes memory path, uint256 amountIn)\n        external\n        returns (\n            uint256 amountOut,\n            uint160[] memory sqrtPriceX96AfterList,\n            uint32[] memory initializedTicksCrossedList,\n            uint256 gasEstimate\n        );\n\n    struct QuoteExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        int24 tickSpacing;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n    /// @param params The params for the quote, encoded as `QuoteExactInputSingleParams`\n    /// tokenIn The token being swapped in\n    /// tokenOut The token being swapped out\n    /// tickSpacing The tick spacing of the token pool to consider for the pair\n    /// amountIn The desired input amount\n    /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountOut The amount of `tokenOut` that would be received\n    /// @return sqrtPriceX96After The sqrt price of the pool after the swap\n    /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactInputSingle(QuoteExactInputSingleParams memory params)\n        external\n        returns (\n            uint256 amountOut,\n            uint160 sqrtPriceX96After,\n            uint32 initializedTicksCrossed,\n            uint256 gasEstimate\n        );\n\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool tick spacing.\n    ///        Path must be provided in reverse order\n    /// @param amountOut The amount of the last token to receive\n    /// @return amountIn The amount of first token required to be paid\n    /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\n    /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for\n    ///         each pool in the path\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactOutput(bytes memory path, uint256 amountOut)\n        external\n        returns (\n            uint256 amountIn,\n            uint160[] memory sqrtPriceX96AfterList,\n            uint32[] memory initializedTicksCrossedList,\n            uint256 gasEstimate\n        );\n\n    struct QuoteExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amount;\n        int24 tickSpacing;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\n    /// @param params The params for the quote, encoded as `QuoteExactOutputSingleParams`\n    /// tokenIn The token being swapped in\n    /// tokenOut The token being swapped out\n    /// tickSpacing The tick spacing of the token pool to consider for the pair\n    /// amountOut The desired output amount\n    /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\n    /// @return sqrtPriceX96After The sqrt price of the pool after the swap\n    /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactOutputSingle(QuoteExactOutputSingleParams memory params)\n        external\n        returns (\n            uint256 amountIn,\n            uint160 sqrtPriceX96After,\n            uint32 initializedTicksCrossed,\n            uint256 gasEstimate\n        );\n}\n"
    },
    "contracts/interfaces/aerodrome/ISugarHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\npragma abicoder v2;\n\nimport { INonfungiblePositionManager } from \"./INonfungiblePositionManager.sol\";\n\ninterface ISugarHelper {\n    struct PopulatedTick {\n        int24 tick;\n        uint160 sqrtRatioX96;\n        int128 liquidityNet;\n        uint128 liquidityGross;\n    }\n\n    ///\n    /// Wrappers for LiquidityAmounts\n    ///\n\n    function getAmountsForLiquidity(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) external pure returns (uint256 amount0, uint256 amount1);\n\n    function getLiquidityForAmounts(\n        uint256 amount0,\n        uint256 amount1,\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96\n    ) external pure returns (uint256 liquidity);\n\n    /// @notice Computes the amount of token0 for a given amount of token1 and price range\n    /// @param amount1 Amount of token1 to estimate liquidity\n    /// @param pool Address of the pool to be used\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param tickLow Lower tick boundary\n    /// @param tickLow Upper tick boundary\n    /// @dev   If the given pool address is not the zero address, will fetch `sqrtRatioX96` from pool\n    /// @return amount0 Estimated amount of token0\n    function estimateAmount0(\n        uint256 amount1,\n        address pool,\n        uint160 sqrtRatioX96,\n        int24 tickLow,\n        int24 tickHigh\n    ) external view returns (uint256 amount0);\n\n    /// @notice Computes the amount of token1 for a given amount of token0 and price range\n    /// @param amount0 Amount of token0 to estimate liquidity\n    /// @param pool Address of the pool to be used\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param tickLow Lower tick boundary\n    /// @param tickLow Upper tick boundary\n    /// @dev   If the given pool address is not the zero address, will fetch `sqrtRatioX96` from pool\n    /// @return amount1 Estimated amount of token1\n    function estimateAmount1(\n        uint256 amount0,\n        address pool,\n        uint160 sqrtRatioX96,\n        int24 tickLow,\n        int24 tickHigh\n    ) external view returns (uint256 amount1);\n\n    ///\n    /// Wrappers for PositionValue\n    ///\n\n    function principal(\n        INonfungiblePositionManager positionManager,\n        uint256 tokenId,\n        uint160 sqrtRatioX96\n    ) external view returns (uint256 amount0, uint256 amount1);\n\n    function fees(INonfungiblePositionManager positionManager, uint256 tokenId)\n        external\n        view\n        returns (uint256 amount0, uint256 amount1);\n\n    ///\n    /// Wrappers for TickMath\n    ///\n\n    function getSqrtRatioAtTick(int24 tick)\n        external\n        pure\n        returns (uint160 sqrtRatioX96);\n\n    function getTickAtSqrtRatio(uint160 sqrtRatioX96)\n        external\n        pure\n        returns (int24 tick);\n\n    /// @notice Fetches Tick Data for all populated Ticks in given bitmaps\n    /// @param pool Address of the pool from which to fetch data\n    /// @param startTick Tick from which the first bitmap will be fetched\n    /// @dev   The number of bitmaps fetched by this function should always be `MAX_BITMAPS`,\n    ///        unless there are less than `MAX_BITMAPS` left to iterate through\n    /// @return populatedTicks Array of all Populated Ticks in the provided bitmaps\n    function getPopulatedTicks(address pool, int24 startTick)\n        external\n        view\n        returns (PopulatedTick[] memory populatedTicks);\n}\n"
    },
    "contracts/interfaces/aerodrome/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via CL\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        int24 tickSpacing;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        int24 tickSpacing;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params)\n        external\n        payable\n        returns (uint256 amountIn);\n}\n"
    },
    "contracts/interfaces/IBasicToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBasicToken {\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IDripper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IDripper {\n    /// @notice How much funds have dripped out already and are currently\n    //   available to be sent to the vault.\n    /// @return The amount that would be sent if a collect was called\n    function availableFunds() external view returns (uint256);\n\n    /// @notice Collect all dripped funds and send to vault.\n    ///  Recalculate new drip rate.\n    function collect() external;\n\n    /// @notice Collect all dripped funds, send to vault, recalculate new drip\n    ///  rate, and rebase mToken.\n    function collectAndRebase() external;\n\n    /// @notice Change the drip duration. Governor only.\n    /// @param _durationSeconds the number of seconds to drip out the entire\n    ///  balance over if no collects were called during that time.\n    function setDripDuration(uint256 _durationSeconds) external;\n\n    /// @dev Transfer out ERC20 tokens held by the contract. Governor only.\n    /// @param _asset ERC20 token address\n    /// @param _amount amount to transfer\n    function transferToken(address _asset, uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/IGetExchangeRateToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IGetExchangeRateToken {\n    function getExchangeRate() external view returns (uint256 _exchangeRate);\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOracle {\n    /**\n     * @dev returns the asset price in USD, in 8 decimal digits.\n     *\n     * The version of priceProvider deployed for OETH has 18 decimal digits\n     */\n    function price(address asset) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Platform interface to integrate with lending platform like Compound, AAVE etc.\n */\ninterface IStrategy {\n    /**\n     * @dev Deposit the given asset to platform\n     * @param _asset asset address\n     * @param _amount Amount to deposit\n     */\n    function deposit(address _asset, uint256 _amount) external;\n\n    /**\n     * @dev Deposit the entire balance of all supported assets in the Strategy\n     *      to the platform\n     */\n    function depositAll() external;\n\n    /**\n     * @dev Withdraw given asset from Lending platform\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external;\n\n    /**\n     * @dev Liquidate all assets in strategy and return them to Vault.\n     */\n    function withdrawAll() external;\n\n    /**\n     * @dev Returns the current balance of the given asset.\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        returns (uint256 balance);\n\n    /**\n     * @dev Returns bool indicating whether strategy supports asset.\n     */\n    function supportsAsset(address _asset) external view returns (bool);\n\n    /**\n     * @dev Collect reward tokens from the Strategy.\n     */\n    function collectRewardTokens() external;\n\n    /**\n     * @dev The address array of the reward tokens for the Strategy.\n     */\n    function getRewardTokenAddresses() external view returns (address[] memory);\n}\n"
    },
    "contracts/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { VaultStorage } from \"../vault/VaultStorage.sol\";\n\ninterface IVault {\n    event AssetSupported(address _asset);\n    event AssetDefaultStrategyUpdated(address _asset, address _strategy);\n    event AssetAllocated(address _asset, address _strategy, uint256 _amount);\n    event StrategyApproved(address _addr);\n    event StrategyRemoved(address _addr);\n    event Mint(address _addr, uint256 _value);\n    event Redeem(address _addr, uint256 _value);\n    event CapitalPaused();\n    event CapitalUnpaused();\n    event RebasePaused();\n    event RebaseUnpaused();\n    event VaultBufferUpdated(uint256 _vaultBuffer);\n    event RedeemFeeUpdated(uint256 _redeemFeeBps);\n    event PriceProviderUpdated(address _priceProvider);\n    event AllocateThresholdUpdated(uint256 _threshold);\n    event RebaseThresholdUpdated(uint256 _threshold);\n    event StrategistUpdated(address _address);\n    event MaxSupplyDiffChanged(uint256 maxSupplyDiff);\n    event YieldDistribution(address _to, uint256 _yield, uint256 _fee);\n    event TrusteeFeeBpsChanged(uint256 _basis);\n    event TrusteeAddressChanged(address _address);\n    event SwapperChanged(address _address);\n    event SwapAllowedUndervalueChanged(uint256 _basis);\n    event SwapSlippageChanged(address _asset, uint256 _basis);\n    event Swapped(\n        address indexed _fromAsset,\n        address indexed _toAsset,\n        uint256 _fromAssetAmount,\n        uint256 _toAssetAmount\n    );\n    event StrategyAddedToMintWhitelist(address indexed strategy);\n    event StrategyRemovedFromMintWhitelist(address indexed strategy);\n    event DripperChanged(address indexed _dripper);\n    event WithdrawalRequested(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount,\n        uint256 _queued\n    );\n    event WithdrawalClaimed(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount\n    );\n    event WithdrawalClaimable(uint256 _claimable, uint256 _newClaimable);\n\n    // Governable.sol\n    function transferGovernance(address _newGovernor) external;\n\n    function claimGovernance() external;\n\n    function governor() external view returns (address);\n\n    // VaultAdmin.sol\n    function setPriceProvider(address _priceProvider) external;\n\n    function priceProvider() external view returns (address);\n\n    function setRedeemFeeBps(uint256 _redeemFeeBps) external;\n\n    function redeemFeeBps() external view returns (uint256);\n\n    function setVaultBuffer(uint256 _vaultBuffer) external;\n\n    function vaultBuffer() external view returns (uint256);\n\n    function setAutoAllocateThreshold(uint256 _threshold) external;\n\n    function autoAllocateThreshold() external view returns (uint256);\n\n    function setRebaseThreshold(uint256 _threshold) external;\n\n    function rebaseThreshold() external view returns (uint256);\n\n    function setStrategistAddr(address _address) external;\n\n    function strategistAddr() external view returns (address);\n\n    function setMaxSupplyDiff(uint256 _maxSupplyDiff) external;\n\n    function maxSupplyDiff() external view returns (uint256);\n\n    function setTrusteeAddress(address _address) external;\n\n    function trusteeAddress() external view returns (address);\n\n    function setTrusteeFeeBps(uint256 _basis) external;\n\n    function trusteeFeeBps() external view returns (uint256);\n\n    function ousdMetaStrategy() external view returns (address);\n\n    function setSwapper(address _swapperAddr) external;\n\n    function setSwapAllowedUndervalue(uint16 _percentageBps) external;\n\n    function setOracleSlippage(address _asset, uint16 _allowedOracleSlippageBps)\n        external;\n\n    function supportAsset(address _asset, uint8 _supportsAsset) external;\n\n    function approveStrategy(address _addr) external;\n\n    function removeStrategy(address _addr) external;\n\n    function setAssetDefaultStrategy(address _asset, address _strategy)\n        external;\n\n    function assetDefaultStrategies(address _asset)\n        external\n        view\n        returns (address);\n\n    function pauseRebase() external;\n\n    function unpauseRebase() external;\n\n    function rebasePaused() external view returns (bool);\n\n    function pauseCapital() external;\n\n    function unpauseCapital() external;\n\n    function capitalPaused() external view returns (bool);\n\n    function transferToken(address _asset, uint256 _amount) external;\n\n    function priceUnitMint(address asset) external view returns (uint256);\n\n    function priceUnitRedeem(address asset) external view returns (uint256);\n\n    function withdrawAllFromStrategy(address _strategyAddr) external;\n\n    function withdrawAllFromStrategies() external;\n\n    function withdrawFromStrategy(\n        address _strategyFromAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external;\n\n    function depositToStrategy(\n        address _strategyToAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external;\n\n    // VaultCore.sol\n    function mint(\n        address _asset,\n        uint256 _amount,\n        uint256 _minimumOusdAmount\n    ) external;\n\n    function mintForStrategy(uint256 _amount) external;\n\n    function redeem(uint256 _amount, uint256 _minimumUnitAmount) external;\n\n    function burnForStrategy(uint256 _amount) external;\n\n    function redeemAll(uint256 _minimumUnitAmount) external;\n\n    function allocate() external;\n\n    function rebase() external;\n\n    function swapCollateral(\n        address fromAsset,\n        address toAsset,\n        uint256 fromAssetAmount,\n        uint256 minToAssetAmount,\n        bytes calldata data\n    ) external returns (uint256 toAssetAmount);\n\n    function totalValue() external view returns (uint256 value);\n\n    function checkBalance(address _asset) external view returns (uint256);\n\n    function calculateRedeemOutputs(uint256 _amount)\n        external\n        view\n        returns (uint256[] memory);\n\n    function getAssetCount() external view returns (uint256);\n\n    function getAssetConfig(address _asset)\n        external\n        view\n        returns (VaultStorage.Asset memory config);\n\n    function getAllAssets() external view returns (address[] memory);\n\n    function getStrategyCount() external view returns (uint256);\n\n    function swapper() external view returns (address);\n\n    function allowedSwapUndervalue() external view returns (uint256);\n\n    function getAllStrategies() external view returns (address[] memory);\n\n    function isSupportedAsset(address _asset) external view returns (bool);\n\n    function netOusdMintForStrategyThreshold() external view returns (uint256);\n\n    function setOusdMetaStrategy(address _ousdMetaStrategy) external;\n\n    function setNetOusdMintForStrategyThreshold(uint256 _threshold) external;\n\n    function netOusdMintedForStrategy() external view returns (int256);\n\n    function setDripper(address _dripper) external;\n\n    function weth() external view returns (address);\n\n    function cacheWETHAssetIndex() external;\n\n    function wethAssetIndex() external view returns (uint256);\n\n    function initialize(address, address) external;\n\n    function setAdminImpl(address) external;\n\n    function removeAsset(address _asset) external;\n\n    // These are OETH specific functions\n    function addWithdrawalQueueLiquidity() external;\n\n    function requestWithdrawal(uint256 _amount)\n        external\n        returns (uint256 requestId, uint256 queued);\n\n    function claimWithdrawal(uint256 requestId)\n        external\n        returns (uint256 amount);\n\n    function claimWithdrawals(uint256[] memory requestIds)\n        external\n        returns (uint256[] memory amounts, uint256 totalAmount);\n\n    function withdrawalQueueMetadata()\n        external\n        view\n        returns (VaultStorage.WithdrawalQueueMetadata memory);\n\n    function withdrawalRequests(uint256 requestId)\n        external\n        view\n        returns (VaultStorage.WithdrawalRequest memory);\n\n    // OETHb specific functions\n    function addStrategyToMintWhitelist(address strategyAddr) external;\n\n    function removeStrategyFromMintWhitelist(address strategyAddr) external;\n\n    function isMintWhitelistedStrategy(address strategyAddr)\n        external\n        view\n        returns (bool);\n}\n"
    },
    "contracts/interfaces/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWETH9 {\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    function allowance(address, address) external view returns (uint256);\n\n    function approve(address guy, uint256 wad) external returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function deposit() external payable;\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address dst, uint256 wad) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function withdraw(uint256 wad) external;\n}\n"
    },
    "contracts/mocks/MintableERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IMintableERC20 {\n    function mint(uint256 value) external;\n\n    function mintTo(address to, uint256 value) external;\n}\n\n/**\n * @title MintableERC20\n * @dev Exposes the mint function of ERC20 for tests\n */\nabstract contract MintableERC20 is IMintableERC20, ERC20 {\n    /**\n     * @dev Function to mint tokens\n     * @param _value The amount of tokens to mint.\n     */\n    function mint(uint256 _value) public virtual override {\n        _mint(msg.sender, _value);\n    }\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to Address to mint to.\n     * @param _value The amount of tokens to mint.\n     */\n    function mintTo(address _to, uint256 _value) public virtual override {\n        _mint(_to, _value);\n    }\n}\n"
    },
    "contracts/mocks/MockAero.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockAero is MintableERC20 {\n    constructor() ERC20(\"Aerodrome\", \"AERO\") {}\n\n    function deposit() external payable {\n        _mint(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) external {\n        _burn(msg.sender, wad);\n        payable(msg.sender).transfer(wad);\n    }\n}\n"
    },
    "contracts/mocks/MockOETHVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { OETHVaultCore } from \"../vault/OETHVaultCore.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport \"../utils/Helpers.sol\";\n\ncontract MockOETHVault is OETHVaultCore {\n    using StableMath for uint256;\n\n    constructor(address _weth) OETHVaultCore(_weth) {}\n\n    function supportAsset(address asset) external {\n        assets[asset] = Asset({\n            isSupported: true,\n            unitConversion: UnitConversion(0),\n            decimals: 18,\n            allowedOracleSlippageBps: 0\n        });\n\n        allAssets.push(asset);\n    }\n}\n"
    },
    "contracts/proxies/InitializeGovernedUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { Governable } from \"../governance/Governable.sol\";\n\n/**\n * @title BaseGovernedUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with our governor system.\n * It is based on an older version of OpenZeppelins BaseUpgradeabilityProxy\n * with Solidity ^0.8.0.\n * @author Origin Protocol Inc\n */\ncontract InitializeGovernedUpgradeabilityProxy is Governable {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     * @param implementation Address of the new implementation.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Contract initializer with Governor enforcement\n     * @param _logic Address of the initial implementation.\n     * @param _initGovernor Address of the initial Governor.\n     * @param _data Data to send as msg.data to the implementation to initialize\n     * the proxied contract.\n     * It should include the signature and the parameters of the function to be\n     * called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     * This parameter is optional, if no data is given the initialization call\n     * to proxied contract will be skipped.\n     */\n    function initialize(\n        address _logic,\n        address _initGovernor,\n        bytes calldata _data\n    ) public payable onlyGovernor {\n        require(_implementation() == address(0));\n        require(_logic != address(0), \"Implementation not set\");\n        assert(\n            IMPLEMENTATION_SLOT ==\n                bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1)\n        );\n        _setImplementation(_logic);\n        if (_data.length > 0) {\n            (bool success, ) = _logic.delegatecall(_data);\n            require(success);\n        }\n        _changeGovernor(_initGovernor);\n    }\n\n    /**\n     * @return The address of the proxy admin/it's also the governor.\n     */\n    function admin() external view returns (address) {\n        return _governor();\n    }\n\n    /**\n     * @return The address of the implementation.\n     */\n    function implementation() external view returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @dev Upgrade the backing implementation of the proxy.\n     * Only the admin can call this function.\n     * @param _newImplementation Address of the new implementation.\n     */\n    function upgradeTo(address _newImplementation) external onlyGovernor {\n        _upgradeTo(_newImplementation);\n    }\n\n    /**\n     * @dev Upgrade the backing implementation of the proxy and call a function\n     * on the new implementation.\n     * This is useful to initialize the proxied contract.\n     * @param newImplementation Address of the new implementation.\n     * @param data Data to send as msg.data in the low level call.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\n        external\n        payable\n        onlyGovernor\n    {\n        _upgradeTo(newImplementation);\n        (bool success, ) = newImplementation.delegatecall(data);\n        require(success);\n    }\n\n    /**\n     * @dev Fallback function.\n     * Implemented entirely in `_fallback`.\n     */\n    fallback() external payable {\n        _fallback();\n    }\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * This is a low level function that doesn't return to its internal call site.\n     * It will return to the external caller whatever the implementation returns.\n     * @param _impl Address to delegate.\n     */\n    function _delegate(address _impl) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev Function that is run as the first thing in the fallback function.\n     * Can be redefined in derived contracts to add functionality.\n     * Redefinitions must call super._willFallback().\n     */\n    function _willFallback() internal {}\n\n    /**\n     * @dev fallback implementation.\n     * Extracted to enable manual triggering.\n     */\n    function _fallback() internal {\n        _willFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation.\n     * @return impl Address of the current implementation\n     */\n    function _implementation() internal view returns (address impl) {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Upgrades the proxy to a new implementation.\n     * @param newImplementation Address of the new implementation.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation address of the proxy.\n     * @param newImplementation Address of the new implementation.\n     */\n    function _setImplementation(address newImplementation) internal {\n        require(\n            Address.isContract(newImplementation),\n            \"Cannot set a proxy implementation to a non-contract address\"\n        );\n\n        bytes32 slot = IMPLEMENTATION_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n}\n"
    },
    "contracts/proxies/Proxies.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { InitializeGovernedUpgradeabilityProxy } from \"./InitializeGovernedUpgradeabilityProxy.sol\";\n\n/**\n * @notice OUSDProxy delegates calls to an OUSD implementation\n */\ncontract OUSDProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice WrappedOUSDProxy delegates calls to a WrappedOUSD implementation\n */\ncontract WrappedOUSDProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice VaultProxy delegates calls to a Vault implementation\n */\ncontract VaultProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice CompoundStrategyProxy delegates calls to a CompoundStrategy implementation\n */\ncontract CompoundStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice AaveStrategyProxy delegates calls to a AaveStrategy implementation\n */\ncontract AaveStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice ThreePoolStrategyProxy delegates calls to a ThreePoolStrategy implementation\n */\ncontract ThreePoolStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice ConvexStrategyProxy delegates calls to a ConvexStrategy implementation\n */\ncontract ConvexStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice HarvesterProxy delegates calls to a Harvester implementation\n */\ncontract HarvesterProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice DripperProxy delegates calls to a Dripper implementation\n */\ncontract DripperProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice MorphoCompoundStrategyProxy delegates calls to a MorphoCompoundStrategy implementation\n */\ncontract MorphoCompoundStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice ConvexOUSDMetaStrategyProxy delegates calls to a ConvexOUSDMetaStrategy implementation\n */\ncontract ConvexOUSDMetaStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice ConvexLUSDMetaStrategyProxy delegates calls to a ConvexalGeneralizedMetaStrategy implementation\n */\ncontract ConvexLUSDMetaStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice MorphoAaveStrategyProxy delegates calls to a MorphoCompoundStrategy implementation\n */\ncontract MorphoAaveStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHProxy delegates calls to nowhere for now\n */\ncontract OETHProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice WOETHProxy delegates calls to nowhere for now\n */\ncontract WOETHProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHVaultProxy delegates calls to a Vault implementation\n */\ncontract OETHVaultProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHDripperProxy delegates calls to a OETHDripper implementation\n */\ncontract OETHDripperProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHHarvesterProxy delegates calls to a Harvester implementation\n */\ncontract OETHHarvesterProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice FraxETHStrategyProxy delegates calls to a FraxETHStrategy implementation\n */\ncontract FraxETHStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice CurveEthStrategyProxy delegates calls to a CurveEthStrategy implementation\n */\ncontract ConvexEthMetaStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice BuybackProxy delegates calls to Buyback implementation\n */\ncontract BuybackProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHMorphoAaveStrategyProxy delegates calls to a MorphoAaveStrategy implementation\n */\ncontract OETHMorphoAaveStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHBalancerMetaPoolrEthStrategyProxy delegates calls to a BalancerMetaPoolStrategy implementation\n */\ncontract OETHBalancerMetaPoolrEthStrategyProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice OETHBalancerMetaPoolwstEthStrategyProxy delegates calls to a BalancerMetaPoolStrategy implementation\n */\ncontract OETHBalancerMetaPoolwstEthStrategyProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice FluxStrategyProxy delegates calls to a CompoundStrategy implementation\n */\ncontract FluxStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice MakerDsrStrategyProxy delegates calls to a Generalized4626Strategy implementation\n */\ncontract MakerDsrStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice FrxEthRedeemStrategyProxy delegates calls to a FrxEthRedeemStrategy implementation\n */\ncontract FrxEthRedeemStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHBuybackProxy delegates calls to Buyback implementation\n */\ncontract OETHBuybackProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice BridgedWOETHProxy delegates calls to BridgedWOETH implementation\n */\ncontract BridgedWOETHProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice NativeStakingSSVStrategyProxy delegates calls to NativeStakingSSVStrategy implementation\n */\ncontract NativeStakingSSVStrategyProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice NativeStakingFeeAccumulatorProxy delegates calls to FeeAccumulator implementation\n */\ncontract NativeStakingFeeAccumulatorProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice NativeStakingSSVStrategy2Proxy delegates calls to NativeStakingSSVStrategy implementation\n */\ncontract NativeStakingSSVStrategy2Proxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice NativeStakingFeeAccumulator2Proxy delegates calls to FeeAccumulator implementation\n */\ncontract NativeStakingFeeAccumulator2Proxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice LidoWithdrawalStrategyProxy delegates calls to a LidoWithdrawalStrategy implementation\n */\ncontract LidoWithdrawalStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice BridgedBaseWOETHProxy delegates calls to BridgedWOETH implementation\n */\ncontract BridgedBaseWOETHProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHBaseVaultProxy delegates calls to OETHBaseVault implementation\n */\ncontract OETHBaseVaultProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHBaseProxy delegates calls to OETH implementation\n */\ncontract OETHBaseProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice WOETHBaseProxy delegates calls to WOETH implementation\n */\ncontract WOETHBaseProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHBaseDripperProxy delegates calls to a OETHDripper implementation\n */\ncontract OETHBaseDripperProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice AerodromeAMOStrategyProxy delegates calls to AerodromeAMOStrategy implementation\n */\ncontract AerodromeAMOStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice BridgedWOETHStrategyProxy delegates calls to BridgedWOETHStrategy implementation\n */\ncontract BridgedWOETHStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n"
    },
    "contracts/strategies/aerodrome/AerodromeAMOStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Aerodrome AMO strategy\n * @author Origin Protocol Inc\n */\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { IERC20, InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\n\nimport { ISugarHelper } from \"../../interfaces/aerodrome/ISugarHelper.sol\";\nimport { INonfungiblePositionManager } from \"../../interfaces/aerodrome/INonfungiblePositionManager.sol\";\nimport { ISwapRouter } from \"../../interfaces/aerodrome/ISwapRouter.sol\";\nimport { ICLPool } from \"../../interfaces/aerodrome/ICLPool.sol\";\nimport { ICLGauge } from \"../../interfaces/aerodrome/ICLGauge.sol\";\nimport { IVault } from \"../../interfaces/IVault.sol\";\n\ncontract AerodromeAMOStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    /************************************************\n            Important (!) setup configuration\n    *************************************************/\n\n    /**\n     * In order to be able to remove a reasonable amount of complexity from the contract one of the\n     * preconditions for this contract to function correctly is to have an outside account mint a small\n     * amount of liquidity in the tick space where the contract will deploy's its liquidity and then send\n     * that NFT LP position to a dead address (transfer to zero address not allowed.) See example of such\n     * NFT LP token:\n     * https://basescan.org/token/0x827922686190790b37229fd06084350e74485b72?a=413296#inventory\n     */\n\n    /***************************************\n            Storage slot members\n    ****************************************/\n\n    /// @notice tokenId of the liquidity position\n    uint256 public tokenId;\n    /// @dev Minimum amount of tokens the strategy would be able to withdraw from the pool.\n    ///      minimum amount of tokens are withdrawn at a 1:1 price\n    uint256 public underlyingAssets;\n    /// @notice Marks the start of the interval that defines the allowed range of WETH share in\n    /// the pre-configured pool's liquidity ticker\n    uint256 public allowedWethShareStart;\n    /// @notice Marks the end of the interval that defines the allowed range of WETH share in\n    /// the pre-configured pool's liquidity ticker\n    uint256 public allowedWethShareEnd;\n    /// @dev reserved for inheritance\n    int256[46] private __reserved;\n\n    /***************************************\n          Constants, structs and events\n    ****************************************/\n\n    /// @notice The address of the Wrapped ETH (WETH) token contract\n    address public immutable WETH;\n    /// @notice The address of the OETHb token contract\n    address public immutable OETHb;\n    /// @notice lower tick set to -1 representing the price of 1.0001 of WETH for 1 OETHb.\n    int24 public immutable lowerTick;\n    /// @notice lower tick set to 0 representing the price of 1.0000 of WETH for 1 OETHb.\n    int24 public immutable upperTick;\n    /// @notice tick spacing of the pool (set to 1)\n    int24 public immutable tickSpacing;\n    /// @notice the swapRouter for performing swaps\n    ISwapRouter public immutable swapRouter;\n    /// @notice the underlying AMO Slipstream pool\n    ICLPool public immutable clPool;\n    /// @notice the gauge for the corresponding Slipstream pool (clPool)\n    /// @dev can become an immutable once the gauge is created on the base main-net\n    ICLGauge public immutable clGauge;\n    /// @notice the Position manager contract that is used to manage the pool's position\n    INonfungiblePositionManager public immutable positionManager;\n    /// @notice helper contract for liquidity and ticker math\n    ISugarHelper public immutable helper;\n    /// @notice sqrtRatioX96TickLower\n    /// @dev tick lower has value -1 and represents the lowest price of WETH priced in OETHb. Meaning the pool\n    /// offers less than 1 OETHb for 1 WETH. In other terms to get 1 OETHB the swap needs to offer 1.0001 WETH\n    /// this is where purchasing OETHb with WETH within the liquidity position is most expensive\n    uint160 public immutable sqrtRatioX96TickLower;\n    /// @notice sqrtRatioX96TickHigher\n    /// @dev tick higher has value 0 and represents 1:1 price parity of WETH to OETHb\n    uint160 public immutable sqrtRatioX96TickHigher;\n    /// @dev tick closest to 1:1 price parity\n    ///      Correctly assessing which tick is closer to 1:1 price parity is important since it affects\n    ///      the way we calculate the underlying assets in check Balance. The underlying aerodrome pool\n    ///      orders the tokens depending on the values of their addresses. If OETH token is token0 in the pool\n    ///      then sqrtRatioX96TickClosestToParity=sqrtRatioX96TickLower. If it is token1 in the pool then\n    ///      sqrtRatioX96TickClosestToParity=sqrtRatioX96TickHigher\n    uint160 public immutable sqrtRatioX96TickClosestToParity;\n\n    /// @dev a threshold under which the contract no longer allows for the protocol to rebalance. Guarding\n    ///      against a strategist / guardian being taken over and with multiple transactions draining the\n    ///      protocol funds.\n    uint256 public constant SOLVENCY_THRESHOLD = 0.998 ether;\n\n    error NotEnoughWethForSwap(uint256 wethBalance, uint256 requiredWeth); // 0x989e5ca8\n    error NotEnoughWethLiquidity(uint256 wethBalance, uint256 requiredWeth); // 0xa6737d87\n    error PoolRebalanceOutOfBounds(\n        uint256 currentPoolWethShare,\n        uint256 allowedWethShareStart,\n        uint256 allowedWethShareEnd\n    ); // 0x3681e8e0\n    error OutsideExpectedTickRange(int24 currentTick); // 0x5a2eba75\n\n    event PoolRebalanced(uint256 currentPoolWethShare);\n\n    event PoolWethShareIntervalUpdated(\n        uint256 allowedWethShareStart,\n        uint256 allowedWethShareEnd\n    );\n\n    event LiquidityRemoved(\n        uint256 withdrawLiquidityShare,\n        uint256 removedWETHAmount,\n        uint256 removedOETHbAmount,\n        uint256 wethAmountCollected,\n        uint256 oethbAmountCollected,\n        uint256 underlyingAssets\n    );\n\n    event LiquidityAdded(\n        uint256 wethAmountDesired,\n        uint256 oethbAmountDesired,\n        uint256 wethAmountSupplied,\n        uint256 oethbAmountSupplied,\n        uint256 tokenId,\n        uint256 underlyingAssets\n    );\n\n    event UnderlyingAssetsUpdated(uint256 underlyingAssets);\n\n    /**\n     * @dev Verifies that the caller is the Governor, or Strategist.\n     */\n    modifier onlyGovernorOrStrategist() {\n        require(\n            msg.sender == IVault(vaultAddress).strategistAddr() ||\n                msg.sender == governor(),\n            \"Not the Governor or Strategist\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Un-stakes the token from the gauge for the execution duration of\n     * the function and after that re-stakes it back in.\n     *\n     * It is important that the token is unstaked and owned by the strategy contract\n     * during any liquidity altering operations and that it is re-staked back into the\n     * gauge after liquidity changes. If the token fails to re-stake back to the\n     * gauge it is not earning incentives.\n     */\n    // all functions using this modifier are used by functions with reentrancy check\n    // slither-disable-start reentrancy-no-eth\n    modifier gaugeUnstakeAndRestake() {\n        // because of solidity short-circuit _isLpTokenStakedInGauge doesn't get called\n        // when tokenId == 0\n        if (tokenId != 0 && _isLpTokenStakedInGauge()) {\n            clGauge.withdraw(tokenId);\n        }\n        _;\n        // because of solidity short-circuit _isLpTokenStakedInGauge doesn't get called\n        // when tokenId == 0\n        if (tokenId != 0 && !_isLpTokenStakedInGauge()) {\n            /**\n             * It can happen that a withdrawal (or a full withdrawal) transactions would\n             * remove all of the liquidity from the token with a NFT token still existing.\n             * In that case the token can not be staked into the gauge, as some liquidity\n             * needs to be added to it first.\n             */\n            if (_getLiquidity() > 0) {\n                // if token liquidity changes the positionManager requires re-approval.\n                // to any contract pre-approved to handle the token.\n                positionManager.approve(address(clGauge), tokenId);\n                clGauge.deposit(tokenId);\n            }\n        }\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice the constructor\n    /// @param _stratConfig the basic strategy configuration\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\n    /// @param _oethbAddress Address of the Erc20 OETHb Token contract\n    /// @param _swapRouter Address of the Aerodrome Universal Swap Router\n    /// @param _nonfungiblePositionManager Address of position manager to add/remove\n    ///         the liquidity\n    /// @param _clPool Address of the Aerodrome concentrated liquidity pool\n    /// @param _clGauge Address of the Aerodrome slipstream pool gauge\n    /// @param _sugarHelper Address of the Aerodrome Sugar helper contract\n    /// @param _lowerBoundingTick Smaller bounding tick of our liquidity position\n    /// @param _upperBoundingTick Larger bounding tick of our liquidity position\n    /// @param _tickClosestToParity Tick that is closer to 1:1 price parity\n    constructor(\n        BaseStrategyConfig memory _stratConfig,\n        address _wethAddress,\n        address _oethbAddress,\n        address _swapRouter,\n        address _nonfungiblePositionManager,\n        address _clPool,\n        address _clGauge,\n        address _sugarHelper,\n        int24 _lowerBoundingTick,\n        int24 _upperBoundingTick,\n        int24 _tickClosestToParity\n    ) InitializableAbstractStrategy(_stratConfig) {\n        require(\n            _lowerBoundingTick == _tickClosestToParity ||\n                _upperBoundingTick == _tickClosestToParity,\n            \"Misconfigured tickClosestToParity\"\n        );\n        require(\n            ICLPool(_clPool).token0() == _wethAddress,\n            \"Only WETH supported as token0\"\n        );\n        require(\n            ICLPool(_clPool).token1() == _oethbAddress,\n            \"Only OETHb supported as token1\"\n        );\n        int24 _tickSpacing = ICLPool(_clPool).tickSpacing();\n        // when we generalize AMO we might support other tick spacings\n        require(_tickSpacing == 1, \"Unsupported tickSpacing\");\n\n        WETH = _wethAddress;\n        OETHb = _oethbAddress;\n        swapRouter = ISwapRouter(_swapRouter);\n        positionManager = INonfungiblePositionManager(\n            _nonfungiblePositionManager\n        );\n        clPool = ICLPool(_clPool);\n        clGauge = ICLGauge(_clGauge);\n        helper = ISugarHelper(_sugarHelper);\n        sqrtRatioX96TickLower = ISugarHelper(_sugarHelper).getSqrtRatioAtTick(\n            _lowerBoundingTick\n        );\n        sqrtRatioX96TickHigher = ISugarHelper(_sugarHelper).getSqrtRatioAtTick(\n            _upperBoundingTick\n        );\n        sqrtRatioX96TickClosestToParity = ISugarHelper(_sugarHelper)\n            .getSqrtRatioAtTick(_tickClosestToParity);\n\n        lowerTick = _lowerBoundingTick;\n        upperTick = _upperBoundingTick;\n        tickSpacing = _tickSpacing;\n    }\n\n    /**\n     * @notice initialize function, to set up initial internal state\n     * @param _rewardTokenAddresses Address of reward token for platform\n     */\n    function initialize(address[] memory _rewardTokenAddresses)\n        external\n        onlyGovernor\n        initializer\n    {\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            new address[](0),\n            new address[](0)\n        );\n    }\n\n    /***************************************\n                  Configuration \n    ****************************************/\n\n    /**\n     * @notice Set allowed pool weth share interval. After the rebalance happens\n     * the share of WETH token in the ticker needs to be withing the specifications\n     * of the interval.\n     *\n     * @param _allowedWethShareStart Start of WETH share interval expressed as 18 decimal amount\n     * @param _allowedWethShareEnd End of WETH share interval expressed as 18 decimal amount\n     */\n    function setAllowedPoolWethShareInterval(\n        uint256 _allowedWethShareStart,\n        uint256 _allowedWethShareEnd\n    ) external onlyGovernor {\n        require(\n            _allowedWethShareStart < _allowedWethShareEnd,\n            \"Invalid interval\"\n        );\n        // can not go below 1% weth share\n        require(_allowedWethShareStart > 0.01 ether, \"Invalid interval start\");\n        // can not go above 95% weth share\n        require(_allowedWethShareEnd < 0.95 ether, \"Invalid interval end\");\n\n        allowedWethShareStart = _allowedWethShareStart;\n        allowedWethShareEnd = _allowedWethShareEnd;\n        emit PoolWethShareIntervalUpdated(\n            allowedWethShareStart,\n            allowedWethShareEnd\n        );\n    }\n\n    /***************************************\n                Periphery utils\n    ****************************************/\n\n    function _isLpTokenStakedInGauge() internal view returns (bool) {\n        require(tokenId != 0, \"Missing NFT LP token\");\n\n        address owner = positionManager.ownerOf(tokenId);\n        require(\n            owner == address(clGauge) || owner == address(this),\n            \"Unexpected token owner\"\n        );\n        return owner == address(clGauge);\n    }\n\n    /***************************************\n               Strategy overrides \n    ****************************************/\n\n    /**\n     * @notice Deposit an amount of assets into the strategy contract. Calling deposit doesn't\n     *         automatically deposit funds into the underlying Aerodrome pool\n     * @param _asset   Address for the asset\n     * @param _amount  Units of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @notice Deposit WETH to the strategy contract. This function does not add liquidity to the\n     *         underlying Aerodrome pool.\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        if (_wethBalance > 0) {\n            _deposit(WETH, _wethBalance);\n        }\n    }\n\n    /**\n     * @dev Deposit WETH to the contract. This function doesn't deposit the liquidity to the\n     *      pool, that is done via the rebalance call.\n     * @param _asset Address of the asset to deposit\n     * @param _amount Amount of assets to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_asset == WETH, \"Unsupported asset\");\n        require(_amount > 0, \"Must deposit something\");\n        emit Deposit(_asset, address(0), _amount);\n    }\n\n    /**\n     * @notice Rebalance the pool to the desired token split and Deposit any WETH on the contract to the\n     * underlying aerodrome pool. Print the required amount of corresponding OETHb. After the rebalancing is\n     * done burn any potentially remaining OETHb tokens still on the strategy contract.\n     *\n     * This function has a slightly different behaviour depending on the status of the underlying Aerodrome\n     * slipstream pool. The function consists of the following 3 steps:\n     * 1. withdrawPartialLiqidity -> so that moving the activeTrading price via  a swap is cheaper\n     * 2. swapToDesiredPosition   -> move active trading price in the pool to be able to deposit WETH & OETHb\n     *                               tokens with the desired pre-configured shares\n     * 3. addLiquidity            -> add liquidity into the pool respecting share split configuration\n     *\n     * Scenario 1: When there is no liquidity in the pool from the strategy but there is from other LPs then\n     *             only step 1 is skipped. (It is important to note that liquidity needs to exist in the configured\n     *             strategy tick ranges in order for the swap to be possible) Step 3 mints new liquidity position\n     *             instead of adding to an existing one.\n     * Scenario 2: When there is strategy's liquidity in the pool all 3 steps are taken\n     *\n     *\n     * Exact _amountToSwap, _swapWeth & _minTokenReceived parameters shall be determined by simulating the\n     * transaction off-chain. The strategy checks that after the swap the share of the tokens is in the\n     * expected ranges.\n     *\n     * @param _amountToSwap The amount of the token to swap\n     * @param _swapWeth Swap using WETH when true, use OETHb when false\n     * @param _minTokenReceived Slippage check -> minimum amount of token expected in return\n     */\n    function rebalance(\n        uint256 _amountToSwap,\n        bool _swapWeth,\n        uint256 _minTokenReceived\n    ) external nonReentrant onlyGovernorOrStrategist {\n        /**\n         * Would be nice to check if there is any total liquidity in the pool before performing this swap\n         * but there is no easy way to do that in UniswapV3:\n         * - clPool.liquidity() -> only liquidity in the active tick\n         * - asset[1&2].balanceOf(address(clPool)) -> will include uncollected tokens of LP providers\n         *   after their liquidity position has been decreased\n         */\n\n        /**\n         * When rebalance is called for the first time there is no strategy\n         * liquidity in the pool yet. The full liquidity removal is thus skipped.\n         */\n        if (tokenId != 0) {\n            _removeLiquidity(1e18);\n        }\n        // in some cases we will just want to add liquidity and not issue a swap to move the\n        // active trading position within the pool\n        if (_amountToSwap > 0) {\n            _swapToDesiredPosition(_amountToSwap, _swapWeth, _minTokenReceived);\n        }\n        // calling check liquidity early so we don't get unexpected errors when adding liquidity\n        // in the later stages of this function\n        _checkForExpectedPoolPrice();\n\n        _addLiquidity();\n        // this call shouldn't be necessary, since adding liquidity shouldn't affect the active\n        // trading price. It is a defensive programming measure.\n        _checkForExpectedPoolPrice();\n\n        // revert if protocol insolvent\n        _solvencyAssert();\n    }\n\n    /**\n     * Checks that the protocol is solvent, protecting from a rogue Strategist / Guardian that can\n     * keep rebalancing the pool in both directions making the protocol lose a tiny amount of\n     * funds each time.\n     *\n     * Protocol must be at least SOLVENCY_THRESHOLD (99,8 %) backed in order for the rebalances to\n     * function.\n     */\n    function _solvencyAssert() internal view {\n        uint256 _totalVaultValue = IVault(vaultAddress).totalValue();\n        uint256 _totalOethbSupply = IERC20(OETHb).totalSupply();\n\n        if (\n            _totalVaultValue.divPrecisely(_totalOethbSupply) <\n            SOLVENCY_THRESHOLD\n        ) {\n            revert(\"Protocol insolvent\");\n        }\n    }\n\n    /**\n     * @dev Decrease partial or all liquidity from the pool.\n     * @param _liquidityToDecrease The amount of liquidity to remove expressed in 18 decimal point\n     */\n    function _removeLiquidity(uint256 _liquidityToDecrease)\n        internal\n        gaugeUnstakeAndRestake\n    {\n        require(_liquidityToDecrease > 0, \"Must remove some liquidity\");\n\n        uint128 _liquidity = _getLiquidity();\n        // need to convert to uint256 since intermittent result is to big for uint128 to handle\n        uint128 _liqudityToRemove = uint256(_liquidity)\n            .mulTruncate(_liquidityToDecrease)\n            .toUint128();\n\n        /**\n         * There is no liquidity to remove -> exit function early. This can happen after a\n         * withdraw/withdrawAll removes all of the liquidity while retaining the NFT token.\n         */\n        if (_liquidity == 0 || _liqudityToRemove == 0) {\n            return;\n        }\n\n        (uint256 _amountWeth, uint256 _amountOethb) = positionManager\n            .decreaseLiquidity(\n                // Both expected amounts can be 0 since we don't really care if any swaps\n                // happen just before the liquidity removal.\n                INonfungiblePositionManager.DecreaseLiquidityParams({\n                    tokenId: tokenId,\n                    liquidity: _liqudityToRemove,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    deadline: block.timestamp\n                })\n            );\n\n        (\n            uint256 _amountWethCollected,\n            uint256 _amountOethbCollected\n        ) = positionManager.collect(\n                INonfungiblePositionManager.CollectParams({\n                    tokenId: tokenId,\n                    recipient: address(this),\n                    amount0Max: type(uint128).max, // defaults to all tokens owed\n                    amount1Max: type(uint128).max // defaults to all tokens owed\n                })\n            );\n\n        _updateUnderlyingAssets();\n\n        emit LiquidityRemoved(\n            _liquidityToDecrease,\n            _amountWeth, //removedWethAmount\n            _amountOethb, //removedOethbAmount\n            _amountWethCollected,\n            _amountOethbCollected,\n            underlyingAssets\n        );\n    }\n\n    /**\n     * @dev Perform a swap so that after the swap the ticker has the desired WETH to OETHb token share.\n     */\n    function _swapToDesiredPosition(\n        uint256 _amountToSwap,\n        bool _swapWeth,\n        uint256 _minTokenReceived\n    ) internal {\n        IERC20 _tokenToSwap = IERC20(_swapWeth ? WETH : OETHb);\n        uint256 _balance = _tokenToSwap.balanceOf(address(this));\n\n        if (_balance < _amountToSwap) {\n            if (_swapWeth) {\n                revert NotEnoughWethForSwap(_balance, _amountToSwap);\n            }\n            // if swapping OETHb\n            uint256 mintForSwap = _amountToSwap - _balance;\n            IVault(vaultAddress).mintForStrategy(mintForSwap);\n        }\n\n        // Swap it\n        swapRouter.exactInputSingle(\n            // sqrtPriceLimitX96 is just a rough sanity check that we are within 0 -> 1 tick\n            // a more fine check is performed in _checkForExpectedPoolPrice\n            // Note: this needs further work if we want to generalize this approach\n            ISwapRouter.ExactInputSingleParams({\n                tokenIn: address(_tokenToSwap),\n                tokenOut: _swapWeth ? OETHb : WETH,\n                tickSpacing: tickSpacing, // set to 1\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountIn: _amountToSwap,\n                amountOutMinimum: _minTokenReceived, // slippage check\n                sqrtPriceLimitX96: _swapWeth\n                    ? sqrtRatioX96TickLower\n                    : sqrtRatioX96TickHigher\n            })\n        );\n    }\n\n    /**\n     * @dev Add liquidity into the pool in the pre-configured WETH to OETHb share ratios\n     * defined by the allowedPoolWethShareStart|End interval. This function will respect\n     * liquidity ratios when there no liquidity yet in the pool. If liquidity is already\n     * present then it relies on the `_swapToDesiredPosition` function in a step before\n     * to already move the trading price to desired position (with some tolerance).\n     */\n    // rebalance already has re-entrency checks\n    // slither-disable-start reentrancy-no-eth\n    function _addLiquidity() internal gaugeUnstakeAndRestake {\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        uint256 _oethbBalance = IERC20(OETHb).balanceOf(address(this));\n        require(_wethBalance > 0, \"Must add some WETH\");\n\n        uint160 _currentPrice = getPoolX96Price();\n        /**\n         * Sanity check active trading price is positioned within our desired tick.\n         *\n         * We revert when price is equal to the lower tick even though that is still\n         * a valid amount in regards to ticker position by Sugar.estimateAmount call.\n         * Current price equaling tick bound at the 1:1 price parity results in\n         * uint overfow when calculating the OETHb balance to deposit.\n         */\n        if (\n            _currentPrice <= sqrtRatioX96TickLower ||\n            _currentPrice >= sqrtRatioX96TickHigher\n        ) {\n            revert OutsideExpectedTickRange(getCurrentTradingTick());\n        }\n\n        /**\n         * If estimateAmount1 call fails it could be due to _currentPrice being really\n         * close to a tick and amount1 is a larger number than the sugar helper is able\n         * to compute.\n         *\n         * If token addresses were reversed estimateAmount0 would be required here\n         */\n        uint256 _oethbRequired = helper.estimateAmount1(\n            _wethBalance,\n            address(0), // no need to pass pool address when current price is specified\n            _currentPrice,\n            lowerTick,\n            upperTick\n        );\n\n        if (_oethbRequired > _oethbBalance) {\n            IVault(vaultAddress).mintForStrategy(\n                _oethbRequired - _oethbBalance\n            );\n        }\n\n        uint256 _wethAmountSupplied;\n        uint256 _oethbAmountSupplied;\n        if (tokenId == 0) {\n            (\n                tokenId,\n                ,\n                _wethAmountSupplied,\n                _oethbAmountSupplied\n            ) = positionManager.mint(\n                /** amount0Min & amount1Min are left at 0 because slippage protection is ensured by the\n                 * _checkForExpectedPoolPrice\n                 *\n                 * Also sqrtPriceX96 is 0 because the pool is already created\n                 * non zero amount attempts to create a new instance of the pool\n                 */\n                INonfungiblePositionManager.MintParams({\n                    token0: WETH,\n                    token1: OETHb,\n                    tickSpacing: tickSpacing,\n                    tickLower: lowerTick,\n                    tickUpper: upperTick,\n                    amount0Desired: _wethBalance,\n                    amount1Desired: _oethbRequired,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    recipient: address(this),\n                    deadline: block.timestamp,\n                    sqrtPriceX96: 0\n                })\n            );\n        } else {\n            (, _wethAmountSupplied, _oethbAmountSupplied) = positionManager\n                .increaseLiquidity(\n                    /** amount0Min & amount1Min are left at 0 because slippage protection is ensured by the\n                     * _checkForExpectedPoolPrice\n                     */\n                    INonfungiblePositionManager.IncreaseLiquidityParams({\n                        tokenId: tokenId,\n                        amount0Desired: _wethBalance,\n                        amount1Desired: _oethbRequired,\n                        amount0Min: 0,\n                        amount1Min: 0,\n                        deadline: block.timestamp\n                    })\n                );\n        }\n\n        _updateUnderlyingAssets();\n        emit LiquidityAdded(\n            _wethBalance, // wethAmountDesired\n            _oethbRequired, // oethbAmountDesired\n            _wethAmountSupplied, // wethAmountSupplied\n            _oethbAmountSupplied, // oethbAmountSupplied\n            tokenId, // tokenId\n            underlyingAssets\n        );\n\n        // burn remaining OETHb\n        _burnOethbOnTheContract();\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /**\n     * @dev Check that the Aerodrome pool price is within the expected\n     *      parameters.\n     *      This function works whether the strategy contract has liquidity\n     *      position in the pool or not.\n     */\n    function _checkForExpectedPoolPrice() internal {\n        require(\n            allowedWethShareStart != 0 && allowedWethShareEnd != 0,\n            \"Weth share interval not set\"\n        );\n\n        uint160 _currentPrice = getPoolX96Price();\n\n        /**\n         * First check we are in expected tick range\n         *\n         * We revert even though price being equal to the lower tick would still\n         * count being within lower tick for the purpose of Sugar.estimateAmount calls\n         */\n        if (\n            _currentPrice <= sqrtRatioX96TickLower ||\n            _currentPrice >= sqrtRatioX96TickHigher\n        ) {\n            revert OutsideExpectedTickRange(getCurrentTradingTick());\n        }\n\n        /**\n         * If estimateAmount1 call fails it could be due to _currentPrice being really\n         * close to a tick and amount1 too big to compute.\n         *\n         * If token addresses were reversed estimateAmount0 would be required here\n         */\n        uint256 _normalizedWethAmount = 1 ether;\n        uint256 _correspondingOethAmount = helper.estimateAmount1(\n            _normalizedWethAmount,\n            address(0), // no need to pass pool address when current price is specified\n            _currentPrice,\n            lowerTick,\n            upperTick\n        );\n\n        // 18 decimal number expressed weth tick share\n        uint256 _wethSharePct = _normalizedWethAmount.divPrecisely(\n            _normalizedWethAmount + _correspondingOethAmount\n        );\n\n        if (\n            _wethSharePct < allowedWethShareStart ||\n            _wethSharePct > allowedWethShareEnd\n        ) {\n            revert PoolRebalanceOutOfBounds(\n                _wethSharePct,\n                allowedWethShareStart,\n                allowedWethShareEnd\n            );\n        }\n        emit PoolRebalanced(_wethSharePct);\n    }\n\n    /**\n     * Burns any OETHb tokens remaining on the strategy contract\n     */\n    function _burnOethbOnTheContract() internal {\n        uint256 _oethbBalance = IERC20(OETHb).balanceOf(address(this));\n        if (_oethbBalance > 0) {\n            IVault(vaultAddress).burnForStrategy(_oethbBalance);\n        }\n    }\n\n    /// @dev This function assumes there are no uncollected tokens in the clPool owned by the strategy contract.\n    ///      For that reason any liquidity withdrawals must also collect the tokens.\n    function _updateUnderlyingAssets() internal {\n        if (tokenId == 0) {\n            underlyingAssets = 0;\n            emit UnderlyingAssetsUpdated(underlyingAssets);\n            return;\n        }\n\n        uint128 _liquidity = _getLiquidity();\n\n        /**\n         * Our net value represent the smallest amount of tokens we are able to extract from the position\n         * given our liquidity.\n         *\n         * The least amount of tokens extraditable from the position is where the active trading price is\n         * at the ticker 0 meaning the pool is offering 1:1 trades between WETH & OETHb. At that moment the pool\n         * consists completely of OETHb and no WETH.\n         *\n         * The more swaps from WETH -> OETHb happen on the pool the more the price starts to move towards the -1\n         * ticker making OETHb (priced in WETH) more expensive.\n         *\n         * An additional note: when liquidity is 0 then the helper returns 0 for both token amounts. And the\n         * function set underlying assets to 0.\n         */\n        (uint256 _wethAmount, uint256 _oethbAmount) = helper\n            .getAmountsForLiquidity(\n                sqrtRatioX96TickClosestToParity, // sqrtRatioX96\n                sqrtRatioX96TickLower, // sqrtRatioAX96\n                sqrtRatioX96TickHigher, // sqrtRatioBX96\n                _liquidity\n            );\n\n        require(_wethAmount == 0, \"Non zero wethAmount\");\n        underlyingAssets = _oethbAmount;\n        emit UnderlyingAssetsUpdated(underlyingAssets);\n    }\n\n    /**\n     * @notice Withdraw an `amount` of assets from the platform and\n     *         send to the `_recipient`.\n     * @param _recipient  Address to which the asset should be sent\n     * @param _asset      WETH address\n     * @param _amount     Amount of WETH to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_asset == WETH, \"Unsupported asset\");\n        require(_recipient == vaultAddress, \"Only withdraw to vault allowed\");\n\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        if (_wethBalance < _amount) {\n            require(tokenId != 0, \"No liquidity available\");\n            uint256 _additionalWethRequired = _amount - _wethBalance;\n            (uint256 _wethInThePool, ) = getPositionPrincipal();\n\n            if (_wethInThePool < _additionalWethRequired) {\n                revert NotEnoughWethLiquidity(\n                    _wethInThePool,\n                    _additionalWethRequired\n                );\n            }\n\n            uint256 shareOfWethToRemove = Math.min(\n                _additionalWethRequired.divPrecisely(_wethInThePool) + 1,\n                1e18\n            );\n            _removeLiquidity(shareOfWethToRemove);\n        }\n\n        // burn remaining OETHb\n        _burnOethbOnTheContract();\n        _withdraw(_recipient, _amount);\n    }\n\n    /**\n     * @notice Withdraw WETH and sends it to the Vault.\n     */\n    function withdrawAll() external override onlyVault nonReentrant {\n        if (tokenId != 0) {\n            _removeLiquidity(1e18);\n        }\n\n        uint256 _balance = IERC20(WETH).balanceOf(address(this));\n        if (_balance > 0) {\n            _withdraw(vaultAddress, _balance);\n        }\n        // burn remaining OETHb\n        _burnOethbOnTheContract();\n    }\n\n    function _withdraw(address _recipient, uint256 _amount) internal {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient == vaultAddress, \"Only withdraw to vault allowed\");\n\n        IERC20(WETH).safeTransfer(_recipient, _amount);\n        emit Withdrawal(WETH, address(0), _amount);\n    }\n\n    /**\n     * @dev Collect the AERO token from the gauge\n     */\n    function _collectRewardTokens() internal override {\n        if (tokenId != 0 && _isLpTokenStakedInGauge()) {\n            clGauge.getReward(tokenId);\n        }\n        super._collectRewardTokens();\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == WETH;\n    }\n\n    /**\n     * @dev Approve the spending of all assets\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        // to add liquidity to the clPool\n        IERC20(WETH).safeApprove(address(positionManager), type(uint256).max);\n        IERC20(OETHb).safeApprove(address(positionManager), type(uint256).max);\n        // to be able to rebalance using the swapRouter\n        IERC20(WETH).safeApprove(address(swapRouter), type(uint256).max);\n        IERC20(OETHb).safeApprove(address(swapRouter), type(uint256).max);\n    }\n\n    /***************************************\n            Balances and Fees\n    ****************************************/\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(_asset == WETH, \"Only WETH supported\");\n\n        // we could in theory deposit to the strategy and forget to call rebalance in the same\n        // governance transaction batch. In that case the WETH that is on the strategy contract\n        // also needs to be accounted for.\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        // just paranoia check, in case there is OETHb in the strategy that for some reason hasn't\n        // been burned yet.\n        uint256 _oethbBalance = IERC20(OETHb).balanceOf(address(this));\n        return underlyingAssets + _wethBalance + _oethbBalance;\n    }\n\n    /**\n     * @dev Returns the balance of both tokens in a given position (excluding fees)\n     * @return _amountWeth Amount of WETH in position\n     * @return _amountOethb Amount of OETHb in position\n     */\n    function getPositionPrincipal()\n        public\n        view\n        returns (uint256 _amountWeth, uint256 _amountOethb)\n    {\n        if (tokenId == 0) {\n            return (0, 0);\n        }\n\n        uint160 _sqrtRatioX96 = getPoolX96Price();\n        (_amountWeth, _amountOethb) = helper.principal(\n            positionManager,\n            tokenId,\n            _sqrtRatioX96\n        );\n    }\n\n    /**\n     * @notice Returns the current pool price in X96 format\n     * @return _sqrtRatioX96 Pool price\n     */\n    function getPoolX96Price() public view returns (uint160 _sqrtRatioX96) {\n        (_sqrtRatioX96, , , , , ) = clPool.slot0();\n    }\n\n    /**\n     * @notice Returns the current active trading tick of the underlying pool\n     * @return _currentTick Current pool trading tick\n     */\n    function getCurrentTradingTick() public view returns (int24 _currentTick) {\n        (, _currentTick, , , , ) = clPool.slot0();\n    }\n\n    /**\n     * @notice Returns the amount of liquidity in the contract's LP position\n     * @return _liquidity Amount of liquidity in the position\n     */\n    function _getLiquidity() internal view returns (uint128 _liquidity) {\n        if (tokenId == 0) {\n            revert(\"No LP position\");\n        }\n\n        (, , , , , , , _liquidity, , , , ) = positionManager.positions(tokenId);\n    }\n\n    /***************************************\n            Hidden functions\n    ****************************************/\n    /// @inheritdoc InitializableAbstractStrategy\n    function setPTokenAddress(address, address) external override {\n        // The pool tokens can never change.\n        revert(\"Unsupported method\");\n    }\n\n    /// @inheritdoc InitializableAbstractStrategy\n    function removePToken(uint256) external override {\n        // The pool tokens can never change.\n        revert(\"Unsupported method\");\n    }\n\n    /**\n     * @dev Not supported\n     */\n    function _abstractSetPToken(address, address) internal override {\n        // the deployer shall call safeApproveAllTokens() to set necessary approvals\n        revert(\"Unsupported method\");\n    }\n\n    /***************************************\n            ERC721 management\n    ****************************************/\n\n    /// @notice Callback function for whenever a NFT is transferred to this contract\n    //  solhint-disable-next-line max-line-length\n    /// Ref: https://docs.openzeppelin.com/contracts/3.x/api/token/erc721#IERC721Receiver-onERC721Received-address-address-uint256-bytes-\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/token/OUSD.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD Token Contract\n * @dev ERC20 compatible contract for OUSD\n * @dev Implements an elastic supply\n * @author Origin Protocol Inc\n */\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { InitializableERC20Detailed } from \"../utils/InitializableERC20Detailed.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\n\n/**\n * NOTE that this is an ERC20 token but the invariant that the sum of\n * balanceOf(x) for all x is not >= totalSupply(). This is a consequence of the\n * rebasing design. Any integrations with OUSD should be aware.\n */\n\ncontract OUSD is Initializable, InitializableERC20Detailed, Governable {\n    using SafeMath for uint256;\n    using StableMath for uint256;\n\n    event TotalSupplyUpdatedHighres(\n        uint256 totalSupply,\n        uint256 rebasingCredits,\n        uint256 rebasingCreditsPerToken\n    );\n    event AccountRebasingEnabled(address account);\n    event AccountRebasingDisabled(address account);\n\n    enum RebaseOptions {\n        NotSet,\n        OptOut,\n        OptIn\n    }\n\n    uint256 private constant MAX_SUPPLY = ~uint128(0); // (2^128) - 1\n    uint256 public _totalSupply;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    address public vaultAddress = address(0);\n    mapping(address => uint256) private _creditBalances;\n    uint256 private _rebasingCredits;\n    uint256 private _rebasingCreditsPerToken;\n    // Frozen address/credits are non rebasing (value is held in contracts which\n    // do not receive yield unless they explicitly opt in)\n    uint256 public nonRebasingSupply;\n    mapping(address => uint256) public nonRebasingCreditsPerToken;\n    mapping(address => RebaseOptions) public rebaseState;\n    mapping(address => uint256) public isUpgraded;\n\n    uint256 private constant RESOLUTION_INCREASE = 1e9;\n\n    function initialize(\n        string calldata _nameArg,\n        string calldata _symbolArg,\n        address _vaultAddress,\n        uint256 _initialCreditsPerToken\n    ) external onlyGovernor initializer {\n        InitializableERC20Detailed._initialize(_nameArg, _symbolArg, 18);\n        _rebasingCreditsPerToken = _initialCreditsPerToken;\n        vaultAddress = _vaultAddress;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault contract\n     */\n    modifier onlyVault() {\n        require(vaultAddress == msg.sender, \"Caller is not the Vault\");\n        _;\n    }\n\n    /**\n     * @return The total supply of OUSD.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @return Low resolution rebasingCreditsPerToken\n     */\n    function rebasingCreditsPerToken() public view returns (uint256) {\n        return _rebasingCreditsPerToken / RESOLUTION_INCREASE;\n    }\n\n    /**\n     * @return Low resolution total number of rebasing credits\n     */\n    function rebasingCredits() public view returns (uint256) {\n        return _rebasingCredits / RESOLUTION_INCREASE;\n    }\n\n    /**\n     * @return High resolution rebasingCreditsPerToken\n     */\n    function rebasingCreditsPerTokenHighres() public view returns (uint256) {\n        return _rebasingCreditsPerToken;\n    }\n\n    /**\n     * @return High resolution total number of rebasing credits\n     */\n    function rebasingCreditsHighres() public view returns (uint256) {\n        return _rebasingCredits;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param _account Address to query the balance of.\n     * @return A uint256 representing the amount of base units owned by the\n     *         specified address.\n     */\n    function balanceOf(address _account)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (_creditBalances[_account] == 0) return 0;\n        return\n            _creditBalances[_account].divPrecisely(_creditsPerToken(_account));\n    }\n\n    /**\n     * @dev Gets the credits balance of the specified address.\n     * @dev Backwards compatible with old low res credits per token.\n     * @param _account The address to query the balance of.\n     * @return (uint256, uint256) Credit balance and credits per token of the\n     *         address\n     */\n    function creditsBalanceOf(address _account)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        uint256 cpt = _creditsPerToken(_account);\n        if (cpt == 1e27) {\n            // For a period before the resolution upgrade, we created all new\n            // contract accounts at high resolution. Since they are not changing\n            // as a result of this upgrade, we will return their true values\n            return (_creditBalances[_account], cpt);\n        } else {\n            return (\n                _creditBalances[_account] / RESOLUTION_INCREASE,\n                cpt / RESOLUTION_INCREASE\n            );\n        }\n    }\n\n    /**\n     * @dev Gets the credits balance of the specified address.\n     * @param _account The address to query the balance of.\n     * @return (uint256, uint256, bool) Credit balance, credits per token of the\n     *         address, and isUpgraded\n     */\n    function creditsBalanceOfHighres(address _account)\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        return (\n            _creditBalances[_account],\n            _creditsPerToken(_account),\n            isUpgraded[_account] == 1\n        );\n    }\n\n    /**\n     * @dev Transfer tokens to a specified address.\n     * @param _to the address to transfer to.\n     * @param _value the amount to be transferred.\n     * @return true on success.\n     */\n    function transfer(address _to, uint256 _value)\n        public\n        override\n        returns (bool)\n    {\n        require(_to != address(0), \"Transfer to zero address\");\n        require(\n            _value <= balanceOf(msg.sender),\n            \"Transfer greater than balance\"\n        );\n\n        _executeTransfer(msg.sender, _to, _value);\n\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another.\n     * @param _from The address you want to send tokens from.\n     * @param _to The address you want to transfer to.\n     * @param _value The amount of tokens to be transferred.\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public override returns (bool) {\n        require(_to != address(0), \"Transfer to zero address\");\n        require(_value <= balanceOf(_from), \"Transfer greater than balance\");\n\n        _allowances[_from][msg.sender] = _allowances[_from][msg.sender].sub(\n            _value\n        );\n\n        _executeTransfer(_from, _to, _value);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /**\n     * @dev Update the count of non rebasing credits in response to a transfer\n     * @param _from The address you want to send tokens from.\n     * @param _to The address you want to transfer to.\n     * @param _value Amount of OUSD to transfer\n     */\n    function _executeTransfer(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal {\n        bool isNonRebasingTo = _isNonRebasingAccount(_to);\n        bool isNonRebasingFrom = _isNonRebasingAccount(_from);\n\n        // Credits deducted and credited might be different due to the\n        // differing creditsPerToken used by each account\n        uint256 creditsCredited = _value.mulTruncate(_creditsPerToken(_to));\n        uint256 creditsDeducted = _value.mulTruncate(_creditsPerToken(_from));\n\n        _creditBalances[_from] = _creditBalances[_from].sub(\n            creditsDeducted,\n            \"Transfer amount exceeds balance\"\n        );\n        _creditBalances[_to] = _creditBalances[_to].add(creditsCredited);\n\n        if (isNonRebasingTo && !isNonRebasingFrom) {\n            // Transfer to non-rebasing account from rebasing account, credits\n            // are removed from the non rebasing tally\n            nonRebasingSupply = nonRebasingSupply.add(_value);\n            // Update rebasingCredits by subtracting the deducted amount\n            _rebasingCredits = _rebasingCredits.sub(creditsDeducted);\n        } else if (!isNonRebasingTo && isNonRebasingFrom) {\n            // Transfer to rebasing account from non-rebasing account\n            // Decreasing non-rebasing credits by the amount that was sent\n            nonRebasingSupply = nonRebasingSupply.sub(_value);\n            // Update rebasingCredits by adding the credited amount\n            _rebasingCredits = _rebasingCredits.add(creditsCredited);\n        }\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that _owner has allowed to\n     *      `_spender`.\n     * @param _owner The address which owns the funds.\n     * @param _spender The address which will spend the funds.\n     * @return The number of tokens still available for the _spender.\n     */\n    function allowance(address _owner, address _spender)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _allowances[_owner][_spender];\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens\n     *      on behalf of msg.sender. This method is included for ERC20\n     *      compatibility. `increaseAllowance` and `decreaseAllowance` should be\n     *      used instead.\n     *\n     *      Changing an allowance with this method brings the risk that someone\n     *      may transfer both the old and the new allowance - if they are both\n     *      greater than zero - if a transfer transaction is mined before the\n     *      later approve() call is mined.\n     * @param _spender The address which will spend the funds.\n     * @param _value The amount of tokens to be spent.\n     */\n    function approve(address _spender, uint256 _value)\n        public\n        override\n        returns (bool)\n    {\n        _allowances[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner has allowed to\n     *      `_spender`.\n     *      This method should be used instead of approve() to avoid the double\n     *      approval vulnerability described above.\n     * @param _spender The address which will spend the funds.\n     * @param _addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue)\n        public\n        returns (bool)\n    {\n        _allowances[msg.sender][_spender] = _allowances[msg.sender][_spender]\n            .add(_addedValue);\n        emit Approval(msg.sender, _spender, _allowances[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner has allowed to\n            `_spender`.\n     * @param _spender The address which will spend the funds.\n     * @param _subtractedValue The amount of tokens to decrease the allowance\n     *        by.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue)\n        public\n        returns (bool)\n    {\n        uint256 oldValue = _allowances[msg.sender][_spender];\n        if (_subtractedValue >= oldValue) {\n            _allowances[msg.sender][_spender] = 0;\n        } else {\n            _allowances[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, _allowances[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Mints new tokens, increasing totalSupply.\n     */\n    function mint(address _account, uint256 _amount) external onlyVault {\n        _mint(_account, _amount);\n    }\n\n    /**\n     * @dev Creates `_amount` tokens and assigns them to `_account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address _account, uint256 _amount) internal nonReentrant {\n        require(_account != address(0), \"Mint to the zero address\");\n\n        bool isNonRebasingAccount = _isNonRebasingAccount(_account);\n\n        uint256 creditAmount = _amount.mulTruncate(_creditsPerToken(_account));\n        _creditBalances[_account] = _creditBalances[_account].add(creditAmount);\n\n        // If the account is non rebasing and doesn't have a set creditsPerToken\n        // then set it i.e. this is a mint from a fresh contract\n        if (isNonRebasingAccount) {\n            nonRebasingSupply = nonRebasingSupply.add(_amount);\n        } else {\n            _rebasingCredits = _rebasingCredits.add(creditAmount);\n        }\n\n        _totalSupply = _totalSupply.add(_amount);\n\n        require(_totalSupply < MAX_SUPPLY, \"Max supply\");\n\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    /**\n     * @dev Burns tokens, decreasing totalSupply.\n     */\n    function burn(address account, uint256 amount) external onlyVault {\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev Destroys `_amount` tokens from `_account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must have at least `_amount` tokens.\n     */\n    function _burn(address _account, uint256 _amount) internal nonReentrant {\n        require(_account != address(0), \"Burn from the zero address\");\n        if (_amount == 0) {\n            return;\n        }\n\n        bool isNonRebasingAccount = _isNonRebasingAccount(_account);\n        uint256 creditAmount = _amount.mulTruncate(_creditsPerToken(_account));\n        uint256 currentCredits = _creditBalances[_account];\n\n        // Remove the credits, burning rounding errors\n        if (\n            currentCredits == creditAmount || currentCredits - 1 == creditAmount\n        ) {\n            // Handle dust from rounding\n            _creditBalances[_account] = 0;\n        } else if (currentCredits > creditAmount) {\n            _creditBalances[_account] = _creditBalances[_account].sub(\n                creditAmount\n            );\n        } else {\n            revert(\"Remove exceeds balance\");\n        }\n\n        // Remove from the credit tallies and non-rebasing supply\n        if (isNonRebasingAccount) {\n            nonRebasingSupply = nonRebasingSupply.sub(_amount);\n        } else {\n            _rebasingCredits = _rebasingCredits.sub(creditAmount);\n        }\n\n        _totalSupply = _totalSupply.sub(_amount);\n\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    /**\n     * @dev Get the credits per token for an account. Returns a fixed amount\n     *      if the account is non-rebasing.\n     * @param _account Address of the account.\n     */\n    function _creditsPerToken(address _account)\n        internal\n        view\n        returns (uint256)\n    {\n        if (nonRebasingCreditsPerToken[_account] != 0) {\n            return nonRebasingCreditsPerToken[_account];\n        } else {\n            return _rebasingCreditsPerToken;\n        }\n    }\n\n    /**\n     * @dev Is an account using rebasing accounting or non-rebasing accounting?\n     *      Also, ensure contracts are non-rebasing if they have not opted in.\n     * @param _account Address of the account.\n     */\n    function _isNonRebasingAccount(address _account) internal returns (bool) {\n        bool isContract = Address.isContract(_account);\n        if (isContract && rebaseState[_account] == RebaseOptions.NotSet) {\n            _ensureRebasingMigration(_account);\n        }\n        return nonRebasingCreditsPerToken[_account] > 0;\n    }\n\n    /**\n     * @dev Ensures internal account for rebasing and non-rebasing credits and\n     *      supply is updated following deployment of frozen yield change.\n     */\n    function _ensureRebasingMigration(address _account) internal {\n        if (nonRebasingCreditsPerToken[_account] == 0) {\n            emit AccountRebasingDisabled(_account);\n            if (_creditBalances[_account] == 0) {\n                // Since there is no existing balance, we can directly set to\n                // high resolution, and do not have to do any other bookkeeping\n                nonRebasingCreditsPerToken[_account] = 1e27;\n            } else {\n                // Migrate an existing account:\n\n                // Set fixed credits per token for this account\n                nonRebasingCreditsPerToken[_account] = _rebasingCreditsPerToken;\n                // Update non rebasing supply\n                nonRebasingSupply = nonRebasingSupply.add(balanceOf(_account));\n                // Update credit tallies\n                _rebasingCredits = _rebasingCredits.sub(\n                    _creditBalances[_account]\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Enable rebasing for an account.\n     * @dev Add a contract address to the non-rebasing exception list. The\n     * address's balance will be part of rebases and the account will be exposed\n     * to upside and downside.\n     * @param _account Address of the account.\n     */\n    function governanceRebaseOptIn(address _account)\n        public\n        nonReentrant\n        onlyGovernor\n    {\n        _rebaseOptIn(_account);\n    }\n\n    /**\n     * @dev Add a contract address to the non-rebasing exception list. The\n     * address's balance will be part of rebases and the account will be exposed\n     * to upside and downside.\n     */\n    function rebaseOptIn() public nonReentrant {\n        _rebaseOptIn(msg.sender);\n    }\n\n    function _rebaseOptIn(address _account) internal {\n        require(_isNonRebasingAccount(_account), \"Account has not opted out\");\n\n        // Convert balance into the same amount at the current exchange rate\n        uint256 newCreditBalance = _creditBalances[_account]\n            .mul(_rebasingCreditsPerToken)\n            .div(_creditsPerToken(_account));\n\n        // Decreasing non rebasing supply\n        nonRebasingSupply = nonRebasingSupply.sub(balanceOf(_account));\n\n        _creditBalances[_account] = newCreditBalance;\n\n        // Increase rebasing credits, totalSupply remains unchanged so no\n        // adjustment necessary\n        _rebasingCredits = _rebasingCredits.add(_creditBalances[_account]);\n\n        rebaseState[_account] = RebaseOptions.OptIn;\n\n        // Delete any fixed credits per token\n        delete nonRebasingCreditsPerToken[_account];\n        emit AccountRebasingEnabled(_account);\n    }\n\n    /**\n     * @dev Explicitly mark that an address is non-rebasing.\n     */\n    function rebaseOptOut() public nonReentrant {\n        require(!_isNonRebasingAccount(msg.sender), \"Account has not opted in\");\n\n        // Increase non rebasing supply\n        nonRebasingSupply = nonRebasingSupply.add(balanceOf(msg.sender));\n        // Set fixed credits per token\n        nonRebasingCreditsPerToken[msg.sender] = _rebasingCreditsPerToken;\n\n        // Decrease rebasing credits, total supply remains unchanged so no\n        // adjustment necessary\n        _rebasingCredits = _rebasingCredits.sub(_creditBalances[msg.sender]);\n\n        // Mark explicitly opted out of rebasing\n        rebaseState[msg.sender] = RebaseOptions.OptOut;\n        emit AccountRebasingDisabled(msg.sender);\n    }\n\n    /**\n     * @dev Modify the supply without minting new tokens. This uses a change in\n     *      the exchange rate between \"credits\" and OUSD tokens to change balances.\n     * @param _newTotalSupply New total supply of OUSD.\n     */\n    function changeSupply(uint256 _newTotalSupply)\n        external\n        onlyVault\n        nonReentrant\n    {\n        require(_totalSupply > 0, \"Cannot increase 0 supply\");\n\n        if (_totalSupply == _newTotalSupply) {\n            emit TotalSupplyUpdatedHighres(\n                _totalSupply,\n                _rebasingCredits,\n                _rebasingCreditsPerToken\n            );\n            return;\n        }\n\n        _totalSupply = _newTotalSupply > MAX_SUPPLY\n            ? MAX_SUPPLY\n            : _newTotalSupply;\n\n        _rebasingCreditsPerToken = _rebasingCredits.divPrecisely(\n            _totalSupply.sub(nonRebasingSupply)\n        );\n\n        require(_rebasingCreditsPerToken > 0, \"Invalid change in supply\");\n\n        _totalSupply = _rebasingCredits\n            .divPrecisely(_rebasingCreditsPerToken)\n            .add(nonRebasingSupply);\n\n        emit TotalSupplyUpdatedHighres(\n            _totalSupply,\n            _rebasingCredits,\n            _rebasingCreditsPerToken\n        );\n    }\n}\n"
    },
    "contracts/utils/Helpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IBasicToken } from \"../interfaces/IBasicToken.sol\";\n\nlibrary Helpers {\n    /**\n     * @notice Fetch the `symbol()` from an ERC20 token\n     * @dev Grabs the `symbol()` from a contract\n     * @param _token Address of the ERC20 token\n     * @return string Symbol of the ERC20 token\n     */\n    function getSymbol(address _token) internal view returns (string memory) {\n        string memory symbol = IBasicToken(_token).symbol();\n        return symbol;\n    }\n\n    /**\n     * @notice Fetch the `decimals()` from an ERC20 token\n     * @dev Grabs the `decimals()` from a contract and fails if\n     *      the decimal value does not live within a certain range\n     * @param _token Address of the ERC20 token\n     * @return uint256 Decimals of the ERC20 token\n     */\n    function getDecimals(address _token) internal view returns (uint256) {\n        uint256 decimals = IBasicToken(_token).decimals();\n        require(\n            decimals >= 4 && decimals <= 18,\n            \"Token must have sufficient decimal places\"\n        );\n\n        return decimals;\n    }\n}\n"
    },
    "contracts/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Base contract any contracts that need to initialize state after deployment.\n * @author Origin Protocol Inc\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(\n            initializing || !initialized,\n            \"Initializable: contract is already initialized\"\n        );\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/utils/InitializableAbstractStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Base contract for vault strategies.\n * @author Origin Protocol Inc\n */\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\nabstract contract InitializableAbstractStrategy is Initializable, Governable {\n    using SafeERC20 for IERC20;\n\n    event PTokenAdded(address indexed _asset, address _pToken);\n    event PTokenRemoved(address indexed _asset, address _pToken);\n    event Deposit(address indexed _asset, address _pToken, uint256 _amount);\n    event Withdrawal(address indexed _asset, address _pToken, uint256 _amount);\n    event RewardTokenCollected(\n        address recipient,\n        address rewardToken,\n        uint256 amount\n    );\n    event RewardTokenAddressesUpdated(\n        address[] _oldAddresses,\n        address[] _newAddresses\n    );\n    event HarvesterAddressesUpdated(\n        address _oldHarvesterAddress,\n        address _newHarvesterAddress\n    );\n\n    /// @notice Address of the underlying platform\n    address public immutable platformAddress;\n    /// @notice Address of the OToken vault\n    address public immutable vaultAddress;\n\n    /// @dev Replaced with an immutable variable\n    // slither-disable-next-line constable-states\n    address private _deprecated_platformAddress;\n\n    /// @dev Replaced with an immutable\n    // slither-disable-next-line constable-states\n    address private _deprecated_vaultAddress;\n\n    /// @notice asset => pToken (Platform Specific Token Address)\n    mapping(address => address) public assetToPToken;\n\n    /// @notice Full list of all assets supported by the strategy\n    address[] internal assetsMapped;\n\n    // Deprecated: Reward token address\n    // slither-disable-next-line constable-states\n    address private _deprecated_rewardTokenAddress;\n\n    // Deprecated: now resides in Harvester's rewardTokenConfigs\n    // slither-disable-next-line constable-states\n    uint256 private _deprecated_rewardLiquidationThreshold;\n\n    /// @notice Address of the Harvester contract allowed to collect reward tokens\n    address public harvesterAddress;\n\n    /// @notice Address of the reward tokens. eg CRV, BAL, CVX, AURA\n    address[] public rewardTokenAddresses;\n\n    /* Reserved for future expansion. Used to be 100 storage slots\n     * and has decreased to accommodate:\n     * - harvesterAddress\n     * - rewardTokenAddresses\n     */\n    int256[98] private _reserved;\n\n    struct BaseStrategyConfig {\n        address platformAddress; // Address of the underlying platform\n        address vaultAddress; // Address of the OToken's Vault\n    }\n\n    /**\n     * @param _config The platform and OToken vault addresses\n     */\n    constructor(BaseStrategyConfig memory _config) {\n        platformAddress = _config.platformAddress;\n        vaultAddress = _config.vaultAddress;\n    }\n\n    /**\n     * @dev Internal initialize function, to set up initial internal state\n     * @param _rewardTokenAddresses Address of reward token for platform\n     * @param _assets Addresses of initial supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function _initialize(\n        address[] memory _rewardTokenAddresses,\n        address[] memory _assets,\n        address[] memory _pTokens\n    ) internal {\n        rewardTokenAddresses = _rewardTokenAddresses;\n\n        uint256 assetCount = _assets.length;\n        require(assetCount == _pTokens.length, \"Invalid input arrays\");\n        for (uint256 i = 0; i < assetCount; ++i) {\n            _setPTokenAddress(_assets[i], _pTokens[i]);\n        }\n    }\n\n    /**\n     * @notice Collect accumulated reward token and send to Vault.\n     */\n    function collectRewardTokens() external virtual onlyHarvester nonReentrant {\n        _collectRewardTokens();\n    }\n\n    /**\n     * @dev Default implementation that transfers reward tokens to the Harvester\n     * Implementing strategies need to add custom logic to collect the rewards.\n     */\n    function _collectRewardTokens() internal virtual {\n        uint256 rewardTokenCount = rewardTokenAddresses.length;\n        for (uint256 i = 0; i < rewardTokenCount; ++i) {\n            IERC20 rewardToken = IERC20(rewardTokenAddresses[i]);\n            uint256 balance = rewardToken.balanceOf(address(this));\n            if (balance > 0) {\n                emit RewardTokenCollected(\n                    harvesterAddress,\n                    address(rewardToken),\n                    balance\n                );\n                rewardToken.safeTransfer(harvesterAddress, balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault.\n     */\n    modifier onlyVault() {\n        require(msg.sender == vaultAddress, \"Caller is not the Vault\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Harvester.\n     */\n    modifier onlyHarvester() {\n        require(msg.sender == harvesterAddress, \"Caller is not the Harvester\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault or Governor.\n     */\n    modifier onlyVaultOrGovernor() {\n        require(\n            msg.sender == vaultAddress || msg.sender == governor(),\n            \"Caller is not the Vault or Governor\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault, Governor, or Strategist.\n     */\n    modifier onlyVaultOrGovernorOrStrategist() {\n        require(\n            msg.sender == vaultAddress ||\n                msg.sender == governor() ||\n                msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Vault, Governor, or Strategist\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Set the reward token addresses. Any old addresses will be overwritten.\n     * @param _rewardTokenAddresses Array of reward token addresses\n     */\n    function setRewardTokenAddresses(address[] calldata _rewardTokenAddresses)\n        external\n        onlyGovernor\n    {\n        uint256 rewardTokenCount = _rewardTokenAddresses.length;\n        for (uint256 i = 0; i < rewardTokenCount; ++i) {\n            require(\n                _rewardTokenAddresses[i] != address(0),\n                \"Can not set an empty address as a reward token\"\n            );\n        }\n\n        emit RewardTokenAddressesUpdated(\n            rewardTokenAddresses,\n            _rewardTokenAddresses\n        );\n        rewardTokenAddresses = _rewardTokenAddresses;\n    }\n\n    /**\n     * @notice Get the reward token addresses.\n     * @return address[] the reward token addresses.\n     */\n    function getRewardTokenAddresses()\n        external\n        view\n        returns (address[] memory)\n    {\n        return rewardTokenAddresses;\n    }\n\n    /**\n     * @notice Provide support for asset by passing its pToken address.\n     *      This method can only be called by the system Governor\n     * @param _asset    Address for the asset\n     * @param _pToken   Address for the corresponding platform token\n     */\n    function setPTokenAddress(address _asset, address _pToken)\n        external\n        virtual\n        onlyGovernor\n    {\n        _setPTokenAddress(_asset, _pToken);\n    }\n\n    /**\n     * @notice Remove a supported asset by passing its index.\n     *      This method can only be called by the system Governor\n     * @param _assetIndex Index of the asset to be removed\n     */\n    function removePToken(uint256 _assetIndex) external virtual onlyGovernor {\n        require(_assetIndex < assetsMapped.length, \"Invalid index\");\n        address asset = assetsMapped[_assetIndex];\n        address pToken = assetToPToken[asset];\n\n        if (_assetIndex < assetsMapped.length - 1) {\n            assetsMapped[_assetIndex] = assetsMapped[assetsMapped.length - 1];\n        }\n        assetsMapped.pop();\n        assetToPToken[asset] = address(0);\n\n        emit PTokenRemoved(asset, pToken);\n    }\n\n    /**\n     * @notice Provide support for asset by passing its pToken address.\n     *      Add to internal mappings and execute the platform specific,\n     * abstract method `_abstractSetPToken`\n     * @param _asset    Address for the asset\n     * @param _pToken   Address for the corresponding platform token\n     */\n    function _setPTokenAddress(address _asset, address _pToken) internal {\n        require(assetToPToken[_asset] == address(0), \"pToken already set\");\n        require(\n            _asset != address(0) && _pToken != address(0),\n            \"Invalid addresses\"\n        );\n\n        assetToPToken[_asset] = _pToken;\n        assetsMapped.push(_asset);\n\n        emit PTokenAdded(_asset, _pToken);\n\n        _abstractSetPToken(_asset, _pToken);\n    }\n\n    /**\n     * @notice Transfer token to governor. Intended for recovering tokens stuck in\n     *      strategy contracts, i.e. mistaken sends.\n     * @param _asset Address for the asset\n     * @param _amount Amount of the asset to transfer\n     */\n    function transferToken(address _asset, uint256 _amount)\n        public\n        virtual\n        onlyGovernor\n    {\n        require(!supportsAsset(_asset), \"Cannot transfer supported asset\");\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /**\n     * @notice Set the Harvester contract that can collect rewards.\n     * @param _harvesterAddress Address of the harvester contract.\n     */\n    function setHarvesterAddress(address _harvesterAddress)\n        external\n        onlyGovernor\n    {\n        emit HarvesterAddressesUpdated(harvesterAddress, _harvesterAddress);\n        harvesterAddress = _harvesterAddress;\n    }\n\n    /***************************************\n                 Abstract\n    ****************************************/\n\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        virtual;\n\n    function safeApproveAllTokens() external virtual;\n\n    /**\n     * @notice Deposit an amount of assets into the platform\n     * @param _asset               Address for the asset\n     * @param _amount              Units of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount) external virtual;\n\n    /**\n     * @notice Deposit all supported assets in this strategy contract to the platform\n     */\n    function depositAll() external virtual;\n\n    /**\n     * @notice Withdraw an `amount` of assets from the platform and\n     * send to the `_recipient`.\n     * @param _recipient         Address to which the asset should be sent\n     * @param _asset             Address of the asset\n     * @param _amount            Units of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external virtual;\n\n    /**\n     * @notice Withdraw all supported assets from platform and\n     * sends to the OToken's Vault.\n     */\n    function withdrawAll() external virtual;\n\n    /**\n     * @notice Get the total asset value held in the platform.\n     *      This includes any interest that was generated since depositing.\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        virtual\n        returns (uint256 balance);\n\n    /**\n     * @notice Check if an asset is supported.\n     * @param _asset    Address of the asset\n     * @return bool     Whether asset is supported\n     */\n    function supportsAsset(address _asset) public view virtual returns (bool);\n}\n"
    },
    "contracts/utils/InitializableERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n * Converted from openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\n * @author Origin Protocol Inc\n */\nabstract contract InitializableERC20Detailed is IERC20 {\n    // Storage gap to skip storage from prior to OUSD reset\n    uint256[100] private _____gap;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     * @notice To avoid variable shadowing appended `Arg` after arguments name.\n     */\n    function _initialize(\n        string memory nameArg,\n        string memory symbolArg,\n        uint8 decimalsArg\n    ) internal {\n        _name = nameArg;\n        _symbol = symbolArg;\n        _decimals = decimalsArg;\n    }\n\n    /**\n     * @notice Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @notice Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @notice Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/utils/StableMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n// Based on StableMath from Stability Labs Pty. Ltd.\n// https://github.com/mstable/mStable-contracts/blob/master/contracts/shared/StableMath.sol\n\nlibrary StableMath {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Scaling unit for use in specific calculations,\n     * where 1 * 10**18, or 1e18 represents a unit '1'\n     */\n    uint256 private constant FULL_SCALE = 1e18;\n\n    /***************************************\n                    Helpers\n    ****************************************/\n\n    /**\n     * @dev Adjust the scale of an integer\n     * @param to Decimals to scale to\n     * @param from Decimals to scale from\n     */\n    function scaleBy(\n        uint256 x,\n        uint256 to,\n        uint256 from\n    ) internal pure returns (uint256) {\n        if (to > from) {\n            x = x.mul(10**(to - from));\n        } else if (to < from) {\n            // slither-disable-next-line divide-before-multiply\n            x = x.div(10**(from - to));\n        }\n        return x;\n    }\n\n    /***************************************\n               Precise Arithmetic\n    ****************************************/\n\n    /**\n     * @dev Multiplies two precise units, and then truncates by the full scale\n     * @param x Left hand input to multiplication\n     * @param y Right hand input to multiplication\n     * @return Result after multiplying the two inputs and then dividing by the shared\n     *         scale unit\n     */\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulTruncateScale(x, y, FULL_SCALE);\n    }\n\n    /**\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\n     * @param x Left hand input to multiplication\n     * @param y Right hand input to multiplication\n     * @param scale Scale unit\n     * @return Result after multiplying the two inputs and then dividing by the shared\n     *         scale unit\n     */\n    function mulTruncateScale(\n        uint256 x,\n        uint256 y,\n        uint256 scale\n    ) internal pure returns (uint256) {\n        // e.g. assume scale = fullScale\n        // z = 10e18 * 9e17 = 9e36\n        uint256 z = x.mul(y);\n        // return 9e36 / 1e18 = 9e18\n        return z.div(scale);\n    }\n\n    /**\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\n     * @param x Left hand input to multiplication\n     * @param y Right hand input to multiplication\n     * @return Result after multiplying the two inputs and then dividing by the shared\n     *          scale unit, rounded up to the closest base unit.\n     */\n    function mulTruncateCeil(uint256 x, uint256 y)\n        internal\n        pure\n        returns (uint256)\n    {\n        // e.g. 8e17 * 17268172638 = 138145381104e17\n        uint256 scaled = x.mul(y);\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\n        uint256 ceil = scaled.add(FULL_SCALE.sub(1));\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\n        return ceil.div(FULL_SCALE);\n    }\n\n    /**\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\n     * @param x Left hand input to division\n     * @param y Right hand input to division\n     * @return Result after multiplying the left operand by the scale, and\n     *         executing the division on the right hand input.\n     */\n    function divPrecisely(uint256 x, uint256 y)\n        internal\n        pure\n        returns (uint256)\n    {\n        // e.g. 8e18 * 1e18 = 8e36\n        uint256 z = x.mul(FULL_SCALE);\n        // e.g. 8e36 / 10e18 = 8e17\n        return z.div(y);\n    }\n}\n"
    },
    "contracts/vault/OETHBaseVaultCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { OETHVaultCore } from \"./OETHVaultCore.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\n\n/**\n * @title OETH Base VaultCore Contract\n * @author Origin Protocol Inc\n */\ncontract OETHBaseVaultCore is OETHVaultCore {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    constructor(address _weth) OETHVaultCore(_weth) {}\n\n    // @inheritdoc VaultCore\n    function mintForStrategy(uint256 amount)\n        external\n        override\n        whenNotCapitalPaused\n    {\n        require(\n            strategies[msg.sender].isSupported == true,\n            \"Unsupported strategy\"\n        );\n        require(\n            isMintWhitelistedStrategy[msg.sender] == true,\n            \"Not whitelisted strategy\"\n        );\n\n        emit Mint(msg.sender, amount);\n\n        // Mint matching amount of OTokens\n        oUSD.mint(msg.sender, amount);\n    }\n\n    // @inheritdoc VaultCore\n    function burnForStrategy(uint256 amount)\n        external\n        override\n        whenNotCapitalPaused\n    {\n        require(\n            strategies[msg.sender].isSupported == true,\n            \"Unsupported strategy\"\n        );\n        require(\n            isMintWhitelistedStrategy[msg.sender] == true,\n            \"Not whitelisted strategy\"\n        );\n\n        emit Redeem(msg.sender, amount);\n\n        // Burn OTokens\n        oUSD.burn(msg.sender, amount);\n    }\n\n    // @inheritdoc OETHVaultCore\n    function _redeem(uint256 _amount, uint256 _minimumUnitAmount)\n        internal\n        virtual\n        override\n    {\n        // Only Strategist or Governor can redeem using the Vault for now.\n        // We don't have the onlyGovernorOrStrategist modifier on VaultCore.\n        // Since we won't be using that modifier anywhere in the VaultCore as well,\n        // the check has been added inline instead of moving it to VaultStorage.\n        require(\n            msg.sender == strategistAddr || isGovernor(),\n            \"Caller is not the Strategist or Governor\"\n        );\n\n        super._redeem(_amount, _minimumUnitAmount);\n    }\n\n    // @inheritdoc OETHVaultCore\n    function requestWithdrawal(uint256 _amount)\n        external\n        virtual\n        override\n        returns (uint256 requestId, uint256 queued)\n    {\n        revert(\"Async withdrawals disabled\");\n    }\n\n    // @inheritdoc OETHVaultCore\n    function claimWithdrawal(uint256 _requestId)\n        external\n        virtual\n        override\n        returns (uint256 amount)\n    {\n        revert(\"Async withdrawals disabled\");\n    }\n\n    // @inheritdoc OETHVaultCore\n    function claimWithdrawals(uint256[] memory _requestIds)\n        external\n        virtual\n        override\n        returns (uint256[] memory amounts, uint256 totalAmount)\n    {\n        revert(\"Async withdrawals disabled\");\n    }\n}\n"
    },
    "contracts/vault/OETHBaseZapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { IERC4626 } from \"../../lib/openzeppelin/interfaces/IERC4626.sol\";\n\ncontract OETHBaseZapper {\n    IERC20 public immutable oethb;\n    IERC4626 public immutable woethb;\n    IVault public immutable vault;\n\n    IWETH9 public constant weth =\n        IWETH9(0x4200000000000000000000000000000000000006);\n    address private constant ETH_MARKER =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    event Zap(address indexed minter, address indexed asset, uint256 amount);\n\n    constructor(\n        address _oethb,\n        address _woethb,\n        address _vault\n    ) {\n        oethb = IERC20(_oethb);\n        woethb = IERC4626(_woethb);\n        vault = IVault(_vault);\n\n        weth.approve(address(_vault), type(uint256).max);\n        IERC20(_oethb).approve(_woethb, type(uint256).max);\n    }\n\n    /**\n     * @dev Deposit ETH and receive OETH in return.\n     * Will verify that the user is sent 1:1 for ETH.\n     */\n    receive() external payable {\n        deposit();\n    }\n\n    /**\n     * @dev Deposit ETH and receive superOETHb in return\n     * Will verify that the user is sent 1:1 for ETH.\n     * @return Amount of OETH sent to user\n     */\n    function deposit() public payable returns (uint256) {\n        uint256 balance = address(this).balance;\n\n        emit Zap(msg.sender, ETH_MARKER, balance);\n\n        // Wrap ETH\n        weth.deposit{ value: balance }();\n\n        // Mint with WETH\n        return _mint(balance, msg.sender);\n    }\n\n    /**\n     * @dev Deposit ETH and receive superOETHb in return\n     * @param minReceived min amount of wsuperOETHb to receive\n     * @return Amount of wsuperOETHb sent to user\n     */\n    function depositETHForWrappedTokens(uint256 minReceived)\n        external\n        payable\n        returns (uint256)\n    {\n        uint256 balance = address(this).balance;\n\n        emit Zap(msg.sender, ETH_MARKER, balance);\n\n        // Wrap ETH\n        weth.deposit{ value: balance }();\n\n        // Mint with WETH\n        uint256 mintedOethb = _mint(balance, address(this));\n\n        // Wrap superOETHb into wsuperOETHb\n        uint256 mintedWoethb = woethb.deposit(mintedOethb, msg.sender);\n\n        require(mintedWoethb >= minReceived, \"Zapper: not enough minted\");\n\n        return mintedWoethb;\n    }\n\n    /**\n     * @dev Deposit WETH and receive superOETHb in return\n     * @param wethAmount Amount of WETH to deposit\n     * @param minReceived min amount of wsuperOETHb to receive\n     * @return Amount of wsuperOETHb sent to user\n     */\n    function depositWETHForWrappedTokens(\n        uint256 wethAmount,\n        uint256 minReceived\n    ) external returns (uint256) {\n        // slither-disable-next-line unchecked-transfer unused-return\n        weth.transferFrom(msg.sender, address(this), wethAmount);\n\n        emit Zap(msg.sender, address(weth), wethAmount);\n\n        // Mint with WETH\n        uint256 mintedOethb = _mint(wethAmount, address(this));\n\n        // Wrap superOETHb into wsuperOETHb\n        uint256 mintedWoethb = woethb.deposit(mintedOethb, msg.sender);\n\n        require(mintedWoethb >= minReceived, \"Zapper: not enough minted\");\n\n        return mintedWoethb;\n    }\n\n    /**\n     * @dev Internal function to mint superOETHb with WETH\n     * @param minOETH Minimum amount of OETH to for user to receive\n     * @param recipient Address that receives the tokens\n     * @return Amount of OETH sent to user\n     */\n    function _mint(uint256 minOETH, address recipient)\n        internal\n        returns (uint256)\n    {\n        uint256 toMint = weth.balanceOf(address(this));\n        vault.mint(address(weth), toMint, minOETH);\n        uint256 mintedAmount = oethb.balanceOf(address(this));\n        require(mintedAmount >= minOETH, \"Zapper: not enough minted\");\n\n        if (recipient != address(this)) {\n            require(oethb.transfer(recipient, mintedAmount));\n        }\n\n        return mintedAmount;\n    }\n}\n"
    },
    "contracts/vault/OETHVaultCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { VaultCore } from \"./VaultCore.sol\";\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\nimport { IDripper } from \"../interfaces/IDripper.sol\";\n\n/**\n * @title OETH VaultCore Contract\n * @author Origin Protocol Inc\n */\ncontract OETHVaultCore is VaultCore {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    uint256 public constant CLAIM_DELAY = 10 minutes;\n    address public immutable weth;\n    uint256 public wethAssetIndex;\n\n    // For future use (because OETHBaseVaultCore inherits from this)\n    uint256[50] private __gap;\n\n    constructor(address _weth) {\n        weth = _weth;\n    }\n\n    /**\n     * @dev Caches WETH's index in `allAssets` variable.\n     *      Reduces gas usage by redeem by caching that.\n     */\n    function cacheWETHAssetIndex() external onlyGovernor {\n        uint256 assetCount = allAssets.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            if (allAssets[i] == weth) {\n                wethAssetIndex = i;\n                break;\n            }\n        }\n\n        require(allAssets[wethAssetIndex] == weth, \"Invalid WETH Asset Index\");\n    }\n\n    // @inheritdoc VaultCore\n    // slither-disable-start reentrancy-no-eth\n    function _mint(\n        address _asset,\n        uint256 _amount,\n        uint256 _minimumOusdAmount\n    ) internal virtual override {\n        require(_asset == weth, \"Unsupported asset for minting\");\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(\n            _amount >= _minimumOusdAmount,\n            \"Mint amount lower than minimum\"\n        );\n\n        emit Mint(msg.sender, _amount);\n\n        // Rebase must happen before any transfers occur.\n        if (!rebasePaused && _amount >= rebaseThreshold) {\n            // Stream any harvested rewards (WETH) that are available to the Vault\n            IDripper(dripper).collect();\n\n            _rebase();\n        }\n\n        // Mint oTokens\n        oUSD.mint(msg.sender, _amount);\n\n        // Transfer the deposited coins to the vault\n        IERC20(_asset).safeTransferFrom(msg.sender, address(this), _amount);\n\n        // Give priority to the withdrawal queue for the new WETH liquidity\n        _addWithdrawalQueueLiquidity();\n\n        // Auto-allocate if necessary\n        if (_amount >= autoAllocateThreshold) {\n            _allocate();\n        }\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    // @inheritdoc VaultCore\n    function _calculateRedeemOutputs(uint256 _amount)\n        internal\n        view\n        virtual\n        override\n        returns (uint256[] memory outputs)\n    {\n        // Overrides `VaultCore._calculateRedeemOutputs` to redeem with only\n        // WETH instead of LST-mix. Doesn't change the function signature\n        // for backward compatibility\n\n        // Calculate redeem fee\n        if (redeemFeeBps > 0) {\n            uint256 redeemFee = _amount.mulTruncateScale(redeemFeeBps, 1e4);\n            _amount = _amount - redeemFee;\n        }\n\n        // Ensure that the WETH index is cached\n        uint256 _wethAssetIndex = wethAssetIndex;\n        require(\n            allAssets[_wethAssetIndex] == weth,\n            \"WETH Asset index not cached\"\n        );\n\n        outputs = new uint256[](allAssets.length);\n        outputs[_wethAssetIndex] = _amount;\n    }\n\n    // @inheritdoc VaultCore\n    function _redeem(uint256 _amount, uint256 _minimumUnitAmount)\n        internal\n        virtual\n        override\n    {\n        // Override `VaultCore._redeem` to simplify it. Gets rid of oracle\n        // usage and looping through all assets for LST-mix redeem. Instead\n        // does a simple WETH-only redeem.\n        emit Redeem(msg.sender, _amount);\n\n        if (_amount == 0) {\n            return;\n        }\n\n        // Amount excluding fees\n        uint256 amountMinusFee = _calculateRedeemOutputs(_amount)[\n            wethAssetIndex\n        ];\n\n        require(\n            amountMinusFee >= _minimumUnitAmount,\n            \"Redeem amount lower than minimum\"\n        );\n\n        // Is there enough WETH in the Vault available after accounting for the withdrawal queue\n        require(_wethAvailable() >= amountMinusFee, \"Liquidity error\");\n\n        // Transfer WETH minus the fee to the redeemer\n        IERC20(weth).safeTransfer(msg.sender, amountMinusFee);\n\n        // Burn OETH from user (including fees)\n        oUSD.burn(msg.sender, _amount);\n\n        // Prevent insolvency\n        _postRedeem(_amount);\n    }\n\n    /**\n     * @notice Request an asynchronous withdrawal of WETH in exchange for OETH.\n     * The OETH is burned on request and the WETH is transferred to the withdrawer on claim.\n     * This request can be claimed once the withdrawal queue's `claimable` amount\n     * is greater than or equal this request's `queued` amount.\n     * There is no minimum time or block number before a request can be claimed. It just needs\n     * enough WETH liquidity in the Vault to satisfy all the outstanding requests to that point in the queue.\n     * OETH is converted to WETH at 1:1.\n     * @param _amount Amount of OETH to burn.\n     * @param requestId Unique ID for the withdrawal request\n     * @param queued Cumulative total of all WETH queued including already claimed requests.\n     */\n    function requestWithdrawal(uint256 _amount)\n        external\n        virtual\n        whenNotCapitalPaused\n        nonReentrant\n        returns (uint256 requestId, uint256 queued)\n    {\n        // The check that the requester has enough OETH is done in to later burn call\n\n        requestId = withdrawalQueueMetadata.nextWithdrawalIndex;\n        queued = withdrawalQueueMetadata.queued + _amount;\n\n        // Store the next withdrawal request\n        withdrawalQueueMetadata.nextWithdrawalIndex = SafeCast.toUint128(\n            requestId + 1\n        );\n        // Store the updated queued amount which reserves WETH in the withdrawal queue\n        // and reduces the vault's total assets\n        withdrawalQueueMetadata.queued = SafeCast.toUint128(queued);\n        // Store the user's withdrawal request\n        withdrawalRequests[requestId] = WithdrawalRequest({\n            withdrawer: msg.sender,\n            claimed: false,\n            timestamp: uint40(block.timestamp),\n            amount: SafeCast.toUint128(_amount),\n            queued: SafeCast.toUint128(queued)\n        });\n\n        // Burn the user's OETH\n        oUSD.burn(msg.sender, _amount);\n\n        // Prevent withdrawal if the vault is solvent by more than the the allowed percentage\n        _postRedeem(_amount);\n\n        emit WithdrawalRequested(msg.sender, requestId, _amount, queued);\n    }\n\n    // slither-disable-start reentrancy-no-eth\n    /**\n     * @notice Claim a previously requested withdrawal once it is claimable.\n     * This request can be claimed once the withdrawal queue's `claimable` amount\n     * is greater than or equal this request's `queued` amount and 10 minutes has passed.\n     * If the requests is not claimable, the transaction will revert with `Queue pending liquidity`.\n     * If the request is not older than 10 minutes, the transaction will revert with `Claim delay not met`.\n     * OETH is converted to WETH at 1:1.\n     * @param _requestId Unique ID for the withdrawal request\n     * @return amount Amount of WETH transferred to the withdrawer\n     */\n    function claimWithdrawal(uint256 _requestId)\n        external\n        virtual\n        whenNotCapitalPaused\n        nonReentrant\n        returns (uint256 amount)\n    {\n        // Try and get more liquidity if there is not enough available\n        if (\n            withdrawalRequests[_requestId].queued >\n            withdrawalQueueMetadata.claimable\n        ) {\n            // Stream any harvested rewards (WETH) that are available to the Vault\n            IDripper(dripper).collect();\n\n            // Add any WETH from the Dripper to the withdrawal queue\n            _addWithdrawalQueueLiquidity();\n        }\n\n        amount = _claimWithdrawal(_requestId);\n\n        // transfer WETH from the vault to the withdrawer\n        IERC20(weth).safeTransfer(msg.sender, amount);\n\n        // Prevent insolvency\n        _postRedeem(amount);\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /**\n     * @notice Claim a previously requested withdrawals once they are claimable.\n     * This requests can be claimed once the withdrawal queue's `claimable` amount\n     * is greater than or equal each request's `queued` amount and 10 minutes has passed.\n     * If one of the requests is not claimable, the whole transaction will revert with `Queue pending liquidity`.\n     * If one of the requests is not older than 10 minutes,\n     * the whole transaction will revert with `Claim delay not met`.\n     * @param _requestIds Unique ID of each withdrawal request\n     * @return amounts Amount of WETH received for each request\n     * @return totalAmount Total amount of WETH transferred to the withdrawer\n     */\n    function claimWithdrawals(uint256[] memory _requestIds)\n        external\n        virtual\n        whenNotCapitalPaused\n        nonReentrant\n        returns (uint256[] memory amounts, uint256 totalAmount)\n    {\n        // Just call the Dripper instead of looping through _requestIds to find the highest id\n        // and checking it's queued amount is > the queue's claimable amount.\n\n        // Stream any harvested rewards (WETH) that are available to the Vault\n        IDripper(dripper).collect();\n\n        // Add any WETH from the Dripper to the withdrawal queue\n        _addWithdrawalQueueLiquidity();\n\n        amounts = new uint256[](_requestIds.length);\n        for (uint256 i = 0; i < _requestIds.length; ++i) {\n            amounts[i] = _claimWithdrawal(_requestIds[i]);\n            totalAmount += amounts[i];\n        }\n\n        // transfer all the claimed WETH from the vault to the withdrawer\n        IERC20(weth).safeTransfer(msg.sender, totalAmount);\n\n        // Prevent insolvency\n        _postRedeem(totalAmount);\n    }\n\n    function _claimWithdrawal(uint256 requestId)\n        internal\n        returns (uint256 amount)\n    {\n        // Load the structs from storage into memory\n        WithdrawalRequest memory request = withdrawalRequests[requestId];\n        WithdrawalQueueMetadata memory queue = withdrawalQueueMetadata;\n\n        require(\n            request.timestamp + CLAIM_DELAY <= block.timestamp,\n            \"Claim delay not met\"\n        );\n        // If there isn't enough reserved liquidity in the queue to claim\n        require(request.queued <= queue.claimable, \"Queue pending liquidity\");\n        require(request.withdrawer == msg.sender, \"Not requester\");\n        require(request.claimed == false, \"Already claimed\");\n\n        // Store the request as claimed\n        withdrawalRequests[requestId].claimed = true;\n        // Store the updated claimed amount\n        withdrawalQueueMetadata.claimed = queue.claimed + request.amount;\n\n        emit WithdrawalClaimed(msg.sender, requestId, request.amount);\n\n        return request.amount;\n    }\n\n    /// @notice Collects harvested rewards from the Dripper as WETH then\n    /// adds WETH to the withdrawal queue if there is a funding shortfall.\n    /// @dev is called from the Native Staking strategy when validator withdrawals are processed.\n    /// It also called before any WETH is allocated to a strategy.\n    function addWithdrawalQueueLiquidity() external {\n        // Stream any harvested rewards (WETH) that are available to the Vault\n        IDripper(dripper).collect();\n\n        _addWithdrawalQueueLiquidity();\n    }\n\n    /// @dev Adds WETH to the withdrawal queue if there is a funding shortfall.\n    /// This assumes 1 WETH equal 1 OETH.\n    function _addWithdrawalQueueLiquidity()\n        internal\n        returns (uint256 addedClaimable)\n    {\n        WithdrawalQueueMetadata memory queue = withdrawalQueueMetadata;\n\n        // Check if the claimable WETH is less than the queued amount\n        uint256 queueShortfall = queue.queued - queue.claimable;\n\n        // No need to do anything is the withdrawal queue is full funded\n        if (queueShortfall == 0) {\n            return 0;\n        }\n\n        uint256 wethBalance = IERC20(weth).balanceOf(address(this));\n\n        // Of the claimable withdrawal requests, how much is unclaimed?\n        // That is, the amount of WETH that is currently allocated for the withdrawal queue\n        uint256 allocatedWeth = queue.claimable - queue.claimed;\n\n        // If there is no unallocated WETH then there is nothing to add to the queue\n        if (wethBalance <= allocatedWeth) {\n            return 0;\n        }\n\n        uint256 unallocatedWeth = wethBalance - allocatedWeth;\n\n        // the new claimable amount is the smaller of the queue shortfall or unallocated weth\n        addedClaimable = queueShortfall < unallocatedWeth\n            ? queueShortfall\n            : unallocatedWeth;\n        uint256 newClaimable = queue.claimable + addedClaimable;\n\n        // Store the new claimable amount back to storage\n        withdrawalQueueMetadata.claimable = SafeCast.toUint128(newClaimable);\n\n        // emit a WithdrawalClaimable event\n        emit WithdrawalClaimable(newClaimable, addedClaimable);\n    }\n\n    /***************************************\n                View Functions\n    ****************************************/\n\n    /// @dev Calculate how much WETH in the vault is not reserved for the withdrawal queue.\n    // That is, it is available to be redeemed or deposited into a strategy.\n    function _wethAvailable() internal view returns (uint256 wethAvailable) {\n        WithdrawalQueueMetadata memory queue = withdrawalQueueMetadata;\n\n        // The amount of WETH that is still to be claimed in the withdrawal queue\n        uint256 outstandingWithdrawals = queue.queued - queue.claimed;\n\n        // The amount of sitting in WETH in the vault\n        uint256 wethBalance = IERC20(weth).balanceOf(address(this));\n\n        // If there is not enough WETH in the vault to cover the outstanding withdrawals\n        if (wethBalance <= outstandingWithdrawals) {\n            return 0;\n        }\n\n        return wethBalance - outstandingWithdrawals;\n    }\n\n    /// @dev Get the balance of an asset held in Vault and all strategies\n    /// less any WETH that is reserved for the withdrawal queue.\n    /// This will only return a non-zero balance for WETH.\n    /// All other assets will return 0 even if there is some dust amounts left in the Vault.\n    /// For example, there is 1 wei left of stETH in the OETH Vault but will return 0 in this function.\n    ///\n    /// If there is not enough WETH in the vault and all strategies to cover all outstanding\n    /// withdrawal requests then return a WETH balance of 0\n    function _checkBalance(address _asset)\n        internal\n        view\n        override\n        returns (uint256 balance)\n    {\n        if (_asset != weth) {\n            return 0;\n        }\n\n        // Get the WETH in the vault and the strategies\n        balance = super._checkBalance(_asset);\n\n        WithdrawalQueueMetadata memory queue = withdrawalQueueMetadata;\n\n        // If the vault becomes insolvent enough that the total value in the vault and all strategies\n        // is less than the outstanding withdrawals.\n        // For example, there was a mass slashing event and most users request a withdrawal.\n        if (balance + queue.claimed < queue.queued) {\n            return 0;\n        }\n\n        // Need to remove WETH that is reserved for the withdrawal queue\n        return balance + queue.claimed - queue.queued;\n    }\n\n    /**\n     * @notice Allocate unallocated funds on Vault to strategies.\n     **/\n    function allocate() external override whenNotCapitalPaused nonReentrant {\n        // Add any unallocated WETH to the withdrawal queue first\n        _addWithdrawalQueueLiquidity();\n\n        _allocate();\n    }\n\n    /// @dev Allocate WETH to the default WETH strategy if there is excess to the Vault buffer.\n    /// This is called from either `mint` or `allocate` and assumes `_addWithdrawalQueueLiquidity`\n    /// has been called before this function.\n    function _allocate() internal override {\n        // No need to do anything if no default strategy for WETH\n        address depositStrategyAddr = assetDefaultStrategies[weth];\n        if (depositStrategyAddr == address(0)) return;\n\n        uint256 wethAvailableInVault = _wethAvailable();\n        // No need to do anything if there isn't any WETH in the vault to allocate\n        if (wethAvailableInVault == 0) return;\n\n        // Calculate the target buffer for the vault using the total supply\n        uint256 totalSupply = oUSD.totalSupply();\n        uint256 targetBuffer = totalSupply.mulTruncate(vaultBuffer);\n\n        // If available WETH in the Vault is below or equal the target buffer then there's nothing to allocate\n        if (wethAvailableInVault <= targetBuffer) return;\n\n        // The amount of assets to allocate to the default strategy\n        uint256 allocateAmount = wethAvailableInVault - targetBuffer;\n\n        IStrategy strategy = IStrategy(depositStrategyAddr);\n        // Transfer WETH to the strategy and call the strategy's deposit function\n        IERC20(weth).safeTransfer(address(strategy), allocateAmount);\n        strategy.deposit(weth, allocateAmount);\n\n        emit AssetAllocated(weth, depositStrategyAddr, allocateAmount);\n    }\n\n    /// @dev The total value of all WETH held by the vault and all its strategies\n    /// less any WETH that is reserved for the withdrawal queue.\n    ///\n    // If there is not enough WETH in the vault and all strategies to cover all outstanding\n    // withdrawal requests then return a total value of 0.\n    function _totalValue() internal view override returns (uint256 value) {\n        // As WETH is the only asset, just return the WETH balance\n        return _checkBalance(weth);\n    }\n\n    /// @dev Only WETH is supported in the OETH Vault so return the WETH balance only\n    /// Any ETH balances in the Vault will be ignored.\n    /// Amounts from previously supported vault assets will also be ignored.\n    /// For example, there is 1 wei left of stETH in the OETH Vault but is will be ignored.\n    function _totalValueInVault()\n        internal\n        view\n        override\n        returns (uint256 value)\n    {\n        value = IERC20(weth).balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/vault/VaultCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OToken VaultCore contract\n * @notice The Vault contract stores assets. On a deposit, OTokens will be minted\n           and sent to the depositor. On a withdrawal, OTokens will be burned and\n           assets will be sent to the withdrawer. The Vault accepts deposits of\n           interest from yield bearing strategies which will modify the supply\n           of OTokens.\n * @author Origin Protocol Inc\n */\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { IGetExchangeRateToken } from \"../interfaces/IGetExchangeRateToken.sol\";\nimport { IDripper } from \"../interfaces/IDripper.sol\";\n\nimport \"./VaultInitializer.sol\";\n\ncontract VaultCore is VaultInitializer {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n    // max signed int\n    uint256 internal constant MAX_INT = 2**255 - 1;\n    // max un-signed int\n    uint256 internal constant MAX_UINT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /**\n     * @dev Verifies that the rebasing is not paused.\n     */\n    modifier whenNotRebasePaused() {\n        require(!rebasePaused, \"Rebasing paused\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the deposits are not paused.\n     */\n    modifier whenNotCapitalPaused() {\n        require(!capitalPaused, \"Capital paused\");\n        _;\n    }\n\n    modifier onlyOusdMetaStrategy() {\n        require(\n            msg.sender == ousdMetaStrategy,\n            \"Caller is not the OUSD meta strategy\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Deposit a supported asset and mint OTokens.\n     * @param _asset Address of the asset being deposited\n     * @param _amount Amount of the asset being deposited\n     * @param _minimumOusdAmount Minimum OTokens to mint\n     */\n    function mint(\n        address _asset,\n        uint256 _amount,\n        uint256 _minimumOusdAmount\n    ) external whenNotCapitalPaused nonReentrant {\n        _mint(_asset, _amount, _minimumOusdAmount);\n    }\n\n    function _mint(\n        address _asset,\n        uint256 _amount,\n        uint256 _minimumOusdAmount\n    ) internal virtual {\n        require(assets[_asset].isSupported, \"Asset is not supported\");\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        uint256 units = _toUnits(_amount, _asset);\n        uint256 unitPrice = _toUnitPrice(_asset, true);\n        uint256 priceAdjustedDeposit = (units * unitPrice) / 1e18;\n\n        if (_minimumOusdAmount > 0) {\n            require(\n                priceAdjustedDeposit >= _minimumOusdAmount,\n                \"Mint amount lower than minimum\"\n            );\n        }\n\n        emit Mint(msg.sender, priceAdjustedDeposit);\n\n        // Rebase must happen before any transfers occur.\n        if (priceAdjustedDeposit >= rebaseThreshold && !rebasePaused) {\n            if (dripper != address(0)) {\n                // Stream any harvested rewards that are available\n                IDripper(dripper).collect();\n            }\n            _rebase();\n        }\n\n        // Mint matching amount of OTokens\n        oUSD.mint(msg.sender, priceAdjustedDeposit);\n\n        // Transfer the deposited coins to the vault\n        IERC20 asset = IERC20(_asset);\n        asset.safeTransferFrom(msg.sender, address(this), _amount);\n\n        if (priceAdjustedDeposit >= autoAllocateThreshold) {\n            _allocate();\n        }\n    }\n\n    /**\n     * @notice Mint OTokens for a Metapool Strategy\n     * @param _amount Amount of the asset being deposited\n     *\n     * Notice: can't use `nonReentrant` modifier since the `mint` function can\n     * call `allocate`, and that can trigger `ConvexOUSDMetaStrategy` to call this function\n     * while the execution of the `mint` has not yet completed -> causing a `nonReentrant` collision.\n     *\n     * Also important to understand is that this is a limitation imposed by the test suite.\n     * Production / mainnet contracts should never be configured in a way where mint/redeem functions\n     * that are moving funds between the Vault and end user wallets can influence strategies\n     * utilizing this function.\n     */\n    function mintForStrategy(uint256 _amount)\n        external\n        virtual\n        whenNotCapitalPaused\n        onlyOusdMetaStrategy\n    {\n        require(_amount < MAX_INT, \"Amount too high\");\n\n        emit Mint(msg.sender, _amount);\n\n        // safe to cast because of the require check at the beginning of the function\n        netOusdMintedForStrategy += int256(_amount);\n\n        require(\n            abs(netOusdMintedForStrategy) < netOusdMintForStrategyThreshold,\n            \"Minted ousd surpassed netOusdMintForStrategyThreshold.\"\n        );\n\n        // Mint matching amount of OTokens\n        oUSD.mint(msg.sender, _amount);\n    }\n\n    // In memoriam\n\n    /**\n     * @notice Withdraw a supported asset and burn OTokens.\n     * @param _amount Amount of OTokens to burn\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function redeem(uint256 _amount, uint256 _minimumUnitAmount)\n        external\n        whenNotCapitalPaused\n        nonReentrant\n    {\n        _redeem(_amount, _minimumUnitAmount);\n    }\n\n    /**\n     * @notice Withdraw a supported asset and burn OTokens.\n     * @param _amount Amount of OTokens to burn\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function _redeem(uint256 _amount, uint256 _minimumUnitAmount)\n        internal\n        virtual\n    {\n        // Calculate redemption outputs\n        uint256[] memory outputs = _calculateRedeemOutputs(_amount);\n\n        emit Redeem(msg.sender, _amount);\n\n        // Send outputs\n        uint256 assetCount = allAssets.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            if (outputs[i] == 0) continue;\n\n            address assetAddr = allAssets[i];\n\n            if (IERC20(assetAddr).balanceOf(address(this)) >= outputs[i]) {\n                // Use Vault funds first if sufficient\n                IERC20(assetAddr).safeTransfer(msg.sender, outputs[i]);\n            } else {\n                address strategyAddr = assetDefaultStrategies[assetAddr];\n                if (strategyAddr != address(0)) {\n                    // Nothing in Vault, but something in Strategy, send from there\n                    IStrategy strategy = IStrategy(strategyAddr);\n                    strategy.withdraw(msg.sender, assetAddr, outputs[i]);\n                } else {\n                    // Cant find funds anywhere\n                    revert(\"Liquidity error\");\n                }\n            }\n        }\n\n        if (_minimumUnitAmount > 0) {\n            uint256 unitTotal = 0;\n            for (uint256 i = 0; i < outputs.length; ++i) {\n                unitTotal += _toUnits(outputs[i], allAssets[i]);\n            }\n            require(\n                unitTotal >= _minimumUnitAmount,\n                \"Redeem amount lower than minimum\"\n            );\n        }\n\n        oUSD.burn(msg.sender, _amount);\n\n        _postRedeem(_amount);\n    }\n\n    function _postRedeem(uint256 _amount) internal {\n        // Until we can prove that we won't affect the prices of our assets\n        // by withdrawing them, this should be here.\n        // It's possible that a strategy was off on its asset total, perhaps\n        // a reward token sold for more or for less than anticipated.\n        uint256 totalUnits = 0;\n        if (_amount >= rebaseThreshold && !rebasePaused) {\n            totalUnits = _rebase();\n        } else {\n            totalUnits = _totalValue();\n        }\n\n        // Check that the OTokens are backed by enough assets\n        if (maxSupplyDiff > 0) {\n            // If there are more outstanding withdrawal requests than assets in the vault and strategies\n            // then the available assets will be negative and totalUnits will be rounded up to zero.\n            // As we don't know the exact shortfall amount, we will reject all redeem and withdrawals\n            require(totalUnits > 0, \"Too many outstanding requests\");\n\n            // Allow a max difference of maxSupplyDiff% between\n            // backing assets value and OUSD total supply\n            uint256 diff = oUSD.totalSupply().divPrecisely(totalUnits);\n            require(\n                (diff > 1e18 ? diff - 1e18 : 1e18 - diff) <= maxSupplyDiff,\n                \"Backing supply liquidity error\"\n            );\n        }\n    }\n\n    /**\n     * @notice Burn OTokens for Metapool Strategy\n     * @param _amount Amount of OUSD to burn\n     *\n     * @dev Notice: can't use `nonReentrant` modifier since the `redeem` function could\n     * require withdrawal on `ConvexOUSDMetaStrategy` and that one can call `burnForStrategy`\n     * while the execution of the `redeem` has not yet completed -> causing a `nonReentrant` collision.\n     *\n     * Also important to understand is that this is a limitation imposed by the test suite.\n     * Production / mainnet contracts should never be configured in a way where mint/redeem functions\n     * that are moving funds between the Vault and end user wallets can influence strategies\n     * utilizing this function.\n     */\n    function burnForStrategy(uint256 _amount)\n        external\n        virtual\n        whenNotCapitalPaused\n        onlyOusdMetaStrategy\n    {\n        require(_amount < MAX_INT, \"Amount too high\");\n\n        emit Redeem(msg.sender, _amount);\n\n        // safe to cast because of the require check at the beginning of the function\n        netOusdMintedForStrategy -= int256(_amount);\n\n        require(\n            abs(netOusdMintedForStrategy) < netOusdMintForStrategyThreshold,\n            \"Attempting to burn too much OUSD.\"\n        );\n\n        // Burn OTokens\n        oUSD.burn(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Withdraw a supported asset and burn all OTokens.\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function redeemAll(uint256 _minimumUnitAmount)\n        external\n        whenNotCapitalPaused\n        nonReentrant\n    {\n        _redeem(oUSD.balanceOf(msg.sender), _minimumUnitAmount);\n    }\n\n    /**\n     * @notice Allocate unallocated funds on Vault to strategies.\n     **/\n    function allocate() external virtual whenNotCapitalPaused nonReentrant {\n        _allocate();\n    }\n\n    /**\n     * @dev Allocate unallocated funds on Vault to strategies.\n     **/\n    function _allocate() internal virtual {\n        uint256 vaultValue = _totalValueInVault();\n        // Nothing in vault to allocate\n        if (vaultValue == 0) return;\n        uint256 strategiesValue = _totalValueInStrategies();\n        // We have a method that does the same as this, gas optimisation\n        uint256 calculatedTotalValue = vaultValue + strategiesValue;\n\n        // We want to maintain a buffer on the Vault so calculate a percentage\n        // modifier to multiply each amount being allocated by to enforce the\n        // vault buffer\n        uint256 vaultBufferModifier;\n        if (strategiesValue == 0) {\n            // Nothing in Strategies, allocate 100% minus the vault buffer to\n            // strategies\n            vaultBufferModifier = uint256(1e18) - vaultBuffer;\n        } else {\n            vaultBufferModifier =\n                (vaultBuffer * calculatedTotalValue) /\n                vaultValue;\n            if (1e18 > vaultBufferModifier) {\n                // E.g. 1e18 - (1e17 * 10e18)/5e18 = 8e17\n                // (5e18 * 8e17) / 1e18 = 4e18 allocated from Vault\n                vaultBufferModifier = uint256(1e18) - vaultBufferModifier;\n            } else {\n                // We need to let the buffer fill\n                return;\n            }\n        }\n        if (vaultBufferModifier == 0) return;\n\n        // Iterate over all assets in the Vault and allocate to the appropriate\n        // strategy\n        uint256 assetCount = allAssets.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            IERC20 asset = IERC20(allAssets[i]);\n            uint256 assetBalance = asset.balanceOf(address(this));\n            // No balance, nothing to do here\n            if (assetBalance == 0) continue;\n\n            // Multiply the balance by the vault buffer modifier and truncate\n            // to the scale of the asset decimals\n            uint256 allocateAmount = assetBalance.mulTruncate(\n                vaultBufferModifier\n            );\n\n            address depositStrategyAddr = assetDefaultStrategies[\n                address(asset)\n            ];\n\n            if (depositStrategyAddr != address(0) && allocateAmount > 0) {\n                IStrategy strategy = IStrategy(depositStrategyAddr);\n                // Transfer asset to Strategy and call deposit method to\n                // mint or take required action\n                asset.safeTransfer(address(strategy), allocateAmount);\n                strategy.deposit(address(asset), allocateAmount);\n                emit AssetAllocated(\n                    address(asset),\n                    depositStrategyAddr,\n                    allocateAmount\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Calculate the total value of assets held by the Vault and all\n     *      strategies and update the supply of OTokens.\n     */\n    function rebase() external virtual nonReentrant {\n        _rebase();\n    }\n\n    /**\n     * @dev Calculate the total value of assets held by the Vault and all\n     *      strategies and update the supply of OTokens, optionally sending a\n     *      portion of the yield to the trustee.\n     * @return totalUnits Total balance of Vault in units\n     */\n    function _rebase() internal whenNotRebasePaused returns (uint256) {\n        uint256 ousdSupply = oUSD.totalSupply();\n        uint256 vaultValue = _totalValue();\n        if (ousdSupply == 0) {\n            return vaultValue;\n        }\n\n        // Yield fee collection\n        address _trusteeAddress = trusteeAddress; // gas savings\n        if (_trusteeAddress != address(0) && (vaultValue > ousdSupply)) {\n            uint256 yield = vaultValue - ousdSupply;\n            uint256 fee = yield.mulTruncateScale(trusteeFeeBps, 1e4);\n            require(yield > fee, \"Fee must not be greater than yield\");\n            if (fee > 0) {\n                oUSD.mint(_trusteeAddress, fee);\n            }\n            emit YieldDistribution(_trusteeAddress, yield, fee);\n        }\n\n        // Only rachet OToken supply upwards\n        ousdSupply = oUSD.totalSupply(); // Final check should use latest value\n        if (vaultValue > ousdSupply) {\n            oUSD.changeSupply(vaultValue);\n        }\n        return vaultValue;\n    }\n\n    /**\n     * @notice Determine the total value of assets held by the vault and its\n     *         strategies.\n     * @return value Total value in USD/ETH (1e18)\n     */\n    function totalValue() external view virtual returns (uint256 value) {\n        value = _totalValue();\n    }\n\n    /**\n     * @dev Internal Calculate the total value of the assets held by the\n     *         vault and its strategies.\n     * @return value Total value in USD/ETH (1e18)\n     */\n    function _totalValue() internal view virtual returns (uint256 value) {\n        return _totalValueInVault() + _totalValueInStrategies();\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held in Vault.\n     * @return value Total value in USD/ETH (1e18)\n     */\n    function _totalValueInVault()\n        internal\n        view\n        virtual\n        returns (uint256 value)\n    {\n        uint256 assetCount = allAssets.length;\n        for (uint256 y = 0; y < assetCount; ++y) {\n            address assetAddr = allAssets[y];\n            uint256 balance = IERC20(assetAddr).balanceOf(address(this));\n            if (balance > 0) {\n                value += _toUnits(balance, assetAddr);\n            }\n        }\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held in Strategies.\n     * @return value Total value in USD/ETH (1e18)\n     */\n    function _totalValueInStrategies() internal view returns (uint256 value) {\n        uint256 stratCount = allStrategies.length;\n        for (uint256 i = 0; i < stratCount; ++i) {\n            value = value + _totalValueInStrategy(allStrategies[i]);\n        }\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held by strategy.\n     * @param _strategyAddr Address of the strategy\n     * @return value Total value in USD/ETH (1e18)\n     */\n    function _totalValueInStrategy(address _strategyAddr)\n        internal\n        view\n        returns (uint256 value)\n    {\n        IStrategy strategy = IStrategy(_strategyAddr);\n        uint256 assetCount = allAssets.length;\n        for (uint256 y = 0; y < assetCount; ++y) {\n            address assetAddr = allAssets[y];\n            if (strategy.supportsAsset(assetAddr)) {\n                uint256 balance = strategy.checkBalance(assetAddr);\n                if (balance > 0) {\n                    value += _toUnits(balance, assetAddr);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Get the balance of an asset held in Vault and all strategies.\n     * @param _asset Address of asset\n     * @return uint256 Balance of asset in decimals of asset\n     */\n    function checkBalance(address _asset) external view returns (uint256) {\n        return _checkBalance(_asset);\n    }\n\n    /**\n     * @notice Get the balance of an asset held in Vault and all strategies.\n     * @param _asset Address of asset\n     * @return balance Balance of asset in decimals of asset\n     */\n    function _checkBalance(address _asset)\n        internal\n        view\n        virtual\n        returns (uint256 balance)\n    {\n        IERC20 asset = IERC20(_asset);\n        balance = asset.balanceOf(address(this));\n        uint256 stratCount = allStrategies.length;\n        for (uint256 i = 0; i < stratCount; ++i) {\n            IStrategy strategy = IStrategy(allStrategies[i]);\n            if (strategy.supportsAsset(_asset)) {\n                balance = balance + strategy.checkBalance(_asset);\n            }\n        }\n    }\n\n    /**\n     * @notice Calculate the outputs for a redeem function, i.e. the mix of\n     * coins that will be returned\n     */\n    function calculateRedeemOutputs(uint256 _amount)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return _calculateRedeemOutputs(_amount);\n    }\n\n    /**\n     * @dev Calculate the outputs for a redeem function, i.e. the mix of\n     * coins that will be returned.\n     * @return outputs Array of amounts respective to the supported assets\n     */\n    function _calculateRedeemOutputs(uint256 _amount)\n        internal\n        view\n        virtual\n        returns (uint256[] memory outputs)\n    {\n        // We always give out coins in proportion to how many we have,\n        // Now if all coins were the same value, this math would easy,\n        // just take the percentage of each coin, and multiply by the\n        // value to be given out. But if coins are worth more than $1,\n        // then we would end up handing out too many coins. We need to\n        // adjust by the total value of coins.\n        //\n        // To do this, we total up the value of our coins, by their\n        // percentages. Then divide what we would otherwise give out by\n        // this number.\n        //\n        // Let say we have 100 DAI at $1.06  and 200 USDT at $1.00.\n        // So for every 1 DAI we give out, we'll be handing out 2 USDT\n        // Our total output ratio is: 33% * 1.06 + 66% * 1.00 = 1.02\n        //\n        // So when calculating the output, we take the percentage of\n        // each coin, times the desired output value, divided by the\n        // totalOutputRatio.\n        //\n        // For example, withdrawing: 30 OUSD:\n        // DAI 33% * 30 / 1.02 = 9.80 DAI\n        // USDT = 66 % * 30 / 1.02 = 19.60 USDT\n        //\n        // Checking these numbers:\n        // 9.80 DAI * 1.06 = $10.40\n        // 19.60 USDT * 1.00 = $19.60\n        //\n        // And so the user gets $10.40 + $19.60 = $30 worth of value.\n\n        uint256 assetCount = allAssets.length;\n        uint256[] memory assetUnits = new uint256[](assetCount);\n        uint256[] memory assetBalances = new uint256[](assetCount);\n        outputs = new uint256[](assetCount);\n\n        // Calculate redeem fee\n        if (redeemFeeBps > 0) {\n            uint256 redeemFee = _amount.mulTruncateScale(redeemFeeBps, 1e4);\n            _amount = _amount - redeemFee;\n        }\n\n        // Calculate assets balances and decimals once,\n        // for a large gas savings.\n        uint256 totalUnits = 0;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            address assetAddr = allAssets[i];\n            uint256 balance = _checkBalance(assetAddr);\n            assetBalances[i] = balance;\n            assetUnits[i] = _toUnits(balance, assetAddr);\n            totalUnits = totalUnits + assetUnits[i];\n        }\n        // Calculate totalOutputRatio\n        uint256 totalOutputRatio = 0;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            uint256 unitPrice = _toUnitPrice(allAssets[i], false);\n            uint256 ratio = (assetUnits[i] * unitPrice) / totalUnits;\n            totalOutputRatio = totalOutputRatio + ratio;\n        }\n        // Calculate final outputs\n        uint256 factor = _amount.divPrecisely(totalOutputRatio);\n        for (uint256 i = 0; i < assetCount; ++i) {\n            outputs[i] = (assetBalances[i] * factor) / totalUnits;\n        }\n    }\n\n    /***************************************\n                    Pricing\n    ****************************************/\n\n    /**\n     * @notice Returns the total price in 18 digit units for a given asset.\n     *      Never goes above 1, since that is how we price mints.\n     * @param asset address of the asset\n     * @return price uint256: unit (USD / ETH) price for 1 unit of the asset, in 18 decimal fixed\n     */\n    function priceUnitMint(address asset)\n        external\n        view\n        returns (uint256 price)\n    {\n        /* need to supply 1 asset unit in asset's decimals and can not just hard-code\n         * to 1e18 and ignore calling `_toUnits` since we need to consider assets\n         * with the exchange rate\n         */\n        uint256 units = _toUnits(\n            uint256(1e18).scaleBy(_getDecimals(asset), 18),\n            asset\n        );\n        price = (_toUnitPrice(asset, true) * units) / 1e18;\n    }\n\n    /**\n     * @notice Returns the total price in 18 digit unit for a given asset.\n     *      Never goes below 1, since that is how we price redeems\n     * @param asset Address of the asset\n     * @return price uint256: unit (USD / ETH) price for 1 unit of the asset, in 18 decimal fixed\n     */\n    function priceUnitRedeem(address asset)\n        external\n        view\n        returns (uint256 price)\n    {\n        /* need to supply 1 asset unit in asset's decimals and can not just hard-code\n         * to 1e18 and ignore calling `_toUnits` since we need to consider assets\n         * with the exchange rate\n         */\n        uint256 units = _toUnits(\n            uint256(1e18).scaleBy(_getDecimals(asset), 18),\n            asset\n        );\n        price = (_toUnitPrice(asset, false) * units) / 1e18;\n    }\n\n    /***************************************\n                    Utils\n    ****************************************/\n\n    /**\n     * @dev Convert a quantity of a token into 1e18 fixed decimal \"units\"\n     * in the underlying base (USD/ETH) used by the vault.\n     * Price is not taken into account, only quantity.\n     *\n     * Examples of this conversion:\n     *\n     * - 1e18 DAI becomes 1e18 units (same decimals)\n     * - 1e6 USDC becomes 1e18 units (decimal conversion)\n     * - 1e18 rETH becomes 1.2e18 units (exchange rate conversion)\n     *\n     * @param _raw Quantity of asset\n     * @param _asset Core Asset address\n     * @return value 1e18 normalized quantity of units\n     */\n    function _toUnits(uint256 _raw, address _asset)\n        internal\n        view\n        returns (uint256)\n    {\n        UnitConversion conversion = assets[_asset].unitConversion;\n        if (conversion == UnitConversion.DECIMALS) {\n            return _raw.scaleBy(18, _getDecimals(_asset));\n        } else if (conversion == UnitConversion.GETEXCHANGERATE) {\n            uint256 exchangeRate = IGetExchangeRateToken(_asset)\n                .getExchangeRate();\n            return (_raw * exchangeRate) / 1e18;\n        } else {\n            revert(\"Unsupported conversion type\");\n        }\n    }\n\n    /**\n     * @dev Returns asset's unit price accounting for different asset types\n     *      and takes into account the context in which that price exists -\n     *      - mint or redeem.\n     *\n     * Note: since we are returning the price of the unit and not the one of the\n     * asset (see comment above how 1 rETH exchanges for 1.2 units) we need\n     * to make the Oracle price adjustment as well since we are pricing the\n     * units and not the assets.\n     *\n     * The price also snaps to a \"full unit price\" in case a mint or redeem\n     * action would be unfavourable to the protocol.\n     *\n     */\n    function _toUnitPrice(address _asset, bool isMint)\n        internal\n        view\n        returns (uint256 price)\n    {\n        UnitConversion conversion = assets[_asset].unitConversion;\n        price = IOracle(priceProvider).price(_asset);\n\n        if (conversion == UnitConversion.GETEXCHANGERATE) {\n            uint256 exchangeRate = IGetExchangeRateToken(_asset)\n                .getExchangeRate();\n            price = (price * 1e18) / exchangeRate;\n        } else if (conversion != UnitConversion.DECIMALS) {\n            revert(\"Unsupported conversion type\");\n        }\n\n        /* At this stage the price is already adjusted to the unit\n         * so the price checks are agnostic to underlying asset being\n         * pegged to a USD or to an ETH or having a custom exchange rate.\n         */\n        require(price <= MAX_UNIT_PRICE_DRIFT, \"Vault: Price exceeds max\");\n        require(price >= MIN_UNIT_PRICE_DRIFT, \"Vault: Price under min\");\n\n        if (isMint) {\n            /* Never price a normalized unit price for more than one\n             * unit of OETH/OUSD when minting.\n             */\n            if (price > 1e18) {\n                price = 1e18;\n            }\n            require(price >= MINT_MINIMUM_UNIT_PRICE, \"Asset price below peg\");\n        } else {\n            /* Never give out more than 1 normalized unit amount of assets\n             * for one unit of OETH/OUSD when redeeming.\n             */\n            if (price < 1e18) {\n                price = 1e18;\n            }\n        }\n    }\n\n    function _getDecimals(address _asset)\n        internal\n        view\n        returns (uint256 decimals)\n    {\n        decimals = assets[_asset].decimals;\n        require(decimals > 0, \"Decimals not cached\");\n    }\n\n    /**\n     * @notice Return the number of assets supported by the Vault.\n     */\n    function getAssetCount() public view returns (uint256) {\n        return allAssets.length;\n    }\n\n    /**\n     * @notice Gets the vault configuration of a supported asset.\n     */\n    function getAssetConfig(address _asset)\n        public\n        view\n        returns (Asset memory config)\n    {\n        config = assets[_asset];\n    }\n\n    /**\n     * @notice Return all vault asset addresses in order\n     */\n    function getAllAssets() external view returns (address[] memory) {\n        return allAssets;\n    }\n\n    /**\n     * @notice Return the number of strategies active on the Vault.\n     */\n    function getStrategyCount() external view returns (uint256) {\n        return allStrategies.length;\n    }\n\n    /**\n     * @notice Return the array of all strategies\n     */\n    function getAllStrategies() external view returns (address[] memory) {\n        return allStrategies;\n    }\n\n    /**\n     * @notice Returns whether the vault supports the asset\n     * @param _asset address of the asset\n     * @return true if supported\n     */\n    function isSupportedAsset(address _asset) external view returns (bool) {\n        return assets[_asset].isSupported;\n    }\n\n    /**\n     * @dev Falldown to the admin implementation\n     * @notice This is a catch all for all functions not declared in core\n     */\n    // solhint-disable-next-line no-complex-fallback\n    fallback() external {\n        bytes32 slot = adminImplPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(\n                gas(),\n                sload(slot),\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    function abs(int256 x) private pure returns (uint256) {\n        require(x < int256(MAX_INT), \"Amount too high\");\n        return x >= 0 ? uint256(x) : uint256(-x);\n    }\n}\n"
    },
    "contracts/vault/VaultInitializer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OToken VaultInitializer contract\n * @notice The Vault contract initializes the vault.\n * @author Origin Protocol Inc\n */\n\nimport \"./VaultStorage.sol\";\n\ncontract VaultInitializer is VaultStorage {\n    function initialize(address _priceProvider, address _oToken)\n        external\n        onlyGovernor\n        initializer\n    {\n        require(_priceProvider != address(0), \"PriceProvider address is zero\");\n        require(_oToken != address(0), \"oToken address is zero\");\n\n        oUSD = OUSD(_oToken);\n\n        priceProvider = _priceProvider;\n\n        rebasePaused = false;\n        capitalPaused = true;\n\n        // Initial redeem fee of 0 basis points\n        redeemFeeBps = 0;\n        // Initial Vault buffer of 0%\n        vaultBuffer = 0;\n        // Initial allocate threshold of 25,000 OUSD\n        autoAllocateThreshold = 25000e18;\n        // Threshold for rebasing\n        rebaseThreshold = 1000e18;\n        // Initialize all strategies\n        allStrategies = new address[](0);\n    }\n}\n"
    },
    "contracts/vault/VaultStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OToken VaultStorage contract\n * @notice The VaultStorage contract defines the storage for the Vault contracts\n * @author Origin Protocol Inc\n */\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { OUSD } from \"../token/OUSD.sol\";\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport \"../utils/Helpers.sol\";\n\ncontract VaultStorage is Initializable, Governable {\n    using SafeERC20 for IERC20;\n\n    event AssetSupported(address _asset);\n    event AssetRemoved(address _asset);\n    event AssetDefaultStrategyUpdated(address _asset, address _strategy);\n    event AssetAllocated(address _asset, address _strategy, uint256 _amount);\n    event StrategyApproved(address _addr);\n    event StrategyRemoved(address _addr);\n    event Mint(address _addr, uint256 _value);\n    event Redeem(address _addr, uint256 _value);\n    event CapitalPaused();\n    event CapitalUnpaused();\n    event RebasePaused();\n    event RebaseUnpaused();\n    event VaultBufferUpdated(uint256 _vaultBuffer);\n    event OusdMetaStrategyUpdated(address _ousdMetaStrategy);\n    event RedeemFeeUpdated(uint256 _redeemFeeBps);\n    event PriceProviderUpdated(address _priceProvider);\n    event AllocateThresholdUpdated(uint256 _threshold);\n    event RebaseThresholdUpdated(uint256 _threshold);\n    event StrategistUpdated(address _address);\n    event MaxSupplyDiffChanged(uint256 maxSupplyDiff);\n    event YieldDistribution(address _to, uint256 _yield, uint256 _fee);\n    event TrusteeFeeBpsChanged(uint256 _basis);\n    event TrusteeAddressChanged(address _address);\n    event NetOusdMintForStrategyThresholdChanged(uint256 _threshold);\n    event SwapperChanged(address _address);\n    event SwapAllowedUndervalueChanged(uint256 _basis);\n    event SwapSlippageChanged(address _asset, uint256 _basis);\n    event Swapped(\n        address indexed _fromAsset,\n        address indexed _toAsset,\n        uint256 _fromAssetAmount,\n        uint256 _toAssetAmount\n    );\n    event StrategyAddedToMintWhitelist(address indexed strategy);\n    event StrategyRemovedFromMintWhitelist(address indexed strategy);\n    event DripperChanged(address indexed _dripper);\n    event WithdrawalRequested(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount,\n        uint256 _queued\n    );\n    event WithdrawalClaimed(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount\n    );\n    event WithdrawalClaimable(uint256 _claimable, uint256 _newClaimable);\n\n    // Assets supported by the Vault, i.e. Stablecoins\n    enum UnitConversion {\n        DECIMALS,\n        GETEXCHANGERATE\n    }\n    // Changed to fit into a single storage slot so the decimals needs to be recached\n    struct Asset {\n        // Note: OETHVaultCore doesn't use `isSupported` when minting,\n        // redeeming or checking balance of assets.\n        bool isSupported;\n        UnitConversion unitConversion;\n        uint8 decimals;\n        // Max allowed slippage from the Oracle price when swapping collateral assets in basis points.\n        // For example 40 == 0.4% slippage\n        uint16 allowedOracleSlippageBps;\n    }\n\n    /// @dev mapping of supported vault assets to their configuration\n    // slither-disable-next-line uninitialized-state\n    mapping(address => Asset) internal assets;\n    /// @dev list of all assets supported by the vault.\n    // slither-disable-next-line uninitialized-state\n    address[] internal allAssets;\n\n    // Strategies approved for use by the Vault\n    struct Strategy {\n        bool isSupported;\n        uint256 _deprecated; // Deprecated storage slot\n    }\n    /// @dev mapping of strategy contracts to their configuration\n    // slither-disable-next-line uninitialized-state\n    mapping(address => Strategy) internal strategies;\n    /// @dev list of all vault strategies\n    address[] internal allStrategies;\n\n    /// @notice Address of the Oracle price provider contract\n    // slither-disable-next-line uninitialized-state\n    address public priceProvider;\n    /// @notice pause rebasing if true\n    bool public rebasePaused = false;\n    /// @notice pause operations that change the OToken supply.\n    /// eg mint, redeem, allocate, mint/burn for strategy\n    bool public capitalPaused = true;\n    /// @notice Redemption fee in basis points. eg 50 = 0.5%\n    uint256 public redeemFeeBps;\n    /// @notice Percentage of assets to keep in Vault to handle (most) withdrawals. 100% = 1e18.\n    uint256 public vaultBuffer;\n    /// @notice OToken mints over this amount automatically allocate funds. 18 decimals.\n    uint256 public autoAllocateThreshold;\n    /// @notice OToken mints over this amount automatically rebase. 18 decimals.\n    uint256 public rebaseThreshold;\n\n    /// @dev Address of the OToken token. eg OUSD or OETH.\n    // slither-disable-next-line uninitialized-state\n    OUSD internal oUSD;\n\n    //keccak256(\"OUSD.vault.governor.admin.impl\");\n    bytes32 constant adminImplPosition =\n        0xa2bd3d3cf188a41358c8b401076eb59066b09dec5775650c0de4c55187d17bd9;\n\n    // Address of the contract responsible for post rebase syncs with AMMs\n    address private _deprecated_rebaseHooksAddr = address(0);\n\n    // Deprecated: Address of Uniswap\n    // slither-disable-next-line constable-states\n    address private _deprecated_uniswapAddr = address(0);\n\n    /// @notice Address of the Strategist\n    address public strategistAddr = address(0);\n\n    /// @notice Mapping of asset address to the Strategy that they should automatically\n    // be allocated to\n    // slither-disable-next-line uninitialized-state\n    mapping(address => address) public assetDefaultStrategies;\n\n    /// @notice Max difference between total supply and total value of assets. 18 decimals.\n    // slither-disable-next-line uninitialized-state\n    uint256 public maxSupplyDiff;\n\n    /// @notice Trustee contract that can collect a percentage of yield\n    address public trusteeAddress;\n\n    /// @notice Amount of yield collected in basis points. eg 2000 = 20%\n    uint256 public trusteeFeeBps;\n\n    /// @dev Deprecated: Tokens that should be swapped for stablecoins\n    address[] private _deprecated_swapTokens;\n\n    uint256 constant MINT_MINIMUM_UNIT_PRICE = 0.998e18;\n\n    /// @notice Metapool strategy that is allowed to mint/burn OTokens without changing collateral\n\n    // slither-disable-start constable-states\n    // slither-disable-next-line uninitialized-state\n    address public ousdMetaStrategy;\n\n    /// @notice How much OTokens are currently minted by the strategy\n    // slither-disable-next-line uninitialized-state\n    int256 public netOusdMintedForStrategy;\n\n    /// @notice How much net total OTokens are allowed to be minted by all strategies\n    // slither-disable-next-line uninitialized-state\n    uint256 public netOusdMintForStrategyThreshold;\n\n    // slither-disable-end constable-states\n\n    uint256 constant MIN_UNIT_PRICE_DRIFT = 0.7e18;\n    uint256 constant MAX_UNIT_PRICE_DRIFT = 1.3e18;\n\n    /// @notice Collateral swap configuration.\n    /// @dev is packed into a single storage slot to save gas.\n    struct SwapConfig {\n        // Contract that swaps the vault's collateral assets\n        address swapper;\n        // Max allowed percentage the total value can drop below the total supply in basis points.\n        // For example 100 == 1%\n        uint16 allowedUndervalueBps;\n    }\n    SwapConfig internal swapConfig = SwapConfig(address(0), 0);\n\n    // List of strategies that can mint oTokens directly\n    // Used in OETHBaseVaultCore\n    // slither-disable-next-line uninitialized-state\n    mapping(address => bool) public isMintWhitelistedStrategy;\n\n    /// @notice Address of the Dripper contract that streams harvested rewards to the Vault\n    /// @dev The vault is proxied so needs to be set with setDripper against the proxy contract.\n    // slither-disable-start constable-states\n    // slither-disable-next-line uninitialized-state\n    address public dripper;\n    // slither-disable-end constable-states\n\n    /// Withdrawal Queue Storage /////\n\n    struct WithdrawalQueueMetadata {\n        // cumulative total of all withdrawal requests included the ones that have already been claimed\n        uint128 queued;\n        // cumulative total of all the requests that can be claimed including the ones that have already been claimed\n        uint128 claimable;\n        // total of all the requests that have been claimed\n        uint128 claimed;\n        // index of the next withdrawal request starting at 0\n        uint128 nextWithdrawalIndex;\n    }\n\n    /// @notice Global metadata for the withdrawal queue including:\n    /// queued - cumulative total of all withdrawal requests included the ones that have already been claimed\n    /// claimable - cumulative total of all the requests that can be claimed including the ones already claimed\n    /// claimed - total of all the requests that have been claimed\n    /// nextWithdrawalIndex - index of the next withdrawal request starting at 0\n    // slither-disable-next-line uninitialized-state\n    WithdrawalQueueMetadata public withdrawalQueueMetadata;\n\n    struct WithdrawalRequest {\n        address withdrawer;\n        bool claimed;\n        uint40 timestamp; // timestamp of the withdrawal request\n        // Amount of oTokens to redeem. eg OETH\n        uint128 amount;\n        // cumulative total of all withdrawal requests including this one.\n        // this request can be claimed when this queued amount is less than or equal to the queue's claimable amount.\n        uint128 queued;\n    }\n\n    /// @notice Mapping of withdrawal request indices to the user withdrawal request data\n    mapping(uint256 => WithdrawalRequest) public withdrawalRequests;\n\n    // For future use\n    uint256[45] private __gap;\n\n    /**\n     * @notice set the implementation for the admin, this needs to be in a base class else we cannot set it\n     * @param newImpl address of the implementation\n     */\n    function setAdminImpl(address newImpl) external onlyGovernor {\n        require(\n            Address.isContract(newImpl),\n            \"new implementation is not a contract\"\n        );\n        bytes32 position = adminImplPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, newImpl)\n        }\n    }\n}\n"
    },
    "lib/openzeppelin/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is managed by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}