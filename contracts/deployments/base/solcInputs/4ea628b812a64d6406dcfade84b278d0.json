{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouterClient {\n  error UnsupportedDestinationChain(uint64 destChainSelector);\n  error InsufficientFeeTokenAmount();\n  error InvalidMsgValue();\n\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\n  /// @param chainSelector The chain to check.\n  /// @return supported is true if it is supported, false if not.\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\n\n  /// @notice Gets a list of all supported tokens which can be sent or received\n  /// to/from a given chain id.\n  /// @param chainSelector The chainSelector.\n  /// @return tokens The addresses of all tokens that are supported.\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\n\n  /// @param destinationChainSelector The destination chainSelector\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return fee returns execution fee for the message\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function getFee(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage memory message\n  ) external view returns (uint256 fee);\n\n  /// @notice Request a message to be sent to the destination chain\n  /// @param destinationChainSelector The destination chain ID\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return messageId The message ID\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\n  /// the overpayment with no refund.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\n    bytes data; // Data payload\n    EVMTokenAmount[] tokenAmounts; // Token transfers\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\n  }\n\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit;\n  }\n\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/libs/ExecutorOptions.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol\";\n\nlibrary ExecutorOptions {\n    using CalldataBytesLib for bytes;\n\n    uint8 internal constant WORKER_ID = 1;\n\n    uint8 internal constant OPTION_TYPE_LZRECEIVE = 1;\n    uint8 internal constant OPTION_TYPE_NATIVE_DROP = 2;\n    uint8 internal constant OPTION_TYPE_LZCOMPOSE = 3;\n    uint8 internal constant OPTION_TYPE_ORDERED_EXECUTION = 4;\n    uint8 internal constant OPTION_TYPE_LZREAD = 5;\n\n    error Executor_InvalidLzReceiveOption();\n    error Executor_InvalidNativeDropOption();\n    error Executor_InvalidLzComposeOption();\n    error Executor_InvalidLzReadOption();\n\n    /// @dev decode the next executor option from the options starting from the specified cursor\n    /// @param _options [executor_id][executor_option][executor_id][executor_option]...\n    ///        executor_option = [option_size][option_type][option]\n    ///        option_size = len(option_type) + len(option)\n    ///        executor_id: uint8, option_size: uint16, option_type: uint8, option: bytes\n    /// @param _cursor the cursor to start decoding from\n    /// @return optionType the type of the option\n    /// @return option the option of the executor\n    /// @return cursor the cursor to start decoding the next executor option\n    function nextExecutorOption(\n        bytes calldata _options,\n        uint256 _cursor\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {\n        unchecked {\n            // skip worker id\n            cursor = _cursor + 1;\n\n            // read option size\n            uint16 size = _options.toU16(cursor);\n            cursor += 2;\n\n            // read option type\n            optionType = _options.toU8(cursor);\n\n            // startCursor and endCursor are used to slice the option from _options\n            uint256 startCursor = cursor + 1; // skip option type\n            uint256 endCursor = cursor + size;\n            option = _options[startCursor:endCursor];\n            cursor += size;\n        }\n    }\n\n    function decodeLzReceiveOption(bytes calldata _option) internal pure returns (uint128 gas, uint128 value) {\n        if (_option.length != 16 && _option.length != 32) revert Executor_InvalidLzReceiveOption();\n        gas = _option.toU128(0);\n        value = _option.length == 32 ? _option.toU128(16) : 0;\n    }\n\n    function decodeNativeDropOption(bytes calldata _option) internal pure returns (uint128 amount, bytes32 receiver) {\n        if (_option.length != 48) revert Executor_InvalidNativeDropOption();\n        amount = _option.toU128(0);\n        receiver = _option.toB32(16);\n    }\n\n    function decodeLzComposeOption(\n        bytes calldata _option\n    ) internal pure returns (uint16 index, uint128 gas, uint128 value) {\n        if (_option.length != 18 && _option.length != 34) revert Executor_InvalidLzComposeOption();\n        index = _option.toU16(0);\n        gas = _option.toU128(2);\n        value = _option.length == 34 ? _option.toU128(18) : 0;\n    }\n\n    function decodeLzReadOption(\n        bytes calldata _option\n    ) internal pure returns (uint128 gas, uint32 calldataSize, uint128 value) {\n        if (_option.length != 20 && _option.length != 36) revert Executor_InvalidLzReadOption();\n        gas = _option.toU128(0);\n        calldataSize = _option.toU32(16);\n        value = _option.length == 36 ? _option.toU128(20) : 0;\n    }\n\n    function encodeLzReceiveOption(uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_gas) : abi.encodePacked(_gas, _value);\n    }\n\n    function encodeNativeDropOption(uint128 _amount, bytes32 _receiver) internal pure returns (bytes memory) {\n        return abi.encodePacked(_amount, _receiver);\n    }\n\n    function encodeLzComposeOption(uint16 _index, uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_index, _gas) : abi.encodePacked(_index, _gas, _value);\n    }\n\n    function encodeLzReadOption(\n        uint128 _gas,\n        uint32 _calldataSize,\n        uint128 _value\n    ) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_gas, _calldataSize) : abi.encodePacked(_gas, _calldataSize, _value);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/DVNOptions.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { BytesLib } from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport { BitMap256 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol\";\nimport { CalldataBytesLib } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol\";\n\nlibrary DVNOptions {\n    using CalldataBytesLib for bytes;\n    using BytesLib for bytes;\n\n    uint8 internal constant WORKER_ID = 2;\n    uint8 internal constant OPTION_TYPE_PRECRIME = 1;\n\n    error DVN_InvalidDVNIdx();\n    error DVN_InvalidDVNOptions(uint256 cursor);\n\n    /// @dev group dvn options by its idx\n    /// @param _options [dvn_id][dvn_option][dvn_id][dvn_option]...\n    ///        dvn_option = [option_size][dvn_idx][option_type][option]\n    ///        option_size = len(dvn_idx) + len(option_type) + len(option)\n    ///        dvn_id: uint8, dvn_idx: uint8, option_size: uint16, option_type: uint8, option: bytes\n    /// @return dvnOptions the grouped options, still share the same format of _options\n    /// @return dvnIndices the dvn indices\n    function groupDVNOptionsByIdx(\n        bytes memory _options\n    ) internal pure returns (bytes[] memory dvnOptions, uint8[] memory dvnIndices) {\n        if (_options.length == 0) return (dvnOptions, dvnIndices);\n\n        uint8 numDVNs = getNumDVNs(_options);\n\n        // if there is only 1 dvn, we can just return the whole options\n        if (numDVNs == 1) {\n            dvnOptions = new bytes[](1);\n            dvnOptions[0] = _options;\n\n            dvnIndices = new uint8[](1);\n            dvnIndices[0] = _options.toUint8(3); // dvn idx\n            return (dvnOptions, dvnIndices);\n        }\n\n        // otherwise, we need to group the options by dvn_idx\n        dvnIndices = new uint8[](numDVNs);\n        dvnOptions = new bytes[](numDVNs);\n        unchecked {\n            uint256 cursor = 0;\n            uint256 start = 0;\n            uint8 lastDVNIdx = 255; // 255 is an invalid dvn_idx\n\n            while (cursor < _options.length) {\n                ++cursor; // skip worker_id\n\n                // optionLength asserted in getNumDVNs (skip check)\n                uint16 optionLength = _options.toUint16(cursor);\n                cursor += 2;\n\n                // dvnIdx asserted in getNumDVNs (skip check)\n                uint8 dvnIdx = _options.toUint8(cursor);\n\n                // dvnIdx must equal to the lastDVNIdx for the first option\n                // so it is always skipped in the first option\n                // this operation slices out options whenever the scan finds a different lastDVNIdx\n                if (lastDVNIdx == 255) {\n                    lastDVNIdx = dvnIdx;\n                } else if (dvnIdx != lastDVNIdx) {\n                    uint256 len = cursor - start - 3; // 3 is for worker_id and option_length\n                    bytes memory opt = _options.slice(start, len);\n                    _insertDVNOptions(dvnOptions, dvnIndices, lastDVNIdx, opt);\n\n                    // reset the start and lastDVNIdx\n                    start += len;\n                    lastDVNIdx = dvnIdx;\n                }\n\n                cursor += optionLength;\n            }\n\n            // skip check the cursor here because the cursor is asserted in getNumDVNs\n            // if we have reached the end of the options, we need to process the last dvn\n            uint256 size = cursor - start;\n            bytes memory op = _options.slice(start, size);\n            _insertDVNOptions(dvnOptions, dvnIndices, lastDVNIdx, op);\n\n            // revert dvnIndices to start from 0\n            for (uint8 i = 0; i < numDVNs; ++i) {\n                --dvnIndices[i];\n            }\n        }\n    }\n\n    function _insertDVNOptions(\n        bytes[] memory _dvnOptions,\n        uint8[] memory _dvnIndices,\n        uint8 _dvnIdx,\n        bytes memory _newOptions\n    ) internal pure {\n        // dvnIdx starts from 0 but default value of dvnIndices is 0,\n        // so we tell if the slot is empty by adding 1 to dvnIdx\n        if (_dvnIdx == 255) revert DVN_InvalidDVNIdx();\n        uint8 dvnIdxAdj = _dvnIdx + 1;\n\n        for (uint256 j = 0; j < _dvnIndices.length; ++j) {\n            uint8 index = _dvnIndices[j];\n            if (dvnIdxAdj == index) {\n                _dvnOptions[j] = abi.encodePacked(_dvnOptions[j], _newOptions);\n                break;\n            } else if (index == 0) {\n                // empty slot, that means it is the first time we see this dvn\n                _dvnIndices[j] = dvnIdxAdj;\n                _dvnOptions[j] = _newOptions;\n                break;\n            }\n        }\n    }\n\n    /// @dev get the number of unique dvns\n    /// @param _options the format is the same as groupDVNOptionsByIdx\n    function getNumDVNs(bytes memory _options) internal pure returns (uint8 numDVNs) {\n        uint256 cursor = 0;\n        BitMap256 bitmap;\n\n        // find number of unique dvn_idx\n        unchecked {\n            while (cursor < _options.length) {\n                ++cursor; // skip worker_id\n\n                uint16 optionLength = _options.toUint16(cursor);\n                cursor += 2;\n                if (optionLength < 2) revert DVN_InvalidDVNOptions(cursor); // at least 1 byte for dvn_idx and 1 byte for option_type\n\n                uint8 dvnIdx = _options.toUint8(cursor);\n\n                // if dvnIdx is not set, increment numDVNs\n                // max num of dvns is 255, 255 is an invalid dvn_idx\n                // The order of the dvnIdx is not required to be sequential, as enforcing the order may weaken\n                // the composability of the options. e.g. if we refrain from enforcing the order, an OApp that has\n                // already enforced certain options can append additional options to the end of the enforced\n                // ones without restrictions.\n                if (dvnIdx == 255) revert DVN_InvalidDVNIdx();\n                if (!bitmap.get(dvnIdx)) {\n                    ++numDVNs;\n                    bitmap = bitmap.set(dvnIdx);\n                }\n\n                cursor += optionLength;\n            }\n        }\n        if (cursor != _options.length) revert DVN_InvalidDVNOptions(cursor);\n    }\n\n    /// @dev decode the next dvn option from _options starting from the specified cursor\n    /// @param _options the format is the same as groupDVNOptionsByIdx\n    /// @param _cursor the cursor to start decoding\n    /// @return optionType the type of the option\n    /// @return option the option\n    /// @return cursor the cursor to start decoding the next option\n    function nextDVNOption(\n        bytes calldata _options,\n        uint256 _cursor\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {\n        unchecked {\n            // skip worker id\n            cursor = _cursor + 1;\n\n            // read option size\n            uint16 size = _options.toU16(cursor);\n            cursor += 2;\n\n            // read option type\n            optionType = _options.toU8(cursor + 1); // skip dvn_idx\n\n            // startCursor and endCursor are used to slice the option from _options\n            uint256 startCursor = cursor + 2; // skip option type and dvn_idx\n            uint256 endCursor = cursor + size;\n            option = _options[startCursor:endCursor];\n            cursor += size;\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IMessageLibManager } from \"./IMessageLibManager.sol\";\nimport { IMessagingComposer } from \"./IMessagingComposer.sol\";\nimport { IMessagingChannel } from \"./IMessagingChannel.sol\";\nimport { IMessagingContext } from \"./IMessagingContext.sol\";\n\nstruct MessagingParams {\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes message;\n    bytes options;\n    bool payInLzToken;\n}\n\nstruct MessagingReceipt {\n    bytes32 guid;\n    uint64 nonce;\n    MessagingFee fee;\n}\n\nstruct MessagingFee {\n    uint256 nativeFee;\n    uint256 lzTokenFee;\n}\n\nstruct Origin {\n    uint32 srcEid;\n    bytes32 sender;\n    uint64 nonce;\n}\n\ninterface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\n\n    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);\n\n    event PacketDelivered(Origin origin, address receiver);\n\n    event LzReceiveAlert(\n        address indexed receiver,\n        address indexed executor,\n        Origin origin,\n        bytes32 guid,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    event LzTokenSet(address token);\n\n    event DelegateSet(address sender, address delegate);\n\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory);\n\n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory);\n\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;\n\n    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function initializable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function lzReceive(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n\n    // oapp can burn messages partially by calling this function with its own business logic if messages are verified in order\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;\n\n    function setLzToken(address _lzToken) external;\n\n    function lzToken() external view returns (address);\n\n    function nativeToken() external view returns (address);\n\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { Origin } from \"./ILayerZeroEndpointV2.sol\";\n\ninterface ILayerZeroReceiver {\n    function allowInitializePath(Origin calldata _origin) external view returns (bool);\n\n    function nextNonce(uint32 _eid, bytes32 _sender) external view returns (uint64);\n\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport { SetConfigParam } from \"./IMessageLibManager.sol\";\n\nenum MessageLibType {\n    Send,\n    Receive,\n    SendAndReceive\n}\n\ninterface IMessageLib is IERC165 {\n    function setConfig(address _oapp, SetConfigParam[] calldata _config) external;\n\n    function getConfig(uint32 _eid, address _oapp, uint32 _configType) external view returns (bytes memory config);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    // message libs of same major version are compatible\n    function version() external view returns (uint64 major, uint8 minor, uint8 endpointVersion);\n\n    function messageLibType() external view returns (MessageLibType);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nstruct SetConfigParam {\n    uint32 eid;\n    uint32 configType;\n    bytes config;\n}\n\ninterface IMessageLibManager {\n    struct Timeout {\n        address lib;\n        uint256 expiry;\n    }\n\n    event LibraryRegistered(address newLib);\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\n    event ReceiveLibrarySet(address receiver, uint32 eid, address newLib);\n    event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);\n\n    function registerLibrary(address _lib) external;\n\n    function isRegisteredLibrary(address _lib) external view returns (bool);\n\n    function getRegisteredLibraries() external view returns (address[] memory);\n\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\n\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    function isValidReceiveLibrary(address _receiver, uint32 _eid, address _lib) external view returns (bool);\n\n    /// ------------------- OApp interfaces -------------------\n    function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;\n\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\n\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\n\n    function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\n\n    function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external;\n\n    function getConfig(\n        address _oapp,\n        address _lib,\n        uint32 _eid,\n        uint32 _configType\n    ) external view returns (bytes memory config);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingChannel {\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\n    event PacketNilified(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n    event PacketBurnt(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n\n    function eid() external view returns (uint32);\n\n    // this is an emergency function if a message cannot be verified for some reasons\n    // required to provide _nextNonce to avoid race condition\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\n\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\n\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\n\n    function inboundPayloadHash(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce\n    ) external view returns (bytes32);\n\n    function lazyInboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingComposer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingComposer {\n    event ComposeSent(address from, address to, bytes32 guid, uint16 index, bytes message);\n    event ComposeDelivered(address from, address to, bytes32 guid, uint16 index);\n    event LzComposeAlert(\n        address indexed from,\n        address indexed to,\n        address indexed executor,\n        bytes32 guid,\n        uint16 index,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    function composeQueue(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index\n    ) external view returns (bytes32 messageHash);\n\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external;\n\n    function lzCompose(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingContext {\n    function isSendingMessage() external view returns (bool);\n\n    function getSendContext() external view returns (uint32 dstEid, address sender);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { MessagingFee } from \"./ILayerZeroEndpointV2.sol\";\nimport { IMessageLib } from \"./IMessageLib.sol\";\n\nstruct Packet {\n    uint64 nonce;\n    uint32 srcEid;\n    address sender;\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes32 guid;\n    bytes message;\n}\n\ninterface ISendLib is IMessageLib {\n    function send(\n        Packet calldata _packet,\n        bytes calldata _options,\n        bool _payInLzToken\n    ) external returns (MessagingFee memory, bytes memory encodedPacket);\n\n    function quote(\n        Packet calldata _packet,\n        bytes calldata _options,\n        bool _payInLzToken\n    ) external view returns (MessagingFee memory);\n\n    function setTreasury(address _treasury) external;\n\n    function withdrawFee(address _to, uint256 _amount) external;\n\n    function withdrawLzTokenFee(address _lzToken, address _to, uint256 _amount) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nlibrary AddressCast {\n    error AddressCast_InvalidSizeForAddress();\n    error AddressCast_InvalidAddress();\n\n    function toBytes32(bytes calldata _addressBytes) internal pure returns (bytes32 result) {\n        if (_addressBytes.length > 32) revert AddressCast_InvalidAddress();\n        result = bytes32(_addressBytes);\n        unchecked {\n            uint256 offset = 32 - _addressBytes.length;\n            result = result >> (offset * 8);\n        }\n    }\n\n    function toBytes32(address _address) internal pure returns (bytes32 result) {\n        result = bytes32(uint256(uint160(_address)));\n    }\n\n    function toBytes(bytes32 _addressBytes32, uint256 _size) internal pure returns (bytes memory result) {\n        if (_size == 0 || _size > 32) revert AddressCast_InvalidSizeForAddress();\n        result = new bytes(_size);\n        unchecked {\n            uint256 offset = 256 - _size * 8;\n            assembly {\n                mstore(add(result, 32), shl(offset, _addressBytes32))\n            }\n        }\n    }\n\n    function toAddress(bytes32 _addressBytes32) internal pure returns (address result) {\n        result = address(uint160(uint256(_addressBytes32)));\n    }\n\n    function toAddress(bytes calldata _addressBytes) internal pure returns (address result) {\n        if (_addressBytes.length != 20) revert AddressCast_InvalidAddress();\n        result = address(bytes20(_addressBytes));\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nlibrary CalldataBytesLib {\n    function toU8(bytes calldata _bytes, uint256 _start) internal pure returns (uint8) {\n        return uint8(_bytes[_start]);\n    }\n\n    function toU16(bytes calldata _bytes, uint256 _start) internal pure returns (uint16) {\n        unchecked {\n            uint256 end = _start + 2;\n            return uint16(bytes2(_bytes[_start:end]));\n        }\n    }\n\n    function toU32(bytes calldata _bytes, uint256 _start) internal pure returns (uint32) {\n        unchecked {\n            uint256 end = _start + 4;\n            return uint32(bytes4(_bytes[_start:end]));\n        }\n    }\n\n    function toU64(bytes calldata _bytes, uint256 _start) internal pure returns (uint64) {\n        unchecked {\n            uint256 end = _start + 8;\n            return uint64(bytes8(_bytes[_start:end]));\n        }\n    }\n\n    function toU128(bytes calldata _bytes, uint256 _start) internal pure returns (uint128) {\n        unchecked {\n            uint256 end = _start + 16;\n            return uint128(bytes16(_bytes[_start:end]));\n        }\n    }\n\n    function toU256(bytes calldata _bytes, uint256 _start) internal pure returns (uint256) {\n        unchecked {\n            uint256 end = _start + 32;\n            return uint256(bytes32(_bytes[_start:end]));\n        }\n    }\n\n    function toAddr(bytes calldata _bytes, uint256 _start) internal pure returns (address) {\n        unchecked {\n            uint256 end = _start + 20;\n            return address(bytes20(_bytes[_start:end]));\n        }\n    }\n\n    function toB32(bytes calldata _bytes, uint256 _start) internal pure returns (bytes32) {\n        unchecked {\n            uint256 end = _start + 32;\n            return bytes32(_bytes[_start:end]);\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/BitMaps.sol\npragma solidity ^0.8.20;\n\ntype BitMap256 is uint256;\n\nusing BitMaps for BitMap256 global;\n\nlibrary BitMaps {\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap256 bitmap, uint8 index) internal pure returns (bool) {\n        uint256 mask = 1 << index;\n        return BitMap256.unwrap(bitmap) & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap256 bitmap, uint8 index) internal pure returns (BitMap256) {\n        uint256 mask = 1 << index;\n        return BitMap256.wrap(BitMap256.unwrap(bitmap) | mask);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Packet } from \"../../interfaces/ISendLib.sol\";\nimport { AddressCast } from \"../../libs/AddressCast.sol\";\n\nlibrary PacketV1Codec {\n    using AddressCast for address;\n    using AddressCast for bytes32;\n\n    uint8 internal constant PACKET_VERSION = 1;\n\n    // header (version + nonce + path)\n    // version\n    uint256 private constant PACKET_VERSION_OFFSET = 0;\n    //    nonce\n    uint256 private constant NONCE_OFFSET = 1;\n    //    path\n    uint256 private constant SRC_EID_OFFSET = 9;\n    uint256 private constant SENDER_OFFSET = 13;\n    uint256 private constant DST_EID_OFFSET = 45;\n    uint256 private constant RECEIVER_OFFSET = 49;\n    // payload (guid + message)\n    uint256 private constant GUID_OFFSET = 81; // keccak256(nonce + path)\n    uint256 private constant MESSAGE_OFFSET = 113;\n\n    function encode(Packet memory _packet) internal pure returns (bytes memory encodedPacket) {\n        encodedPacket = abi.encodePacked(\n            PACKET_VERSION,\n            _packet.nonce,\n            _packet.srcEid,\n            _packet.sender.toBytes32(),\n            _packet.dstEid,\n            _packet.receiver,\n            _packet.guid,\n            _packet.message\n        );\n    }\n\n    function encodePacketHeader(Packet memory _packet) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                PACKET_VERSION,\n                _packet.nonce,\n                _packet.srcEid,\n                _packet.sender.toBytes32(),\n                _packet.dstEid,\n                _packet.receiver\n            );\n    }\n\n    function encodePayload(Packet memory _packet) internal pure returns (bytes memory) {\n        return abi.encodePacked(_packet.guid, _packet.message);\n    }\n\n    function header(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return _packet[0:GUID_OFFSET];\n    }\n\n    function version(bytes calldata _packet) internal pure returns (uint8) {\n        return uint8(bytes1(_packet[PACKET_VERSION_OFFSET:NONCE_OFFSET]));\n    }\n\n    function nonce(bytes calldata _packet) internal pure returns (uint64) {\n        return uint64(bytes8(_packet[NONCE_OFFSET:SRC_EID_OFFSET]));\n    }\n\n    function srcEid(bytes calldata _packet) internal pure returns (uint32) {\n        return uint32(bytes4(_packet[SRC_EID_OFFSET:SENDER_OFFSET]));\n    }\n\n    function sender(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[SENDER_OFFSET:DST_EID_OFFSET]);\n    }\n\n    function senderAddressB20(bytes calldata _packet) internal pure returns (address) {\n        return sender(_packet).toAddress();\n    }\n\n    function dstEid(bytes calldata _packet) internal pure returns (uint32) {\n        return uint32(bytes4(_packet[DST_EID_OFFSET:RECEIVER_OFFSET]));\n    }\n\n    function receiver(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[RECEIVER_OFFSET:GUID_OFFSET]);\n    }\n\n    function receiverB20(bytes calldata _packet) internal pure returns (address) {\n        return receiver(_packet).toAddress();\n    }\n\n    function guid(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[GUID_OFFSET:MESSAGE_OFFSET]);\n    }\n\n    function message(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return bytes(_packet[MESSAGE_OFFSET:]);\n    }\n\n    function payload(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return bytes(_packet[GUID_OFFSET:]);\n    }\n\n    function payloadHash(bytes calldata _packet) internal pure returns (bytes32) {\n        return keccak256(payload(_packet));\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { ILayerZeroEndpointV2 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\n/**\n * @title IOAppCore\n */\ninterface IOAppCore {\n    // Custom error messages\n    error OnlyPeer(uint32 eid, bytes32 sender);\n    error NoPeer(uint32 eid);\n    error InvalidEndpointCall();\n    error InvalidDelegate();\n\n    // Event emitted when a peer (OApp) is set for a corresponding endpoint\n    event PeerSet(uint32 eid, bytes32 peer);\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     */\n    function oAppVersion() external view returns (uint64 senderVersion, uint64 receiverVersion);\n\n    /**\n     * @notice Retrieves the LayerZero endpoint associated with the OApp.\n     * @return iEndpoint The LayerZero endpoint as an interface.\n     */\n    function endpoint() external view returns (ILayerZeroEndpointV2 iEndpoint);\n\n    /**\n     * @notice Retrieves the peer (OApp) associated with a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @return peer The peer address (OApp instance) associated with the corresponding endpoint.\n     */\n    function peers(uint32 _eid) external view returns (bytes32 peer);\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) external;\n\n    /**\n     * @notice Sets the delegate address for the OApp Core.\n     * @param _delegate The address of the delegate to be set.\n     */\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppMsgInspector.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @title IOAppMsgInspector\n * @dev Interface for the OApp Message Inspector, allowing examination of message and options contents.\n */\ninterface IOAppMsgInspector {\n    // Custom error message for inspection failure\n    error InspectionFailed(bytes message, bytes options);\n\n    /**\n     * @notice Allows the inspector to examine LayerZero message contents and optionally throw a revert if invalid.\n     * @param _message The message payload to be inspected.\n     * @param _options Additional options or parameters for inspection.\n     * @return valid A boolean indicating whether the inspection passed (true) or failed (false).\n     *\n     * @dev Optionally done as a revert, OR use the boolean provided to handle the failure.\n     */\n    function inspect(bytes calldata _message, bytes calldata _options) external view returns (bool valid);\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppOptionsType3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Struct representing enforced option parameters.\n */\nstruct EnforcedOptionParam {\n    uint32 eid; // Endpoint ID\n    uint16 msgType; // Message Type\n    bytes options; // Additional options\n}\n\n/**\n * @title IOAppOptionsType3\n * @dev Interface for the OApp with Type 3 Options, allowing the setting and combining of enforced options.\n */\ninterface IOAppOptionsType3 {\n    // Custom error message for invalid options\n    error InvalidOptions(bytes options);\n\n    // Event emitted when enforced options are set\n    event EnforcedOptionSet(EnforcedOptionParam[] _enforcedOptions);\n\n    /**\n     * @notice Sets enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     */\n    function setEnforcedOptions(EnforcedOptionParam[] calldata _enforcedOptions) external;\n\n    /**\n     * @notice Combines options for a given endpoint and message type.\n     * @param _eid The endpoint ID.\n     * @param _msgType The OApp message type.\n     * @param _extraOptions Additional options passed by the caller.\n     * @return options The combination of caller specified options AND enforced options.\n     */\n    function combineOptions(\n        uint32 _eid,\n        uint16 _msgType,\n        bytes calldata _extraOptions\n    ) external view returns (bytes memory options);\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ILayerZeroReceiver, Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\";\n\ninterface IOAppReceiver is ILayerZeroReceiver {\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement a separate composeMsg sender that is NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata _origin,\n        bytes calldata _message,\n        address _sender\n    ) external view returns (bool isSender);\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/libs/OAppOptionsType3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IOAppOptionsType3, EnforcedOptionParam } from \"../interfaces/IOAppOptionsType3.sol\";\n\n/**\n * @title OAppOptionsType3\n * @dev Abstract contract implementing the IOAppOptionsType3 interface with type 3 options.\n */\nabstract contract OAppOptionsType3 is IOAppOptionsType3, Ownable {\n    uint16 internal constant OPTION_TYPE_3 = 3;\n\n    // @dev The \"msgType\" should be defined in the child contract.\n    mapping(uint32 eid => mapping(uint16 msgType => bytes enforcedOption)) public enforcedOptions;\n\n    /**\n     * @dev Sets the enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides a way for the OApp to enforce things like paying for PreCrime, AND/OR minimum dst lzReceive gas amounts etc.\n     * @dev These enforced options can vary as the potential options/execution on the remote may differ as per the msgType.\n     * eg. Amount of lzReceive() gas necessary to deliver a lzCompose() message adds overhead you dont want to pay\n     * if you are only making a standard LayerZero message ie. lzReceive() WITHOUT sendCompose().\n     */\n    function setEnforcedOptions(EnforcedOptionParam[] calldata _enforcedOptions) public virtual onlyOwner {\n        _setEnforcedOptions(_enforcedOptions);\n    }\n\n    /**\n     * @dev Sets the enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     *\n     * @dev Provides a way for the OApp to enforce things like paying for PreCrime, AND/OR minimum dst lzReceive gas amounts etc.\n     * @dev These enforced options can vary as the potential options/execution on the remote may differ as per the msgType.\n     * eg. Amount of lzReceive() gas necessary to deliver a lzCompose() message adds overhead you dont want to pay\n     * if you are only making a standard LayerZero message ie. lzReceive() WITHOUT sendCompose().\n     */\n    function _setEnforcedOptions(EnforcedOptionParam[] memory _enforcedOptions) internal virtual {\n        for (uint256 i = 0; i < _enforcedOptions.length; i++) {\n            // @dev Enforced options are only available for optionType 3, as type 1 and 2 dont support combining.\n            _assertOptionsType3(_enforcedOptions[i].options);\n            enforcedOptions[_enforcedOptions[i].eid][_enforcedOptions[i].msgType] = _enforcedOptions[i].options;\n        }\n\n        emit EnforcedOptionSet(_enforcedOptions);\n    }\n\n    /**\n     * @notice Combines options for a given endpoint and message type.\n     * @param _eid The endpoint ID.\n     * @param _msgType The OAPP message type.\n     * @param _extraOptions Additional options passed by the caller.\n     * @return options The combination of caller specified options AND enforced options.\n     *\n     * @dev If there is an enforced lzReceive option:\n     * - {gasLimit: 200k, msg.value: 1 ether} AND a caller supplies a lzReceive option: {gasLimit: 100k, msg.value: 0.5 ether}\n     * - The resulting options will be {gasLimit: 300k, msg.value: 1.5 ether} when the message is executed on the remote lzReceive() function.\n     * @dev This presence of duplicated options is handled off-chain in the verifier/executor.\n     */\n    function combineOptions(\n        uint32 _eid,\n        uint16 _msgType,\n        bytes calldata _extraOptions\n    ) public view virtual returns (bytes memory) {\n        bytes memory enforced = enforcedOptions[_eid][_msgType];\n\n        // No enforced options, pass whatever the caller supplied, even if it's empty or legacy type 1/2 options.\n        if (enforced.length == 0) return _extraOptions;\n\n        // No caller options, return enforced\n        if (_extraOptions.length == 0) return enforced;\n\n        // @dev If caller provided _extraOptions, must be type 3 as its the ONLY type that can be combined.\n        if (_extraOptions.length >= 2) {\n            _assertOptionsType3(_extraOptions);\n            // @dev Remove the first 2 bytes containing the type from the _extraOptions and combine with enforced.\n            return bytes.concat(enforced, _extraOptions[2:]);\n        }\n\n        // No valid set of options was found.\n        revert InvalidOptions(_extraOptions);\n    }\n\n    /**\n     * @dev Internal function to assert that options are of type 3.\n     * @param _options The options to be checked.\n     */\n    function _assertOptionsType3(bytes memory _options) internal pure virtual {\n        uint16 optionsType;\n        assembly {\n            optionsType := mload(add(_options, 2))\n        }\n        if (optionsType != OPTION_TYPE_3) revert InvalidOptions(_options);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/libs/OptionsBuilder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { BytesLib } from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { ExecutorOptions } from \"@layerzerolabs/lz-evm-messagelib-v2/contracts/libs/ExecutorOptions.sol\";\nimport { DVNOptions } from \"@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/DVNOptions.sol\";\n\n/**\n * @title OptionsBuilder\n * @dev Library for building and encoding various message options.\n */\nlibrary OptionsBuilder {\n    using SafeCast for uint256;\n    using BytesLib for bytes;\n\n    // Constants for options types\n    uint16 internal constant TYPE_1 = 1; // legacy options type 1\n    uint16 internal constant TYPE_2 = 2; // legacy options type 2\n    uint16 internal constant TYPE_3 = 3;\n\n    // Custom error message\n    error InvalidSize(uint256 max, uint256 actual);\n    error InvalidOptionType(uint16 optionType);\n\n    // Modifier to ensure only options of type 3 are used\n    modifier onlyType3(bytes memory _options) {\n        if (_options.toUint16(0) != TYPE_3) revert InvalidOptionType(_options.toUint16(0));\n        _;\n    }\n\n    /**\n     * @dev Creates a new options container with type 3.\n     * @return options The newly created options container.\n     */\n    function newOptions() internal pure returns (bytes memory) {\n        return abi.encodePacked(TYPE_3);\n    }\n\n    /**\n     * @dev Adds an executor LZ receive option to the existing options.\n     * @param _options The existing options container.\n     * @param _gas The gasLimit used on the lzReceive() function in the OApp.\n     * @param _value The msg.value passed to the lzReceive() function in the OApp.\n     * @return options The updated options container.\n     *\n     * @dev When multiples of this option are added, they are summed by the executor\n     * eg. if (_gas: 200k, and _value: 1 ether) AND (_gas: 100k, _value: 0.5 ether) are sent in an option to the LayerZeroEndpoint,\n     * that becomes (300k, 1.5 ether) when the message is executed on the remote lzReceive() function.\n     */\n    function addExecutorLzReceiveOption(\n        bytes memory _options,\n        uint128 _gas,\n        uint128 _value\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeLzReceiveOption(_gas, _value);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZRECEIVE, option);\n    }\n\n    /**\n     * @dev Adds an executor native drop option to the existing options.\n     * @param _options The existing options container.\n     * @param _amount The amount for the native value that is airdropped to the 'receiver'.\n     * @param _receiver The receiver address for the native drop option.\n     * @return options The updated options container.\n     *\n     * @dev When multiples of this option are added, they are summed by the executor on the remote chain.\n     */\n    function addExecutorNativeDropOption(\n        bytes memory _options,\n        uint128 _amount,\n        bytes32 _receiver\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeNativeDropOption(_amount, _receiver);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_NATIVE_DROP, option);\n    }\n\n    // /**\n    //  * @dev Adds an executor native drop option to the existing options.\n    //  * @param _options The existing options container.\n    //  * @param _amount The amount for the native value that is airdropped to the 'receiver'.\n    //  * @param _receiver The receiver address for the native drop option.\n    //  * @return options The updated options container.\n    //  *\n    //  * @dev When multiples of this option are added, they are summed by the executor on the remote chain.\n    //  */\n    function addExecutorLzReadOption(\n        bytes memory _options,\n        uint128 _gas,\n        uint32 _size,\n        uint128 _value\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeLzReadOption(_gas, _size, _value);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZREAD, option);\n    }\n\n    /**\n     * @dev Adds an executor LZ compose option to the existing options.\n     * @param _options The existing options container.\n     * @param _index The index for the lzCompose() function call.\n     * @param _gas The gasLimit for the lzCompose() function call.\n     * @param _value The msg.value for the lzCompose() function call.\n     * @return options The updated options container.\n     *\n     * @dev When multiples of this option are added, they are summed PER index by the executor on the remote chain.\n     * @dev If the OApp sends N lzCompose calls on the remote, you must provide N incremented indexes starting with 0.\n     * ie. When your remote OApp composes (N = 3) messages, you must set this option for index 0,1,2\n     */\n    function addExecutorLzComposeOption(\n        bytes memory _options,\n        uint16 _index,\n        uint128 _gas,\n        uint128 _value\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeLzComposeOption(_index, _gas, _value);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZCOMPOSE, option);\n    }\n\n    /**\n     * @dev Adds an executor ordered execution option to the existing options.\n     * @param _options The existing options container.\n     * @return options The updated options container.\n     */\n    function addExecutorOrderedExecutionOption(\n        bytes memory _options\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_ORDERED_EXECUTION, bytes(\"\"));\n    }\n\n    /**\n     * @dev Adds a DVN pre-crime option to the existing options.\n     * @param _options The existing options container.\n     * @param _dvnIdx The DVN index for the pre-crime option.\n     * @return options The updated options container.\n     */\n    function addDVNPreCrimeOption(\n        bytes memory _options,\n        uint8 _dvnIdx\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return addDVNOption(_options, _dvnIdx, DVNOptions.OPTION_TYPE_PRECRIME, bytes(\"\"));\n    }\n\n    /**\n     * @dev Adds an executor option to the existing options.\n     * @param _options The existing options container.\n     * @param _optionType The type of the executor option.\n     * @param _option The encoded data for the executor option.\n     * @return options The updated options container.\n     */\n    function addExecutorOption(\n        bytes memory _options,\n        uint8 _optionType,\n        bytes memory _option\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _options,\n                ExecutorOptions.WORKER_ID,\n                _option.length.toUint16() + 1, // +1 for optionType\n                _optionType,\n                _option\n            );\n    }\n\n    /**\n     * @dev Adds a DVN option to the existing options.\n     * @param _options The existing options container.\n     * @param _dvnIdx The DVN index for the DVN option.\n     * @param _optionType The type of the DVN option.\n     * @param _option The encoded data for the DVN option.\n     * @return options The updated options container.\n     */\n    function addDVNOption(\n        bytes memory _options,\n        uint8 _dvnIdx,\n        uint8 _optionType,\n        bytes memory _option\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _options,\n                DVNOptions.WORKER_ID,\n                _option.length.toUint16() + 2, // +2 for optionType and dvnIdx\n                _dvnIdx,\n                _optionType,\n                _option\n            );\n    }\n\n    /**\n     * @dev Encodes legacy options of type 1.\n     * @param _executionGas The gasLimit value passed to lzReceive().\n     * @return legacyOptions The encoded legacy options.\n     */\n    function encodeLegacyOptionsType1(uint256 _executionGas) internal pure returns (bytes memory) {\n        if (_executionGas > type(uint128).max) revert InvalidSize(type(uint128).max, _executionGas);\n        return abi.encodePacked(TYPE_1, _executionGas);\n    }\n\n    /**\n     * @dev Encodes legacy options of type 2.\n     * @param _executionGas The gasLimit value passed to lzReceive().\n     * @param _nativeForDst The amount of native air dropped to the receiver.\n     * @param _receiver The _nativeForDst receiver address.\n     * @return legacyOptions The encoded legacy options of type 2.\n     */\n    function encodeLegacyOptionsType2(\n        uint256 _executionGas,\n        uint256 _nativeForDst,\n        bytes memory _receiver // @dev Use bytes instead of bytes32 in legacy type 2 for _receiver.\n    ) internal pure returns (bytes memory) {\n        if (_executionGas > type(uint128).max) revert InvalidSize(type(uint128).max, _executionGas);\n        if (_nativeForDst > type(uint128).max) revert InvalidSize(type(uint128).max, _nativeForDst);\n        if (_receiver.length > 32) revert InvalidSize(32, _receiver.length);\n        return abi.encodePacked(TYPE_2, _executionGas, _nativeForDst, _receiver);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/OApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n// @dev Import the 'MessagingFee' and 'MessagingReceipt' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppSender, MessagingFee, MessagingReceipt } from \"./OAppSender.sol\";\n// @dev Import the 'Origin' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppReceiver, Origin } from \"./OAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OApp\n * @dev Abstract contract serving as the base for OApp implementation, combining OAppSender and OAppReceiver functionality.\n */\nabstract contract OApp is OAppSender, OAppReceiver {\n    /**\n     * @dev Constructor to initialize the OApp with the provided endpoint and owner.\n     * @param _endpoint The address of the LOCAL LayerZero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(address _endpoint, address _delegate) OAppCore(_endpoint, _delegate) {}\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol implementation.\n     * @return receiverVersion The version of the OAppReceiver.sol implementation.\n     */\n    function oAppVersion()\n        public\n        pure\n        virtual\n        override(OAppSender, OAppReceiver)\n        returns (uint64 senderVersion, uint64 receiverVersion)\n    {\n        return (SENDER_VERSION, RECEIVER_VERSION);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/OAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IOAppCore, ILayerZeroEndpointV2 } from \"./interfaces/IOAppCore.sol\";\n\n/**\n * @title OAppCore\n * @dev Abstract contract implementing the IOAppCore interface with basic OApp configurations.\n */\nabstract contract OAppCore is IOAppCore, Ownable {\n    // The LayerZero endpoint associated with the given OApp\n    ILayerZeroEndpointV2 public immutable endpoint;\n\n    // Mapping to store peers associated with corresponding endpoints\n    mapping(uint32 eid => bytes32 peer) public peers;\n\n    /**\n     * @dev Constructor to initialize the OAppCore with the provided endpoint and delegate.\n     * @param _endpoint The address of the LOCAL Layer Zero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     *\n     * @dev The delegate typically should be set as the owner of the contract.\n     */\n    constructor(address _endpoint, address _delegate) {\n        endpoint = ILayerZeroEndpointV2(_endpoint);\n\n        if (_delegate == address(0)) revert InvalidDelegate();\n        endpoint.setDelegate(_delegate);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) public virtual onlyOwner {\n        _setPeer(_eid, _peer);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function _setPeer(uint32 _eid, bytes32 _peer) internal virtual {\n        peers[_eid] = _peer;\n        emit PeerSet(_eid, _peer);\n    }\n\n    /**\n     * @notice Internal function to get the peer address associated with a specific endpoint; reverts if NOT set.\n     * ie. the peer is set to bytes32(0).\n     * @param _eid The endpoint ID.\n     * @return peer The address of the peer associated with the specified endpoint.\n     */\n    function _getPeerOrRevert(uint32 _eid) internal view virtual returns (bytes32) {\n        bytes32 peer = peers[_eid];\n        if (peer == bytes32(0)) revert NoPeer(_eid);\n        return peer;\n    }\n\n    /**\n     * @notice Sets the delegate address for the OApp.\n     * @param _delegate The address of the delegate to be set.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides the ability for a delegate to set configs, on behalf of the OApp, directly on the Endpoint contract.\n     */\n    function setDelegate(address _delegate) public onlyOwner {\n        endpoint.setDelegate(_delegate);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/OAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { IOAppReceiver, Origin } from \"./interfaces/IOAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppReceiver\n * @dev Abstract contract implementing the ILayerZeroReceiver interface and extending OAppCore for OApp receivers.\n */\nabstract contract OAppReceiver is IOAppReceiver, OAppCore {\n    // Custom error message for when the caller is not the registered endpoint/\n    error OnlyEndpoint(address addr);\n\n    // @dev The version of the OAppReceiver implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant RECEIVER_VERSION = 2;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppSender version. Indicates that the OAppSender is not implemented.\n     * ie. this is a RECEIVE only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions.\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (0, RECEIVER_VERSION);\n    }\n\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @dev _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @dev _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement separate composeMsg senders that are NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata /*_origin*/,\n        bytes calldata /*_message*/,\n        address _sender\n    ) public view virtual returns (bool) {\n        return _sender == address(this);\n    }\n\n    /**\n     * @notice Checks if the path initialization is allowed based on the provided origin.\n     * @param origin The origin information containing the source endpoint and sender address.\n     * @return Whether the path has been initialized.\n     *\n     * @dev This indicates to the endpoint that the OApp has enabled msgs for this particular path to be received.\n     * @dev This defaults to assuming if a peer has been set, its initialized.\n     * Can be overridden by the OApp if there is other logic to determine this.\n     */\n    function allowInitializePath(Origin calldata origin) public view virtual returns (bool) {\n        return peers[origin.srcEid] == origin.sender;\n    }\n\n    /**\n     * @notice Retrieves the next nonce for a given source endpoint and sender address.\n     * @dev _srcEid The source endpoint ID.\n     * @dev _sender The sender address.\n     * @return nonce The next nonce.\n     *\n     * @dev The path nonce starts from 1. If 0 is returned it means that there is NO nonce ordered enforcement.\n     * @dev Is required by the off-chain executor to determine the OApp expects msg execution is ordered.\n     * @dev This is also enforced by the OApp.\n     * @dev By default this is NOT enabled. ie. nextNonce is hardcoded to return 0.\n     */\n    function nextNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/) public view virtual returns (uint64 nonce) {\n        return 0;\n    }\n\n    /**\n     * @dev Entry point for receiving messages or packets from the endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The payload of the received message.\n     * @param _executor The address of the executor for the received message.\n     * @param _extraData Additional arbitrary data provided by the corresponding executor.\n     *\n     * @dev Entry point for receiving msg/packet from the LayerZero endpoint.\n     */\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) public payable virtual {\n        // Ensures that only the endpoint can attempt to lzReceive() messages to this OApp.\n        if (address(endpoint) != msg.sender) revert OnlyEndpoint(msg.sender);\n\n        // Ensure that the sender matches the expected peer for the source endpoint.\n        if (_getPeerOrRevert(_origin.srcEid) != _origin.sender) revert OnlyPeer(_origin.srcEid, _origin.sender);\n\n        // Call the internal OApp implementation of lzReceive.\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Internal function to implement lzReceive logic without needing to copy the basic parameter validation.\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual;\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/OAppSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { MessagingParams, MessagingFee, MessagingReceipt } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppSender\n * @dev Abstract contract implementing the OAppSender functionality for sending messages to a LayerZero endpoint.\n */\nabstract contract OAppSender is OAppCore {\n    using SafeERC20 for IERC20;\n\n    // Custom error messages\n    error NotEnoughNative(uint256 msgValue);\n    error LzTokenUnavailable();\n\n    // @dev The version of the OAppSender implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant SENDER_VERSION = 1;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppReceiver version. Indicates that the OAppReceiver is not implemented.\n     * ie. this is a SEND only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (SENDER_VERSION, 0);\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.quote() for fee calculation.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _payInLzToken Flag indicating whether to pay the fee in LZ tokens.\n     * @return fee The calculated MessagingFee for the message.\n     *      - nativeFee: The native fee for the message.\n     *      - lzTokenFee: The LZ token fee for the message.\n     */\n    function _quote(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        bool _payInLzToken\n    ) internal view virtual returns (MessagingFee memory fee) {\n        return\n            endpoint.quote(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _payInLzToken),\n                address(this)\n            );\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.send() for sending a message.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _fee The calculated LayerZero fee for the message.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess fee values sent to the endpoint.\n     * @return receipt The receipt for the sent message.\n     *      - guid: The unique identifier for the sent message.\n     *      - nonce: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     */\n    function _lzSend(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        MessagingFee memory _fee,\n        address _refundAddress\n    ) internal virtual returns (MessagingReceipt memory receipt) {\n        // @dev Push corresponding fees to the endpoint, any excess is sent back to the _refundAddress from the endpoint.\n        uint256 messageValue = _payNative(_fee.nativeFee);\n        if (_fee.lzTokenFee > 0) _payLzToken(_fee.lzTokenFee);\n\n        return\n            // solhint-disable-next-line check-send-result\n            endpoint.send{ value: messageValue }(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _fee.lzTokenFee > 0),\n                _refundAddress\n            );\n    }\n\n    /**\n     * @dev Internal function to pay the native fee associated with the message.\n     * @param _nativeFee The native fee to be paid.\n     * @return nativeFee The amount of native currency paid.\n     *\n     * @dev If the OApp needs to initiate MULTIPLE LayerZero messages in a single transaction,\n     * this will need to be overridden because msg.value would contain multiple lzFees.\n     * @dev Should be overridden in the event the LayerZero endpoint requires a different native currency.\n     * @dev Some EVMs use an ERC20 as a method for paying transactions/gasFees.\n     * @dev The endpoint is EITHER/OR, ie. it will NOT support both types of native payment at a time.\n     */\n    function _payNative(uint256 _nativeFee) internal virtual returns (uint256 nativeFee) {\n        if (msg.value != _nativeFee) revert NotEnoughNative(msg.value);\n        return _nativeFee;\n    }\n\n    /**\n     * @dev Internal function to pay the LZ token fee associated with the message.\n     * @param _lzTokenFee The LZ token fee to be paid.\n     *\n     * @dev If the caller is trying to pay in the specified lzToken, then the lzTokenFee is passed to the endpoint.\n     * @dev Any excess sent, is passed back to the specified _refundAddress in the _lzSend().\n     */\n    function _payLzToken(uint256 _lzTokenFee) internal virtual {\n        // @dev Cannot cache the token because it is not immutable in the endpoint.\n        address lzToken = endpoint.lzToken();\n        if (lzToken == address(0)) revert LzTokenUnavailable();\n\n        // Pay LZ token fee by sending tokens to the endpoint.\n        IERC20(lzToken).safeTransferFrom(msg.sender, address(endpoint), _lzTokenFee);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/precrime/interfaces/IOAppPreCrimeSimulator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n// @dev Import the Origin so it's exposed to OAppPreCrimeSimulator implementers.\n// solhint-disable-next-line no-unused-import\nimport { InboundPacket, Origin } from \"../libs/Packet.sol\";\n\n/**\n * @title IOAppPreCrimeSimulator Interface\n * @dev Interface for the preCrime simulation functionality in an OApp.\n */\ninterface IOAppPreCrimeSimulator {\n    // @dev simulation result used in PreCrime implementation\n    error SimulationResult(bytes result);\n    error OnlySelf();\n\n    /**\n     * @dev Emitted when the preCrime contract address is set.\n     * @param preCrimeAddress The address of the preCrime contract.\n     */\n    event PreCrimeSet(address preCrimeAddress);\n\n    /**\n     * @dev Retrieves the address of the preCrime contract implementation.\n     * @return The address of the preCrime contract.\n     */\n    function preCrime() external view returns (address);\n\n    /**\n     * @dev Retrieves the address of the OApp contract.\n     * @return The address of the OApp contract.\n     */\n    function oApp() external view returns (address);\n\n    /**\n     * @dev Sets the preCrime contract address.\n     * @param _preCrime The address of the preCrime contract.\n     */\n    function setPreCrime(address _preCrime) external;\n\n    /**\n     * @dev Mocks receiving a packet, then reverts with a series of data to infer the state/result.\n     * @param _packets An array of LayerZero InboundPacket objects representing received packets.\n     */\n    function lzReceiveAndRevert(InboundPacket[] calldata _packets) external payable;\n\n    /**\n     * @dev checks if the specified peer is considered 'trusted' by the OApp.\n     * @param _eid The endpoint Id to check.\n     * @param _peer The peer to check.\n     * @return Whether the peer passed is considered 'trusted' by the OApp.\n     */\n    function isPeer(uint32 _eid, bytes32 _peer) external view returns (bool);\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/precrime/interfaces/IPreCrime.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\nstruct PreCrimePeer {\n    uint32 eid;\n    bytes32 preCrime;\n    bytes32 oApp;\n}\n\n// TODO not done yet\ninterface IPreCrime {\n    error OnlyOffChain();\n\n    // for simulate()\n    error PacketOversize(uint256 max, uint256 actual);\n    error PacketUnsorted();\n    error SimulationFailed(bytes reason);\n\n    // for preCrime()\n    error SimulationResultNotFound(uint32 eid);\n    error InvalidSimulationResult(uint32 eid, bytes reason);\n    error CrimeFound(bytes crime);\n\n    function getConfig(bytes[] calldata _packets, uint256[] calldata _packetMsgValues) external returns (bytes memory);\n\n    function simulate(\n        bytes[] calldata _packets,\n        uint256[] calldata _packetMsgValues\n    ) external payable returns (bytes memory);\n\n    function buildSimulationResult() external view returns (bytes memory);\n\n    function preCrime(\n        bytes[] calldata _packets,\n        uint256[] calldata _packetMsgValues,\n        bytes[] calldata _simulations\n    ) external;\n\n    function version() external view returns (uint64 major, uint8 minor);\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/precrime/libs/Packet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\n\n/**\n * @title InboundPacket\n * @dev Structure representing an inbound packet received by the contract.\n */\nstruct InboundPacket {\n    Origin origin; // Origin information of the packet.\n    uint32 dstEid; // Destination endpointId of the packet.\n    address receiver; // Receiver address for the packet.\n    bytes32 guid; // Unique identifier of the packet.\n    uint256 value; // msg.value of the packet.\n    address executor; // Executor address for the packet.\n    bytes message; // Message payload of the packet.\n    bytes extraData; // Additional arbitrary data for the packet.\n}\n\n/**\n * @title PacketDecoder\n * @dev Library for decoding LayerZero packets.\n */\nlibrary PacketDecoder {\n    using PacketV1Codec for bytes;\n\n    /**\n     * @dev Decode an inbound packet from the given packet data.\n     * @param _packet The packet data to decode.\n     * @return packet An InboundPacket struct representing the decoded packet.\n     */\n    function decode(bytes calldata _packet) internal pure returns (InboundPacket memory packet) {\n        packet.origin = Origin(_packet.srcEid(), _packet.sender(), _packet.nonce());\n        packet.dstEid = _packet.dstEid();\n        packet.receiver = _packet.receiverB20();\n        packet.guid = _packet.guid();\n        packet.message = _packet.message();\n    }\n\n    /**\n     * @dev Decode multiple inbound packets from the given packet data and associated message values.\n     * @param _packets An array of packet data to decode.\n     * @param _packetMsgValues An array of associated message values for each packet.\n     * @return packets An array of InboundPacket structs representing the decoded packets.\n     */\n    function decode(\n        bytes[] calldata _packets,\n        uint256[] memory _packetMsgValues\n    ) internal pure returns (InboundPacket[] memory packets) {\n        packets = new InboundPacket[](_packets.length);\n        for (uint256 i = 0; i < _packets.length; i++) {\n            bytes calldata packet = _packets[i];\n            packets[i] = PacketDecoder.decode(packet);\n            // @dev Allows the verifier to specify the msg.value that gets passed in lzReceive.\n            packets[i].value = _packetMsgValues[i];\n        }\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/precrime/OAppPreCrimeSimulator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IPreCrime } from \"./interfaces/IPreCrime.sol\";\nimport { IOAppPreCrimeSimulator, InboundPacket, Origin } from \"./interfaces/IOAppPreCrimeSimulator.sol\";\n\n/**\n * @title OAppPreCrimeSimulator\n * @dev Abstract contract serving as the base for preCrime simulation functionality in an OApp.\n */\nabstract contract OAppPreCrimeSimulator is IOAppPreCrimeSimulator, Ownable {\n    // The address of the preCrime implementation.\n    address public preCrime;\n\n    /**\n     * @dev Retrieves the address of the OApp contract.\n     * @return The address of the OApp contract.\n     *\n     * @dev The simulator contract is the base contract for the OApp by default.\n     * @dev If the simulator is a separate contract, override this function.\n     */\n    function oApp() external view virtual returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @dev Sets the preCrime contract address.\n     * @param _preCrime The address of the preCrime contract.\n     */\n    function setPreCrime(address _preCrime) public virtual onlyOwner {\n        preCrime = _preCrime;\n        emit PreCrimeSet(_preCrime);\n    }\n\n    /**\n     * @dev Interface for pre-crime simulations. Always reverts at the end with the simulation results.\n     * @param _packets An array of InboundPacket objects representing received packets to be delivered.\n     *\n     * @dev WARNING: MUST revert at the end with the simulation results.\n     * @dev Gives the preCrime implementation the ability to mock sending packets to the lzReceive function,\n     * WITHOUT actually executing them.\n     */\n    function lzReceiveAndRevert(InboundPacket[] calldata _packets) public payable virtual {\n        for (uint256 i = 0; i < _packets.length; i++) {\n            InboundPacket calldata packet = _packets[i];\n\n            // Ignore packets that are not from trusted peers.\n            if (!isPeer(packet.origin.srcEid, packet.origin.sender)) continue;\n\n            // @dev Because a verifier is calling this function, it doesnt have access to executor params:\n            //  - address _executor\n            //  - bytes calldata _extraData\n            // preCrime will NOT work for OApps that rely on these two parameters inside of their _lzReceive().\n            // They are instead stubbed to default values, address(0) and bytes(\"\")\n            // @dev Calling this.lzReceiveSimulate removes ability for assembly return 0 callstack exit,\n            // which would cause the revert to be ignored.\n            this.lzReceiveSimulate{ value: packet.value }(\n                packet.origin,\n                packet.guid,\n                packet.message,\n                packet.executor,\n                packet.extraData\n            );\n        }\n\n        // @dev Revert with the simulation results. msg.sender must implement IPreCrime.buildSimulationResult().\n        revert SimulationResult(IPreCrime(msg.sender).buildSimulationResult());\n    }\n\n    /**\n     * @dev Is effectively an internal function because msg.sender must be address(this).\n     * Allows resetting the call stack for 'internal' calls.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _guid The unique identifier of the packet.\n     * @param _message The message payload of the packet.\n     * @param _executor The executor address for the packet.\n     * @param _extraData Additional data for the packet.\n     */\n    function lzReceiveSimulate(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable virtual {\n        // @dev Ensure ONLY can be called 'internally'.\n        if (msg.sender != address(this)) revert OnlySelf();\n        _lzReceiveSimulate(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Internal function to handle the OAppPreCrimeSimulator simulated receive.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The GUID of the LayerZero message.\n     * @param _message The LayerZero message.\n     * @param _executor The address of the off-chain executor.\n     * @param _extraData Arbitrary data passed by the msg executor.\n     *\n     * @dev Enables the preCrime simulator to mock sending lzReceive() messages,\n     * routes the msg down from the OAppPreCrimeSimulator, and back up to the OAppReceiver.\n     */\n    function _lzReceiveSimulate(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual;\n\n    /**\n     * @dev checks if the specified peer is considered 'trusted' by the OApp.\n     * @param _eid The endpoint Id to check.\n     * @param _peer The peer to check.\n     * @return Whether the peer passed is considered 'trusted' by the OApp.\n     */\n    function isPeer(uint32 _eid, bytes32 _peer) public view virtual returns (bool);\n}\n"
    },
    "@layerzerolabs/oft-evm/contracts/interfaces/IMintableBurnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n/// @title Interface for mintable and burnable tokens\ninterface IMintableBurnable {\n    \n    /**\n     * @notice Burns tokens from a specified account\n     * @param _from Address from which tokens will be burned\n     * @param _amount Amount of tokens to be burned\n     * @return success Indicates whether the operation was successful\n     */\n    function burn(address _from, uint256 _amount) external returns (bool success);\n\n    /**\n     * @notice Mints tokens to a specified account\n     * @param _to Address to which tokens will be minted\n     * @param _amount Amount of tokens to be minted\n     * @return success Indicates whether the operation was successful\n     */\n    function mint(address _to, uint256 _amount) external returns (bool success);\n}"
    },
    "@layerzerolabs/oft-evm/contracts/interfaces/IOFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { MessagingReceipt, MessagingFee } from \"@layerzerolabs/oapp-evm/contracts/oapp/OAppSender.sol\";\n\n/**\n * @dev Struct representing token parameters for the OFT send() operation.\n */\nstruct SendParam {\n    uint32 dstEid; // Destination endpoint ID.\n    bytes32 to; // Recipient address.\n    uint256 amountLD; // Amount to send in local decimals.\n    uint256 minAmountLD; // Minimum amount to send in local decimals.\n    bytes extraOptions; // Additional options supplied by the caller to be used in the LayerZero message.\n    bytes composeMsg; // The composed message for the send() operation.\n    bytes oftCmd; // The OFT command to be executed, unused in default OFT implementations.\n}\n\n/**\n * @dev Struct representing OFT limit information.\n * @dev These amounts can change dynamically and are up the specific oft implementation.\n */\nstruct OFTLimit {\n    uint256 minAmountLD; // Minimum amount in local decimals that can be sent to the recipient.\n    uint256 maxAmountLD; // Maximum amount in local decimals that can be sent to the recipient.\n}\n\n/**\n * @dev Struct representing OFT receipt information.\n */\nstruct OFTReceipt {\n    uint256 amountSentLD; // Amount of tokens ACTUALLY debited from the sender in local decimals.\n    // @dev In non-default implementations, the amountReceivedLD COULD differ from this value.\n    uint256 amountReceivedLD; // Amount of tokens to be received on the remote side.\n}\n\n/**\n * @dev Struct representing OFT fee details.\n * @dev Future proof mechanism to provide a standardized way to communicate fees to things like a UI.\n */\nstruct OFTFeeDetail {\n    int256 feeAmountLD; // Amount of the fee in local decimals.\n    string description; // Description of the fee.\n}\n\n/**\n * @title IOFT\n * @dev Interface for the OftChain (OFT) token.\n * @dev Does not inherit ERC20 to accommodate usage by OFTAdapter as well.\n * @dev This specific interface ID is '0x02e49c2c'.\n */\ninterface IOFT {\n    // Custom error messages\n    error InvalidLocalDecimals();\n    error SlippageExceeded(uint256 amountLD, uint256 minAmountLD);\n\n    // Events\n    event OFTSent(\n        bytes32 indexed guid, // GUID of the OFT message.\n        uint32 dstEid, // Destination Endpoint ID.\n        address indexed fromAddress, // Address of the sender on the src chain.\n        uint256 amountSentLD, // Amount of tokens sent in local decimals.\n        uint256 amountReceivedLD // Amount of tokens received in local decimals.\n    );\n    event OFTReceived(\n        bytes32 indexed guid, // GUID of the OFT message.\n        uint32 srcEid, // Source Endpoint ID.\n        address indexed toAddress, // Address of the recipient on the dst chain.\n        uint256 amountReceivedLD // Amount of tokens received in local decimals.\n    );\n\n    /**\n     * @notice Retrieves interfaceID and the version of the OFT.\n     * @return interfaceId The interface ID.\n     * @return version The version.\n     *\n     * @dev interfaceId: This specific interface ID is '0x02e49c2c'.\n     * @dev version: Indicates a cross-chain compatible msg encoding with other OFTs.\n     * @dev If a new feature is added to the OFT cross-chain msg encoding, the version will be incremented.\n     * ie. localOFT version(x,1) CAN send messages to remoteOFT version(x,1)\n     */\n    function oftVersion() external view returns (bytes4 interfaceId, uint64 version);\n\n    /**\n     * @notice Retrieves the address of the token associated with the OFT.\n     * @return token The address of the ERC20 token implementation.\n     */\n    function token() external view returns (address);\n\n    /**\n     * @notice Indicates whether the OFT contract requires approval of the 'token()' to send.\n     * @return requiresApproval Needs approval of the underlying token implementation.\n     *\n     * @dev Allows things like wallet implementers to determine integration requirements,\n     * without understanding the underlying token implementation.\n     */\n    function approvalRequired() external view returns (bool);\n\n    /**\n     * @notice Retrieves the shared decimals of the OFT.\n     * @return sharedDecimals The shared decimals of the OFT.\n     */\n    function sharedDecimals() external view returns (uint8);\n\n    /**\n     * @notice Provides the fee breakdown and settings data for an OFT. Unused in the default implementation.\n     * @param _sendParam The parameters for the send operation.\n     * @return limit The OFT limit information.\n     * @return oftFeeDetails The details of OFT fees.\n     * @return receipt The OFT receipt information.\n     */\n    function quoteOFT(\n        SendParam calldata _sendParam\n    ) external view returns (OFTLimit memory, OFTFeeDetail[] memory oftFeeDetails, OFTReceipt memory);\n\n    /**\n     * @notice Provides a quote for the send() operation.\n     * @param _sendParam The parameters for the send() operation.\n     * @param _payInLzToken Flag indicating whether the caller is paying in the LZ token.\n     * @return fee The calculated LayerZero messaging fee from the send() operation.\n     *\n     * @dev MessagingFee: LayerZero msg fee\n     *  - nativeFee: The native fee.\n     *  - lzTokenFee: The lzToken fee.\n     */\n    function quoteSend(SendParam calldata _sendParam, bool _payInLzToken) external view returns (MessagingFee memory);\n\n    /**\n     * @notice Executes the send() operation.\n     * @param _sendParam The parameters for the send operation.\n     * @param _fee The fee information supplied by the caller.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess funds from fees etc. on the src.\n     * @return receipt The LayerZero messaging receipt from the send() operation.\n     * @return oftReceipt The OFT receipt information.\n     *\n     * @dev MessagingReceipt: LayerZero msg receipt\n     *  - guid: The unique identifier for the sent message.\n     *  - nonce: The nonce of the sent message.\n     *  - fee: The LayerZero fee incurred for the message.\n     */\n    function send(\n        SendParam calldata _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory, OFTReceipt memory);\n}\n"
    },
    "@layerzerolabs/oft-evm/contracts/libs/OFTComposeMsgCodec.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nlibrary OFTComposeMsgCodec {\n    // Offset constants for decoding composed messages\n    uint8 private constant NONCE_OFFSET = 8;\n    uint8 private constant SRC_EID_OFFSET = 12;\n    uint8 private constant AMOUNT_LD_OFFSET = 44;\n    uint8 private constant COMPOSE_FROM_OFFSET = 76;\n\n    /**\n     * @dev Encodes a OFT composed message.\n     * @param _nonce The nonce value.\n     * @param _srcEid The source endpoint ID.\n     * @param _amountLD The amount in local decimals.\n     * @param _composeMsg The composed message.\n     * @return _msg The encoded Composed message.\n     */\n    function encode(\n        uint64 _nonce,\n        uint32 _srcEid,\n        uint256 _amountLD,\n        bytes memory _composeMsg // 0x[composeFrom][composeMsg]\n    ) internal pure returns (bytes memory _msg) {\n        _msg = abi.encodePacked(_nonce, _srcEid, _amountLD, _composeMsg);\n    }\n\n    /**\n     * @dev Retrieves the nonce for the composed message.\n     * @param _msg The message.\n     * @return The nonce value.\n     */\n    function nonce(bytes calldata _msg) internal pure returns (uint64) {\n        return uint64(bytes8(_msg[:NONCE_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the source endpoint ID for the composed message.\n     * @param _msg The message.\n     * @return The source endpoint ID.\n     */\n    function srcEid(bytes calldata _msg) internal pure returns (uint32) {\n        return uint32(bytes4(_msg[NONCE_OFFSET:SRC_EID_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the amount in local decimals from the composed message.\n     * @param _msg The message.\n     * @return The amount in local decimals.\n     */\n    function amountLD(bytes calldata _msg) internal pure returns (uint256) {\n        return uint256(bytes32(_msg[SRC_EID_OFFSET:AMOUNT_LD_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the composeFrom value from the composed message.\n     * @param _msg The message.\n     * @return The composeFrom value.\n     */\n    function composeFrom(bytes calldata _msg) internal pure returns (bytes32) {\n        return bytes32(_msg[AMOUNT_LD_OFFSET:COMPOSE_FROM_OFFSET]);\n    }\n\n    /**\n     * @dev Retrieves the composed message.\n     * @param _msg The message.\n     * @return The composed message.\n     */\n    function composeMsg(bytes calldata _msg) internal pure returns (bytes memory) {\n        return _msg[COMPOSE_FROM_OFFSET:];\n    }\n\n    /**\n     * @dev Converts an address to bytes32.\n     * @param _addr The address to convert.\n     * @return The bytes32 representation of the address.\n     */\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    /**\n     * @dev Converts bytes32 to an address.\n     * @param _b The bytes32 value to convert.\n     * @return The address representation of bytes32.\n     */\n    function bytes32ToAddress(bytes32 _b) internal pure returns (address) {\n        return address(uint160(uint256(_b)));\n    }\n}\n"
    },
    "@layerzerolabs/oft-evm/contracts/libs/OFTMsgCodec.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nlibrary OFTMsgCodec {\n    // Offset constants for encoding and decoding OFT messages\n    uint8 private constant SEND_TO_OFFSET = 32;\n    uint8 private constant SEND_AMOUNT_SD_OFFSET = 40;\n\n    /**\n     * @dev Encodes an OFT LayerZero message.\n     * @param _sendTo The recipient address.\n     * @param _amountShared The amount in shared decimals.\n     * @param _composeMsg The composed message.\n     * @return _msg The encoded message.\n     * @return hasCompose A boolean indicating whether the message has a composed payload.\n     */\n    function encode(\n        bytes32 _sendTo,\n        uint64 _amountShared,\n        bytes memory _composeMsg\n    ) internal view returns (bytes memory _msg, bool hasCompose) {\n        hasCompose = _composeMsg.length > 0;\n        // @dev Remote chains will want to know the composed function caller ie. msg.sender on the src.\n        _msg = hasCompose\n            ? abi.encodePacked(_sendTo, _amountShared, addressToBytes32(msg.sender), _composeMsg)\n            : abi.encodePacked(_sendTo, _amountShared);\n    }\n\n    /**\n     * @dev Checks if the OFT message is composed.\n     * @param _msg The OFT message.\n     * @return A boolean indicating whether the message is composed.\n     */\n    function isComposed(bytes calldata _msg) internal pure returns (bool) {\n        return _msg.length > SEND_AMOUNT_SD_OFFSET;\n    }\n\n    /**\n     * @dev Retrieves the recipient address from the OFT message.\n     * @param _msg The OFT message.\n     * @return The recipient address.\n     */\n    function sendTo(bytes calldata _msg) internal pure returns (bytes32) {\n        return bytes32(_msg[:SEND_TO_OFFSET]);\n    }\n\n    /**\n     * @dev Retrieves the amount in shared decimals from the OFT message.\n     * @param _msg The OFT message.\n     * @return The amount in shared decimals.\n     */\n    function amountSD(bytes calldata _msg) internal pure returns (uint64) {\n        return uint64(bytes8(_msg[SEND_TO_OFFSET:SEND_AMOUNT_SD_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the composed message from the OFT message.\n     * @param _msg The OFT message.\n     * @return The composed message.\n     */\n    function composeMsg(bytes calldata _msg) internal pure returns (bytes memory) {\n        return _msg[SEND_AMOUNT_SD_OFFSET:];\n    }\n\n    /**\n     * @dev Converts an address to bytes32.\n     * @param _addr The address to convert.\n     * @return The bytes32 representation of the address.\n     */\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    /**\n     * @dev Converts bytes32 to an address.\n     * @param _b The bytes32 value to convert.\n     * @return The address representation of bytes32.\n     */\n    function bytes32ToAddress(bytes32 _b) internal pure returns (address) {\n        return address(uint160(uint256(_b)));\n    }\n}\n"
    },
    "@layerzerolabs/oft-evm/contracts/MintBurnOFTAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n// External imports\nimport { IERC20, IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n// Local imports\nimport { IMintableBurnable } from \"./interfaces/IMintableBurnable.sol\";\nimport { OFTCore } from \"./OFTCore.sol\";\n\n/**\n * @title MintBurnOFTAdapter\n * @notice A variant of the standard OFT Adapter that uses an existing ERC20's mint and burn mechanisms for cross-chain transfers.\n *\n * @dev Inherits from OFTCore and provides implementations for _debit and _credit functions using a mintable and burnable token.\n */\nabstract contract MintBurnOFTAdapter is OFTCore {\n    /// @dev The underlying ERC20 token.\n    IERC20 internal immutable innerToken;\n\n    /// @notice The contract responsible for minting and burning tokens.\n    IMintableBurnable public immutable minterBurner;\n\n    /**\n     * @notice Initializes the MintBurnOFTAdapter contract.\n     *\n     * @param _token The address of the underlying ERC20 token.\n     * @param _minterBurner The contract responsible for minting and burning tokens.\n     * @param _lzEndpoint The LayerZero endpoint address.\n     * @param _delegate The address of the delegate.\n     *\n     * @dev Calls the OFTCore constructor with the token's decimals, the endpoint, and the delegate.\n     */\n    constructor(\n        address _token,\n        IMintableBurnable _minterBurner,\n        address _lzEndpoint,\n        address _delegate\n    ) OFTCore(IERC20Metadata(_token).decimals(), _lzEndpoint, _delegate) {\n        innerToken = IERC20(_token);\n        minterBurner = _minterBurner;\n    }\n\n    /**\n     * @notice Retrieves the address of the underlying ERC20 token.\n     *\n     * @return The address of the adapted ERC20 token.\n     *\n     * @dev In the case of MintBurnOFTAdapter, address(this) and erc20 are NOT the same contract.\n     */\n    function token() public view returns (address) {\n        return address(innerToken);\n    }\n\n    /**\n     * @notice Indicates whether the OFT contract requires approval of the underlying token to send.\n     *\n     * @return requiresApproval True if approval is required, false otherwise.\n     *\n     * @dev In this MintBurnOFTAdapter, approval is NOT required because it uses mint and burn privileges.\n     */\n    function approvalRequired() external pure virtual returns (bool) {\n        return false;\n    }\n\n    /**\n     * @notice Burns tokens from the sender's balance to prepare for sending.\n     *\n     * @param _from The address to debit the tokens from.\n     * @param _amountLD The amount of tokens to send in local decimals.\n     * @param _minAmountLD The minimum amount to send in local decimals.\n     * @param _dstEid The destination chain ID.\n     *\n     * @return amountSentLD The amount sent in local decimals.\n     * @return amountReceivedLD The amount received in local decimals on the remote.\n     *\n     * @dev WARNING: The default OFTAdapter implementation assumes LOSSLESS transfers, i.e., 1 token in, 1 token out.\n     *      If the 'innerToken' applies something like a transfer fee, the default will NOT work.\n     *      A pre/post balance check will need to be done to calculate the amountReceivedLD.\n     */\n    function _debit(\n        address _from,\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        uint32 _dstEid\n    ) internal virtual override returns (uint256 amountSentLD, uint256 amountReceivedLD) {\n        (amountSentLD, amountReceivedLD) = _debitView(_amountLD, _minAmountLD, _dstEid);\n        // Burns tokens from the caller.\n        minterBurner.burn(_from, amountSentLD);\n    }\n\n    /**\n     * @notice Mints tokens to the specified address upon receiving them.\n     *\n     * @param _to The address to credit the tokens to.\n     * @param _amountLD The amount of tokens to credit in local decimals.\n     *\n     * @return amountReceivedLD The amount of tokens actually received in local decimals.\n     *\n     * @dev WARNING: The default OFTAdapter implementation assumes LOSSLESS transfers, i.e., 1 token in, 1 token out.\n     *      If the 'innerToken' applies something like a transfer fee, the default will NOT work.\n     *      A pre/post balance check will need to be done to calculate the amountReceivedLD.\n     */\n    function _credit(\n        address _to,\n        uint256 _amountLD,\n        uint32 /* _srcEid */\n    ) internal virtual override returns (uint256 amountReceivedLD) {\n        if (_to == address(0x0)) _to = address(0xdead); // _mint(...) does not support address(0x0)\n        // Mints the tokens and transfers to the recipient.\n        minterBurner.mint(_to, _amountLD);\n        // In the case of NON-default OFTAdapter, the amountLD MIGHT not be equal to amountReceivedLD.\n        return _amountLD;\n    }\n}\n"
    },
    "@layerzerolabs/oft-evm/contracts/OFTAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { IERC20Metadata, IERC20 } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IOFT, OFTCore } from \"./OFTCore.sol\";\n\n/**\n * @title OFTAdapter Contract\n * @dev OFTAdapter is a contract that adapts an ERC-20 token to the OFT functionality.\n *\n * @dev For existing ERC20 tokens, this can be used to convert the token to crosschain compatibility.\n * @dev WARNING: ONLY 1 of these should exist for a given global mesh,\n * unless you make a NON-default implementation of OFT and needs to be done very carefully.\n * @dev WARNING: The default OFTAdapter implementation assumes LOSSLESS transfers, ie. 1 token in, 1 token out.\n * IF the 'innerToken' applies something like a transfer fee, the default will NOT work...\n * a pre/post balance check will need to be done to calculate the amountSentLD/amountReceivedLD.\n */\nabstract contract OFTAdapter is OFTCore {\n    using SafeERC20 for IERC20;\n\n    IERC20 internal immutable innerToken;\n\n    /**\n     * @dev Constructor for the OFTAdapter contract.\n     * @param _token The address of the ERC-20 token to be adapted.\n     * @param _lzEndpoint The LayerZero endpoint address.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(\n        address _token,\n        address _lzEndpoint,\n        address _delegate\n    ) OFTCore(IERC20Metadata(_token).decimals(), _lzEndpoint, _delegate) {\n        innerToken = IERC20(_token);\n    }\n\n    /**\n     * @dev Retrieves the address of the underlying ERC20 implementation.\n     * @return The address of the adapted ERC-20 token.\n     *\n     * @dev In the case of OFTAdapter, address(this) and erc20 are NOT the same contract.\n     */\n    function token() public view returns (address) {\n        return address(innerToken);\n    }\n\n    /**\n     * @notice Indicates whether the OFT contract requires approval of the 'token()' to send.\n     * @return requiresApproval Needs approval of the underlying token implementation.\n     *\n     * @dev In the case of default OFTAdapter, approval is required.\n     * @dev In non-default OFTAdapter contracts with something like mint and burn privileges, it would NOT need approval.\n     */\n    function approvalRequired() external pure virtual returns (bool) {\n        return true;\n    }\n\n    /**\n     * @dev Locks tokens from the sender's specified balance in this contract.\n     * @param _from The address to debit from.\n     * @param _amountLD The amount of tokens to send in local decimals.\n     * @param _minAmountLD The minimum amount to send in local decimals.\n     * @param _dstEid The destination chain ID.\n     * @return amountSentLD The amount sent in local decimals.\n     * @return amountReceivedLD The amount received in local decimals on the remote.\n     *\n     * @dev msg.sender will need to approve this _amountLD of tokens to be locked inside of the contract.\n     * @dev WARNING: The default OFTAdapter implementation assumes LOSSLESS transfers, ie. 1 token in, 1 token out.\n     * IF the 'innerToken' applies something like a transfer fee, the default will NOT work...\n     * a pre/post balance check will need to be done to calculate the amountReceivedLD.\n     */\n    function _debit(\n        address _from,\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        uint32 _dstEid\n    ) internal virtual override returns (uint256 amountSentLD, uint256 amountReceivedLD) {\n        (amountSentLD, amountReceivedLD) = _debitView(_amountLD, _minAmountLD, _dstEid);\n        // @dev Lock tokens by moving them into this contract from the caller.\n        innerToken.safeTransferFrom(_from, address(this), amountSentLD);\n    }\n\n    /**\n     * @dev Credits tokens to the specified address.\n     * @param _to The address to credit the tokens to.\n     * @param _amountLD The amount of tokens to credit in local decimals.\n     * @dev _srcEid The source chain ID.\n     * @return amountReceivedLD The amount of tokens ACTUALLY received in local decimals.\n     *\n     * @dev WARNING: The default OFTAdapter implementation assumes LOSSLESS transfers, ie. 1 token in, 1 token out.\n     * IF the 'innerToken' applies something like a transfer fee, the default will NOT work...\n     * a pre/post balance check will need to be done to calculate the amountReceivedLD.\n     */\n    function _credit(\n        address _to,\n        uint256 _amountLD,\n        uint32 /*_srcEid*/\n    ) internal virtual override returns (uint256 amountReceivedLD) {\n        // @dev Unlock the tokens and transfer to the recipient.\n        innerToken.safeTransfer(_to, _amountLD);\n        // @dev In the case of NON-default OFTAdapter, the amountLD MIGHT not be == amountReceivedLD.\n        return _amountLD;\n    }\n}\n"
    },
    "@layerzerolabs/oft-evm/contracts/OFTCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { OApp, Origin } from \"@layerzerolabs/oapp-evm/contracts/oapp/OApp.sol\";\nimport { OAppOptionsType3 } from \"@layerzerolabs/oapp-evm/contracts/oapp/libs/OAppOptionsType3.sol\";\nimport { IOAppMsgInspector } from \"@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppMsgInspector.sol\";\n\nimport { OAppPreCrimeSimulator } from \"@layerzerolabs/oapp-evm/contracts/precrime/OAppPreCrimeSimulator.sol\";\n\nimport { IOFT, SendParam, OFTLimit, OFTReceipt, OFTFeeDetail, MessagingReceipt, MessagingFee } from \"./interfaces/IOFT.sol\";\nimport { OFTMsgCodec } from \"./libs/OFTMsgCodec.sol\";\nimport { OFTComposeMsgCodec } from \"./libs/OFTComposeMsgCodec.sol\";\n\n/**\n * @title OFTCore\n * @dev Abstract contract for the OftChain (OFT) token.\n */\nabstract contract OFTCore is IOFT, OApp, OAppPreCrimeSimulator, OAppOptionsType3 {\n    using OFTMsgCodec for bytes;\n    using OFTMsgCodec for bytes32;\n\n    // @notice Provides a conversion rate when swapping between denominations of SD and LD\n    //      - shareDecimals == SD == shared Decimals\n    //      - localDecimals == LD == local decimals\n    // @dev Considers that tokens have different decimal amounts on various chains.\n    // @dev eg.\n    //  For a token\n    //      - locally with 4 decimals --> 1.2345 => uint(12345)\n    //      - remotely with 2 decimals --> 1.23 => uint(123)\n    //      - The conversion rate would be 10 ** (4 - 2) = 100\n    //  @dev If you want to send 1.2345 -> (uint 12345), you CANNOT represent that value on the remote,\n    //  you can only display 1.23 -> uint(123).\n    //  @dev To preserve the dust that would otherwise be lost on that conversion,\n    //  we need to unify a denomination that can be represented on ALL chains inside of the OFT mesh\n    uint256 public immutable decimalConversionRate;\n\n    // @notice Msg types that are used to identify the various OFT operations.\n    // @dev This can be extended in child contracts for non-default oft operations\n    // @dev These values are used in things like combineOptions() in OAppOptionsType3.sol.\n    uint16 public constant SEND = 1;\n    uint16 public constant SEND_AND_CALL = 2;\n\n    // Address of an optional contract to inspect both 'message' and 'options'\n    address public msgInspector;\n    event MsgInspectorSet(address inspector);\n\n    /**\n     * @dev Constructor.\n     * @param _localDecimals The decimals of the token on the local chain (this chain).\n     * @param _endpoint The address of the LayerZero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(uint8 _localDecimals, address _endpoint, address _delegate) OApp(_endpoint, _delegate) {\n        if (_localDecimals < sharedDecimals()) revert InvalidLocalDecimals();\n        decimalConversionRate = 10 ** (_localDecimals - sharedDecimals());\n    }\n\n    /**\n     * @notice Retrieves interfaceID and the version of the OFT.\n     * @return interfaceId The interface ID.\n     * @return version The version.\n     *\n     * @dev interfaceId: This specific interface ID is '0x02e49c2c'.\n     * @dev version: Indicates a cross-chain compatible msg encoding with other OFTs.\n     * @dev If a new feature is added to the OFT cross-chain msg encoding, the version will be incremented.\n     * ie. localOFT version(x,1) CAN send messages to remoteOFT version(x,1)\n     */\n    function oftVersion() external pure virtual returns (bytes4 interfaceId, uint64 version) {\n        return (type(IOFT).interfaceId, 1);\n    }\n\n    /**\n     * @dev Retrieves the shared decimals of the OFT.\n     * @return The shared decimals of the OFT.\n     *\n     * @dev Sets an implicit cap on the amount of tokens, over uint64.max() will need some sort of outbound cap / totalSupply cap\n     * Lowest common decimal denominator between chains.\n     * Defaults to 6 decimal places to provide up to 18,446,744,073,709.551615 units (max uint64).\n     * For tokens exceeding this totalSupply(), they will need to override the sharedDecimals function with something smaller.\n     * ie. 4 sharedDecimals would be 1,844,674,407,370,955.1615\n     */\n    function sharedDecimals() public view virtual returns (uint8) {\n        return 6;\n    }\n\n    /**\n     * @dev Sets the message inspector address for the OFT.\n     * @param _msgInspector The address of the message inspector.\n     *\n     * @dev This is an optional contract that can be used to inspect both 'message' and 'options'.\n     * @dev Set it to address(0) to disable it, or set it to a contract address to enable it.\n     */\n    function setMsgInspector(address _msgInspector) public virtual onlyOwner {\n        msgInspector = _msgInspector;\n        emit MsgInspectorSet(_msgInspector);\n    }\n\n    /**\n     * @notice Provides the fee breakdown and settings data for an OFT. Unused in the default implementation.\n     * @param _sendParam The parameters for the send operation.\n     * @return oftLimit The OFT limit information.\n     * @return oftFeeDetails The details of OFT fees.\n     * @return oftReceipt The OFT receipt information.\n     */\n    function quoteOFT(\n        SendParam calldata _sendParam\n    )\n        external\n        view\n        virtual\n        returns (OFTLimit memory oftLimit, OFTFeeDetail[] memory oftFeeDetails, OFTReceipt memory oftReceipt)\n    {\n        uint256 minAmountLD = 0; // Unused in the default implementation.\n        uint256 maxAmountLD = IERC20(this.token()).totalSupply(); // Unused in the default implementation.\n        oftLimit = OFTLimit(minAmountLD, maxAmountLD);\n\n        // Unused in the default implementation; reserved for future complex fee details.\n        oftFeeDetails = new OFTFeeDetail[](0);\n\n        // @dev This is the same as the send() operation, but without the actual send.\n        // - amountSentLD is the amount in local decimals that would be sent from the sender.\n        // - amountReceivedLD is the amount in local decimals that will be credited to the recipient on the remote OFT instance.\n        // @dev The amountSentLD MIGHT not equal the amount the user actually receives. HOWEVER, the default does.\n        (uint256 amountSentLD, uint256 amountReceivedLD) = _debitView(\n            _sendParam.amountLD,\n            _sendParam.minAmountLD,\n            _sendParam.dstEid\n        );\n        oftReceipt = OFTReceipt(amountSentLD, amountReceivedLD);\n    }\n\n    /**\n     * @notice Provides a quote for the send() operation.\n     * @param _sendParam The parameters for the send() operation.\n     * @param _payInLzToken Flag indicating whether the caller is paying in the LZ token.\n     * @return msgFee The calculated LayerZero messaging fee from the send() operation.\n     *\n     * @dev MessagingFee: LayerZero msg fee\n     *  - nativeFee: The native fee.\n     *  - lzTokenFee: The lzToken fee.\n     */\n    function quoteSend(\n        SendParam calldata _sendParam,\n        bool _payInLzToken\n    ) external view virtual returns (MessagingFee memory msgFee) {\n        // @dev mock the amount to receive, this is the same operation used in the send().\n        // The quote is as similar as possible to the actual send() operation.\n        (, uint256 amountReceivedLD) = _debitView(_sendParam.amountLD, _sendParam.minAmountLD, _sendParam.dstEid);\n\n        // @dev Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) = _buildMsgAndOptions(_sendParam, amountReceivedLD);\n\n        // @dev Calculates the LayerZero fee for the send() operation.\n        return _quote(_sendParam.dstEid, message, options, _payInLzToken);\n    }\n\n    /**\n     * @dev Executes the send operation.\n     * @param _sendParam The parameters for the send operation.\n     * @param _fee The calculated fee for the send() operation.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess funds.\n     * @return msgReceipt The receipt for the send operation.\n     * @return oftReceipt The OFT receipt information.\n     *\n     * @dev MessagingReceipt: LayerZero msg receipt\n     *  - guid: The unique identifier for the sent message.\n     *  - nonce: The nonce of the sent message.\n     *  - fee: The LayerZero fee incurred for the message.\n     */\n    function send(\n        SendParam calldata _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    ) external payable virtual returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt) {\n        return _send(_sendParam, _fee, _refundAddress);\n    }\n\n    /**\n     * @dev Internal function to execute the send operation.\n     * @param _sendParam The parameters for the send operation.\n     * @param _fee The calculated fee for the send() operation.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess funds.\n     * @return msgReceipt The receipt for the send operation.\n     * @return oftReceipt The OFT receipt information.\n     *\n     * @dev MessagingReceipt: LayerZero msg receipt\n     *  - guid: The unique identifier for the sent message.\n     *  - nonce: The nonce of the sent message.\n     *  - fee: The LayerZero fee incurred for the message.\n     */\n    function _send(\n        SendParam calldata _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    ) internal virtual returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt) {\n        // @dev Applies the token transfers regarding this send() operation.\n        // - amountSentLD is the amount in local decimals that was ACTUALLY sent/debited from the sender.\n        // - amountReceivedLD is the amount in local decimals that will be received/credited to the recipient on the remote OFT instance.\n        (uint256 amountSentLD, uint256 amountReceivedLD) = _debit(\n            msg.sender,\n            _sendParam.amountLD,\n            _sendParam.minAmountLD,\n            _sendParam.dstEid\n        );\n\n        // @dev Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) = _buildMsgAndOptions(_sendParam, amountReceivedLD);\n\n        // @dev Sends the message to the LayerZero endpoint and returns the LayerZero msg receipt.\n        msgReceipt = _lzSend(_sendParam.dstEid, message, options, _fee, _refundAddress);\n        // @dev Formulate the OFT receipt.\n        oftReceipt = OFTReceipt(amountSentLD, amountReceivedLD);\n\n        emit OFTSent(msgReceipt.guid, _sendParam.dstEid, msg.sender, amountSentLD, amountReceivedLD);\n    }\n\n    /**\n     * @dev Internal function to build the message and options.\n     * @param _sendParam The parameters for the send() operation.\n     * @param _amountLD The amount in local decimals.\n     * @return message The encoded message.\n     * @return options The encoded options.\n     */\n    function _buildMsgAndOptions(\n        SendParam calldata _sendParam,\n        uint256 _amountLD\n    ) internal view virtual returns (bytes memory message, bytes memory options) {\n        bool hasCompose;\n        // @dev This generated message has the msg.sender encoded into the payload so the remote knows who the caller is.\n        (message, hasCompose) = OFTMsgCodec.encode(\n            _sendParam.to,\n            _toSD(_amountLD),\n            // @dev Must be include a non empty bytes if you want to compose, EVEN if you dont need it on the remote.\n            // EVEN if you dont require an arbitrary payload to be sent... eg. '0x01'\n            _sendParam.composeMsg\n        );\n        // @dev Change the msg type depending if its composed or not.\n        uint16 msgType = hasCompose ? SEND_AND_CALL : SEND;\n        // @dev Combine the callers _extraOptions with the enforced options via the OAppOptionsType3.\n        options = combineOptions(_sendParam.dstEid, msgType, _sendParam.extraOptions);\n\n        // @dev Optionally inspect the message and options depending if the OApp owner has set a msg inspector.\n        // @dev If it fails inspection, needs to revert in the implementation. ie. does not rely on return boolean\n        address inspector = msgInspector; // caches the msgInspector to avoid potential double storage read\n        if (inspector != address(0)) IOAppMsgInspector(inspector).inspect(message, options);\n    }\n\n    /**\n     * @dev Internal function to handle the receive on the LayerZero endpoint.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The encoded message.\n     * @dev _executor The address of the executor.\n     * @dev _extraData Additional data.\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address /*_executor*/, // @dev unused in the default implementation.\n        bytes calldata /*_extraData*/ // @dev unused in the default implementation.\n    ) internal virtual override {\n        // @dev The src sending chain doesnt know the address length on this chain (potentially non-evm)\n        // Thus everything is bytes32() encoded in flight.\n        address toAddress = _message.sendTo().bytes32ToAddress();\n        // @dev Credit the amountLD to the recipient and return the ACTUAL amount the recipient received in local decimals\n        uint256 amountReceivedLD = _credit(toAddress, _toLD(_message.amountSD()), _origin.srcEid);\n\n        if (_message.isComposed()) {\n            // @dev Proprietary composeMsg format for the OFT.\n            bytes memory composeMsg = OFTComposeMsgCodec.encode(\n                _origin.nonce,\n                _origin.srcEid,\n                amountReceivedLD,\n                _message.composeMsg()\n            );\n\n            // @dev Stores the lzCompose payload that will be executed in a separate tx.\n            // Standardizes functionality for executing arbitrary contract invocation on some non-evm chains.\n            // @dev The off-chain executor will listen and process the msg based on the src-chain-callers compose options passed.\n            // @dev The index is used when a OApp needs to compose multiple msgs on lzReceive.\n            // For default OFT implementation there is only 1 compose msg per lzReceive, thus its always 0.\n            endpoint.sendCompose(toAddress, _guid, 0 /* the index of the composed message*/, composeMsg);\n        }\n\n        emit OFTReceived(_guid, _origin.srcEid, toAddress, amountReceivedLD);\n    }\n\n    /**\n     * @dev Internal function to handle the OAppPreCrimeSimulator simulated receive.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The LayerZero message.\n     * @param _executor The address of the off-chain executor.\n     * @param _extraData Arbitrary data passed by the msg executor.\n     *\n     * @dev Enables the preCrime simulator to mock sending lzReceive() messages,\n     * routes the msg down from the OAppPreCrimeSimulator, and back up to the OAppReceiver.\n     */\n    function _lzReceiveSimulate(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual override {\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Check if the peer is considered 'trusted' by the OApp.\n     * @param _eid The endpoint ID to check.\n     * @param _peer The peer to check.\n     * @return Whether the peer passed is considered 'trusted' by the OApp.\n     *\n     * @dev Enables OAppPreCrimeSimulator to check whether a potential Inbound Packet is from a trusted source.\n     */\n    function isPeer(uint32 _eid, bytes32 _peer) public view virtual override returns (bool) {\n        return peers[_eid] == _peer;\n    }\n\n    /**\n     * @dev Internal function to remove dust from the given local decimal amount.\n     * @param _amountLD The amount in local decimals.\n     * @return amountLD The amount after removing dust.\n     *\n     * @dev Prevents the loss of dust when moving amounts between chains with different decimals.\n     * @dev eg. uint(123) with a conversion rate of 100 becomes uint(100).\n     */\n    function _removeDust(uint256 _amountLD) internal view virtual returns (uint256 amountLD) {\n        return (_amountLD / decimalConversionRate) * decimalConversionRate;\n    }\n\n    /**\n     * @dev Internal function to convert an amount from shared decimals into local decimals.\n     * @param _amountSD The amount in shared decimals.\n     * @return amountLD The amount in local decimals.\n     */\n    function _toLD(uint64 _amountSD) internal view virtual returns (uint256 amountLD) {\n        return _amountSD * decimalConversionRate;\n    }\n\n    /**\n     * @dev Internal function to convert an amount from local decimals into shared decimals.\n     * @param _amountLD The amount in local decimals.\n     * @return amountSD The amount in shared decimals.\n     */\n    function _toSD(uint256 _amountLD) internal view virtual returns (uint64 amountSD) {\n        return uint64(_amountLD / decimalConversionRate);\n    }\n\n    /**\n     * @dev Internal function to mock the amount mutation from a OFT debit() operation.\n     * @param _amountLD The amount to send in local decimals.\n     * @param _minAmountLD The minimum amount to send in local decimals.\n     * @dev _dstEid The destination endpoint ID.\n     * @return amountSentLD The amount sent, in local decimals.\n     * @return amountReceivedLD The amount to be received on the remote chain, in local decimals.\n     *\n     * @dev This is where things like fees would be calculated and deducted from the amount to be received on the remote.\n     */\n    function _debitView(\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        uint32 /*_dstEid*/\n    ) internal view virtual returns (uint256 amountSentLD, uint256 amountReceivedLD) {\n        // @dev Remove the dust so nothing is lost on the conversion between chains with different decimals for the token.\n        amountSentLD = _removeDust(_amountLD);\n        // @dev The amount to send is the same as amount received in the default implementation.\n        amountReceivedLD = amountSentLD;\n\n        // @dev Check for slippage.\n        if (amountReceivedLD < _minAmountLD) {\n            revert SlippageExceeded(amountReceivedLD, _minAmountLD);\n        }\n    }\n\n    /**\n     * @dev Internal function to perform a debit operation.\n     * @param _from The address to debit.\n     * @param _amountLD The amount to send in local decimals.\n     * @param _minAmountLD The minimum amount to send in local decimals.\n     * @param _dstEid The destination endpoint ID.\n     * @return amountSentLD The amount sent in local decimals.\n     * @return amountReceivedLD The amount received in local decimals on the remote.\n     *\n     * @dev Defined here but are intended to be overriden depending on the OFT implementation.\n     * @dev Depending on OFT implementation the _amountLD could differ from the amountReceivedLD.\n     */\n    function _debit(\n        address _from,\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        uint32 _dstEid\n    ) internal virtual returns (uint256 amountSentLD, uint256 amountReceivedLD);\n\n    /**\n     * @dev Internal function to perform a credit operation.\n     * @param _to The address to credit.\n     * @param _amountLD The amount to credit in local decimals.\n     * @param _srcEid The source endpoint ID.\n     * @return amountReceivedLD The amount ACTUALLY received in local decimals.\n     *\n     * @dev Defined here but are intended to be overriden depending on the OFT implementation.\n     * @dev Depending on OFT implementation the _amountLD could differ from the amountReceivedLD.\n     */\n    function _credit(\n        address _to,\n        uint256 _amountLD,\n        uint32 _srcEid\n    ) internal virtual returns (uint256 amountReceivedLD);\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/automation/AbstractCCIPBridgeHelperModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractSafeModule } from \"./AbstractSafeModule.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IRouterClient } from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport { Client } from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\n\nabstract contract AbstractCCIPBridgeHelperModule is AbstractSafeModule {\n    /**\n     * @notice Bridges a token from the source chain to the destination chain using CCIP\n     * @param ccipRouter The CCIP router contract\n     * @param destinationChainSelector The selector for the destination chain\n     * @param token The token to bridge\n     * @param amount The amount of token to bridge\n     */\n    function _bridgeTokenWithCCIP(\n        IRouterClient ccipRouter,\n        uint64 destinationChainSelector,\n        IERC20 token,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        // Approve CCIP Router to move the token\n        success = safeContract.execTransactionFromModule(\n            address(token),\n            0, // Value\n            abi.encodeWithSelector(token.approve.selector, ccipRouter, amount),\n            0 // Call\n        );\n        require(success, \"Failed to approve token\");\n\n        Client.EVMTokenAmount[]\n            memory tokenAmounts = new Client.EVMTokenAmount[](1);\n        Client.EVMTokenAmount memory tokenAmount = Client.EVMTokenAmount({\n            token: address(token),\n            amount: amount\n        });\n        tokenAmounts[0] = tokenAmount;\n\n        Client.EVM2AnyMessage memory ccipMessage = Client.EVM2AnyMessage({\n            receiver: abi.encode(address(safeContract)), // ABI-encoded receiver address\n            data: abi.encode(\"\"),\n            tokenAmounts: tokenAmounts,\n            extraArgs: Client._argsToBytes(\n                Client.EVMExtraArgsV1({ gasLimit: 0 })\n            ),\n            feeToken: address(0)\n        });\n\n        // Get CCIP fee\n        uint256 ccipFee = ccipRouter.getFee(\n            destinationChainSelector,\n            ccipMessage\n        );\n\n        // Send CCIP message\n        success = safeContract.execTransactionFromModule(\n            address(ccipRouter),\n            ccipFee, // Value\n            abi.encodeWithSelector(\n                ccipRouter.ccipSend.selector,\n                destinationChainSelector,\n                ccipMessage\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to send CCIP message\");\n    }\n}\n"
    },
    "contracts/automation/AbstractLZBridgeHelperModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractSafeModule } from \"./AbstractSafeModule.sol\";\n\nimport { IOFT, SendParam } from \"@layerzerolabs/oft-evm/contracts/interfaces/IOFT.sol\";\nimport { MessagingFee } from \"@layerzerolabs/oapp-evm/contracts/oapp/OAppSender.sol\";\nimport { OptionsBuilder } from \"@layerzerolabs/oapp-evm/contracts/oapp/libs/OptionsBuilder.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nabstract contract AbstractLZBridgeHelperModule is AbstractSafeModule {\n    using OptionsBuilder for bytes;\n\n    /**\n     * @dev Bridges token using LayerZero.\n     * @param lzEndpointId LayerZero endpoint id.\n     * @param token Token to bridge.\n     * @param lzAdapter LZ Adapter to use.\n     * @param amount Amount of token to bridge.\n     * @param slippageBps Slippage in 10^4 basis points.\n     * @param isNativeToken Whether the token is native token.\n     */\n    function _bridgeTokenWithLz(\n        uint32 lzEndpointId,\n        IERC20 token,\n        IOFT lzAdapter,\n        uint256 amount,\n        uint256 slippageBps,\n        bool isNativeToken\n    ) internal {\n        bool success;\n\n        if (!isNativeToken) {\n            // Approve LZ Adapter to move the token\n            success = safeContract.execTransactionFromModule(\n                address(token),\n                0, // Value\n                abi.encodeWithSelector(\n                    token.approve.selector,\n                    address(lzAdapter),\n                    amount\n                ),\n                0 // Call\n            );\n            require(success, \"Failed to approve token\");\n        }\n\n        // Calculate minimum amount to receive\n        uint256 minAmount = (amount * (10000 - slippageBps)) / 10000;\n\n        // Hardcoded gaslimit of 400k\n        bytes memory options = OptionsBuilder\n            .newOptions()\n            .addExecutorLzReceiveOption(400000, 0);\n\n        // Build send param\n        SendParam memory sendParam = SendParam({\n            dstEid: lzEndpointId,\n            to: bytes32(uint256(uint160(address(safeContract)))),\n            amountLD: amount,\n            minAmountLD: minAmount,\n            extraOptions: options,\n            composeMsg: bytes(\"\"),\n            oftCmd: bytes(\"\")\n        });\n\n        // Compute fees\n        MessagingFee memory msgFee = lzAdapter.quoteSend(sendParam, false);\n\n        uint256 value = isNativeToken\n            ? amount + msgFee.nativeFee\n            : msgFee.nativeFee;\n\n        // Execute transaction\n        success = safeContract.execTransactionFromModule(\n            address(lzAdapter),\n            value,\n            abi.encodeWithSelector(\n                lzAdapter.send.selector,\n                sendParam,\n                msgFee,\n                address(safeContract)\n            ),\n            0\n        );\n        require(success, \"Failed to bridge token\");\n    }\n}\n"
    },
    "contracts/automation/AbstractSafeModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AccessControlEnumerable } from \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ISafe } from \"../interfaces/ISafe.sol\";\n\nabstract contract AbstractSafeModule is AccessControlEnumerable {\n    ISafe public immutable safeContract;\n\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n\n    modifier onlySafe() {\n        require(\n            msg.sender == address(safeContract),\n            \"Caller is not the safe contract\"\n        );\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(\n            hasRole(OPERATOR_ROLE, msg.sender),\n            \"Caller is not an operator\"\n        );\n        _;\n    }\n\n    constructor(address _safeContract) {\n        safeContract = ISafe(_safeContract);\n        _grantRole(DEFAULT_ADMIN_ROLE, address(safeContract));\n        _grantRole(OPERATOR_ROLE, address(safeContract));\n    }\n\n    /**\n     * @dev Helps recovering any tokens accidentally sent to this module.\n     * @param token Token to transfer. 0x0 to transfer Native token.\n     * @param amount Amount to transfer. 0 to transfer all balance.\n     */\n    function transferTokens(address token, uint256 amount) external onlySafe {\n        if (address(token) == address(0)) {\n            // Move ETH\n            amount = amount > 0 ? amount : address(this).balance;\n            payable(address(safeContract)).transfer(amount);\n            return;\n        }\n\n        // Move all balance if amount set to 0\n        amount = amount > 0 ? amount : IERC20(token).balanceOf(address(this));\n\n        // Transfer to Safe contract\n        // slither-disable-next-line unchecked-transfer unused-return\n        IERC20(token).transfer(address(safeContract), amount);\n    }\n\n    receive() external payable {\n        // Accept ETH to pay for bridge fees\n    }\n}\n"
    },
    "contracts/automation/BaseBridgeHelperModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line max-line-length\nimport { AbstractCCIPBridgeHelperModule, AbstractSafeModule, IRouterClient } from \"./AbstractCCIPBridgeHelperModule.sol\";\n\nimport { AccessControlEnumerable } from \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC4626 } from \"../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\nimport { BridgedWOETHStrategy } from \"../strategies/BridgedWOETHStrategy.sol\";\n\ncontract BaseBridgeHelperModule is\n    AccessControlEnumerable,\n    AbstractCCIPBridgeHelperModule\n{\n    IVault public constant vault =\n        IVault(0x98a0CbeF61bD2D21435f433bE4CD42B56B38CC93);\n    IWETH9 public constant weth =\n        IWETH9(0x4200000000000000000000000000000000000006);\n    IERC20 public constant oethb =\n        IERC20(0xDBFeFD2e8460a6Ee4955A68582F85708BAEA60A3);\n    IERC4626 public constant bridgedWOETH =\n        IERC4626(0xD8724322f44E5c58D7A815F542036fb17DbbF839);\n\n    BridgedWOETHStrategy public constant bridgedWOETHStrategy =\n        BridgedWOETHStrategy(0x80c864704DD06C3693ed5179190786EE38ACf835);\n\n    IRouterClient public constant CCIP_ROUTER =\n        IRouterClient(0x881e3A65B4d4a04dD529061dd0071cf975F58bCD);\n\n    uint64 public constant CCIP_ETHEREUM_CHAIN_SELECTOR = 5009297550715157269;\n\n    constructor(address _safeContract) AbstractSafeModule(_safeContract) {}\n\n    /**\n     * @dev Bridges wOETH to Ethereum.\n     * @param woethAmount Amount of wOETH to bridge.\n     */\n    function bridgeWOETHToEthereum(uint256 woethAmount)\n        public\n        payable\n        onlyOperator\n    {\n        _bridgeTokenWithCCIP(\n            CCIP_ROUTER,\n            CCIP_ETHEREUM_CHAIN_SELECTOR,\n            IERC20(address(bridgedWOETH)),\n            woethAmount\n        );\n    }\n\n    /**\n     * @dev Bridges WETH to Ethereum.\n     * @param wethAmount Amount of WETH to bridge.\n     */\n    function bridgeWETHToEthereum(uint256 wethAmount)\n        public\n        payable\n        onlyOperator\n    {\n        _bridgeTokenWithCCIP(\n            CCIP_ROUTER,\n            CCIP_ETHEREUM_CHAIN_SELECTOR,\n            IERC20(address(weth)),\n            wethAmount\n        );\n    }\n\n    /**\n     * @dev Deposits wOETH into the bridgedWOETH strategy.\n     * @param woethAmount Amount of wOETH to deposit.\n     * @param redeemWithVault Whether to redeem the wOETH for WETH using the Vault.\n     * @return Amount of WETH received.\n     */\n    function depositWOETH(uint256 woethAmount, bool redeemWithVault)\n        external\n        onlyOperator\n        returns (uint256)\n    {\n        return _depositWOETH(woethAmount, redeemWithVault);\n    }\n\n    /**\n     * @dev Deposits wOETH into the bridgedWOETH strategy and bridges it to Ethereum.\n     * @param woethAmount Amount of wOETH to deposit.\n     * @return Amount of WETH received.\n     */\n    function depositWOETHAndBridgeWETH(uint256 woethAmount)\n        external\n        onlyOperator\n        returns (uint256)\n    {\n        uint256 wethAmount = _depositWOETH(woethAmount, true);\n        bridgeWETHToEthereum(wethAmount);\n        return wethAmount;\n    }\n\n    /**\n     * @dev Deposits wOETH into the bridgedWOETH strategy.\n     * @param woethAmount Amount of wOETH to deposit.\n     * @param redeemWithVault Whether to redeem the wOETH for WETH using the Vault.\n     * @return Amount of WETH received.\n     */\n    function _depositWOETH(uint256 woethAmount, bool redeemWithVault)\n        internal\n        returns (uint256)\n    {\n        // Update oracle price\n        bridgedWOETHStrategy.updateWOETHOraclePrice();\n\n        // Rebase to account for any yields from price update\n        vault.rebase();\n\n        uint256 oethbAmount = oethb.balanceOf(address(safeContract));\n\n        // Approve bridgedWOETH strategy to move wOETH\n        bool success = safeContract.execTransactionFromModule(\n            address(bridgedWOETH),\n            0, // Value\n            abi.encodeWithSelector(\n                bridgedWOETH.approve.selector,\n                address(bridgedWOETHStrategy),\n                woethAmount\n            ),\n            0 // Call\n        );\n\n        // Deposit to bridgedWOETH strategy\n        success = safeContract.execTransactionFromModule(\n            address(bridgedWOETHStrategy),\n            0, // Value\n            abi.encodeWithSelector(\n                bridgedWOETHStrategy.depositBridgedWOETH.selector,\n                woethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to deposit bridged WOETH\");\n\n        oethbAmount = oethb.balanceOf(address(safeContract)) - oethbAmount;\n\n        // Rebase to account for any yields from price update\n        // and backing asset change from deposit\n        vault.rebase();\n\n        if (!redeemWithVault) {\n            return oethbAmount;\n        }\n\n        // Redeem for WETH using Vault\n        success = safeContract.execTransactionFromModule(\n            address(vault),\n            0, // Value\n            abi.encodeWithSelector(\n                vault.redeem.selector,\n                oethbAmount,\n                oethbAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to redeem OETHb\");\n\n        return oethbAmount;\n    }\n\n    /**\n     * @dev Deposits WETH into the Vault and redeems wOETH from the bridgedWOETH strategy.\n     * @param wethAmount Amount of WETH to deposit.\n     * @return Amount of wOETH received.\n     */\n    function depositWETHAndRedeemWOETH(uint256 wethAmount)\n        external\n        onlyOperator\n        returns (uint256)\n    {\n        return _withdrawWOETH(wethAmount);\n    }\n\n    function depositWETHAndBridgeWOETH(uint256 wethAmount)\n        external\n        onlyOperator\n        returns (uint256)\n    {\n        uint256 woethAmount = _withdrawWOETH(wethAmount);\n        bridgeWOETHToEthereum(woethAmount);\n        return woethAmount;\n    }\n\n    /**\n     * @dev Withdraws wOETH from the bridgedWOETH strategy.\n     * @param wethAmount Amount of WETH to use to withdraw.\n     * @return Amount of wOETH received.\n     */\n    function _withdrawWOETH(uint256 wethAmount) internal returns (uint256) {\n        // Approve Vault to move WETH\n        bool success = safeContract.execTransactionFromModule(\n            address(weth),\n            0, // Value\n            abi.encodeWithSelector(\n                weth.approve.selector,\n                address(vault),\n                wethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to approve WETH\");\n\n        // Mint OETHb with WETH\n        success = safeContract.execTransactionFromModule(\n            address(vault),\n            0, // Value\n            abi.encodeWithSelector(\n                vault.mint.selector,\n                address(weth),\n                wethAmount,\n                wethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to mint OETHb\");\n\n        // Approve bridgedWOETH strategy to move OETHb\n        success = safeContract.execTransactionFromModule(\n            address(oethb),\n            0, // Value\n            abi.encodeWithSelector(\n                oethb.approve.selector,\n                address(bridgedWOETHStrategy),\n                wethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to approve OETHb\");\n\n        uint256 woethAmount = bridgedWOETH.balanceOf(address(safeContract));\n\n        // Withdraw from bridgedWOETH strategy\n        success = safeContract.execTransactionFromModule(\n            address(bridgedWOETHStrategy),\n            0, // Value\n            abi.encodeWithSelector(\n                bridgedWOETHStrategy.withdrawBridgedWOETH.selector,\n                wethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to withdraw bridged WOETH\");\n\n        woethAmount =\n            bridgedWOETH.balanceOf(address(safeContract)) -\n            woethAmount;\n\n        return woethAmount;\n    }\n}\n"
    },
    "contracts/automation/ClaimBribesSafeModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractSafeModule } from \"./AbstractSafeModule.sol\";\nimport { ICLGauge } from \"../interfaces/aerodrome/ICLGauge.sol\";\nimport { ICLPool } from \"../interfaces/aerodrome/ICLPool.sol\";\n\nstruct BribePoolInfo {\n    address poolAddress;\n    address rewardContractAddress;\n    address[] rewardTokens;\n}\n\ninterface IAerodromeVoter {\n    function claimBribes(\n        address[] memory _bribes,\n        address[][] memory _tokens,\n        uint256 _tokenId\n    ) external;\n}\n\ninterface IVeNFT {\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    function ownerToNFTokenIdList(address owner, uint256 index)\n        external\n        view\n        returns (uint256);\n}\n\ninterface ICLRewardContract {\n    function rewards(uint256 index) external view returns (address);\n\n    function rewardsListLength() external view returns (uint256);\n}\n\ncontract ClaimBribesSafeModule is AbstractSafeModule {\n    IAerodromeVoter public immutable voter;\n    address public immutable veNFT;\n\n    uint256[] nftIds;\n    mapping(uint256 => uint256) nftIdIndex;\n\n    BribePoolInfo[] bribePools;\n    mapping(address => uint256) bribePoolIndex;\n\n    event NFTIdAdded(uint256 nftId);\n    event NFTIdRemoved(uint256 nftId);\n\n    event BribePoolAdded(address bribePool);\n    event BribePoolRemoved(address bribePool);\n\n    constructor(\n        address _safeContract,\n        address _voter,\n        address _veNFT\n    ) AbstractSafeModule(_safeContract) {\n        voter = IAerodromeVoter(_voter);\n        veNFT = _veNFT;\n    }\n\n    /**\n     * @dev Claim bribes for a range of NFTs\n     * @param nftIndexStart The start index of the NFTs\n     * @param nftIndexEnd The end index of the NFTs\n     * @param silent Doesn't revert if the claim fails when true\n     */\n    function claimBribes(\n        uint256 nftIndexStart,\n        uint256 nftIndexEnd,\n        bool silent\n    ) external onlyOperator {\n        if (nftIndexEnd < nftIndexStart) {\n            (nftIndexStart, nftIndexEnd) = (nftIndexEnd, nftIndexStart);\n        }\n        uint256 nftCount = nftIds.length;\n        nftIndexEnd = nftCount < nftIndexEnd ? nftCount : nftIndexEnd;\n\n        (\n            address[] memory rewardContractAddresses,\n            address[][] memory rewardTokens\n        ) = _getRewardsInfoArray();\n\n        for (uint256 i = nftIndexStart; i < nftIndexEnd; i++) {\n            uint256 nftId = nftIds[i];\n            bool success = safeContract.execTransactionFromModule(\n                address(voter),\n                0, // Value\n                abi.encodeWithSelector(\n                    IAerodromeVoter.claimBribes.selector,\n                    rewardContractAddresses,\n                    rewardTokens,\n                    nftId\n                ),\n                0 // Call\n            );\n\n            require(success || silent, \"ClaimBribes failed\");\n        }\n    }\n\n    /**\n     * @dev Get the reward contract address and reward tokens for all pools\n     * @return rewardContractAddresses The reward contract addresses\n     * @return rewardTokens The reward tokens\n     */\n    function _getRewardsInfoArray()\n        internal\n        view\n        returns (\n            address[] memory rewardContractAddresses,\n            address[][] memory rewardTokens\n        )\n    {\n        BribePoolInfo[] memory _bribePools = bribePools;\n        uint256 bribePoolCount = _bribePools.length;\n        rewardContractAddresses = new address[](bribePoolCount);\n        rewardTokens = new address[][](bribePoolCount);\n\n        for (uint256 i = 0; i < bribePoolCount; i++) {\n            rewardContractAddresses[i] = _bribePools[i].rewardContractAddress;\n            rewardTokens[i] = _bribePools[i].rewardTokens;\n        }\n    }\n\n    /***************************************\n                NFT Management\n    ****************************************/\n    /**\n     * @dev Add NFT IDs to the list\n     * @param _nftIds The NFT IDs to add\n     */\n    function addNFTIds(uint256[] memory _nftIds) external onlyOperator {\n        for (uint256 i = 0; i < _nftIds.length; i++) {\n            uint256 nftId = _nftIds[i];\n            if (nftIdExists(nftId)) {\n                // If it already exists, skip\n                continue;\n            }\n\n            // Make sure the NFT is owned by the Safe\n            require(\n                IVeNFT(veNFT).ownerOf(nftId) == address(safeContract),\n                \"NFT not owned by safe\"\n            );\n\n            nftIdIndex[nftId] = nftIds.length;\n            nftIds.push(nftId);\n\n            emit NFTIdAdded(nftId);\n        }\n    }\n\n    /**\n     * @dev Remove NFT IDs from the list\n     * @param _nftIds The NFT IDs to remove\n     */\n    function removeNFTIds(uint256[] memory _nftIds) external onlyOperator {\n        for (uint256 i = 0; i < _nftIds.length; i++) {\n            uint256 nftId = _nftIds[i];\n            if (!nftIdExists(nftId)) {\n                // If it doesn't exist, skip\n                continue;\n            }\n\n            uint256 index = nftIdIndex[nftId];\n            uint256 lastNftId = nftIds[nftIds.length - 1];\n            nftIds[index] = lastNftId;\n            nftIdIndex[lastNftId] = index;\n            nftIds.pop();\n\n            emit NFTIdRemoved(nftId);\n        }\n    }\n\n    /**\n     * @dev Check if a NFT exists on the list\n     * @param nftId The NFT ID to check\n     * @return true if the NFT ID exists, false otherwise\n     */\n    function nftIdExists(uint256 nftId) public view returns (bool) {\n        uint256 index = nftIdIndex[nftId];\n        uint256[] memory _nftIds = nftIds;\n        return (index < _nftIds.length) && _nftIds[index] == nftId;\n    }\n\n    /**\n     * @dev Get the length of the nftIds list\n     * @return The length of the nftIds list\n     */\n    function getNFTIdsLength() external view returns (uint256) {\n        return nftIds.length;\n    }\n\n    /**\n     * @dev Get all NFT IDs\n     * @return The NFT IDs\n     */\n    function getAllNFTIds() external view returns (uint256[] memory) {\n        return nftIds;\n    }\n\n    /**\n     * @dev Fetch all NFT IDs from the veNFT contract\n     * @notice This can revert if Safe owns too many NFTs since tx will be huge.\n     *         This function is public, anyone can call it, since it only fetches\n     *         the NFT IDs owned by the Safe. It shouldn't cause us any issues.\n     */\n    function fetchNFTIds() external {\n        // Purge the array\n        delete nftIds;\n\n        uint256 i = 0;\n        while (true) {\n            uint256 nftId = IVeNFT(veNFT).ownerToNFTokenIdList(\n                address(safeContract),\n                i\n            );\n            if (nftId == 0) {\n                break;\n            }\n\n            nftIdIndex[nftId] = nftIds.length;\n            nftIds.push(nftId);\n            i++;\n        }\n    }\n\n    /**\n     * @dev Remove all NFT IDs from the list\n     */\n    function removeAllNFTIds() external onlyOperator {\n        uint256 length = nftIds.length;\n        for (uint256 i = 0; i < length; i++) {\n            uint256 nftId = nftIds[i];\n            delete nftIdIndex[nftId];\n            emit NFTIdRemoved(nftId);\n        }\n\n        delete nftIds;\n    }\n\n    /***************************************\n            Bribe Pool Management\n    ****************************************/\n    // @dev Whitelist a pool to claim bribes from\n    // @param _poolAddress The address of the pool to whitelist\n    function addBribePool(address _poolAddress, bool _isVotingContract)\n        external\n        onlySafe\n    {\n        BribePoolInfo memory bribePool;\n\n        if (_isVotingContract) {\n            bribePool = BribePoolInfo({\n                poolAddress: _poolAddress,\n                rewardContractAddress: _poolAddress,\n                rewardTokens: _getRewardTokenAddresses(_poolAddress)\n            });\n        } else {\n            // Find the gauge address\n            address _gaugeAddress = ICLPool(_poolAddress).gauge();\n            // And the reward contract address\n            address _rewardContractAddress = ICLGauge(_gaugeAddress)\n                .feesVotingReward();\n\n            bribePool = BribePoolInfo({\n                poolAddress: _poolAddress,\n                rewardContractAddress: _rewardContractAddress,\n                rewardTokens: _getRewardTokenAddresses(_rewardContractAddress)\n            });\n        }\n\n        if (bribePoolExists(_poolAddress)) {\n            // Update if it already exists\n            bribePools[bribePoolIndex[_poolAddress]] = bribePool;\n        } else {\n            // If not, Append to the list\n            bribePoolIndex[_poolAddress] = bribePools.length;\n            bribePools.push(bribePool);\n        }\n\n        emit BribePoolAdded(_poolAddress);\n    }\n\n    /**\n     * @dev Update the reward token addresses for all pools\n     */\n    function updateRewardTokenAddresses() external onlyOperator {\n        BribePoolInfo[] storage _bribePools = bribePools;\n        for (uint256 i = 0; i < _bribePools.length; i++) {\n            BribePoolInfo storage bribePool = _bribePools[i];\n            bribePool.rewardTokens = _getRewardTokenAddresses(\n                bribePool.rewardContractAddress == bribePool.poolAddress\n                    ? bribePool.poolAddress\n                    : bribePool.rewardContractAddress\n            );\n        }\n    }\n\n    /**\n     * @dev Get the reward token addresses for a given reward contract address\n     * @param _rewardContractAddress The address of the reward contract\n     * @return _rewardTokens The reward token addresses\n     */\n    function _getRewardTokenAddresses(address _rewardContractAddress)\n        internal\n        view\n        returns (address[] memory)\n    {\n        address[] memory _rewardTokens = new address[](\n            ICLRewardContract(_rewardContractAddress).rewardsListLength()\n        );\n        for (uint256 i = 0; i < _rewardTokens.length; i++) {\n            _rewardTokens[i] = ICLRewardContract(_rewardContractAddress)\n                .rewards(i);\n        }\n\n        return _rewardTokens;\n    }\n\n    /**\n     * @dev Remove a bribe pool from the list\n     * @param _poolAddress The address of the pool to remove\n     */\n    function removeBribePool(address _poolAddress) external onlySafe {\n        if (!bribePoolExists(_poolAddress)) {\n            // If it doesn't exist, skip\n            return;\n        }\n\n        uint256 index = bribePoolIndex[_poolAddress];\n        BribePoolInfo memory lastBribePool = bribePools[bribePools.length - 1];\n        bribePools[index] = lastBribePool;\n        bribePoolIndex[lastBribePool.poolAddress] = index;\n        bribePools.pop();\n\n        emit BribePoolRemoved(_poolAddress);\n    }\n\n    /**\n     * @dev Check if a bribe pool exists\n     * @param bribePool The address of the pool to check\n     * @return true if the pool exists, false otherwise\n     */\n    function bribePoolExists(address bribePool) public view returns (bool) {\n        BribePoolInfo[] memory _bribePools = bribePools;\n        uint256 poolIndex = bribePoolIndex[bribePool];\n        return\n            poolIndex < _bribePools.length &&\n            _bribePools[poolIndex].poolAddress == bribePool;\n    }\n\n    /**\n     * @dev Get the length of the bribe pools list\n     * @return The length of the bribe pools list\n     */\n    function getBribePoolsLength() external view returns (uint256) {\n        return bribePools.length;\n    }\n}\n"
    },
    "contracts/automation/ClaimStrategyRewardsSafeModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { AbstractSafeModule } from \"./AbstractSafeModule.sol\";\n\nimport { ISafe } from \"../interfaces/ISafe.sol\";\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract ClaimStrategyRewardsSafeModule is AbstractSafeModule {\n    using SafeERC20 for IERC20;\n\n    mapping(address => bool) public isStrategyWhitelisted;\n    address[] public strategies;\n\n    event StrategyAdded(address strategy);\n    event StrategyRemoved(address strategy);\n\n    event ClaimRewardsFailed(address strategy);\n\n    constructor(\n        address _safeAddress,\n        address operator,\n        address[] memory _strategies\n    ) AbstractSafeModule(_safeAddress) {\n        _grantRole(OPERATOR_ROLE, operator);\n\n        // Whitelist all strategies\n        for (uint256 i = 0; i < _strategies.length; i++) {\n            _addStrategy(_strategies[i]);\n        }\n    }\n\n    /**\n     * @dev Claim rewards from all whitelisted strategies\n     * @param silent Doesn't revert on error if set to true\n     */\n    function claimRewards(bool silent) external onlyRole(OPERATOR_ROLE) {\n        uint256 strategiesLength = strategies.length;\n        for (uint256 i = 0; i < strategiesLength; i++) {\n            address strategy = strategies[i];\n\n            // Execute `collectRewardTokens` for all strategies\n            bool success = safeContract.execTransactionFromModule(\n                strategy, // To\n                0, // Value\n                abi.encodeWithSelector(IStrategy.collectRewardTokens.selector),\n                0 // Call\n            );\n\n            if (!success) {\n                emit ClaimRewardsFailed(strategy);\n            }\n\n            require(success || silent, \"Failed to claim rewards\");\n        }\n    }\n\n    /**\n     * @dev Add a strategy to the whitelist\n     * @param _strategy The address of the strategy to add\n     */\n    function addStrategy(address _strategy)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        _addStrategy(_strategy);\n    }\n\n    function _addStrategy(address _strategy) internal {\n        require(\n            !isStrategyWhitelisted[_strategy],\n            \"Strategy already whitelisted\"\n        );\n        isStrategyWhitelisted[_strategy] = true;\n        strategies.push(_strategy);\n        emit StrategyAdded(_strategy);\n    }\n\n    /**\n     * @dev Remove a strategy from the whitelist\n     * @param _strategy The address of the strategy to remove\n     */\n    function removeStrategy(address _strategy)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(isStrategyWhitelisted[_strategy], \"Strategy not whitelisted\");\n        isStrategyWhitelisted[_strategy] = false;\n\n        for (uint256 i = 0; i < strategies.length; i++) {\n            if (strategies[i] == _strategy) {\n                strategies[i] = strategies[strategies.length - 1];\n                strategies.pop();\n                break;\n            }\n        }\n\n        emit StrategyRemoved(_strategy);\n    }\n}\n"
    },
    "contracts/automation/CollectXOGNRewardsModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractSafeModule } from \"./AbstractSafeModule.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IXOGN {\n    function collectRewards() external;\n}\n\ncontract CollectXOGNRewardsModule is AbstractSafeModule {\n    IXOGN public constant xogn =\n        IXOGN(0x63898b3b6Ef3d39332082178656E9862bee45C57);\n    address public constant rewardsSource =\n        0x7609c88E5880e934dd3A75bCFef44E31b1Badb8b;\n    IERC20 public constant ogn =\n        IERC20(0x8207c1FfC5B6804F6024322CcF34F29c3541Ae26);\n\n    constructor(address _safeContract, address operator)\n        AbstractSafeModule(_safeContract)\n    {\n        _grantRole(OPERATOR_ROLE, operator);\n    }\n\n    function collectRewards() external onlyOperator {\n        uint256 balance = ogn.balanceOf(address(safeContract));\n\n        bool success = safeContract.execTransactionFromModule(\n            address(xogn),\n            0, // Value\n            abi.encodeWithSelector(IXOGN.collectRewards.selector),\n            0 // Call\n        );\n\n        require(success, \"Failed to collect rewards\");\n\n        balance = ogn.balanceOf(address(safeContract)) - balance;\n\n        if (balance == 0) {\n            return;\n        }\n\n        success = safeContract.execTransactionFromModule(\n            address(ogn),\n            0, // Value\n            abi.encodeWithSelector(\n                IERC20.transfer.selector,\n                rewardsSource,\n                balance\n            ),\n            0 // Call\n        );\n\n        require(success, \"Failed to collect rewards\");\n    }\n}\n"
    },
    "contracts/automation/CurvePoolBoosterBribesModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractSafeModule } from \"./AbstractSafeModule.sol\";\n\ninterface ICurvePoolBooster {\n    function manageTotalRewardAmount(\n        uint256 bridgeFee,\n        uint256 additionalGasLimit\n    ) external;\n\n    function manageNumberOfPeriods(\n        uint8 extraNumberOfPeriods,\n        uint256 bridgeFee,\n        uint256 additionalGasLimit\n    ) external;\n}\n\ncontract CurvePoolBoosterBribesModule is AbstractSafeModule {\n    address[] public POOLS;\n\n    event PoolBoosterAddressAdded(address pool);\n    event PoolBoosterAddressRemoved(address pool);\n\n    constructor(\n        address _safeContract,\n        address _operator,\n        address[] memory _pools\n    ) AbstractSafeModule(_safeContract) {\n        _grantRole(OPERATOR_ROLE, _operator);\n        _addPoolBoosterAddress(_pools);\n    }\n\n    function addPoolBoosterAddress(address[] memory pools)\n        external\n        onlyOperator\n    {\n        _addPoolBoosterAddress(pools);\n    }\n\n    function _addPoolBoosterAddress(address[] memory pools) internal {\n        for (uint256 i = 0; i < pools.length; i++) {\n            POOLS.push(pools[i]);\n            emit PoolBoosterAddressAdded(pools[i]);\n        }\n    }\n\n    function removePoolBoosterAddress(address[] calldata pools)\n        external\n        onlyOperator\n    {\n        for (uint256 i = 0; i < pools.length; i++) {\n            _removePoolBoosterAddress(pools[i]);\n        }\n    }\n\n    function _removePoolBoosterAddress(address pool) internal {\n        uint256 length = POOLS.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (POOLS[i] == pool) {\n                POOLS[i] = POOLS[length - 1];\n                POOLS.pop();\n                emit PoolBoosterAddressRemoved(pool);\n            }\n        }\n    }\n\n    function manageBribes() external onlyOperator {\n        uint256 length = POOLS.length;\n        for (uint256 i = 0; i < length; i++) {\n            address poolBoosterAddress = POOLS[i];\n\n            // PoolBooster need to have a balance of at least 0.002 ether to operate\n            // 0.001 ether are used for the bridge fee\n            require(\n                poolBoosterAddress.balance > 0.002 ether,\n                \"Insufficient balance for bribes\"\n            );\n\n            require(\n                safeContract.execTransactionFromModule(\n                    poolBoosterAddress,\n                    0, // Value\n                    abi.encodeWithSelector(\n                        ICurvePoolBooster.manageNumberOfPeriods.selector,\n                        1, // extraNumberOfPeriods\n                        0.001 ether, // bridgeFee\n                        1000000 // additionalGasLimit\n                    ),\n                    0\n                ),\n                \"Manage number of periods failed\"\n            );\n\n            require(\n                safeContract.execTransactionFromModule(\n                    poolBoosterAddress,\n                    0, // Value\n                    abi.encodeWithSelector(\n                        ICurvePoolBooster.manageTotalRewardAmount.selector,\n                        0.001 ether, // bridgeFee\n                        1000000 // additionalGasLimit\n                    ),\n                    0\n                ),\n                \"Manage total reward failed\"\n            );\n        }\n    }\n}\n"
    },
    "contracts/automation/EthereumBridgeHelperModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractLZBridgeHelperModule, AbstractSafeModule } from \"./AbstractLZBridgeHelperModule.sol\";\nimport { AbstractCCIPBridgeHelperModule, IRouterClient } from \"./AbstractCCIPBridgeHelperModule.sol\";\n\nimport { AccessControlEnumerable } from \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\n\nimport { IOFT } from \"@layerzerolabs/oft-evm/contracts/interfaces/IOFT.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC4626 } from \"../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract EthereumBridgeHelperModule is\n    AccessControlEnumerable,\n    AbstractLZBridgeHelperModule,\n    AbstractCCIPBridgeHelperModule\n{\n    IVault public constant vault =\n        IVault(0x39254033945AA2E4809Cc2977E7087BEE48bd7Ab);\n    IWETH9 public constant weth =\n        IWETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20 public constant oeth =\n        IERC20(0x856c4Efb76C1D1AE02e20CEB03A2A6a08b0b8dC3);\n    IERC4626 public constant woeth =\n        IERC4626(0xDcEe70654261AF21C44c093C300eD3Bb97b78192);\n\n    uint32 public constant LZ_PLUME_ENDPOINT_ID = 30370;\n    IOFT public constant LZ_WOETH_OMNICHAIN_ADAPTER =\n        IOFT(0x7d1bEa5807e6af125826d56ff477745BB89972b8);\n    IOFT public constant LZ_ETH_OMNICHAIN_ADAPTER =\n        IOFT(0x77b2043768d28E9C9aB44E1aBfC95944bcE57931);\n\n    IRouterClient public constant CCIP_ROUTER =\n        IRouterClient(0x80226fc0Ee2b096224EeAc085Bb9a8cba1146f7D);\n\n    uint64 public constant CCIP_BASE_CHAIN_SELECTOR = 15971525489660198786;\n\n    constructor(address _safeContract) AbstractSafeModule(_safeContract) {}\n\n    /**\n     * @dev Bridges wOETH to Plume.\n     * @param woethAmount Amount of wOETH to bridge.\n     * @param slippageBps Slippage in 10^4 basis points.\n     */\n    function bridgeWOETHToPlume(uint256 woethAmount, uint256 slippageBps)\n        public\n        payable\n        onlyOperator\n    {\n        _bridgeTokenWithLz(\n            LZ_PLUME_ENDPOINT_ID,\n            woeth,\n            LZ_WOETH_OMNICHAIN_ADAPTER,\n            woethAmount,\n            slippageBps,\n            false\n        );\n    }\n\n    /**\n     * @dev Bridges wOETH to Base using CCIP.\n     * @param woethAmount Amount of wOETH to bridge.\n     */\n    function bridgeWOETHToBase(uint256 woethAmount)\n        public\n        payable\n        onlyOperator\n    {\n        _bridgeTokenWithCCIP(\n            CCIP_ROUTER,\n            CCIP_BASE_CHAIN_SELECTOR,\n            woeth,\n            woethAmount\n        );\n    }\n\n    /**\n     * @dev Bridges wETH to Plume.\n     * @param wethAmount Amount of wETH to bridge.\n     * @param slippageBps Slippage in 10^4 basis points.\n     */\n    function bridgeWETHToPlume(uint256 wethAmount, uint256 slippageBps)\n        public\n        payable\n        onlyOperator\n    {\n        // Unwrap into ETH\n        safeContract.execTransactionFromModule(\n            address(weth),\n            0, // Value\n            abi.encodeWithSelector(weth.withdraw.selector, wethAmount),\n            0 // Call\n        );\n\n        _bridgeTokenWithLz(\n            LZ_PLUME_ENDPOINT_ID,\n            IERC20(address(weth)),\n            LZ_ETH_OMNICHAIN_ADAPTER,\n            wethAmount,\n            slippageBps,\n            true\n        );\n    }\n\n    /**\n     * @dev Bridges wETH to Base using CCIP.\n     * @param wethAmount Amount of wETH to bridge.\n     */\n    function bridgeWETHToBase(uint256 wethAmount) public payable onlyOperator {\n        _bridgeTokenWithCCIP(\n            CCIP_ROUTER,\n            CCIP_BASE_CHAIN_SELECTOR,\n            IERC20(address(weth)),\n            wethAmount\n        );\n    }\n\n    /**\n     * @dev Mints OETH and wraps it into wOETH.\n     * @param wethAmount Amount of WETH to mint.\n     * @param useNativeToken Whether to use native token to mint.\n     * @return Amount of wOETH minted.\n     */\n    function mintAndWrap(uint256 wethAmount, bool useNativeToken)\n        external\n        onlyOperator\n        returns (uint256)\n    {\n        if (useNativeToken) {\n            wrapETH(wethAmount);\n        }\n\n        return _mintAndWrap(wethAmount);\n    }\n\n    function wrapETH(uint256 ethAmount) public payable onlyOperator {\n        // Deposit ETH into WETH\n        safeContract.execTransactionFromModule(\n            address(weth),\n            ethAmount, // Value\n            abi.encodeWithSelector(weth.deposit.selector),\n            0 // Call\n        );\n    }\n\n    /**\n     * @dev Mints OETH and wraps it into wOETH.\n     * @param wethAmount Amount of WETH to mint.\n     * @return Amount of wOETH minted.\n     */\n    function _mintAndWrap(uint256 wethAmount) internal returns (uint256) {\n        // Approve Vault to move WETH\n        bool success = safeContract.execTransactionFromModule(\n            address(weth),\n            0, // Value\n            abi.encodeWithSelector(\n                weth.approve.selector,\n                address(vault),\n                wethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to approve WETH\");\n\n        // Mint OETH\n        success = safeContract.execTransactionFromModule(\n            address(vault),\n            0, // Value\n            abi.encodeWithSelector(\n                vault.mint.selector,\n                address(weth),\n                wethAmount,\n                wethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to mint OETH\");\n\n        // Approve wOETH to move OETH\n        success = safeContract.execTransactionFromModule(\n            address(oeth),\n            0, // Value\n            abi.encodeWithSelector(\n                oeth.approve.selector,\n                address(woeth),\n                wethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to approve OETH\");\n\n        uint256 woethAmount = woeth.balanceOf(address(safeContract));\n\n        // Wrap OETH into wOETH\n        success = safeContract.execTransactionFromModule(\n            address(woeth),\n            0, // Value\n            abi.encodeWithSelector(\n                woeth.deposit.selector,\n                wethAmount,\n                address(safeContract)\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to wrap OETH\");\n\n        // Compute amount of wOETH minted\n        return woeth.balanceOf(address(safeContract)) - woethAmount;\n    }\n\n    /**\n     * @dev Mints OETH and wraps it into wOETH, then bridges it to Plume.\n     * @param wethAmount Amount of WETH to mint.\n     * @param slippageBps Bridge slippage in 10^4 basis points.\n     * @param useNativeToken Whether to use native token to mint.\n     */\n    function mintWrapAndBridgeToPlume(\n        uint256 wethAmount,\n        uint256 slippageBps,\n        bool useNativeToken\n    ) external payable onlyOperator {\n        if (useNativeToken) {\n            wrapETH(wethAmount);\n        }\n\n        uint256 woethAmount = _mintAndWrap(wethAmount);\n        bridgeWOETHToPlume(woethAmount, slippageBps);\n    }\n\n    /**\n     * @dev Mints OETH and wraps it into wOETH, then bridges it to Base using CCIP.\n     * @param wethAmount Amount of WETH to mint.\n     * @param useNativeToken Whether to use native token to mint.\n     */\n    function mintWrapAndBridgeToBase(uint256 wethAmount, bool useNativeToken)\n        external\n        payable\n        onlyOperator\n    {\n        if (useNativeToken) {\n            wrapETH(wethAmount);\n        }\n\n        uint256 woethAmount = _mintAndWrap(wethAmount);\n        bridgeWOETHToBase(woethAmount);\n    }\n\n    /**\n     * @dev Unwraps wOETH and redeems it to get WETH.\n     * @param woethAmount Amount of wOETH to unwrap.\n     * @return Amount of WETH received.\n     */\n    function unwrapAndRedeem(uint256 woethAmount)\n        external\n        onlyOperator\n        returns (uint256)\n    {\n        return _unwrapAndRedeem(woethAmount);\n    }\n\n    /**\n     * @dev Unwraps wOETH and redeems it to get WETH.\n     * @param woethAmount Amount of wOETH to unwrap.\n     * @return Amount of WETH received.\n     */\n    function _unwrapAndRedeem(uint256 woethAmount) internal returns (uint256) {\n        uint256 oethAmount = oeth.balanceOf(address(safeContract));\n\n        // Unwrap wOETH\n        bool success = safeContract.execTransactionFromModule(\n            address(woeth),\n            0, // Value\n            abi.encodeWithSelector(\n                woeth.redeem.selector,\n                woethAmount,\n                address(safeContract),\n                address(safeContract)\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to unwrap wOETH\");\n\n        oethAmount = oeth.balanceOf(address(safeContract)) - oethAmount;\n\n        // Redeem OETH using Vault to get WETH\n        success = safeContract.execTransactionFromModule(\n            address(vault),\n            0, // Value\n            abi.encodeWithSelector(\n                vault.redeem.selector,\n                oethAmount,\n                oethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to redeem OETH\");\n\n        return oethAmount;\n    }\n\n    /**\n     * @dev Unwraps wOETH and redeems it to get WETH, then bridges it to Plume.\n     * @param woethAmount Amount of wOETH to unwrap.\n     * @param slippageBps Bridge slippage in 10^4 basis points.\n     */\n    function unwrapRedeemAndBridgeToPlume(\n        uint256 woethAmount,\n        uint256 slippageBps\n    ) external payable onlyOperator {\n        uint256 wethAmount = _unwrapAndRedeem(woethAmount);\n        // Unwrap into ETH\n        safeContract.execTransactionFromModule(\n            address(weth),\n            0, // Value\n            abi.encodeWithSelector(weth.withdraw.selector, wethAmount),\n            0 // Call\n        );\n\n        bridgeWETHToPlume(wethAmount, slippageBps);\n    }\n\n    /**\n     * @dev Unwraps wOETH and redeems it to get WETH, then bridges it to Base using CCIP.\n     * @param woethAmount Amount of wOETH to unwrap.\n     */\n    function unwrapRedeemAndBridgeToBase(uint256 woethAmount)\n        external\n        payable\n        onlyOperator\n    {\n        uint256 wethAmount = _unwrapAndRedeem(woethAmount);\n        bridgeWETHToBase(wethAmount);\n    }\n}\n"
    },
    "contracts/automation/PlumeBridgeHelperModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractSafeModule } from \"./AbstractSafeModule.sol\";\nimport { AbstractLZBridgeHelperModule } from \"./AbstractLZBridgeHelperModule.sol\";\n\nimport { AccessControlEnumerable } from \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\n\nimport { IOFT } from \"@layerzerolabs/oft-evm/contracts/interfaces/IOFT.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC4626 } from \"../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\nimport { BridgedWOETHStrategy } from \"../strategies/BridgedWOETHStrategy.sol\";\n\ncontract PlumeBridgeHelperModule is\n    AccessControlEnumerable,\n    AbstractLZBridgeHelperModule\n{\n    IVault public constant vault =\n        IVault(0xc8c8F8bEA5631A8AF26440AF32a55002138cB76a);\n    IWETH9 public constant weth =\n        IWETH9(0xca59cA09E5602fAe8B629DeE83FfA819741f14be);\n    IERC20 public constant oethp =\n        IERC20(0xFCbe50DbE43bF7E5C88C6F6Fb9ef432D4165406E);\n    IERC4626 public constant bridgedWOETH =\n        IERC4626(0xD8724322f44E5c58D7A815F542036fb17DbbF839);\n\n    uint32 public constant LZ_ETHEREUM_ENDPOINT_ID = 30101;\n    IOFT public constant LZ_WOETH_OMNICHAIN_ADAPTER =\n        IOFT(0x592CB6A596E7919930bF49a27AdAeCA7C055e4DB);\n    IOFT public constant LZ_ETH_OMNICHAIN_ADAPTER =\n        IOFT(0x4683CE822272CD66CEa73F5F1f9f5cBcaEF4F066);\n\n    BridgedWOETHStrategy public constant bridgedWOETHStrategy =\n        BridgedWOETHStrategy(0x1E3EdD5e019207D6355Ea77F724b1F1BF639B569);\n\n    constructor(address _safeContract) AbstractSafeModule(_safeContract) {}\n\n    /**\n     * @dev Bridges wOETH to Ethereum.\n     * @param woethAmount Amount of wOETH to bridge.\n     * @param slippageBps Slippage in 10^4 basis points.\n     */\n    function bridgeWOETHToEthereum(uint256 woethAmount, uint256 slippageBps)\n        public\n        payable\n        onlyOperator\n    {\n        _bridgeTokenWithLz(\n            LZ_ETHEREUM_ENDPOINT_ID,\n            IERC20(address(bridgedWOETH)),\n            LZ_WOETH_OMNICHAIN_ADAPTER,\n            woethAmount,\n            slippageBps,\n            false\n        );\n    }\n\n    /**\n     * @dev Bridges wETH to Ethereum.\n     * @param wethAmount Amount of wETH to bridge.\n     * @param slippageBps Slippage in 10^4 basis points.\n     */\n    function bridgeWETHToEthereum(uint256 wethAmount, uint256 slippageBps)\n        public\n        payable\n        onlyOperator\n    {\n        _bridgeTokenWithLz(\n            LZ_ETHEREUM_ENDPOINT_ID,\n            IERC20(address(weth)),\n            LZ_ETH_OMNICHAIN_ADAPTER,\n            wethAmount,\n            slippageBps,\n            false\n        );\n    }\n\n    /**\n     * @dev Deposits wOETH into the bridgedWOETH strategy.\n     * @param woethAmount Amount of wOETH to deposit.\n     * @param redeemWithVault Whether to redeem with Vault.\n     * @return Amount of OETHp received.\n     */\n    function depositWOETH(uint256 woethAmount, bool redeemWithVault)\n        external\n        onlyOperator\n        returns (uint256)\n    {\n        return _depositWOETH(woethAmount, redeemWithVault);\n    }\n\n    /**\n     * @dev Deposits wOETH into the bridgedWOETH strategy and bridges it to Ethereum.\n     * @param woethAmount Amount of wOETH to deposit.\n     * @param slippageBps Slippage in 10^4 basis points.\n     * @return Amount of WETH received.\n     */\n    function depositWOETHAndBridgeWETH(uint256 woethAmount, uint256 slippageBps)\n        external\n        payable\n        onlyOperator\n        returns (uint256)\n    {\n        uint256 wethAmount = _depositWOETH(woethAmount, true);\n        bridgeWETHToEthereum(wethAmount, slippageBps);\n        return wethAmount;\n    }\n\n    /**\n     * @dev Deposits wOETH into the bridgedWOETH strategy.\n     * @param woethAmount Amount of wOETH to deposit.\n     * @param redeemWithVault Whether to redeem with Vault.\n     * @return Amount of OETHp received.\n     */\n    function _depositWOETH(uint256 woethAmount, bool redeemWithVault)\n        internal\n        returns (uint256)\n    {\n        // Update oracle price\n        bridgedWOETHStrategy.updateWOETHOraclePrice();\n\n        // Rebase to account for any yields from price update\n        vault.rebase();\n\n        uint256 oethpAmount = oethp.balanceOf(address(safeContract));\n\n        // Approve bridgedWOETH strategy to move wOETH\n        bool success = safeContract.execTransactionFromModule(\n            address(bridgedWOETH),\n            0, // Value\n            abi.encodeWithSelector(\n                bridgedWOETH.approve.selector,\n                address(bridgedWOETHStrategy),\n                woethAmount\n            ),\n            0 // Call\n        );\n\n        // Deposit to bridgedWOETH strategy\n        success = safeContract.execTransactionFromModule(\n            address(bridgedWOETHStrategy),\n            0, // Value\n            abi.encodeWithSelector(\n                bridgedWOETHStrategy.depositBridgedWOETH.selector,\n                woethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to deposit bridged WOETH\");\n\n        oethpAmount = oethp.balanceOf(address(safeContract)) - oethpAmount;\n\n        // Rebase to account for any yields from price update\n        // and backing asset change from deposit\n        vault.rebase();\n\n        if (!redeemWithVault) {\n            return oethpAmount;\n        }\n\n        // Redeem for WETH using Vault\n        success = safeContract.execTransactionFromModule(\n            address(vault),\n            0, // Value\n            abi.encodeWithSelector(\n                vault.redeem.selector,\n                oethpAmount,\n                oethpAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to redeem OETHp\");\n\n        return oethpAmount;\n    }\n\n    /**\n     * @dev Deposits wETH into the vault.\n     * @param wethAmount Amount of wETH to deposit.\n     * @return Amount of OETHp received.\n     */\n    function depositWETHAndRedeemWOETH(uint256 wethAmount)\n        external\n        onlyOperator\n        returns (uint256)\n    {\n        return _withdrawWOETH(wethAmount);\n    }\n\n    /**\n     * @dev Deposits wETH into the vault and bridges it to Ethereum.\n     * @param wethAmount Amount of wETH to deposit.\n     * @param slippageBps Slippage in 10^4 basis points.\n     * @return Amount of WOETH received.\n     */\n    function depositWETHAndBridgeWOETH(uint256 wethAmount, uint256 slippageBps)\n        external\n        payable\n        onlyOperator\n        returns (uint256)\n    {\n        uint256 woethAmount = _withdrawWOETH(wethAmount);\n        bridgeWOETHToEthereum(woethAmount, slippageBps);\n        return woethAmount;\n    }\n\n    /**\n     * @dev Withdraws wOETH from the bridgedWOETH strategy.\n     * @param wethAmount Amount of WETH to use to withdraw.\n     * @return Amount of wOETH received.\n     */\n    function _withdrawWOETH(uint256 wethAmount) internal returns (uint256) {\n        // Approve Vault to move WETH\n        bool success = safeContract.execTransactionFromModule(\n            address(weth),\n            0, // Value\n            abi.encodeWithSelector(\n                weth.approve.selector,\n                address(vault),\n                wethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to approve WETH\");\n\n        // Mint OETHp with WETH\n        success = safeContract.execTransactionFromModule(\n            address(vault),\n            0, // Value\n            abi.encodeWithSelector(\n                vault.mint.selector,\n                address(weth),\n                wethAmount,\n                wethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to mint OETHp\");\n\n        // Approve bridgedWOETH strategy to move OETHp\n        success = safeContract.execTransactionFromModule(\n            address(oethp),\n            0, // Value\n            abi.encodeWithSelector(\n                oethp.approve.selector,\n                address(bridgedWOETHStrategy),\n                wethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to approve OETHp\");\n\n        uint256 woethAmount = bridgedWOETH.balanceOf(address(safeContract));\n\n        // Withdraw from bridgedWOETH strategy\n        success = safeContract.execTransactionFromModule(\n            address(bridgedWOETHStrategy),\n            0, // Value\n            abi.encodeWithSelector(\n                bridgedWOETHStrategy.withdrawBridgedWOETH.selector,\n                wethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to withdraw bridged WOETH\");\n\n        woethAmount =\n            bridgedWOETH.balanceOf(address(safeContract)) -\n            woethAmount;\n\n        return woethAmount;\n    }\n}\n"
    },
    "contracts/beacon/BeaconConsolidation.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Library to request validator consolidation on the beacon chain.\n * @author Origin Protocol Inc\n */\nlibrary BeaconConsolidation {\n    /// @notice The address the validator consolidation requests are sent\n    /// See https://eips.ethereum.org/EIPS/eip-7251\n    address internal constant CONSOLIDATION_REQUEST_ADDRESS =\n        0x0000BBdDc7CE488642fb579F8B00f3a590007251;\n\n    function request(bytes calldata source, bytes calldata target)\n        internal\n        returns (uint256 fee_)\n    {\n        require(source.length == 48, \"Invalid source byte length\");\n        require(target.length == 48, \"Invalid target byte length\");\n\n        fee_ = fee();\n\n        // Call the Consolidation Request contract with the public keys of the source and target\n        // validators packed together.\n        // This does not have a function signature, so we use a call\n        (bool success, ) = CONSOLIDATION_REQUEST_ADDRESS.call{ value: fee_ }(\n            abi.encodePacked(source, target)\n        );\n\n        require(success, \"Consolidation request failed\");\n    }\n\n    function fee() internal view returns (uint256) {\n        // Get fee from the consolidation request contract\n        (bool success, bytes memory result) = CONSOLIDATION_REQUEST_ADDRESS\n            .staticcall(\"\");\n\n        require(success && result.length > 0, \"Failed to get fee\");\n        return abi.decode(result, (uint256));\n    }\n}\n"
    },
    "contracts/beacon/BeaconProofs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { BeaconProofsLib } from \"./BeaconProofsLib.sol\";\nimport { IBeaconProofs } from \"../interfaces/IBeaconProofs.sol\";\n\n/**\n * @title Verifies merkle proofs of beacon chain data.\n * @author Origin Protocol Inc\n */\ncontract BeaconProofs is IBeaconProofs {\n    /// @notice Verifies the validator index is for the given validator public key.\n    /// Also verify the validator's withdrawal credential points to the withdrawal address.\n    /// BeaconBlock.state.validators[validatorIndex].pubkey\n    /// @param beaconBlockRoot The root of the beacon block\n    /// @param pubKeyHash Hash of validator's public key using the Beacon Chain's format\n    /// @param proof The merkle proof for the validator public key to the beacon block root.\n    /// This is 53 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    /// @param validatorIndex The validator index\n    /// @param withdrawalAddress The withdrawal address used in the validator's withdrawal credentials\n    function verifyValidator(\n        bytes32 beaconBlockRoot,\n        bytes32 pubKeyHash,\n        bytes calldata proof,\n        uint64 validatorIndex,\n        address withdrawalAddress\n    ) external view {\n        BeaconProofsLib.verifyValidator(\n            beaconBlockRoot,\n            pubKeyHash,\n            proof,\n            validatorIndex,\n            withdrawalAddress\n        );\n    }\n\n    /// @notice Verifies a validator's withdrawable epoch to the beacon block root\n    /// for a given validator index.\n    /// Also verifies the validator's public key for the given validator index.\n    /// BeaconBlock.state.validators[validatorIndex].withdrawableEpoch\n    /// @param beaconBlockRoot The root of the beacon block\n    /// @param validatorIndex The validator index to verify the withdrawable epoch for.\n    /// @param withdrawableEpoch The withdrawable epoch to verify in big endian uint64 format\n    /// @param withdrawableEpochProof The merkle proof for the validator's withdrawable epoch to the beacon block root.\n    /// This is 53 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    /// @param validatorPubKeyProof The merkle proof for the validator public key in a sub tree of height two.\n    /// This is 2 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    function verifyValidatorWithdrawable(\n        bytes32 beaconBlockRoot,\n        uint64 validatorIndex,\n        bytes32 pubKeyHash,\n        uint64 withdrawableEpoch,\n        bytes calldata withdrawableEpochProof,\n        bytes calldata validatorPubKeyProof\n    ) external view {\n        BeaconProofsLib.verifyValidatorWithdrawableEpoch(\n            beaconBlockRoot,\n            validatorIndex,\n            withdrawableEpoch,\n            withdrawableEpochProof\n        );\n\n        // Get the third 32 byte witness from the withdrawable epoch proof\n        // 2 * 32 bytes = 64 bytes offset\n        bytes32 subTreeRoot = bytes32(withdrawableEpochProof[64:96]);\n\n        BeaconProofsLib.verifyValidatorPubKeySubTree(\n            subTreeRoot,\n            pubKeyHash,\n            validatorPubKeyProof\n        );\n    }\n\n    function verifyValidatorWithdrawable(\n        bytes32 beaconBlockRoot,\n        uint64 validatorIndex,\n        uint64 withdrawableEpoch,\n        bytes calldata withdrawableEpochProof\n    ) external view {\n        BeaconProofsLib.verifyValidatorWithdrawableEpoch(\n            beaconBlockRoot,\n            validatorIndex,\n            withdrawableEpoch,\n            withdrawableEpochProof\n        );\n    }\n\n    /// @notice Verifies the balances container to the beacon block root\n    /// BeaconBlock.state.balances\n    /// @param beaconBlockRoot The root of the beacon block\n    /// @param balancesContainerRoot The merkle root of the the balances container\n    /// @param balancesContainerProof The merkle proof for the balances container to the beacon block root.\n    /// This is 9 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    function verifyBalancesContainer(\n        bytes32 beaconBlockRoot,\n        bytes32 balancesContainerRoot,\n        bytes calldata balancesContainerProof\n    ) external view {\n        BeaconProofsLib.verifyBalancesContainer(\n            beaconBlockRoot,\n            balancesContainerRoot,\n            balancesContainerProof\n        );\n    }\n\n    /// @notice Verifies the validator balance to the root of the Balances container.\n    /// @param balancesContainerRoot The merkle root of the Balances container.\n    /// @param validatorBalanceLeaf The leaf node containing the validator balance with three other balances.\n    /// @param balanceProof The merkle proof for the validator balance to the Balances container root.\n    /// This is 39 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    /// @param validatorIndex The validator index to verify the balance for\n    /// @return validatorBalanceGwei The balance in Gwei of the validator at the given index\n    function verifyValidatorBalance(\n        bytes32 balancesContainerRoot,\n        bytes32 validatorBalanceLeaf,\n        bytes calldata balanceProof,\n        uint64 validatorIndex\n    ) external view returns (uint256 validatorBalanceGwei) {\n        validatorBalanceGwei = BeaconProofsLib.verifyValidatorBalance(\n            balancesContainerRoot,\n            validatorBalanceLeaf,\n            balanceProof,\n            validatorIndex\n        );\n    }\n\n    /// @notice If the deposit queue is not empty,\n    /// verify the pubKey and slot of the first pending deposit to the beacon block root.\n    /// BeaconBlock.state.PendingDeposits[0].pubKey\n    /// If the deposit queue is empty, verify the root of the first pending deposit is empty\n    /// BeaconBlock.state.PendingDeposits[0]\n    /// @param beaconBlockRoot The root of the beacon block\n    /// @param slot The beacon chain slot of the first deposit in the beacon chain's deposit queue.\n    /// Can be anything if the deposit queue is empty, but zero would be a good choice.\n    /// @param pubKeyHash The hash of the validator public key for the first pending deposit.\n    /// Use zero bytes if the deposit queue is empty.\n    /// @param firstPendingDepositProof The merkle proof to the beacon block root. Can be either:\n    /// - 40 witness hashes for BeaconBlock.state.PendingDeposits[0].pubKey when the deposit queue is not empty.\n    /// - 37 witness hashes for BeaconBlock.state.PendingDeposits[0] when the deposit queue is empty.\n    /// The 32 byte witness hashes are concatenated together starting from the leaf node.\n    /// @return isEmptyDepositQueue True if the deposit queue is empty, false otherwise\n    function verifyFirstPendingDeposit(\n        bytes32 beaconBlockRoot,\n        uint64 slot,\n        bytes32 pubKeyHash,\n        bytes calldata firstPendingDepositProof\n    ) external view returns (bool isEmptyDepositQueue) {\n        isEmptyDepositQueue = BeaconProofsLib.verifyFirstPendingDeposit(\n            beaconBlockRoot,\n            slot,\n            pubKeyHash,\n            firstPendingDepositProof\n        );\n    }\n}\n"
    },
    "contracts/beacon/BeaconProofsLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Merkle } from \"./Merkle.sol\";\nimport { Endian } from \"./Endian.sol\";\n\n/**\n * @title Library to verify merkle proofs of beacon chain data.\n * @author Origin Protocol Inc\n */\nlibrary BeaconProofsLib {\n    // Known generalized indices in the beacon block\n    /// @dev BeaconBlock.state.PendingDeposits[0]\n    /// Beacon block container: height 3, state at at index 3\n    /// Beacon state container: height 6, pending deposits at index 34\n    /// Pending deposits container: height 28, first deposit at index 0\n    /// ((2 ^ 3 + 3) * 2 ^ 6 + 34) * 2 ^ 28 + 0 = 198105366528\n    uint256 internal constant FIRST_PENDING_DEPOSIT_GENERALIZED_INDEX =\n        198105366528;\n    /// @dev BeaconBlock.state.PendingDeposits[0].pubkey\n    /// Pending Deposit container: height 3, pubkey at index 0\n    /// (((2 ^ 3 + 3) * 2 ^ 6 + 34) * 2 ^ 28 + 0) * 2 ^ 3 + 0  = 1584842932224\n    uint256 internal constant FIRST_PENDING_DEPOSIT_PUBKEY_GENERALIZED_INDEX =\n        1584842932224;\n    /// @dev BeaconBlock.state.validators\n    /// Beacon block container: height 3, state at at index 3\n    /// Beacon state container: height 6, validators at index 11\n    /// (2 ^ 3 + 3) * 2 ^ 6 + 11 = 715\n    uint256 internal constant VALIDATORS_CONTAINER_GENERALIZED_INDEX = 715;\n    /// @dev BeaconBlock.state.balances\n    /// Beacon block container: height 3, state at at index 3\n    /// Beacon state container: height 6, balances at index 13\n    /// (2 ^ 3 + 3) * 2 ^ 6 + 13 = 716\n    uint256 internal constant BALANCES_CONTAINER_GENERALIZED_INDEX = 716;\n\n    /// @dev Number of bytes in the proof to the first pending deposit.\n    /// 37 witness hashes of 32 bytes each concatenated together.\n    /// BeaconBlock.state.PendingDeposits[0]\n    /// 37 * 32 bytes = 1184 bytes\n    uint256 internal constant FIRST_PENDING_DEPOSIT_PROOF_LENGTH = 1184;\n    /// @dev Number of bytes in the proof from the pubKey of the first pending deposit to the beacon block root.\n    /// 40 witness hashes of 32 bytes each concatenated together.\n    /// BeaconBlock.state.PendingDeposits[0].pubKey\n    /// 40 * 32 bytes = 1280 bytes\n    uint256 internal constant FIRST_PENDING_DEPOSIT_PUBKEY_PROOF_LENGTH = 1280;\n    /// The slot is at index 4 in the Pending Deposits container.\n    /// The sub tree from the right node from the root is a tree of height 2.\n    /// The first 32 bytes witness is an empty bytes32 as there are\n    /// no items after the slot in the Pending Deposits container.\n    /// The second 32 bytes witness is a hash or two empty bytes32.\n    bytes internal constant PENDING_DEPOSIT_SLOT_PROOF =\n        // solhint-disable-next-line max-line-length\n        hex\"0000000000000000000000000000000000000000000000000000000000000000f5a5fd42d16a20302798ef6ed309979b43003d2320d9f0e8ea9831a92759fb4b\";\n\n    /// @dev Merkle height of the Balances container\n    /// BeaconBlock.state.balances\n    uint256 internal constant BALANCES_HEIGHT = 39;\n    /// @dev Merkle height of the Validators container list\n    /// BeaconBlock.state.validators\n    uint256 internal constant VALIDATORS_LIST_HEIGHT = 41;\n    /// @dev Merkle height of the Validator container\n    /// BeaconBlock.state.validators[validatorIndex]\n    uint256 internal constant VALIDATOR_CONTAINER_HEIGHT = 3;\n\n    /// @dev Position of the pubkey field in the Validator container.\n    /// BeaconBlock.state.validators[validatorIndex].pubkey\n    uint256 internal constant VALIDATOR_PUBKEY_INDEX = 0;\n    /// @dev Position of the withdrawable epoch field in the Validator container.\n    /// BeaconBlock.state.validators[validatorIndex].withdrawableEpoch\n    uint256 internal constant VALIDATOR_WITHDRAWABLE_EPOCH_INDEX = 7;\n\n    /// @notice Verifies the validator index is for the given validator public key.\n    /// Also verify the validator's withdrawal credential points to the withdrawal address.\n    /// BeaconBlock.state.validators[validatorIndex].pubkey\n    /// @param beaconBlockRoot The root of the beacon block\n    /// @param pubKeyHash Hash of validator's public key using the Beacon Chain's format\n    /// @param proof The merkle proof for the validator public key to the beacon block root.\n    /// This is 53 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    /// @param validatorIndex The validator index\n    /// @param withdrawalAddress The withdrawal address used in the validator's withdrawal credentials\n    function verifyValidator(\n        bytes32 beaconBlockRoot,\n        bytes32 pubKeyHash,\n        bytes calldata proof,\n        uint64 validatorIndex,\n        address withdrawalAddress\n    ) internal view {\n        require(beaconBlockRoot != bytes32(0), \"Invalid block root\");\n\n        // BeaconBlock.state.validators[validatorIndex]\n        uint256 generalizedIndex = concatGenIndices(\n            VALIDATORS_CONTAINER_GENERALIZED_INDEX,\n            VALIDATORS_LIST_HEIGHT,\n            validatorIndex\n        );\n        // BeaconBlock.state.validators[validatorIndex].pubkey\n        generalizedIndex = concatGenIndices(\n            generalizedIndex,\n            VALIDATOR_CONTAINER_HEIGHT,\n            VALIDATOR_PUBKEY_INDEX\n        );\n\n        // Get the withdrawal address from the first witness in the pubkey merkle proof.\n        address withdrawalAddressFromProof;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // The first 32 bytes of the proof is the withdrawal credential so load it into memory.\n            calldatacopy(0, proof.offset, 32)\n            // Cast the 32 bytes in memory to an address which is the last 20 bytes.\n            withdrawalAddressFromProof := mload(0)\n        }\n        require(\n            withdrawalAddressFromProof == withdrawalAddress,\n            \"Invalid withdrawal address\"\n        );\n\n        require(\n            // 53 * 32 bytes = 1696 bytes\n            proof.length == 1696 &&\n                Merkle.verifyInclusionSha256({\n                    proof: proof,\n                    root: beaconBlockRoot,\n                    leaf: pubKeyHash,\n                    index: generalizedIndex\n                }),\n            \"Invalid validator proof\"\n        );\n    }\n\n    /// @notice Verifies a validator's withdrawable epoch to the beacon block root\n    /// for a given validator index.\n    /// BeaconBlock.state.validators[validatorIndex].withdrawableEpoch\n    /// @param beaconBlockRoot The root of the beacon block\n    /// @param validatorIndex The validator index to verify the withdrawable epoch for.\n    /// @param withdrawableEpoch The withdrawable epoch to verify in big endian uint64 format\n    /// @param proof The merkle proof for the validator's withdrawable epoch to the beacon block root.\n    /// This is 53 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    function verifyValidatorWithdrawableEpoch(\n        bytes32 beaconBlockRoot,\n        uint64 validatorIndex,\n        uint64 withdrawableEpoch,\n        bytes calldata proof\n    ) internal view {\n        require(beaconBlockRoot != bytes32(0), \"Invalid block root\");\n\n        // BeaconBlock.state.validators[validatorIndex]\n        uint256 exitEpochGenIndex = concatGenIndices(\n            VALIDATORS_CONTAINER_GENERALIZED_INDEX,\n            VALIDATORS_LIST_HEIGHT,\n            validatorIndex\n        );\n        // BeaconBlock.state.validators[validatorIndex].withdrawableEpoch\n        exitEpochGenIndex = concatGenIndices(\n            exitEpochGenIndex,\n            VALIDATOR_CONTAINER_HEIGHT,\n            VALIDATOR_WITHDRAWABLE_EPOCH_INDEX\n        );\n\n        require(\n            // 53 * 32 bytes = 1696 bytes\n            proof.length == 1696 &&\n                Merkle.verifyInclusionSha256({\n                    proof: proof,\n                    root: beaconBlockRoot,\n                    leaf: Endian.toLittleEndianUint64(withdrawableEpoch),\n                    index: exitEpochGenIndex\n                }),\n            \"Invalid withdrawable proof\"\n        );\n    }\n\n    /// @param subTreeRoot The third 32 byte witness from the withdrawable epoch proof\n    /// @param pubKeyHash Hash of validator's public key using the Beacon Chain's format\n    /// @param proof The merkle proof for the validator public key in a sub tree of height two.\n    /// This is 2 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    function verifyValidatorPubKeySubTree(\n        bytes32 subTreeRoot,\n        bytes32 pubKeyHash,\n        bytes calldata proof\n    ) internal view {\n        // Tree height 2 and pub key is at index 0\n        // index = 2 ^ 2 + 0 = 4\n        require(\n            // 2 * 32 bytes = 64 bytes\n            proof.length == 64 &&\n                Merkle.verifyInclusionSha256({\n                    proof: proof,\n                    root: subTreeRoot,\n                    leaf: pubKeyHash,\n                    index: 4\n                }),\n            \"Invalid pub key proof\"\n        );\n    }\n\n    /// @notice Verifies the balances container to the beacon block root.\n    /// BeaconBlock.state.balances\n    /// @param beaconBlockRoot The root of the beacon block.\n    /// @param balancesContainerRoot The merkle root of the the balances container.\n    /// @param proof The merkle proof for the balances container to the beacon block root.\n    /// This is 9 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    function verifyBalancesContainer(\n        bytes32 beaconBlockRoot,\n        bytes32 balancesContainerRoot,\n        bytes calldata proof\n    ) internal view {\n        require(beaconBlockRoot != bytes32(0), \"Invalid block root\");\n\n        // BeaconBlock.state.balances\n        require(\n            // 9 * 32 bytes = 288 bytes\n            proof.length == 288 &&\n                Merkle.verifyInclusionSha256({\n                    proof: proof,\n                    root: beaconBlockRoot,\n                    leaf: balancesContainerRoot,\n                    index: BALANCES_CONTAINER_GENERALIZED_INDEX\n                }),\n            \"Invalid balance container proof\"\n        );\n    }\n\n    /// @notice Verifies the validator balance to the root of the Balances container.\n    /// @param balancesContainerRoot The merkle root of the Balances container.\n    /// @param validatorBalanceLeaf The leaf node containing the validator balance with three other balances.\n    /// @param proof The merkle proof for the validator balance to the Balances container root.\n    /// This is 39 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    /// @param validatorIndex The validator index to verify the balance for.\n    /// @return validatorBalanceGwei The balance in Gwei of the validator at the given index.\n    function verifyValidatorBalance(\n        bytes32 balancesContainerRoot,\n        bytes32 validatorBalanceLeaf,\n        bytes calldata proof,\n        uint64 validatorIndex\n    ) internal view returns (uint256 validatorBalanceGwei) {\n        require(balancesContainerRoot != bytes32(0), \"Invalid container root\");\n\n        // Four balances are stored in each leaf so the validator index is divided by 4\n        uint64 balanceIndex = validatorIndex / 4;\n\n        // Get the index within the balances container, not the Beacon Block\n        // BeaconBlock.state.balances[balanceIndex]\n        uint256 generalizedIndex = concatGenIndices(\n            1,\n            BALANCES_HEIGHT,\n            balanceIndex\n        );\n\n        validatorBalanceGwei = balanceAtIndex(\n            validatorBalanceLeaf,\n            validatorIndex\n        );\n\n        require(\n            // 39 * 32 bytes = 1248 bytes\n            proof.length == 1248 &&\n                Merkle.verifyInclusionSha256({\n                    proof: proof,\n                    root: balancesContainerRoot,\n                    leaf: validatorBalanceLeaf,\n                    index: generalizedIndex\n                }),\n            \"Invalid balance proof\"\n        );\n    }\n\n    /// @notice If the deposit queue is not empty,\n    /// verify the pubKey and slot of the first pending deposit to the beacon block root.\n    /// BeaconBlock.state.pendingDeposits[0].pubKey\n    /// BeaconBlock.state.pendingDeposits[0].slot\n    /// If the deposit queue is empty, verify the root of the first pending deposit is empty\n    /// BeaconBlock.state.PendingDeposits[0]\n    /// @param beaconBlockRoot The root of the beacon block.\n    /// @param slot The beacon chain slot of the first deposit in the beacon chain's deposit queue.\n    /// Can be anything if the deposit queue is empty, but zero would be a good choice.\n    /// @param pubKeyHash The hash of the validator public key for the first pending deposit.\n    /// Use zero bytes if the deposit queue is empty.\n    /// @param proof The merkle proof to the beacon block root. Can be either:\n    /// - 40 witness hashes for BeaconBlock.state.PendingDeposits[0].pubKey when the deposit queue is not empty.\n    /// - 37 witness hashes for BeaconBlock.state.PendingDeposits[0] when the deposit queue is empty.\n    /// The 32 byte witness hashes are concatenated together starting from the leaf node.\n    /// @return isEmptyDepositQueue True if the deposit queue is empty, false otherwise.\n    function verifyFirstPendingDeposit(\n        bytes32 beaconBlockRoot,\n        uint64 slot,\n        bytes32 pubKeyHash,\n        bytes calldata proof\n    ) internal view returns (bool isEmptyDepositQueue) {\n        require(beaconBlockRoot != bytes32(0), \"Invalid block root\");\n\n        // If the deposit queue is empty\n        if (proof.length == FIRST_PENDING_DEPOSIT_PROOF_LENGTH) {\n            require(\n                Merkle.verifyInclusionSha256({\n                    proof: proof,\n                    root: beaconBlockRoot,\n                    leaf: bytes32(0),\n                    index: FIRST_PENDING_DEPOSIT_GENERALIZED_INDEX\n                }),\n                \"Invalid empty deposits proof\"\n            );\n            return true;\n        }\n\n        // Verify the public key of the first pending deposit\n        // BeaconBlock.state.PendingDeposits[0].pubKey\n        require(\n            proof.length == FIRST_PENDING_DEPOSIT_PUBKEY_PROOF_LENGTH &&\n                Merkle.verifyInclusionSha256({\n                    proof: proof,\n                    root: beaconBlockRoot,\n                    leaf: pubKeyHash,\n                    index: FIRST_PENDING_DEPOSIT_PUBKEY_GENERALIZED_INDEX\n                }),\n            \"Invalid deposit pub key proof\"\n        );\n\n        // Now verify the slot of the first pending deposit\n\n        // Get the third 32 bytes witness from the first pending deposit pubKey proof\n        // 2 * 32 bytes = 64 bytes offset\n        bytes32 slotRoot = bytes32(proof[64:96]);\n\n        // Sub tree height 2 and slot is at index 0 in the sub tree\n        // index = 2 ^ 2 + 0 = 4\n        require(\n            Merkle.verifyInclusionSha256({\n                proof: PENDING_DEPOSIT_SLOT_PROOF,\n                root: slotRoot,\n                leaf: Endian.toLittleEndianUint64(slot),\n                index: 4\n            }),\n            \"Invalid deposit slot\"\n        );\n    }\n\n    ////////////////////////////////////////////////////\n    ///       Internal Helper Functions\n    ////////////////////////////////////////////////////\n\n    function balanceAtIndex(bytes32 validatorBalanceLeaf, uint64 validatorIndex)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 bitShiftAmount = (validatorIndex % 4) * 64;\n        return\n            Endian.fromLittleEndianUint64(\n                bytes32((uint256(validatorBalanceLeaf) << bitShiftAmount))\n            );\n    }\n\n    /// @notice Concatenates two beacon chain generalized indices into one.\n    /// @param genIndex The first generalized index or 1 if calculating for a single container.\n    /// @param height The merkle tree height of the second container. eg 39 for balances, 41 for validators.\n    /// @param index The index within the second container. eg the validator index.\n    /// @return genIndex The concatenated generalized index.\n    function concatGenIndices(\n        uint256 genIndex,\n        uint256 height,\n        uint256 index\n    ) internal pure returns (uint256) {\n        return (genIndex << height) | index;\n    }\n}\n"
    },
    "contracts/beacon/BeaconRoots.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Library to retrieve beacon block roots.\n * @author Origin Protocol Inc\n */\nlibrary BeaconRoots {\n    /// @notice The address of beacon block roots oracle\n    /// See https://eips.ethereum.org/EIPS/eip-4788\n    address internal constant BEACON_ROOTS_ADDRESS =\n        0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02;\n\n    /// @notice Returns the beacon block root for the previous block.\n    /// This comes from the Beacon Roots contract defined in EIP-4788.\n    /// This will revert if the block is more than 8,191 blocks old as\n    /// that is the size of the beacon root's ring buffer.\n    /// @param timestamp The timestamp of the block for which to get the parent root.\n    /// @return parentRoot The parent block root for the given timestamp.\n    function parentBlockRoot(uint64 timestamp)\n        internal\n        view\n        returns (bytes32 parentRoot)\n    {\n        // Call the Beacon Roots contract to get the parent block root.\n        // This does not have a function signature, so we use a staticcall.\n        (bool success, bytes memory result) = BEACON_ROOTS_ADDRESS.staticcall(\n            abi.encode(timestamp)\n        );\n\n        require(success && result.length > 0, \"Invalid beacon timestamp\");\n        parentRoot = abi.decode(result, (bytes32));\n    }\n}\n"
    },
    "contracts/beacon/Endian.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Library to handle conversion between little-endian and big-endian formats.\n * @author Origin Protocol Inc\n */\nlibrary Endian {\n    /**\n     * @notice Converts a little endian-formatted uint64 to a big endian-formatted uint64\n     * @param lenum little endian-formatted uint64 input, provided as 'bytes32' type\n     * @return n The big endian-formatted uint64\n     * @dev Note that the input is formatted as a 'bytes32' type (i.e. 256 bits),\n     * but it is immediately truncated to a uint64 (i.e. 64 bits)\n     * through a right-shift/shr operation.\n     */\n    function fromLittleEndianUint64(bytes32 lenum)\n        internal\n        pure\n        returns (uint64 n)\n    {\n        // the number needs to be stored in little-endian encoding (ie in bytes 0-8)\n        n = uint64(uint256(lenum >> 192));\n        // forgefmt: disable-next-item\n        return\n            (n >> 56) |\n            ((0x00FF000000000000 & n) >> 40) |\n            ((0x0000FF0000000000 & n) >> 24) |\n            ((0x000000FF00000000 & n) >> 8) |\n            ((0x00000000FF000000 & n) << 8) |\n            ((0x0000000000FF0000 & n) << 24) |\n            ((0x000000000000FF00 & n) << 40) |\n            ((0x00000000000000FF & n) << 56);\n    }\n\n    function toLittleEndianUint64(uint64 benum)\n        internal\n        pure\n        returns (bytes32 n)\n    {\n        // Convert to little-endian by reversing byte order\n        uint64 reversed = (benum >> 56) |\n            ((0x00FF000000000000 & benum) >> 40) |\n            ((0x0000FF0000000000 & benum) >> 24) |\n            ((0x000000FF00000000 & benum) >> 8) |\n            ((0x00000000FF000000 & benum) << 8) |\n            ((0x0000000000FF0000 & benum) << 24) |\n            ((0x000000000000FF00 & benum) << 40) |\n            ((0x00000000000000FF & benum) << 56);\n\n        // Store the little-endian uint64 in the least significant 64 bits of bytes32\n        n = bytes32(uint256(reversed));\n        // Shift to most significant bits\n        n = n << 192;\n    }\n}\n"
    },
    "contracts/beacon/Merkle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Adapted from OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary Merkle {\n    error InvalidProofLength();\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is\n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     *\n     * Note this is for a Merkle tree using the sha256 hash function\n     */\n    function verifyInclusionSha256(\n        bytes memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        uint256 index\n    ) internal view returns (bool) {\n        return processInclusionProofSha256(proof, leaf, index) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is\n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     *\n     * _Available since v4.4._\n     *\n     * Note this is for a Merkle tree using the sha256 hash function\n     */\n    function processInclusionProofSha256(\n        bytes memory proof,\n        bytes32 leaf,\n        uint256 index\n    ) internal view returns (bytes32) {\n        require(\n            proof.length != 0 && proof.length % 32 == 0,\n            InvalidProofLength()\n        );\n        bytes32[1] memory computedHash = [leaf];\n        for (uint256 i = 32; i <= proof.length; i += 32) {\n            if (index % 2 == 0) {\n                // if ith bit of index is 0, then computedHash is a left sibling\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    mstore(0x00, mload(computedHash))\n                    mstore(0x20, mload(add(proof, i)))\n                    if iszero(\n                        staticcall(\n                            sub(gas(), 2000),\n                            2,\n                            0x00,\n                            0x40,\n                            computedHash,\n                            0x20\n                        )\n                    ) {\n                        revert(0, 0)\n                    }\n                    index := div(index, 2)\n                }\n            } else {\n                // if ith bit of index is 1, then computedHash is a right sibling\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    mstore(0x00, mload(add(proof, i)))\n                    mstore(0x20, mload(computedHash))\n                    if iszero(\n                        staticcall(\n                            sub(gas(), 2000),\n                            2,\n                            0x00,\n                            0x40,\n                            computedHash,\n                            0x20\n                        )\n                    ) {\n                        revert(0, 0)\n                    }\n                    index := div(index, 2)\n                }\n            }\n        }\n        return computedHash[0];\n    }\n}\n"
    },
    "contracts/beacon/PartialWithdrawal.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Library to request full or partial withdrawals from validators on the beacon chain.\n * @author Origin Protocol Inc\n */\nlibrary PartialWithdrawal {\n    /// @notice The address where the withdrawal request is sent to\n    /// See https://eips.ethereum.org/EIPS/eip-7002\n    address internal constant WITHDRAWAL_REQUEST_ADDRESS =\n        0x00000961Ef480Eb55e80D19ad83579A64c007002;\n\n    function request(bytes calldata validatorPubKey, uint64 amount)\n        internal\n        returns (uint256 fee_)\n    {\n        require(validatorPubKey.length == 48, \"Invalid validator byte length\");\n        fee_ = fee();\n\n        // Call the Withdrawal Request contract with the validator public key\n        // and amount to be withdrawn packed together\n\n        // This is a general purpose EL to CL request:\n        // https://eips.ethereum.org/EIPS/eip-7685\n        (bool success, ) = WITHDRAWAL_REQUEST_ADDRESS.call{ value: fee_ }(\n            abi.encodePacked(validatorPubKey, amount)\n        );\n\n        require(success, \"Withdrawal request failed\");\n    }\n\n    function fee() internal view returns (uint256) {\n        // Get fee from the withdrawal request contract\n        (bool success, bytes memory result) = WITHDRAWAL_REQUEST_ADDRESS\n            .staticcall(\"\");\n\n        require(success && result.length > 0, \"Failed to get fee\");\n        return abi.decode(result, (uint256));\n    }\n}\n"
    },
    "contracts/bridges/OmnichainL2Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport { MintBurnOFTAdapter } from \"@layerzerolabs/oft-evm/contracts/MintBurnOFTAdapter.sol\";\nimport { IMintableBurnable } from \"@layerzerolabs/oft-evm/contracts/interfaces/IMintableBurnable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// NOTE: It's necessary to inherit from Ownable instead of Governable\n///       because OFTCore uses Ownable to manage the governor.\n///       Ownable uses slot 0 for storing the address, whereas Goveranble\n///       stores it in a computed slot.\n\n/// @notice Omnichain uses a deployed ERC-20 token and safeERC20\n///         to interact with the OFTCore contract.\n///         On L2, we follow the mint and burn mechanism.\n///         The adapter should have minter and burner roles.\n\n/// @title Omnichain L2 Adapter\ncontract OmnichainL2Adapter is MintBurnOFTAdapter {\n    constructor(\n        address _token,\n        address _lzEndpoint,\n        address _governor\n    )\n        MintBurnOFTAdapter(\n            _token,\n            IMintableBurnable(_token),\n            _lzEndpoint,\n            _governor\n        )\n        Ownable()\n    {\n        _transferOwnership(_governor);\n    }\n\n    /// @inheritdoc MintBurnOFTAdapter\n    function _debit(\n        address _from,\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        uint32 _dstEid\n    )\n        internal\n        virtual\n        override\n        returns (uint256 amountSentLD, uint256 amountReceivedLD)\n    {\n        (amountSentLD, amountReceivedLD) = _debitView(\n            _amountLD,\n            _minAmountLD,\n            _dstEid\n        );\n        // Burns tokens from the caller.\n        IMintableERC20(address(minterBurner)).burn(_from, amountSentLD);\n    }\n\n    /// @inheritdoc MintBurnOFTAdapter\n    function _credit(\n        address _to,\n        uint256 _amountLD,\n        uint32 /* _srcEid */\n    ) internal virtual override returns (uint256 amountReceivedLD) {\n        if (_to == address(0x0)) _to = address(0xdead); // _mint(...) does not support address(0x0)\n        // Mints the tokens and transfers to the recipient.\n        IMintableERC20(address(minterBurner)).mint(_to, _amountLD);\n        // In the case of NON-default OFTAdapter, the amountLD MIGHT not be equal to amountReceivedLD.\n        return _amountLD;\n    }\n}\n\ninterface IMintableERC20 {\n    function mint(address to, uint256 value) external;\n\n    function burn(address to, uint256 value) external;\n}\n"
    },
    "contracts/bridges/OmnichainMainnetAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport { OFTAdapter } from \"@layerzerolabs/oft-evm/contracts/OFTAdapter.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// NOTE: It's necessary to inherit from Ownable instead of Governable\n///       because OFTCore uses Ownable to manage the governor.\n///       Ownable uses slot 0 for storing the address, whereas Goveranble\n///       stores it in a computed slot.\n\n/// @notice Omnichain uses a deployed ERC-20 token and safeERC20\n///         to interact with the OFTCore contract.\n///         On Ethereum, we follow the lock and unlock mechanism.\n\n/// @title Omnichain Mainnet Adapter\ncontract OmnichainMainnetAdapter is OFTAdapter {\n    constructor(\n        address _token,\n        address _lzEndpoint,\n        address _governor\n    ) OFTAdapter(_token, _lzEndpoint, _governor) Ownable() {\n        _transferOwnership(_governor);\n    }\n}\n"
    },
    "contracts/buyback/AbstractBuyback.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Strategizable } from \"../governance/Strategizable.sol\";\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ICVXLocker } from \"../interfaces/ICVXLocker.sol\";\nimport { ISwapper } from \"../interfaces/ISwapper.sol\";\n\nimport { Initializable } from \"../utils/Initializable.sol\";\n\nabstract contract AbstractBuyback is Initializable, Strategizable {\n    using SafeERC20 for IERC20;\n\n    event SwapRouterUpdated(address indexed _address);\n\n    event RewardsSourceUpdated(address indexed _address);\n    event TreasuryManagerUpdated(address indexed _address);\n    event CVXShareBpsUpdated(uint256 bps);\n\n    // Emitted whenever OUSD/OETH is swapped for OGN/CVX or any other token\n    event OTokenBuyback(\n        address indexed oToken,\n        address indexed swappedFor,\n        uint256 swapAmountIn,\n        uint256 amountOut\n    );\n\n    // Address of 1-inch Swap Router\n    address public swapRouter;\n\n    // slither-disable-next-line constable-states\n    address private __deprecated_ousd;\n    // slither-disable-next-line constable-states\n    address private __deprecated_ogv;\n    // slither-disable-next-line constable-states\n    address private __deprecated_usdt;\n    // slither-disable-next-line constable-states\n    address private __deprecated_weth9;\n\n    // Address that receives OGN after swaps\n    address public rewardsSource;\n\n    // Address that receives all other tokens after swaps\n    address public treasuryManager;\n\n    // slither-disable-next-line constable-states\n    uint256 private __deprecated_treasuryBps;\n\n    address public immutable oToken;\n    address public immutable ogn;\n    address public immutable cvx;\n    address public immutable cvxLocker;\n\n    // Amount of `oToken` balance to use for OGN buyback\n    uint256 public balanceForOGN;\n\n    // Amount of `oToken` balance to use for CVX buyback\n    uint256 public balanceForCVX;\n\n    // Percentage of `oToken` balance to be used for CVX\n    uint256 public cvxShareBps; // 10000 = 100%\n\n    constructor(\n        address _oToken,\n        address _ogn,\n        address _cvx,\n        address _cvxLocker\n    ) {\n        // Make sure nobody owns the implementation contract\n        _setGovernor(address(0));\n\n        oToken = _oToken;\n        ogn = _ogn;\n        cvx = _cvx;\n        cvxLocker = _cvxLocker;\n    }\n\n    /**\n     * @param _swapRouter Address of Uniswap V3 Router\n     * @param _strategistAddr Address of Strategist multi-sig wallet\n     * @param _treasuryManagerAddr Address that receives the treasury's share of OUSD\n     * @param _rewardsSource Address of RewardsSource contract\n     * @param _cvxShareBps Percentage of balance to use for CVX\n     */\n    function initialize(\n        address _swapRouter,\n        address _strategistAddr,\n        address _treasuryManagerAddr,\n        address _rewardsSource,\n        uint256 _cvxShareBps\n    ) external onlyGovernor initializer {\n        _setStrategistAddr(_strategistAddr);\n\n        _setSwapRouter(_swapRouter);\n        _setRewardsSource(_rewardsSource);\n\n        _setTreasuryManager(_treasuryManagerAddr);\n\n        _setCVXShareBps(_cvxShareBps);\n    }\n\n    /**\n     * @dev Set address of Uniswap Universal Router for performing liquidation\n     * of platform fee tokens. Setting to 0x0 will pause swaps.\n     *\n     * @param _router Address of the Uniswap Universal router\n     */\n    function setSwapRouter(address _router) external onlyGovernor {\n        _setSwapRouter(_router);\n    }\n\n    function _setSwapRouter(address _router) internal {\n        address oldRouter = swapRouter;\n        swapRouter = _router;\n\n        if (oldRouter != address(0)) {\n            // Remove allowance of old router, if any\n\n            if (IERC20(ogn).allowance(address(this), oldRouter) != 0) {\n                // slither-disable-next-line unused-return\n                IERC20(ogn).safeApprove(oldRouter, 0);\n            }\n\n            if (IERC20(cvx).allowance(address(this), oldRouter) != 0) {\n                // slither-disable-next-line unused-return\n                IERC20(cvx).safeApprove(oldRouter, 0);\n            }\n        }\n\n        emit SwapRouterUpdated(_router);\n    }\n\n    /**\n     * @dev Sets the address that receives the OGN buyback rewards\n     * @param _address Address\n     */\n    function setRewardsSource(address _address) external onlyGovernor {\n        _setRewardsSource(_address);\n    }\n\n    function _setRewardsSource(address _address) internal {\n        require(_address != address(0), \"Address not set\");\n        rewardsSource = _address;\n        emit RewardsSourceUpdated(_address);\n    }\n\n    /**\n     * @dev Sets the address that can receive and manage the funds for Treasury\n     * @param _address Address\n     */\n    function setTreasuryManager(address _address) external onlyGovernor {\n        _setTreasuryManager(_address);\n    }\n\n    function _setTreasuryManager(address _address) internal {\n        require(_address != address(0), \"Address not set\");\n        treasuryManager = _address;\n        emit TreasuryManagerUpdated(_address);\n    }\n\n    /**\n     * @dev Sets the percentage of oToken to use for Flywheel tokens\n     * @param _bps BPS, 10000 to 100%\n     */\n    function setCVXShareBps(uint256 _bps) external onlyGovernor {\n        _setCVXShareBps(_bps);\n    }\n\n    function _setCVXShareBps(uint256 _bps) internal {\n        require(_bps <= 10000, \"Invalid bps value\");\n        cvxShareBps = _bps;\n        emit CVXShareBpsUpdated(_bps);\n    }\n\n    /**\n     * @dev Computes the split of oToken balance that can be\n     *      used for OGN and CVX buybacks.\n     */\n    function _updateBuybackSplits()\n        internal\n        returns (uint256 _balanceForOGN, uint256 _balanceForCVX)\n    {\n        _balanceForOGN = balanceForOGN;\n        _balanceForCVX = balanceForCVX;\n\n        uint256 totalBalance = IERC20(oToken).balanceOf(address(this));\n        uint256 unsplitBalance = totalBalance - _balanceForOGN - _balanceForCVX;\n\n        // Check if all balance is accounted for\n        if (unsplitBalance != 0) {\n            // If not, split unaccounted balance based on `cvxShareBps`\n            uint256 addToCVX = (unsplitBalance * cvxShareBps) / 10000;\n            _balanceForCVX = _balanceForCVX + addToCVX;\n            _balanceForOGN = _balanceForOGN + unsplitBalance - addToCVX;\n\n            // Update storage\n            balanceForOGN = _balanceForOGN;\n            balanceForCVX = _balanceForCVX;\n        }\n    }\n\n    function updateBuybackSplits() external onlyGovernor {\n        // slither-disable-next-line unused-return\n        _updateBuybackSplits();\n    }\n\n    function _swapToken(\n        address tokenOut,\n        uint256 oTokenAmount,\n        uint256 minAmountOut,\n        bytes calldata swapData\n    ) internal returns (uint256 amountOut) {\n        require(oTokenAmount > 0, \"Invalid Swap Amount\");\n        require(swapRouter != address(0), \"Swap Router not set\");\n        require(minAmountOut > 0, \"Invalid minAmount\");\n\n        // Transfer OToken to Swapper for swapping\n        // slither-disable-next-line unchecked-transfer unused-return\n        IERC20(oToken).transfer(swapRouter, oTokenAmount);\n\n        // Swap\n        amountOut = ISwapper(swapRouter).swap(\n            oToken,\n            tokenOut,\n            oTokenAmount,\n            minAmountOut,\n            swapData\n        );\n\n        require(amountOut >= minAmountOut, \"Higher Slippage\");\n\n        emit OTokenBuyback(oToken, tokenOut, oTokenAmount, amountOut);\n    }\n\n    /**\n     * @dev Swaps `oTokenAmount` to OGN\n     * @param oTokenAmount Amount of OUSD/OETH to swap\n     * @param minOGN Minimum OGN to receive for oTokenAmount\n     * @param swapData 1inch Swap Data\n     */\n    function swapForOGN(\n        uint256 oTokenAmount,\n        uint256 minOGN,\n        bytes calldata swapData\n    ) external onlyGovernorOrStrategist nonReentrant {\n        (uint256 _amountForOGN, ) = _updateBuybackSplits();\n        require(_amountForOGN >= oTokenAmount, \"Balance underflow\");\n        require(rewardsSource != address(0), \"RewardsSource contract not set\");\n\n        unchecked {\n            // Subtract the amount to swap from net balance\n            balanceForOGN = _amountForOGN - oTokenAmount;\n        }\n\n        uint256 ognReceived = _swapToken(ogn, oTokenAmount, minOGN, swapData);\n\n        // Transfer OGN received to RewardsSource contract\n        // slither-disable-next-line unchecked-transfer unused-return\n        IERC20(ogn).transfer(rewardsSource, ognReceived);\n    }\n\n    /**\n     * @dev Swaps `oTokenAmount` to CVX\n     * @param oTokenAmount Amount of OUSD/OETH to swap\n     * @param minCVX Minimum CVX to receive for oTokenAmount\n     * @param swapData 1inch Swap Data\n     */\n    function swapForCVX(\n        uint256 oTokenAmount,\n        uint256 minCVX,\n        bytes calldata swapData\n    ) external onlyGovernorOrStrategist nonReentrant {\n        (, uint256 _amountForCVX) = _updateBuybackSplits();\n        require(_amountForCVX >= oTokenAmount, \"Balance underflow\");\n\n        unchecked {\n            // Subtract the amount to swap from net balance\n            balanceForCVX = _amountForCVX - oTokenAmount;\n        }\n\n        uint256 cvxReceived = _swapToken(cvx, oTokenAmount, minCVX, swapData);\n\n        // Lock all CVX\n        _lockAllCVX(cvxReceived);\n    }\n\n    /**\n     * @dev Locks all CVX held by the contract on behalf of the Treasury Manager\n     */\n    function lockAllCVX() external onlyGovernorOrStrategist {\n        _lockAllCVX(IERC20(cvx).balanceOf(address(this)));\n    }\n\n    function _lockAllCVX(uint256 cvxAmount) internal {\n        require(\n            treasuryManager != address(0),\n            \"Treasury manager address not set\"\n        );\n\n        // Lock all available CVX on behalf of `treasuryManager`\n        ICVXLocker(cvxLocker).lock(treasuryManager, cvxAmount, 0);\n    }\n\n    /**\n     * @dev Approve CVX Locker to move CVX held by this contract\n     */\n    function safeApproveAllTokens() external onlyGovernorOrStrategist {\n        IERC20(cvx).safeApprove(cvxLocker, type(uint256).max);\n    }\n\n    /**\n     * @notice Owner function to withdraw a specific amount of a token\n     * @param token token to be transferered\n     * @param amount amount of the token to be transferred\n     */\n    function transferToken(address token, uint256 amount)\n        external\n        onlyGovernor\n        nonReentrant\n    {\n        IERC20(token).safeTransfer(_governor(), amount);\n    }\n}\n"
    },
    "contracts/buyback/ARMBuyback.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractBuyback } from \"./AbstractBuyback.sol\";\n\ncontract ARMBuyback is AbstractBuyback {\n    constructor(\n        address _oToken,\n        address _ogn,\n        address _cvx,\n        address _cvxLocker\n    ) AbstractBuyback(_oToken, _ogn, _cvx, _cvxLocker) {}\n}\n"
    },
    "contracts/buyback/OETHBuyback.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractBuyback } from \"./AbstractBuyback.sol\";\n\ncontract OETHBuyback is AbstractBuyback {\n    constructor(\n        address _oToken,\n        address _ogn,\n        address _cvx,\n        address _cvxLocker\n    ) AbstractBuyback(_oToken, _ogn, _cvx, _cvxLocker) {}\n}\n"
    },
    "contracts/buyback/OUSDBuyback.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractBuyback } from \"./AbstractBuyback.sol\";\n\ncontract OUSDBuyback is AbstractBuyback {\n    constructor(\n        address _oToken,\n        address _ogn,\n        address _cvx,\n        address _cvxLocker\n    ) AbstractBuyback(_oToken, _ogn, _cvx, _cvxLocker) {}\n}\n"
    },
    "contracts/echidna/Debugger.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary Debugger {\n    event Debug(string debugString);\n    event Debug(string description, string data);\n    event Debug(string prefix, string description, string data);\n    event Debug(string description, bytes32 data);\n    event Debug(string prefix, string description, bytes32 data);\n    event Debug(string description, uint256 data);\n    event Debug(string prefix, string description, uint256 data);\n    event Debug(string description, int256 data);\n    event Debug(string prefix, string description, int256 data);\n    event Debug(string description, address data);\n    event Debug(string prefix, string description, address data);\n    event Debug(string description, bool data);\n    event Debug(string prefix, string description, bool data);\n\n    function log(string memory debugString) internal {\n        emit Debug(debugString);\n    }\n\n    function log(string memory description, string memory data) internal {\n        emit Debug(description, data);\n    }\n\n    function log(\n        string memory prefix,\n        string memory description,\n        string memory data\n    ) internal {\n        emit Debug(prefix, description, data);\n    }\n\n    function log(string memory description, bytes32 data) internal {\n        emit Debug(description, data);\n    }\n\n    function log(\n        string memory prefix,\n        string memory description,\n        bytes32 data\n    ) internal {\n        emit Debug(prefix, description, data);\n    }\n\n    function log(string memory description, uint256 data) internal {\n        emit Debug(description, data);\n    }\n\n    function log(\n        string memory prefix,\n        string memory description,\n        uint256 data\n    ) internal {\n        emit Debug(prefix, description, data);\n    }\n\n    function log(string memory description, int256 data) internal {\n        emit Debug(description, data);\n    }\n\n    function log(\n        string memory prefix,\n        string memory description,\n        int256 data\n    ) internal {\n        emit Debug(prefix, description, data);\n    }\n\n    function log(string memory description, address data) internal {\n        emit Debug(description, data);\n    }\n\n    function log(\n        string memory prefix,\n        string memory description,\n        address data\n    ) internal {\n        emit Debug(prefix, description, data);\n    }\n\n    function log(string memory description, bool data) internal {\n        emit Debug(description, data);\n    }\n\n    function log(\n        string memory prefix,\n        string memory description,\n        bool data\n    ) internal {\n        emit Debug(prefix, description, data);\n    }\n}\n"
    },
    "contracts/echidna/Echidna.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./EchidnaTestApproval.sol\";\n\n/**\n * @title Echidna test contract for OUSD\n * @notice Target contract to be tested, containing all mixins\n * @author Rappie\n */\ncontract Echidna is EchidnaTestApproval {\n\n}\n"
    },
    "contracts/echidna/EchidnaConfig.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Top-level mixin for configuring the desired fuzzing setup\n * @author Rappie\n */\ncontract EchidnaConfig {\n    address internal constant ADDRESS_VAULT = address(0x10000);\n    address internal constant ADDRESS_OUTSIDER_USER = address(0x20000);\n\n    address internal constant ADDRESS_USER0 = address(0x30000);\n    address internal constant ADDRESS_USER1 = address(0x40000);\n\n    // Will be set in EchidnaSetup constructor\n    address internal ADDRESS_OUTSIDER_CONTRACT;\n    address internal ADDRESS_CONTRACT0;\n    address internal ADDRESS_CONTRACT1;\n\n    // Toggle known issues\n    //\n    // This can be used to skip tests that are known to fail. This is useful\n    // when debugging a specific issue, but should be disabled when running\n    // the full test suite.\n    //\n    //   True => skip tests that are known to fail\n    //   False => run all tests\n    //\n    bool internal constant TOGGLE_KNOWN_ISSUES = false;\n\n    // Toggle known issues within limits\n    //\n    // Same as TOGGLE_KNOWN_ISSUES, but also skip tests that are known to fail\n    // within limits set by the variables below.\n    //\n    bool internal constant TOGGLE_KNOWN_ISSUES_WITHIN_LIMITS = true;\n\n    // Starting balance\n    //\n    // Gives OUSD a non-zero starting supply, which can be useful to ignore\n    // certain edge cases.\n    //\n    // The starting balance is given to outsider accounts that are not used as\n    // accounts while fuzzing.\n    //\n    bool internal constant TOGGLE_STARTING_BALANCE = true;\n    uint256 internal constant STARTING_BALANCE = 1_000_000e18;\n\n    // Change supply\n    //\n    // Set a limit to the amount of change per rebase, which can be useful to\n    // ignore certain edge cases.\n    //\n    //  True => limit the amount of change to a percentage of total supply\n    //  False => no limit\n    //\n    bool internal constant TOGGLE_CHANGESUPPLY_LIMIT = true;\n    uint256 internal constant CHANGESUPPLY_DIVISOR = 10; // 10% of total supply\n\n    // Mint limit\n    //\n    // Set a limit the amount minted per mint, which can be useful to\n    // ignore certain edge cases.\n    //\n    //  True => limit the amount of minted tokens\n    //  False => no limit\n    //\n    bool internal constant TOGGLE_MINT_LIMIT = true;\n    uint256 internal constant MINT_MODULO = 1_000_000_000_000e18;\n\n    // Known rounding errors\n    uint256 internal constant TRANSFER_ROUNDING_ERROR = 1e18 - 1;\n    uint256 internal constant OPT_IN_ROUNDING_ERROR = 1e18 - 1;\n    uint256 internal constant MINT_ROUNDING_ERROR = 1e18 - 1;\n\n    /**\n     * @notice Modifier to skip tests that are known to fail\n     * @dev see TOGGLE_KNOWN_ISSUES for more information\n     */\n    modifier hasKnownIssue() {\n        if (TOGGLE_KNOWN_ISSUES) return;\n        _;\n    }\n\n    /**\n     * @notice Modifier to skip tests that are known to fail within limits\n     * @dev see TOGGLE_KNOWN_ISSUES_WITHIN_LIMITS for more information\n     */\n    modifier hasKnownIssueWithinLimits() {\n        if (TOGGLE_KNOWN_ISSUES_WITHIN_LIMITS) return;\n        _;\n    }\n\n    /**\n     * @notice Translate an account ID to an address\n     * @param accountId The ID of the account\n     * @return account The address of the account\n     */\n    function getAccount(uint8 accountId)\n        internal\n        view\n        returns (address account)\n    {\n        accountId = accountId / 64;\n        if (accountId == 0) return account = ADDRESS_USER0;\n        if (accountId == 1) return account = ADDRESS_USER1;\n        if (accountId == 2) return account = ADDRESS_CONTRACT0;\n        if (accountId == 3) return account = ADDRESS_CONTRACT1;\n        require(false, \"Unknown account ID\");\n    }\n}\n"
    },
    "contracts/echidna/EchidnaDebug.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"./EchidnaHelper.sol\";\nimport \"./Debugger.sol\";\n\nimport \"../token/OUSD.sol\";\n\n/**\n * @title Room for random debugging functions\n * @author Rappie\n */\ncontract EchidnaDebug is EchidnaHelper {\n    function debugOUSD() public pure {\n        // assert(ousd.balanceOf(ADDRESS_USER0) == 1000);\n        // assert(ousd.rebaseState(ADDRESS_USER0) != OUSD.RebaseOptions.OptIn);\n        // assert(Address.isContract(ADDRESS_CONTRACT0));\n        // Debugger.log(\"nonRebasingSupply\", ousd.nonRebasingSupply());\n        // assert(false);\n    }\n}\n"
    },
    "contracts/echidna/EchidnaHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./EchidnaSetup.sol\";\nimport \"./Debugger.sol\";\n\n/**\n * @title Mixin containing helper functions\n * @author Rappie\n */\ncontract EchidnaHelper is EchidnaSetup {\n    /**\n     * @notice Mint tokens to an account\n     * @param toAcc Account to mint to\n     * @param amount Amount to mint\n     * @return Amount minted (in case of capped mint with modulo)\n     */\n    function mint(uint8 toAcc, uint256 amount) public returns (uint256) {\n        address to = getAccount(toAcc);\n\n        if (TOGGLE_MINT_LIMIT) {\n            amount = amount % MINT_MODULO;\n        }\n\n        hevm.prank(ADDRESS_VAULT);\n        ousd.mint(to, amount);\n\n        return amount;\n    }\n\n    /**\n     * @notice Burn tokens from an account\n     * @param fromAcc Account to burn from\n     * @param amount Amount to burn\n     */\n    function burn(uint8 fromAcc, uint256 amount) public {\n        address from = getAccount(fromAcc);\n        hevm.prank(ADDRESS_VAULT);\n        ousd.burn(from, amount);\n    }\n\n    /**\n     * @notice Change the total supply of OUSD (rebase)\n     * @param amount New total supply\n     */\n    function changeSupply(uint256 amount) public {\n        if (TOGGLE_CHANGESUPPLY_LIMIT) {\n            amount =\n                ousd.totalSupply() +\n                (amount % (ousd.totalSupply() / CHANGESUPPLY_DIVISOR));\n        }\n\n        hevm.prank(ADDRESS_VAULT);\n        ousd.changeSupply(amount);\n    }\n\n    /**\n     * @notice Transfer tokens between accounts\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function transfer(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n        hevm.prank(from);\n        // slither-disable-next-line unchecked-transfer\n        ousd.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfer approved tokens between accounts\n     * @param authorizedAcc Account that is authorized to transfer\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function transferFrom(\n        uint8 authorizedAcc,\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address authorized = getAccount(authorizedAcc);\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n        hevm.prank(authorized);\n        // slither-disable-next-line unchecked-transfer\n        ousd.transferFrom(from, to, amount);\n    }\n\n    /**\n     * @notice Opt in to rebasing\n     * @param targetAcc Account to opt in\n     */\n    function optIn(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n        hevm.prank(target);\n        ousd.rebaseOptIn();\n    }\n\n    /**\n     * @notice Opt out of rebasing\n     * @param targetAcc Account to opt out\n     */\n    function optOut(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n        hevm.prank(target);\n        ousd.rebaseOptOut();\n    }\n\n    /**\n     * @notice Approve an account to spend OUSD\n     * @param ownerAcc Account that owns the OUSD\n     * @param spenderAcc Account that is approved to spend the OUSD\n     * @param amount Amount to approve\n     */\n    function approve(\n        uint8 ownerAcc,\n        uint8 spenderAcc,\n        uint256 amount\n    ) public {\n        address owner = getAccount(ownerAcc);\n        address spender = getAccount(spenderAcc);\n        hevm.prank(owner);\n        // slither-disable-next-line unused-return\n        ousd.approve(spender, amount);\n    }\n\n    /**\n     * @notice Get the sum of all OUSD balances\n     * @return total Total balance\n     */\n    function getTotalBalance() public view returns (uint256 total) {\n        total += ousd.balanceOf(ADDRESS_VAULT);\n        total += ousd.balanceOf(ADDRESS_OUTSIDER_USER);\n        total += ousd.balanceOf(ADDRESS_OUTSIDER_CONTRACT);\n        total += ousd.balanceOf(ADDRESS_USER0);\n        total += ousd.balanceOf(ADDRESS_USER1);\n        total += ousd.balanceOf(ADDRESS_CONTRACT0);\n        total += ousd.balanceOf(ADDRESS_CONTRACT1);\n    }\n\n    /**\n     * @notice Get the sum of all non-rebasing OUSD balances\n     * @return total Total balance\n     */\n    function getTotalNonRebasingBalance() public returns (uint256 total) {\n        total += ousd._isNonRebasingAccountEchidna(ADDRESS_VAULT)\n            ? ousd.balanceOf(ADDRESS_VAULT)\n            : 0;\n        total += ousd._isNonRebasingAccountEchidna(ADDRESS_OUTSIDER_USER)\n            ? ousd.balanceOf(ADDRESS_OUTSIDER_USER)\n            : 0;\n        total += ousd._isNonRebasingAccountEchidna(ADDRESS_OUTSIDER_CONTRACT)\n            ? ousd.balanceOf(ADDRESS_OUTSIDER_CONTRACT)\n            : 0;\n        total += ousd._isNonRebasingAccountEchidna(ADDRESS_USER0)\n            ? ousd.balanceOf(ADDRESS_USER0)\n            : 0;\n        total += ousd._isNonRebasingAccountEchidna(ADDRESS_USER1)\n            ? ousd.balanceOf(ADDRESS_USER1)\n            : 0;\n        total += ousd._isNonRebasingAccountEchidna(ADDRESS_CONTRACT0)\n            ? ousd.balanceOf(ADDRESS_CONTRACT0)\n            : 0;\n        total += ousd._isNonRebasingAccountEchidna(ADDRESS_CONTRACT1)\n            ? ousd.balanceOf(ADDRESS_CONTRACT1)\n            : 0;\n    }\n}\n"
    },
    "contracts/echidna/EchidnaSetup.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./IHevm.sol\";\nimport \"./EchidnaConfig.sol\";\nimport \"./OUSDEchidna.sol\";\n\ncontract Dummy {}\n\n/**\n * @title Mixin for setup and deployment\n * @author Rappie\n */\ncontract EchidnaSetup is EchidnaConfig {\n    IHevm hevm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    OUSDEchidna ousd = new OUSDEchidna();\n\n    /**\n     * @notice Deploy the OUSD contract and set up initial state\n     */\n    constructor() {\n        ousd.initialize(ADDRESS_VAULT, 1e18);\n\n        // Deploy dummny contracts as users\n        Dummy outsider = new Dummy();\n        ADDRESS_OUTSIDER_CONTRACT = address(outsider);\n        Dummy dummy0 = new Dummy();\n        ADDRESS_CONTRACT0 = address(dummy0);\n        Dummy dummy1 = new Dummy();\n        ADDRESS_CONTRACT1 = address(dummy1);\n\n        // Start out with a reasonable amount of OUSD\n        if (TOGGLE_STARTING_BALANCE) {\n            // Rebasing tokens\n            hevm.prank(ADDRESS_VAULT);\n            ousd.mint(ADDRESS_OUTSIDER_USER, STARTING_BALANCE / 2);\n\n            // Non-rebasing tokens\n            hevm.prank(ADDRESS_VAULT);\n            ousd.mint(ADDRESS_OUTSIDER_CONTRACT, STARTING_BALANCE / 2);\n        }\n    }\n}\n"
    },
    "contracts/echidna/EchidnaTestAccounting.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./EchidnaDebug.sol\";\nimport \"./EchidnaTestSupply.sol\";\n\n/**\n * @title Mixin for testing accounting functions\n * @author Rappie\n */\ncontract EchidnaTestAccounting is EchidnaTestSupply {\n    /**\n     * @notice After opting in, balance should not increase. (Ok to lose rounding funds doing this)\n     * @param targetAcc Account to opt in\n     */\n    function testOptInBalance(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        optIn(targetAcc);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        assert(balanceAfter <= balanceBefore);\n    }\n\n    /**\n     * @notice After opting out, balance should remain the same\n     * @param targetAcc Account to opt out\n     */\n    function testOptOutBalance(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        optOut(targetAcc);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        assert(balanceAfter == balanceBefore);\n    }\n\n    /**\n     * @notice Account balance should remain the same after opting in minus rounding error\n     * @param targetAcc Account to opt in\n     */\n    function testOptInBalanceRounding(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        optIn(targetAcc);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        int256 delta = int256(balanceAfter) - int256(balanceBefore);\n        Debugger.log(\"delta\", delta);\n\n        // slither-disable-next-line tautology\n        assert(-1 * delta >= 0);\n        assert(-1 * delta <= int256(OPT_IN_ROUNDING_ERROR));\n    }\n\n    /**\n     * @notice After opting in, total supply should remain the same\n     * @param targetAcc Account to opt in\n     */\n    function testOptInTotalSupply(uint8 targetAcc) public {\n        uint256 totalSupplyBefore = ousd.totalSupply();\n        optIn(targetAcc);\n        uint256 totalSupplyAfter = ousd.totalSupply();\n\n        assert(totalSupplyAfter == totalSupplyBefore);\n    }\n\n    /**\n     * @notice After opting out, total supply should remain the same\n     * @param targetAcc Account to opt out\n     */\n    function testOptOutTotalSupply(uint8 targetAcc) public {\n        uint256 totalSupplyBefore = ousd.totalSupply();\n        optOut(targetAcc);\n        uint256 totalSupplyAfter = ousd.totalSupply();\n\n        assert(totalSupplyAfter == totalSupplyBefore);\n    }\n\n    /**\n     * @notice Account balance should remain the same when a smart contract auto converts\n     * @param targetAcc Account to auto convert\n     */\n    function testAutoConvertBalance(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        // slither-disable-next-line unused-return\n        ousd._isNonRebasingAccountEchidna(target);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        assert(balanceAfter == balanceBefore);\n    }\n\n    /**\n     * @notice The `balanceOf` function should never revert\n     * @param targetAcc Account to check balance of\n     */\n    function testBalanceOfShouldNotRevert(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        // slither-disable-next-line unused-return\n        try ousd.balanceOf(target) {\n            assert(true);\n        } catch {\n            assert(false);\n        }\n    }\n}\n"
    },
    "contracts/echidna/EchidnaTestApproval.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./EchidnaTestMintBurn.sol\";\nimport \"./Debugger.sol\";\n\n/**\n * @title Mixin for testing approval related functions\n * @author Rappie\n */\ncontract EchidnaTestApproval is EchidnaTestMintBurn {\n    /**\n     * @notice Performing `transferFrom` with an amount inside the allowance should not revert\n     * @param authorizedAcc The account that is authorized to transfer\n     * @param fromAcc The account that is transferring\n     * @param toAcc The account that is receiving\n     * @param amount The amount to transfer\n     */\n    function testTransferFromShouldNotRevert(\n        uint8 authorizedAcc,\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address authorized = getAccount(authorizedAcc);\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(amount <= ousd.balanceOf(from));\n        require(amount <= ousd.allowance(from, authorized));\n\n        hevm.prank(authorized);\n        // slither-disable-next-line unchecked-transfer\n        try ousd.transferFrom(from, to, amount) {\n            // pass\n        } catch {\n            assert(false);\n        }\n    }\n\n    /**\n     * @notice Performing `transferFrom` with an amount outside the allowance should revert\n     * @param authorizedAcc The account that is authorized to transfer\n     * @param fromAcc The account that is transferring\n     * @param toAcc The account that is receiving\n     * @param amount The amount to transfer\n     */\n    function testTransferFromShouldRevert(\n        uint8 authorizedAcc,\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address authorized = getAccount(authorizedAcc);\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(amount > 0);\n        require(\n            !(amount <= ousd.balanceOf(from) &&\n                amount <= ousd.allowance(from, authorized))\n        );\n\n        hevm.prank(authorized);\n        // slither-disable-next-line unchecked-transfer\n        try ousd.transferFrom(from, to, amount) {\n            assert(false);\n        } catch {\n            // pass\n        }\n    }\n\n    /**\n     * @notice Approving an amount should update the allowance and overwrite any previous allowance\n     * @param ownerAcc The account that is approving\n     * @param spenderAcc The account that is being approved\n     * @param amount The amount to approve\n     */\n    function testApprove(\n        uint8 ownerAcc,\n        uint8 spenderAcc,\n        uint256 amount\n    ) public {\n        address owner = getAccount(ownerAcc);\n        address spender = getAccount(spenderAcc);\n\n        approve(ownerAcc, spenderAcc, amount);\n        uint256 allowanceAfter1 = ousd.allowance(owner, spender);\n\n        assert(allowanceAfter1 == amount);\n\n        approve(ownerAcc, spenderAcc, amount / 2);\n        uint256 allowanceAfter2 = ousd.allowance(owner, spender);\n\n        assert(allowanceAfter2 == amount / 2);\n    }\n}\n"
    },
    "contracts/echidna/EchidnaTestMintBurn.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./EchidnaDebug.sol\";\nimport \"./EchidnaTestAccounting.sol\";\n\n/**\n * @title Mixin for testing Mint and Burn functions\n * @author Rappie\n */\ncontract EchidnaTestMintBurn is EchidnaTestAccounting {\n    /**\n     * @notice Minting 0 tokens should not affect account balance\n     * @param targetAcc Account to mint to\n     */\n    function testMintZeroBalance(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        mint(targetAcc, 0);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        assert(balanceAfter == balanceBefore);\n    }\n\n    /**\n     * @notice Burning 0 tokens should not affect account balance\n     * @param targetAcc Account to burn from\n     */\n    function testBurnZeroBalance(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        burn(targetAcc, 0);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        assert(balanceAfter == balanceBefore);\n    }\n\n    /**\n     * @notice Minting tokens must increase the account balance by at least amount\n     * @param targetAcc Account to mint to\n     * @param amount Amount to mint\n     * @custom:error testMintBalance(uint8,uint256): failed!💥\n     *   Call sequence:\n     *       changeSupply(1)\n     *       testMintBalance(0,1)\n     *   Event sequence:\n     *       Debug(«balanceBefore», 0)\n     *       Debug(«balanceAfter», 0)\n     */\n    function testMintBalance(uint8 targetAcc, uint256 amount)\n        public\n        hasKnownIssue\n        hasKnownIssueWithinLimits\n    {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        uint256 amountMinted = mint(targetAcc, amount);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        Debugger.log(\"amountMinted\", amountMinted);\n        Debugger.log(\"balanceBefore\", balanceBefore);\n        Debugger.log(\"balanceAfter\", balanceAfter);\n\n        assert(balanceAfter >= balanceBefore + amountMinted);\n    }\n\n    /**\n     * @notice Burning tokens must decrease the account balance by at least amount\n     * @param targetAcc Account to burn from\n     * @param amount Amount to burn\n     * @custom:error testBurnBalance(uint8,uint256): failed!💥\n     *   Call sequence:\n     *       changeSupply(1)\n     *       mint(0,3)\n     *       testBurnBalance(0,1)\n     *   Event sequence:\n     *       Debug(«balanceBefore», 2)\n     *       Debug(«balanceAfter», 2)\n     */\n    function testBurnBalance(uint8 targetAcc, uint256 amount)\n        public\n        hasKnownIssue\n        hasKnownIssueWithinLimits\n    {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        burn(targetAcc, amount);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        Debugger.log(\"balanceBefore\", balanceBefore);\n        Debugger.log(\"balanceAfter\", balanceAfter);\n\n        assert(balanceAfter <= balanceBefore - amount);\n    }\n\n    /**\n     * @notice Minting tokens should not increase the account balance by less than rounding error above amount\n     * @param targetAcc Account to mint to\n     * @param amount Amount to mint\n     */\n    function testMintBalanceRounding(uint8 targetAcc, uint256 amount) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        uint256 amountMinted = mint(targetAcc, amount);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        int256 delta = int256(balanceAfter) - int256(balanceBefore);\n\n        // delta == amount, if no error\n        // delta < amount,  if too little is minted\n        // delta > amount,  if too much is minted\n        int256 error = int256(amountMinted) - delta;\n\n        assert(error >= 0);\n        assert(error <= int256(MINT_ROUNDING_ERROR));\n    }\n\n    /**\n     * @notice A burn of an account balance must result in a zero balance\n     * @param targetAcc Account to burn from\n     */\n    function testBurnAllBalanceToZero(uint8 targetAcc) public hasKnownIssue {\n        address target = getAccount(targetAcc);\n\n        burn(targetAcc, ousd.balanceOf(target));\n        assert(ousd.balanceOf(target) == 0);\n    }\n\n    /**\n     * @notice You should always be able to burn an account's balance\n     * @param targetAcc Account to burn from\n     */\n    function testBurnAllBalanceShouldNotRevert(uint8 targetAcc)\n        public\n        hasKnownIssue\n    {\n        address target = getAccount(targetAcc);\n        uint256 balance = ousd.balanceOf(target);\n\n        hevm.prank(ADDRESS_VAULT);\n        try ousd.burn(target, balance) {\n            assert(true);\n        } catch {\n            assert(false);\n        }\n    }\n}\n"
    },
    "contracts/echidna/EchidnaTestSupply.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./EchidnaDebug.sol\";\nimport \"./EchidnaTestTransfer.sol\";\n\nimport { StableMath } from \"../utils/StableMath.sol\";\n\n/**\n * @title Mixin for testing supply related functions\n * @author Rappie\n */\ncontract EchidnaTestSupply is EchidnaTestTransfer {\n    using StableMath for uint256;\n\n    uint256 prevRebasingCreditsPerToken = type(uint256).max;\n\n    /**\n     * @notice After a `changeSupply`, the total supply should exactly\n     * match the target total supply. (This is needed to ensure successive\n     * rebases are correct).\n     * @param supply New total supply\n     * @custom:error testChangeSupply(uint256): failed!💥\n     *   Call sequence:\n     *       testChangeSupply(1044505275072865171609)\n     *   Event sequence:\n     *       TotalSupplyUpdatedHighres(1044505275072865171610, 1000000000000000000000000, 957391048054055578595)\n     */\n    function testChangeSupply(uint256 supply)\n        public\n        hasKnownIssue\n        hasKnownIssueWithinLimits\n    {\n        hevm.prank(ADDRESS_VAULT);\n        ousd.changeSupply(supply);\n\n        assert(ousd.totalSupply() == supply);\n    }\n\n    /**\n     * @notice The total supply must not be less than the sum of account balances.\n     * (The difference will go into future rebases)\n     * @custom:error testTotalSupplyLessThanTotalBalance(): failed!💥\n     *   Call sequence:\n     *     mint(0,1)\n     *     changeSupply(1)\n     *     optOut(64)\n     *     transfer(0,64,1)\n     *     testTotalSupplyLessThanTotalBalance()\n     *   Event sequence:\n     *     Debug(«totalSupply», 1000000000000000001000001)\n     *     Debug(«totalBalance», 1000000000000000001000002)\n     */\n    function testTotalSupplyLessThanTotalBalance()\n        public\n        hasKnownIssue\n        hasKnownIssueWithinLimits\n    {\n        uint256 totalSupply = ousd.totalSupply();\n        uint256 totalBalance = getTotalBalance();\n\n        Debugger.log(\"totalSupply\", totalSupply);\n        Debugger.log(\"totalBalance\", totalBalance);\n\n        assert(totalSupply >= totalBalance);\n    }\n\n    /**\n     * @notice Non-rebasing supply should not be larger than total supply\n     * @custom:error testNonRebasingSupplyVsTotalSupply(): failed!💥\n     *   Call sequence:\n     *     mint(0,2)\n     *     changeSupply(3)\n     *     burn(0,1)\n     *     optOut(0)\n     *     testNonRebasingSupplyVsTotalSupply()\n     */\n    function testNonRebasingSupplyVsTotalSupply() public hasKnownIssue {\n        uint256 nonRebasingSupply = ousd.nonRebasingSupply();\n        uint256 totalSupply = ousd.totalSupply();\n\n        assert(nonRebasingSupply <= totalSupply);\n    }\n\n    /**\n     * @notice Global `rebasingCreditsPerToken` should never increase\n     * @custom:error testRebasingCreditsPerTokenNotIncreased(): failed!💥\n     *   Call sequence:\n     *     testRebasingCreditsPerTokenNotIncreased()\n     *     changeSupply(1)\n     *     testRebasingCreditsPerTokenNotIncreased()\n     */\n    function testRebasingCreditsPerTokenNotIncreased() public hasKnownIssue {\n        uint256 curRebasingCreditsPerToken = ousd\n            .rebasingCreditsPerTokenHighres();\n\n        Debugger.log(\n            \"prevRebasingCreditsPerToken\",\n            prevRebasingCreditsPerToken\n        );\n        Debugger.log(\"curRebasingCreditsPerToken\", curRebasingCreditsPerToken);\n\n        assert(curRebasingCreditsPerToken <= prevRebasingCreditsPerToken);\n\n        prevRebasingCreditsPerToken = curRebasingCreditsPerToken;\n    }\n\n    /**\n     * @notice The rebasing credits per token ratio must greater than zero\n     */\n    function testRebasingCreditsPerTokenAboveZero() public {\n        assert(ousd.rebasingCreditsPerTokenHighres() > 0);\n    }\n\n    /**\n     * @notice The sum of all non-rebasing balances should not be larger than\n     * non-rebasing supply\n     * @custom:error testTotalNonRebasingSupplyLessThanTotalBalance(): failed!💥\n     *   Call sequence\n     *     mint(0,2)\n     *     changeSupply(1)\n     *     optOut(0)\n     *     burn(0,1)\n     *     testTotalNonRebasingSupplyLessThanTotalBalance()\n     *   Event sequence:\n     *     Debug(«totalNonRebasingSupply», 500000000000000000000001)\n     *     Debug(«totalNonRebasingBalance», 500000000000000000000002)\n     */\n    function testTotalNonRebasingSupplyLessThanTotalBalance()\n        public\n        hasKnownIssue\n        hasKnownIssueWithinLimits\n    {\n        uint256 totalNonRebasingSupply = ousd.nonRebasingSupply();\n        uint256 totalNonRebasingBalance = getTotalNonRebasingBalance();\n\n        Debugger.log(\"totalNonRebasingSupply\", totalNonRebasingSupply);\n        Debugger.log(\"totalNonRebasingBalance\", totalNonRebasingBalance);\n\n        assert(totalNonRebasingSupply >= totalNonRebasingBalance);\n    }\n\n    /**\n     * @notice An accounts credits / credits per token should not be larger it's balance\n     * @param targetAcc The account to check\n     */\n    function testCreditsPerTokenVsBalance(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        (uint256 credits, uint256 creditsPerToken, ) = ousd\n            .creditsBalanceOfHighres(target);\n        uint256 expectedBalance = credits.divPrecisely(creditsPerToken);\n\n        uint256 balance = ousd.balanceOf(target);\n\n        Debugger.log(\"credits\", credits);\n        Debugger.log(\"creditsPerToken\", creditsPerToken);\n        Debugger.log(\"expectedBalance\", expectedBalance);\n        Debugger.log(\"balance\", balance);\n\n        assert(expectedBalance == balance);\n    }\n}\n"
    },
    "contracts/echidna/EchidnaTestTransfer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./EchidnaDebug.sol\";\nimport \"./Debugger.sol\";\n\n/**\n * @title Mixin for testing transfer related functions\n * @author Rappie\n */\ncontract EchidnaTestTransfer is EchidnaDebug {\n    /**\n     * @notice The receiving account's balance after a transfer must not increase by\n     * less than the amount transferred\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     * @custom:error testTransferBalanceReceivedLess(uint8,uint8,uint256): failed!💥\n     *   Call sequence:\n     *     changeSupply(1)\n     *     mint(64,2)\n     *     testTransferBalanceReceivedLess(64,0,1)\n     *   Event sequence:\n     *     Debug(«totalSupply», 1000000000000000000500002)\n     *     Debug(«toBalBefore», 0)\n     *     Debug(«toBalAfter», 0)\n     */\n    function testTransferBalanceReceivedLess(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public hasKnownIssue hasKnownIssueWithinLimits {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(from != to);\n\n        uint256 toBalBefore = ousd.balanceOf(to);\n        transfer(fromAcc, toAcc, amount);\n        uint256 toBalAfter = ousd.balanceOf(to);\n\n        Debugger.log(\"totalSupply\", ousd.totalSupply());\n        Debugger.log(\"toBalBefore\", toBalBefore);\n        Debugger.log(\"toBalAfter\", toBalAfter);\n\n        assert(toBalAfter >= toBalBefore + amount);\n    }\n\n    /**\n     * @notice The receiving account's balance after a transfer must not\n     * increase by more than the amount transferred\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function testTransferBalanceReceivedMore(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(from != to);\n\n        uint256 toBalBefore = ousd.balanceOf(to);\n        transfer(fromAcc, toAcc, amount);\n        uint256 toBalAfter = ousd.balanceOf(to);\n\n        Debugger.log(\"totalSupply\", ousd.totalSupply());\n        Debugger.log(\"toBalBefore\", toBalBefore);\n        Debugger.log(\"toBalAfter\", toBalAfter);\n\n        assert(toBalAfter <= toBalBefore + amount);\n    }\n\n    /**\n     * @notice The sending account's balance after a transfer must not\n     * decrease by less than the amount transferred\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     * @custom:error testTransferBalanceSentLess(uint8,uint8,uint256): failed!💥\n     *   Call sequence:\n     *     mint(0,1)\n     *     changeSupply(1)\n     *     testTransferBalanceSentLess(0,64,1)\n     *   Event sequence:\n     *     Debug(«totalSupply», 1000000000000000000500001)\n     *     Debug(«fromBalBefore», 1)\n     *     Debug(«fromBalAfter», 1)\n     */\n    function testTransferBalanceSentLess(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public hasKnownIssue hasKnownIssueWithinLimits {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(from != to);\n\n        uint256 fromBalBefore = ousd.balanceOf(from);\n        transfer(fromAcc, toAcc, amount);\n        uint256 fromBalAfter = ousd.balanceOf(from);\n\n        Debugger.log(\"totalSupply\", ousd.totalSupply());\n        Debugger.log(\"fromBalBefore\", fromBalBefore);\n        Debugger.log(\"fromBalAfter\", fromBalAfter);\n\n        assert(fromBalAfter <= fromBalBefore - amount);\n    }\n\n    /**\n     * @notice The sending account's balance after a transfer must not\n     * decrease by more than the amount transferred\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function testTransferBalanceSentMore(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(from != to);\n\n        uint256 fromBalBefore = ousd.balanceOf(from);\n        transfer(fromAcc, toAcc, amount);\n        uint256 fromBalAfter = ousd.balanceOf(from);\n\n        Debugger.log(\"totalSupply\", ousd.totalSupply());\n        Debugger.log(\"fromBalBefore\", fromBalBefore);\n        Debugger.log(\"fromBalAfter\", fromBalAfter);\n\n        assert(fromBalAfter >= fromBalBefore - amount);\n    }\n\n    /**\n     * @notice The receiving account's balance after a transfer must not\n     * increase by less than the amount transferred (minus rounding error)\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function testTransferBalanceReceivedLessRounding(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(from != to);\n\n        uint256 toBalBefore = ousd.balanceOf(to);\n        transfer(fromAcc, toAcc, amount);\n        uint256 toBalAfter = ousd.balanceOf(to);\n\n        int256 toDelta = int256(toBalAfter) - int256(toBalBefore);\n\n        // delta == amount, if no error\n        // delta < amount,  if too little is sent\n        // delta > amount,  if too much is sent\n        int256 error = int256(amount) - toDelta;\n\n        Debugger.log(\"totalSupply\", ousd.totalSupply());\n        Debugger.log(\"toBalBefore\", toBalBefore);\n        Debugger.log(\"toBalAfter\", toBalAfter);\n        Debugger.log(\"toDelta\", toDelta);\n        Debugger.log(\"error\", error);\n\n        assert(error >= 0);\n        assert(error <= int256(TRANSFER_ROUNDING_ERROR));\n    }\n\n    /**\n     * @notice The sending account's balance after a transfer must\n     * not decrease by less than the amount transferred (minus rounding error)\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function testTransferBalanceSentLessRounding(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(from != to);\n\n        uint256 fromBalBefore = ousd.balanceOf(from);\n        transfer(fromAcc, toAcc, amount);\n        uint256 fromBalAfter = ousd.balanceOf(from);\n\n        int256 fromDelta = int256(fromBalAfter) - int256(fromBalBefore);\n\n        // delta == -amount, if no error\n        // delta < -amount,  if too much is sent\n        // delta > -amount,  if too little is sent\n        int256 error = int256(amount) + fromDelta;\n\n        Debugger.log(\"totalSupply\", ousd.totalSupply());\n        Debugger.log(\"fromBalBefore\", fromBalBefore);\n        Debugger.log(\"fromBalAfter\", fromBalAfter);\n        Debugger.log(\"fromDelta\", fromDelta);\n        Debugger.log(\"error\", error);\n\n        assert(error >= 0);\n        assert(error <= int256(TRANSFER_ROUNDING_ERROR));\n    }\n\n    /**\n     * @notice An account should always be able to successfully transfer\n     * an amount within its balance.\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     * @custom:error testTransferWithinBalanceDoesNotRevert(uint8,uint8,uint8): failed!💥\n     *   Call sequence:\n     *       mint(0,1)\n     *       changeSupply(3)\n     *       optOut(0)\n     *       testTransferWithinBalanceDoesNotRevert(0,128,2)\n     *       optIn(0)\n     *       testTransferWithinBalanceDoesNotRevert(128,0,1)\n     *   Event sequence:\n     *       error Revert Panic(17): SafeMath over-/under-flows\n     */\n    function testTransferWithinBalanceDoesNotRevert(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public hasKnownIssue {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(amount > 0);\n        amount = amount % ousd.balanceOf(from);\n\n        Debugger.log(\"Total supply\", ousd.totalSupply());\n\n        hevm.prank(from);\n        // slither-disable-next-line unchecked-transfer\n        try ousd.transfer(to, amount) {\n            assert(true);\n        } catch {\n            assert(false);\n        }\n    }\n\n    /**\n     * @notice An account should never be able to successfully transfer\n     * an amount greater than their balance.\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function testTransferExceedingBalanceReverts(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        amount = ousd.balanceOf(from) + 1 + amount;\n\n        hevm.prank(from);\n        // slither-disable-next-line unchecked-transfer\n        try ousd.transfer(to, amount) {\n            assert(false);\n        } catch {\n            assert(true);\n        }\n    }\n\n    /**\n     * @notice A transfer to the same account should not change that account's balance\n     * @param targetAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function testTransferSelf(uint8 targetAcc, uint256 amount) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        transfer(targetAcc, targetAcc, amount);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        assert(balanceBefore == balanceAfter);\n    }\n\n    /**\n     * @notice Transfers to the zero account revert\n     * @param fromAcc Account to transfer from\n     * @param amount Amount to transfer\n     */\n    function testTransferToZeroAddress(uint8 fromAcc, uint256 amount) public {\n        address from = getAccount(fromAcc);\n\n        hevm.prank(from);\n        // slither-disable-next-line unchecked-transfer\n        try ousd.transfer(address(0), amount) {\n            assert(false);\n        } catch {\n            assert(true);\n        }\n    }\n}\n"
    },
    "contracts/echidna/IHevm.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n// https://github.com/ethereum/hevm/blob/main/doc/src/controlling-the-unit-testing-environment.md#cheat-codes\n\ninterface IHevm {\n    function warp(uint256 x) external;\n\n    function roll(uint256 x) external;\n\n    function store(\n        address c,\n        bytes32 loc,\n        bytes32 val\n    ) external;\n\n    function load(address c, bytes32 loc) external returns (bytes32 val);\n\n    function sign(uint256 sk, bytes32 digest)\n        external\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        );\n\n    function addr(uint256 sk) external returns (address addr);\n\n    function ffi(string[] calldata) external returns (bytes memory);\n\n    function prank(address sender) external;\n}\n"
    },
    "contracts/echidna/OUSDEchidna.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../token/OUSD.sol\";\n\ncontract OUSDEchidna is OUSD {\n    constructor() OUSD() {}\n\n    function _isNonRebasingAccountEchidna(address _account)\n        public\n        returns (bool)\n    {\n        _autoMigrate(_account);\n        return alternativeCreditsPerToken[_account] > 0;\n    }\n}\n"
    },
    "contracts/governance/Governable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Base for contracts that are managed by the Origin Protocol's Governor.\n * @dev Copy of the openzeppelin Ownable.sol contract with nomenclature change\n *      from owner to governor and renounce methods removed. Does not use\n *      Context.sol like Ownable.sol does for simplification.\n * @author Origin Protocol Inc\n */\nabstract contract Governable {\n    // Storage position of the owner and pendingOwner of the contract\n    // keccak256(\"OUSD.governor\");\n    bytes32 private constant governorPosition =\n        0x7bea13895fa79d2831e0a9e28edede30099005a50d652d8957cf8a607ee6ca4a;\n\n    // keccak256(\"OUSD.pending.governor\");\n    bytes32 private constant pendingGovernorPosition =\n        0x44c4d30b2eaad5130ad70c3ba6972730566f3e6359ab83e800d905c61b1c51db;\n\n    // keccak256(\"OUSD.reentry.status\");\n    bytes32 private constant reentryStatusPosition =\n        0x53bf423e48ed90e97d02ab0ebab13b2a235a6bfbe9c321847d5c175333ac4535;\n\n    // See OpenZeppelin ReentrancyGuard implementation\n    uint256 constant _NOT_ENTERED = 1;\n    uint256 constant _ENTERED = 2;\n\n    event PendingGovernorshipTransfer(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    event GovernorshipTransferred(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    /**\n     * @notice Returns the address of the current Governor.\n     */\n    function governor() public view returns (address) {\n        return _governor();\n    }\n\n    /**\n     * @dev Returns the address of the current Governor.\n     */\n    function _governor() internal view returns (address governorOut) {\n        bytes32 position = governorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            governorOut := sload(position)\n        }\n    }\n\n    /**\n     * @dev Returns the address of the pending Governor.\n     */\n    function _pendingGovernor()\n        internal\n        view\n        returns (address pendingGovernor)\n    {\n        bytes32 position = pendingGovernorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            pendingGovernor := sload(position)\n        }\n    }\n\n    /**\n     * @dev Throws if called by any account other than the Governor.\n     */\n    modifier onlyGovernor() {\n        require(isGovernor(), \"Caller is not the Governor\");\n        _;\n    }\n\n    /**\n     * @notice Returns true if the caller is the current Governor.\n     */\n    function isGovernor() public view returns (bool) {\n        return msg.sender == _governor();\n    }\n\n    function _setGovernor(address newGovernor) internal {\n        emit GovernorshipTransferred(_governor(), newGovernor);\n\n        bytes32 position = governorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, newGovernor)\n        }\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        bytes32 position = reentryStatusPosition;\n        uint256 _reentry_status;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _reentry_status := sload(position)\n        }\n\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_reentry_status != _ENTERED, \"Reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, _ENTERED)\n        }\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, _NOT_ENTERED)\n        }\n    }\n\n    function _setPendingGovernor(address newGovernor) internal {\n        bytes32 position = pendingGovernorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, newGovernor)\n        }\n    }\n\n    /**\n     * @notice Transfers Governance of the contract to a new account (`newGovernor`).\n     * Can only be called by the current Governor. Must be claimed for this to complete\n     * @param _newGovernor Address of the new Governor\n     */\n    function transferGovernance(address _newGovernor) external onlyGovernor {\n        _setPendingGovernor(_newGovernor);\n        emit PendingGovernorshipTransfer(_governor(), _newGovernor);\n    }\n\n    /**\n     * @notice Claim Governance of the contract to a new account (`newGovernor`).\n     * Can only be called by the new Governor.\n     */\n    function claimGovernance() external {\n        require(\n            msg.sender == _pendingGovernor(),\n            \"Only the pending Governor can complete the claim\"\n        );\n        _changeGovernor(msg.sender);\n    }\n\n    /**\n     * @dev Change Governance of the contract to a new account (`newGovernor`).\n     * @param _newGovernor Address of the new Governor\n     */\n    function _changeGovernor(address _newGovernor) internal {\n        require(_newGovernor != address(0), \"New Governor is address(0)\");\n        _setGovernor(_newGovernor);\n    }\n}\n"
    },
    "contracts/governance/InitializableGovernable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD InitializableGovernable Contract\n * @author Origin Protocol Inc\n */\nimport { Initializable } from \"../utils/Initializable.sol\";\n\nimport { Governable } from \"./Governable.sol\";\n\ncontract InitializableGovernable is Governable, Initializable {\n    function _initialize(address _newGovernor) internal {\n        _changeGovernor(_newGovernor);\n    }\n}\n"
    },
    "contracts/governance/Strategizable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Governable } from \"./Governable.sol\";\n\ncontract Strategizable is Governable {\n    event StrategistUpdated(address _address);\n\n    // Address of strategist\n    address public strategistAddr;\n\n    // For future use\n    uint256[50] private __gap;\n\n    /**\n     * @dev Verifies that the caller is either Governor or Strategist.\n     */\n    modifier onlyGovernorOrStrategist() {\n        require(\n            msg.sender == strategistAddr || isGovernor(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Set address of Strategist\n     * @param _address Address of Strategist\n     */\n    function setStrategistAddr(address _address) external onlyGovernor {\n        _setStrategistAddr(_address);\n    }\n\n    /**\n     * @dev Set address of Strategist\n     * @param _address Address of Strategist\n     */\n    function _setStrategistAddr(address _address) internal {\n        strategistAddr = _address;\n        emit StrategistUpdated(_address);\n    }\n}\n"
    },
    "contracts/harvest/AbstractHarvester.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\nimport { IUniswapV2Router } from \"../interfaces/uniswap/IUniswapV2Router02.sol\";\nimport { IUniswapV3Router } from \"../interfaces/uniswap/IUniswapV3Router.sol\";\nimport { IBalancerVault } from \"../interfaces/balancer/IBalancerVault.sol\";\nimport { ICurvePool } from \"../strategies/ICurvePool.sol\";\nimport \"../utils/Helpers.sol\";\n\nabstract contract AbstractHarvester is Governable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using StableMath for uint256;\n\n    enum SwapPlatform {\n        UniswapV2Compatible,\n        UniswapV3,\n        Balancer,\n        Curve\n    }\n\n    event SupportedStrategyUpdate(address strategyAddress, bool isSupported);\n    event RewardTokenConfigUpdated(\n        address tokenAddress,\n        uint16 allowedSlippageBps,\n        uint16 harvestRewardBps,\n        SwapPlatform swapPlatform,\n        address swapPlatformAddr,\n        bytes swapData,\n        uint256 liquidationLimit,\n        bool doSwapRewardToken\n    );\n    event RewardTokenSwapped(\n        address indexed rewardToken,\n        address indexed swappedInto,\n        SwapPlatform swapPlatform,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    event RewardProceedsTransferred(\n        address indexed token,\n        address farmer,\n        uint256 protcolYield,\n        uint256 farmerFee\n    );\n    event RewardProceedsAddressChanged(address newProceedsAddress);\n\n    error EmptyAddress();\n    error InvalidSlippageBps();\n    error InvalidHarvestRewardBps();\n\n    error InvalidSwapPlatform(SwapPlatform swapPlatform);\n\n    error InvalidUniswapV2PathLength();\n    error InvalidTokenInSwapPath(address token);\n    error EmptyBalancerPoolId();\n    error InvalidCurvePoolAssetIndex(address token);\n\n    error UnsupportedStrategy(address strategyAddress);\n\n    error SlippageError(uint256 actualBalance, uint256 minExpected);\n    error BalanceMismatchAfterSwap(uint256 actualBalance, uint256 minExpected);\n\n    // Configuration properties for harvesting logic of reward tokens\n    struct RewardTokenConfig {\n        // Max allowed slippage when swapping reward token for a stablecoin denominated in basis points.\n        uint16 allowedSlippageBps;\n        // Reward when calling a harvest function denominated in basis points.\n        uint16 harvestRewardBps;\n        // Address of compatible exchange protocol (Uniswap V2/V3, SushiSwap, Balancer and Curve).\n        address swapPlatformAddr;\n        /* When true the reward token is being swapped. In a need of (temporarily) disabling the swapping of\n         * a reward token this needs to be set to false.\n         */\n        bool doSwapRewardToken;\n        // Platform to use for Swapping\n        SwapPlatform swapPlatform;\n        /* How much token can be sold per one harvest call. If the balance of rewards tokens\n         * exceeds that limit multiple harvest calls are required to harvest all of the tokens.\n         * Set it to MAX_INT to effectively disable the limit.\n         */\n        uint256 liquidationLimit;\n    }\n\n    mapping(address => RewardTokenConfig) public rewardTokenConfigs;\n    mapping(address => bool) public supportedStrategies;\n\n    address public immutable vaultAddress;\n\n    /**\n     * Address receiving rewards proceeds. Initially the Vault contract later will possibly\n     * be replaced by another contract that eases out rewards distribution.\n     **/\n    address public rewardProceedsAddress;\n\n    /**\n     * All tokens are swapped to this token before it gets transferred\n     * to the `rewardProceedsAddress`. USDT for OUSD and WETH for OETH.\n     **/\n    address public immutable baseTokenAddress;\n    // Cached decimals for `baseTokenAddress`\n    uint256 public immutable baseTokenDecimals;\n\n    // Uniswap V2 path for reward tokens using Uniswap V2 Router\n    mapping(address => address[]) public uniswapV2Path;\n    // Uniswap V3 path for reward tokens using Uniswap V3 Router\n    mapping(address => bytes) public uniswapV3Path;\n    // Pool ID to use for reward tokens on Balancer\n    mapping(address => bytes32) public balancerPoolId;\n\n    struct CurvePoolIndices {\n        // Casted into uint128 and stored in a struct to save gas\n        uint128 rewardTokenIndex;\n        uint128 baseTokenIndex;\n    }\n    // Packed indices of assets on the Curve pool\n    mapping(address => CurvePoolIndices) public curvePoolIndices;\n\n    constructor(address _vaultAddress, address _baseTokenAddress) {\n        require(_vaultAddress != address(0));\n        require(_baseTokenAddress != address(0));\n\n        vaultAddress = _vaultAddress;\n        baseTokenAddress = _baseTokenAddress;\n\n        // Cache decimals as well\n        baseTokenDecimals = Helpers.getDecimals(_baseTokenAddress);\n    }\n\n    /***************************************\n                 Configuration\n    ****************************************/\n\n    /**\n     * Set the Address receiving rewards proceeds.\n     * @param _rewardProceedsAddress Address of the reward token\n     */\n    function setRewardProceedsAddress(address _rewardProceedsAddress)\n        external\n        onlyGovernor\n    {\n        if (_rewardProceedsAddress == address(0)) {\n            revert EmptyAddress();\n        }\n\n        rewardProceedsAddress = _rewardProceedsAddress;\n        emit RewardProceedsAddressChanged(_rewardProceedsAddress);\n    }\n\n    /**\n     * @dev Add/update a reward token configuration that holds harvesting config variables\n     * @param _tokenAddress Address of the reward token\n     * @param tokenConfig.allowedSlippageBps uint16 maximum allowed slippage denominated in basis points.\n     *          Example: 300 == 3% slippage\n     * @param tokenConfig.harvestRewardBps uint16 amount of reward tokens the caller of the function is rewarded.\n     *          Example: 100 == 1%\n     * @param tokenConfig.swapPlatformAddr Address Address of a UniswapV2 compatible contract to perform\n     *          the exchange from reward tokens to stablecoin (currently hard-coded to USDT)\n     * @param tokenConfig.liquidationLimit uint256 Maximum amount of token to be sold per one swap function call.\n     *          When value is 0 there is no limit.\n     * @param tokenConfig.doSwapRewardToken bool Disables swapping of the token when set to true,\n     *          does not cause it to revert though.\n     * @param tokenConfig.swapPlatform SwapPlatform to use for Swapping\n     * @param swapData Additional data required for swapping\n     */\n    function setRewardTokenConfig(\n        address _tokenAddress,\n        RewardTokenConfig calldata tokenConfig,\n        bytes calldata swapData\n    ) external onlyGovernor {\n        if (tokenConfig.allowedSlippageBps > 1000) {\n            revert InvalidSlippageBps();\n        }\n\n        if (tokenConfig.harvestRewardBps > 1000) {\n            revert InvalidHarvestRewardBps();\n        }\n\n        address newRouterAddress = tokenConfig.swapPlatformAddr;\n        if (newRouterAddress == address(0)) {\n            // Swap router address should be non zero address\n            revert EmptyAddress();\n        }\n\n        address oldRouterAddress = rewardTokenConfigs[_tokenAddress]\n            .swapPlatformAddr;\n        rewardTokenConfigs[_tokenAddress] = tokenConfig;\n\n        // Revert if feed does not exist\n        // slither-disable-next-line unused-return\n        IOracle(IVault(vaultAddress).priceProvider()).price(_tokenAddress);\n\n        IERC20 token = IERC20(_tokenAddress);\n        // if changing token swap provider cancel existing allowance\n        if (\n            /* oldRouterAddress == address(0) when there is no pre-existing\n             * configuration for said rewards token\n             */\n            oldRouterAddress != address(0) &&\n            oldRouterAddress != newRouterAddress\n        ) {\n            token.safeApprove(oldRouterAddress, 0);\n        }\n\n        // Give SwapRouter infinite approval when needed\n        if (oldRouterAddress != newRouterAddress) {\n            token.safeApprove(newRouterAddress, 0);\n            token.safeApprove(newRouterAddress, type(uint256).max);\n        }\n\n        SwapPlatform _platform = tokenConfig.swapPlatform;\n        if (_platform == SwapPlatform.UniswapV2Compatible) {\n            uniswapV2Path[_tokenAddress] = _decodeUniswapV2Path(\n                swapData,\n                _tokenAddress\n            );\n        } else if (_platform == SwapPlatform.UniswapV3) {\n            uniswapV3Path[_tokenAddress] = _decodeUniswapV3Path(\n                swapData,\n                _tokenAddress\n            );\n        } else if (_platform == SwapPlatform.Balancer) {\n            balancerPoolId[_tokenAddress] = _decodeBalancerPoolId(\n                swapData,\n                newRouterAddress,\n                _tokenAddress\n            );\n        } else if (_platform == SwapPlatform.Curve) {\n            curvePoolIndices[_tokenAddress] = _decodeCurvePoolIndices(\n                swapData,\n                newRouterAddress,\n                _tokenAddress\n            );\n        } else {\n            // Note: This code is unreachable since Solidity reverts when\n            // the value is outside the range of defined values of the enum\n            // (even if it's under the max length of the base type)\n            revert InvalidSwapPlatform(_platform);\n        }\n\n        emit RewardTokenConfigUpdated(\n            _tokenAddress,\n            tokenConfig.allowedSlippageBps,\n            tokenConfig.harvestRewardBps,\n            _platform,\n            newRouterAddress,\n            swapData,\n            tokenConfig.liquidationLimit,\n            tokenConfig.doSwapRewardToken\n        );\n    }\n\n    /**\n     * @dev Decodes the data passed into Uniswap V2 path and validates\n     *      it to make sure the path is for `token` to `baseToken`\n     *\n     * @param data Ecnoded data passed to the `setRewardTokenConfig`\n     * @param token The address of the reward token\n     * @return path The validated Uniswap V2 path\n     */\n    function _decodeUniswapV2Path(bytes calldata data, address token)\n        internal\n        view\n        returns (address[] memory path)\n    {\n        (path) = abi.decode(data, (address[]));\n        uint256 len = path.length;\n\n        if (len < 2) {\n            // Path should have at least two tokens\n            revert InvalidUniswapV2PathLength();\n        }\n\n        // Do some validation\n        if (path[0] != token) {\n            revert InvalidTokenInSwapPath(path[0]);\n        }\n\n        if (path[len - 1] != baseTokenAddress) {\n            revert InvalidTokenInSwapPath(path[len - 1]);\n        }\n    }\n\n    /**\n     * @dev Decodes the data passed into Uniswap V3 path and validates\n     *      it to make sure the path is for `token` to `baseToken`\n     *\n     * @param data Ecnoded data passed to the `setRewardTokenConfig`\n     * @param token The address of the reward token\n     * @return path The validated Uniswap V3 path\n     */\n    function _decodeUniswapV3Path(bytes calldata data, address token)\n        internal\n        view\n        returns (bytes calldata path)\n    {\n        path = data;\n\n        address decodedAddress = address(uint160(bytes20(data[0:20])));\n\n        if (decodedAddress != token) {\n            // Invalid Reward Token in swap path\n            revert InvalidTokenInSwapPath(decodedAddress);\n        }\n\n        decodedAddress = address(uint160(bytes20(data[path.length - 20:])));\n        if (decodedAddress != baseTokenAddress) {\n            // Invalid Base Token in swap path\n            revert InvalidTokenInSwapPath(decodedAddress);\n        }\n    }\n\n    /**\n     * @dev Decodes the data passed to Balancer Pool ID\n     *\n     * @param data Ecnoded data passed to the `setRewardTokenConfig`\n     * @return poolId The pool ID\n     */\n    function _decodeBalancerPoolId(\n        bytes calldata data,\n        address balancerVault,\n        address token\n    ) internal view returns (bytes32 poolId) {\n        (poolId) = abi.decode(data, (bytes32));\n\n        if (poolId == bytes32(0)) {\n            revert EmptyBalancerPoolId();\n        }\n\n        IBalancerVault bVault = IBalancerVault(balancerVault);\n\n        // Note: this reverts if token is not a pool asset\n        // slither-disable-next-line unused-return\n        bVault.getPoolTokenInfo(poolId, token);\n\n        // slither-disable-next-line unused-return\n        bVault.getPoolTokenInfo(poolId, baseTokenAddress);\n    }\n\n    /**\n     * @dev Decodes the data passed to get the pool indices and\n     *      checks it against the Curve Pool to make sure it's\n     *      not misconfigured. The indices are packed into a single\n     *      uint256 for gas savings\n     *\n     * @param data Ecnoded data passed to the `setRewardTokenConfig`\n     * @param poolAddress Curve pool address\n     * @param token The address of the reward token\n     * @return indices Packed pool asset indices\n     */\n    function _decodeCurvePoolIndices(\n        bytes calldata data,\n        address poolAddress,\n        address token\n    ) internal view returns (CurvePoolIndices memory indices) {\n        indices = abi.decode(data, (CurvePoolIndices));\n\n        ICurvePool pool = ICurvePool(poolAddress);\n        if (token != pool.coins(indices.rewardTokenIndex)) {\n            revert InvalidCurvePoolAssetIndex(token);\n        }\n        if (baseTokenAddress != pool.coins(indices.baseTokenIndex)) {\n            revert InvalidCurvePoolAssetIndex(baseTokenAddress);\n        }\n    }\n\n    /**\n     * @dev Flags a strategy as supported or not supported one\n     * @param _strategyAddress Address of the strategy\n     * @param _isSupported Bool marking strategy as supported or not supported\n     */\n    function setSupportedStrategy(address _strategyAddress, bool _isSupported)\n        external\n        onlyGovernor\n    {\n        supportedStrategies[_strategyAddress] = _isSupported;\n        emit SupportedStrategyUpdate(_strategyAddress, _isSupported);\n    }\n\n    /***************************************\n                    Rewards\n    ****************************************/\n\n    /**\n     * @dev Transfer token to governor. Intended for recovering tokens stuck in\n     *      contract, i.e. mistaken sends.\n     * @param _asset Address for the asset\n     * @param _amount Amount of the asset to transfer\n     */\n    function transferToken(address _asset, uint256 _amount)\n        external\n        onlyGovernor\n    {\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /**\n     * @dev Collect reward tokens from a specific strategy and swap them for\n     *      base token on the configured swap platform. Can be called by anyone.\n     *      Rewards incentivizing the caller are sent to the caller of this function.\n     * @param _strategyAddr Address of the strategy to collect rewards from\n     */\n    function harvestAndSwap(address _strategyAddr) external nonReentrant {\n        // Remember _harvest function checks for the validity of _strategyAddr\n        _harvestAndSwap(_strategyAddr, msg.sender);\n    }\n\n    /**\n     * @dev Collect reward tokens from a specific strategy and swap them for\n     *      base token on the configured swap platform. Can be called by anyone\n     * @param _strategyAddr Address of the strategy to collect rewards from\n     * @param _rewardTo Address where to send a share of harvest rewards to as an incentive\n     *      for executing this function\n     */\n    function harvestAndSwap(address _strategyAddr, address _rewardTo)\n        external\n        nonReentrant\n    {\n        // Remember _harvest function checks for the validity of _strategyAddr\n        _harvestAndSwap(_strategyAddr, _rewardTo);\n    }\n\n    /**\n     * @dev Collect reward tokens from a specific strategy and swap them for\n     *      base token on the configured swap platform\n     * @param _strategyAddr Address of the strategy to collect rewards from\n     * @param _rewardTo Address where to send a share of harvest rewards to as an incentive\n     *      for executing this function\n     */\n    function _harvestAndSwap(address _strategyAddr, address _rewardTo)\n        internal\n    {\n        _harvest(_strategyAddr);\n        IStrategy strategy = IStrategy(_strategyAddr);\n        address[] memory rewardTokens = strategy.getRewardTokenAddresses();\n        IOracle priceProvider = IOracle(IVault(vaultAddress).priceProvider());\n        uint256 len = rewardTokens.length;\n        for (uint256 i = 0; i < len; ++i) {\n            _swap(rewardTokens[i], _rewardTo, priceProvider);\n        }\n    }\n\n    /**\n     * @dev Collect reward tokens from a specific strategy and swap them for\n     *      base token on the configured swap platform\n     * @param _strategyAddr Address of the strategy to collect rewards from.\n     */\n    function _harvest(address _strategyAddr) internal virtual {\n        if (!supportedStrategies[_strategyAddr]) {\n            revert UnsupportedStrategy(_strategyAddr);\n        }\n\n        IStrategy strategy = IStrategy(_strategyAddr);\n        strategy.collectRewardTokens();\n    }\n\n    /**\n     * @dev Swap a reward token for the base token on the configured\n     *      swap platform. The token must have a registered price feed\n     *      with the price provider\n     * @param _swapToken Address of the token to swap\n     * @param _rewardTo Address where to send the share of harvest rewards to\n     * @param _priceProvider Oracle to get prices of the swap token\n     */\n    function _swap(\n        address _swapToken,\n        address _rewardTo,\n        IOracle _priceProvider\n    ) internal virtual {\n        uint256 balance = IERC20(_swapToken).balanceOf(address(this));\n\n        // No need to swap if the reward token is the base token. eg USDT or WETH.\n        // There is also no limit on the transfer. Everything in the harvester will be transferred\n        // to the Dripper regardless of the liquidationLimit config.\n        if (_swapToken == baseTokenAddress) {\n            IERC20(_swapToken).safeTransfer(rewardProceedsAddress, balance);\n            // currently not paying the farmer any rewards as there is no swap\n            emit RewardProceedsTransferred(\n                baseTokenAddress,\n                address(0),\n                balance,\n                0\n            );\n            return;\n        }\n\n        RewardTokenConfig memory tokenConfig = rewardTokenConfigs[_swapToken];\n\n        /* This will trigger a return when reward token configuration has not yet been set\n         * or we have temporarily disabled swapping of specific reward token via setting\n         * doSwapRewardToken to false.\n         */\n        if (!tokenConfig.doSwapRewardToken) {\n            return;\n        }\n\n        if (balance == 0) {\n            return;\n        }\n\n        if (tokenConfig.liquidationLimit > 0) {\n            balance = Math.min(balance, tokenConfig.liquidationLimit);\n        }\n\n        // This'll revert if there is no price feed\n        uint256 oraclePrice = _priceProvider.price(_swapToken);\n\n        // Oracle price is 1e18\n        uint256 minExpected = (balance *\n            (1e4 - tokenConfig.allowedSlippageBps) * // max allowed slippage\n            oraclePrice).scaleBy(\n                baseTokenDecimals,\n                Helpers.getDecimals(_swapToken)\n            ) /\n            1e4 / // fix the max slippage decimal position\n            1e18; // and oracle price decimals position\n\n        // Do the swap\n        uint256 amountReceived = _doSwap(\n            tokenConfig.swapPlatform,\n            tokenConfig.swapPlatformAddr,\n            _swapToken,\n            balance,\n            minExpected\n        );\n\n        if (amountReceived < minExpected) {\n            revert SlippageError(amountReceived, minExpected);\n        }\n\n        emit RewardTokenSwapped(\n            _swapToken,\n            baseTokenAddress,\n            tokenConfig.swapPlatform,\n            balance,\n            amountReceived\n        );\n\n        IERC20 baseToken = IERC20(baseTokenAddress);\n        uint256 baseTokenBalance = baseToken.balanceOf(address(this));\n        if (baseTokenBalance < amountReceived) {\n            // Note: It's possible to bypass this check by transferring `baseToken`\n            // directly to Harvester before calling the `harvestAndSwap`. However,\n            // there's no incentive for an attacker to do that. Doing a balance diff\n            // will increase the gas cost significantly\n            revert BalanceMismatchAfterSwap(baseTokenBalance, amountReceived);\n        }\n\n        // Farmer only gets fee from the base amount they helped farm,\n        // They do not get anything from anything that already was there\n        // on the Harvester\n        uint256 farmerFee = amountReceived.mulTruncateScale(\n            tokenConfig.harvestRewardBps,\n            1e4\n        );\n        uint256 protocolYield = baseTokenBalance - farmerFee;\n\n        baseToken.safeTransfer(rewardProceedsAddress, protocolYield);\n        baseToken.safeTransfer(_rewardTo, farmerFee);\n        emit RewardProceedsTransferred(\n            baseTokenAddress,\n            _rewardTo,\n            protocolYield,\n            farmerFee\n        );\n    }\n\n    function _doSwap(\n        SwapPlatform swapPlatform,\n        address routerAddress,\n        address rewardTokenAddress,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        if (swapPlatform == SwapPlatform.UniswapV2Compatible) {\n            return\n                _swapWithUniswapV2(\n                    routerAddress,\n                    rewardTokenAddress,\n                    amountIn,\n                    minAmountOut\n                );\n        } else if (swapPlatform == SwapPlatform.UniswapV3) {\n            return\n                _swapWithUniswapV3(\n                    routerAddress,\n                    rewardTokenAddress,\n                    amountIn,\n                    minAmountOut\n                );\n        } else if (swapPlatform == SwapPlatform.Balancer) {\n            return\n                _swapWithBalancer(\n                    routerAddress,\n                    rewardTokenAddress,\n                    amountIn,\n                    minAmountOut\n                );\n        } else if (swapPlatform == SwapPlatform.Curve) {\n            return\n                _swapWithCurve(\n                    routerAddress,\n                    rewardTokenAddress,\n                    amountIn,\n                    minAmountOut\n                );\n        } else {\n            // Should never be invoked since we catch invalid values\n            // in the `setRewardTokenConfig` function before it's set\n            revert InvalidSwapPlatform(swapPlatform);\n        }\n    }\n\n    /**\n     * @dev Swaps the token to `baseToken` with Uniswap V2\n     *\n     * @param routerAddress Uniswap V2 Router address\n     * @param swapToken Address of the tokenIn\n     * @param amountIn Amount of `swapToken` to swap\n     * @param minAmountOut Minimum expected amount of `baseToken`\n     *\n     * @return amountOut Amount of `baseToken` received after the swap\n     */\n    function _swapWithUniswapV2(\n        address routerAddress,\n        address swapToken,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        address[] memory path = uniswapV2Path[swapToken];\n\n        uint256[] memory amounts = IUniswapV2Router(routerAddress)\n            .swapExactTokensForTokens(\n                amountIn,\n                minAmountOut,\n                path,\n                address(this),\n                block.timestamp\n            );\n\n        amountOut = amounts[amounts.length - 1];\n    }\n\n    /**\n     * @dev Swaps the token to `baseToken` with Uniswap V3\n     *\n     * @param routerAddress Uniswap V3 Router address\n     * @param swapToken Address of the tokenIn\n     * @param amountIn Amount of `swapToken` to swap\n     * @param minAmountOut Minimum expected amount of `baseToken`\n     *\n     * @return amountOut Amount of `baseToken` received after the swap\n     */\n    function _swapWithUniswapV3(\n        address routerAddress,\n        address swapToken,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        bytes memory path = uniswapV3Path[swapToken];\n\n        IUniswapV3Router.ExactInputParams memory params = IUniswapV3Router\n            .ExactInputParams({\n                path: path,\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountIn: amountIn,\n                amountOutMinimum: minAmountOut\n            });\n        amountOut = IUniswapV3Router(routerAddress).exactInput(params);\n    }\n\n    /**\n     * @dev Swaps the token to `baseToken` on Balancer\n     *\n     * @param balancerVaultAddress BalancerVaultAddress\n     * @param swapToken Address of the tokenIn\n     * @param amountIn Amount of `swapToken` to swap\n     * @param minAmountOut Minimum expected amount of `baseToken`\n     *\n     * @return amountOut Amount of `baseToken` received after the swap\n     */\n    function _swapWithBalancer(\n        address balancerVaultAddress,\n        address swapToken,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        bytes32 poolId = balancerPoolId[swapToken];\n\n        IBalancerVault.SingleSwap memory singleSwap = IBalancerVault\n            .SingleSwap({\n                poolId: poolId,\n                kind: IBalancerVault.SwapKind.GIVEN_IN,\n                assetIn: swapToken,\n                assetOut: baseTokenAddress,\n                amount: amountIn,\n                userData: hex\"\"\n            });\n\n        IBalancerVault.FundManagement memory fundMgmt = IBalancerVault\n            .FundManagement({\n                sender: address(this),\n                fromInternalBalance: false,\n                recipient: payable(address(this)),\n                toInternalBalance: false\n            });\n\n        amountOut = IBalancerVault(balancerVaultAddress).swap(\n            singleSwap,\n            fundMgmt,\n            minAmountOut,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Swaps the token to `baseToken` on Curve\n     *\n     * @param poolAddress Curve Pool Address\n     * @param swapToken Address of the tokenIn\n     * @param amountIn Amount of `swapToken` to swap\n     * @param minAmountOut Minimum expected amount of `baseToken`\n     *\n     * @return amountOut Amount of `baseToken` received after the swap\n     */\n    function _swapWithCurve(\n        address poolAddress,\n        address swapToken,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        CurvePoolIndices memory indices = curvePoolIndices[swapToken];\n\n        // Note: Not all CurvePools return the `amountOut`, make sure\n        // to use only pool that do. Otherwise the swap would revert\n        // always\n        amountOut = ICurvePool(poolAddress).exchange(\n            uint256(indices.rewardTokenIndex),\n            uint256(indices.baseTokenIndex),\n            amountIn,\n            minAmountOut\n        );\n    }\n}\n"
    },
    "contracts/harvest/Dripper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\n/**\n * @title OUSD Dripper\n *\n * The dripper contract smooths out the yield from point-in-time yield events\n * and spreads the yield out over a configurable time period. This ensures a\n * continuous per block yield to makes users happy as their next rebase\n * amount is always moving up. Also, this makes historical day to day yields\n * smooth, rather than going from a near zero day, to a large APY day, then\n * back to a near zero day again.\n *\n *\n * Design notes\n * - USDT has a smaller resolution than the number of seconds\n * in a week, which can make per second payouts have a rounding error. However\n * the total effect is not large - cents per day, and this money is\n * not lost, just distributed in the future. While we could use a higher\n * decimal precision for the drip perSecond, we chose simpler code.\n * - By calculating the changing drip rates on collects only, harvests and yield\n * events don't have to call anything on this contract or pay any extra gas.\n * Collect() is already be paying for a single write, since it has to reset\n * the lastCollect time.\n * - By having a collectAndRebase method, and having our external systems call\n * that, the OUSD vault does not need any changes, not even to know the address\n * of the dripper.\n * - A rejected design was to retro-calculate the drip rate on each collect,\n * based on the balance at the time of the collect. While this would have\n * required less state, and would also have made the contract respond more quickly\n * to new income, it would break the predictability that is this contract's entire\n * purpose. If we did this, the amount of fundsAvailable() would make sharp increases\n * when funds were deposited.\n * - When the dripper recalculates the rate, it targets spending the balance over\n * the duration. This means that every time that collect is called, if no\n * new funds have been deposited the duration is being pushed back and the\n * rate decreases. This is expected, and ends up following a smoother but\n * longer curve the more collect() is called without incoming yield.\n *\n */\n\ncontract Dripper is Governable {\n    using SafeERC20 for IERC20;\n\n    struct Drip {\n        uint64 lastCollect; // overflows 262 billion years after the sun dies\n        uint192 perSecond; // drip rate per second\n    }\n\n    address immutable vault; // OUSD vault\n    address immutable token; // token to drip out\n    uint256 public dripDuration; // in seconds\n    Drip public drip; // active drip parameters\n\n    constructor(address _vault, address _token) {\n        vault = _vault;\n        token = _token;\n    }\n\n    /// @notice How much funds have dripped out already and are currently\n    //   available to be sent to the vault.\n    /// @return The amount that would be sent if a collect was called\n    function availableFunds() external view returns (uint256) {\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        return _availableFunds(balance, drip);\n    }\n\n    /// @notice Collect all dripped funds and send to vault.\n    ///  Recalculate new drip rate.\n    function collect() external {\n        _collect();\n    }\n\n    /// @notice Collect all dripped funds, send to vault, recalculate new drip\n    ///  rate, and rebase OUSD.\n    function collectAndRebase() external {\n        _collect();\n        IVault(vault).rebase();\n    }\n\n    /// @dev Change the drip duration. Governor only.\n    /// @param _durationSeconds the number of seconds to drip out the entire\n    ///  balance over if no collects were called during that time.\n    function setDripDuration(uint256 _durationSeconds)\n        external\n        virtual\n        onlyGovernor\n    {\n        require(_durationSeconds > 0, \"duration must be non-zero\");\n        dripDuration = _durationSeconds;\n        _collect(); // duration change take immediate effect\n    }\n\n    /// @dev Transfer out ERC20 tokens held by the contract. Governor only.\n    /// @param _asset ERC20 token address\n    /// @param _amount amount to transfer\n    function transferToken(address _asset, uint256 _amount)\n        external\n        onlyGovernor\n    {\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /// @dev Calculate available funds by taking the lower of either the\n    ///  currently dripped out funds or the balance available.\n    ///  Uses passed in parameters to calculate with for gas savings.\n    /// @param _balance current balance in contract\n    /// @param _drip current drip parameters\n    function _availableFunds(uint256 _balance, Drip memory _drip)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 elapsed = block.timestamp - _drip.lastCollect;\n        uint256 allowed = (elapsed * _drip.perSecond);\n        return (allowed > _balance) ? _balance : allowed;\n    }\n\n    /// @dev Sends the currently dripped funds to be vault, and sets\n    ///  the new drip rate based on the new balance.\n    function _collect() internal virtual {\n        // Calculate send\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        uint256 amountToSend = _availableFunds(balance, drip);\n        uint256 remaining = balance - amountToSend;\n        // Calculate new drip perSecond\n        //   Gas savings by setting entire struct at one time\n        drip = Drip({\n            perSecond: uint192(remaining / dripDuration),\n            lastCollect: uint64(block.timestamp)\n        });\n        // Send funds\n        IERC20(token).safeTransfer(vault, amountToSend);\n    }\n\n    /// @dev Transfer out all ERC20 held by the contract. Governor only.\n    /// @param _asset ERC20 token address\n    function transferAllToken(address _asset, address _receiver)\n        external\n        onlyGovernor\n    {\n        IERC20(_asset).safeTransfer(\n            _receiver,\n            IERC20(_asset).balanceOf(address(this))\n        );\n    }\n}\n"
    },
    "contracts/harvest/FixedRateDripper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { Dripper } from \"./Dripper.sol\";\n\n/**\n * @title Fixed Rate Dripper\n *\n * Similar to the Dripper, Fixed Rate Dripper drips out yield per second.\n * However the Strategist decides the rate and it doesn't change after\n * a drip.\n *\n */\n\ncontract FixedRateDripper is Dripper {\n    using SafeERC20 for IERC20;\n\n    event DripRateUpdated(uint192 oldDripRate, uint192 newDripRate);\n\n    /**\n     * @dev Verifies that the caller is the Governor or Strategist.\n     */\n    modifier onlyGovernorOrStrategist() {\n        require(\n            isGovernor() || msg.sender == IVault(vault).strategistAddr(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    constructor(address _vault, address _token) Dripper(_vault, _token) {}\n\n    /// @inheritdoc Dripper\n    function setDripDuration(uint256) external virtual override {\n        // Not used in FixedRateDripper\n        revert(\"Drip duration disabled\");\n    }\n\n    /// @inheritdoc Dripper\n    function _collect() internal virtual override {\n        // Calculate amount to send\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        uint256 amountToSend = _availableFunds(balance, drip);\n\n        // Update timestamp\n        drip.lastCollect = uint64(block.timestamp);\n\n        // Send funds\n        IERC20(token).safeTransfer(vault, amountToSend);\n    }\n\n    /**\n     * @dev Sets the drip rate. Callable by Strategist or Governor.\n     *      Can be set to zero to stop dripper.\n     * @param _perSecond Rate of WETH to drip per second\n     */\n    function setDripRate(uint192 _perSecond) external onlyGovernorOrStrategist {\n        emit DripRateUpdated(_perSecond, drip.perSecond);\n\n        /**\n         * Note: It's important to call `_collect` before updating\n         * the drip rate especially on a new proxy contract.\n         * When `lastCollect` is not set/initialized, the elapsed\n         * time would be calculated as `block.number` seconds,\n         * resulting in a huge yield, if `collect` isn't called first.\n         */\n        // Collect at existing rate\n        _collect();\n\n        // Update rate\n        drip.perSecond = _perSecond;\n    }\n}\n"
    },
    "contracts/harvest/Harvester.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractHarvester } from \"./AbstractHarvester.sol\";\n\ncontract Harvester is AbstractHarvester {\n    constructor(address _vault, address _usdtAddress)\n        AbstractHarvester(_vault, _usdtAddress)\n    {}\n}\n"
    },
    "contracts/harvest/OETHBaseHarvester.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Governable } from \"../governance/Governable.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\nimport { ISwapRouter } from \"../interfaces/aerodrome/ISwapRouter.sol\";\n\ncontract OETHBaseHarvester is Governable {\n    using SafeERC20 for IERC20;\n\n    IVault public immutable vault;\n    IStrategy public immutable amoStrategy;\n    IERC20 public immutable aero;\n    IERC20 public immutable weth;\n    ISwapRouter public immutable swapRouter;\n\n    address public operatorAddr;\n\n    // Similar sig to `AbstractHarvester.RewardTokenSwapped` for\n    // future compatibility with monitoring\n    event RewardTokenSwapped(\n        address indexed rewardToken,\n        address indexed swappedInto,\n        uint8 swapPlatform,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    event OperatorChanged(address oldOperator, address newOperator);\n    event YieldSent(address recipient, uint256 yield, uint256 fee);\n\n    /**\n     * @notice Verifies that the caller is either Governor or Strategist.\n     */\n    modifier onlyGovernorOrStrategist() {\n        require(\n            msg.sender == vault.strategistAddr() || isGovernor(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Verifies that the caller is either Governor or Strategist.\n     */\n    modifier onlyGovernorOrStrategistOrOperator() {\n        require(\n            msg.sender == operatorAddr ||\n                msg.sender == vault.strategistAddr() ||\n                isGovernor(),\n            \"Caller is not the Operator or Strategist or Governor\"\n        );\n        _;\n    }\n\n    constructor(\n        address _vault,\n        address _amoStrategy,\n        address _aero,\n        address _weth,\n        address _swapRouter\n    ) {\n        vault = IVault(_vault);\n        amoStrategy = IStrategy(_amoStrategy);\n        aero = IERC20(_aero);\n        weth = IERC20(_weth);\n        swapRouter = ISwapRouter(_swapRouter);\n    }\n\n    /**\n     * @dev Changes the operator address which can call `harvest`\n     * @param _operatorAddr New operator address\n     */\n    function setOperatorAddr(address _operatorAddr) external onlyGovernor {\n        emit OperatorChanged(operatorAddr, _operatorAddr);\n        operatorAddr = _operatorAddr;\n    }\n\n    /**\n     * @notice Collects AERO from AMO strategy and\n     *      sends it to the Strategist multisig.\n     *      Anyone can call it.\n     */\n    function harvest() external onlyGovernorOrStrategistOrOperator {\n        address strategistAddr = vault.strategistAddr();\n        require(strategistAddr != address(0), \"Guardian address not set\");\n\n        // Collect all AERO\n        amoStrategy.collectRewardTokens();\n\n        uint256 aeroBalance = aero.balanceOf(address(this));\n        if (aeroBalance == 0) {\n            // Do nothing if there's no AERO to transfer\n            return;\n        }\n\n        // Transfer everything to Strategist\n        aero.safeTransfer(strategistAddr, aeroBalance);\n    }\n\n    /**\n     * @notice Harvests AERO from AMO strategy and then swaps some (or all)\n     *          of it into WETH to distribute yield and fee.\n     *         When `feeBps` is set to 10000 (100%), all WETH received is\n     *          sent to strategist.\n     *\n     * @param aeroToSwap Amount of AERO to swap\n     * @param minWETHExpected Min. amount of WETH to expect\n     * @param feeBps Performance fee bps (Sent to strategist)\n     * @param sendYieldToDripper Sends yield to Dripper, if set to true.\n     *                           Otherwise, to the Guardian\n     */\n    function harvestAndSwap(\n        uint256 aeroToSwap,\n        uint256 minWETHExpected,\n        uint256 feeBps,\n        bool sendYieldToDripper\n    ) external onlyGovernorOrStrategist {\n        address strategistAddr = vault.strategistAddr();\n        require(strategistAddr != address(0), \"Guardian address not set\");\n\n        // Yields can either be sent to the Dripper or Strategist\n        address yieldRecipient = sendYieldToDripper\n            ? vault.dripper()\n            : strategistAddr;\n        require(yieldRecipient != address(0), \"Yield recipient not set\");\n\n        require(feeBps <= 10000, \"Invalid Fee Bps\");\n\n        // Collect all AERO\n        amoStrategy.collectRewardTokens();\n\n        uint256 aeroBalance = aero.balanceOf(address(this));\n        if (aeroBalance == 0) {\n            // Do nothing if there's no AERO to transfer/swap\n            return;\n        }\n\n        if (aeroToSwap > 0) {\n            if (aeroBalance < aeroToSwap) {\n                // Transfer in balance from the multisig as needed\n                // slither-disable-next-line unchecked-transfer arbitrary-send-erc20\n                aero.safeTransferFrom(\n                    strategistAddr,\n                    address(this),\n                    aeroToSwap - aeroBalance\n                );\n            }\n\n            _doSwap(aeroToSwap, minWETHExpected);\n\n            // Figure out AERO left in contract after swap\n            aeroBalance = aero.balanceOf(address(this));\n        }\n\n        // Transfer out any leftover AERO after swap\n        if (aeroBalance > 0) {\n            aero.safeTransfer(strategistAddr, aeroBalance);\n        }\n\n        // Computes using all balance the contract holds,\n        // not just the WETH received from swap. Use `transferToken`\n        // if there's any WETH left that needs to be taken out\n        uint256 availableWETHBalance = weth.balanceOf(address(this));\n        // Computation rounds in favor of protocol\n        uint256 fee = (availableWETHBalance * feeBps) / 10000;\n        uint256 yield = availableWETHBalance - fee;\n\n        // Transfer yield, if any\n        if (yield > 0) {\n            weth.safeTransfer(yieldRecipient, yield);\n        }\n\n        // Transfer fee to the Guardian, if any\n        if (fee > 0) {\n            weth.safeTransfer(strategistAddr, fee);\n        }\n\n        emit YieldSent(yieldRecipient, yield, fee);\n    }\n\n    /**\n     * @notice Swaps AERO to WETH on Aerodrome\n     * @param aeroToSwap Amount of AERO to swap\n     * @param minWETHExpected Min. amount of WETH to expect\n     */\n    function _doSwap(uint256 aeroToSwap, uint256 minWETHExpected) internal {\n        // Let the swap router move funds\n        aero.approve(address(swapRouter), aeroToSwap);\n\n        // Do the swap\n        uint256 wethReceived = swapRouter.exactInputSingle(\n            ISwapRouter.ExactInputSingleParams({\n                tokenIn: address(aero),\n                tokenOut: address(weth),\n                tickSpacing: 200, // From AERO/WETH pool contract\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountIn: aeroToSwap,\n                amountOutMinimum: minWETHExpected,\n                sqrtPriceLimitX96: 0\n            })\n        );\n\n        emit RewardTokenSwapped(\n            address(aero),\n            address(weth),\n            0,\n            aeroToSwap,\n            wethReceived\n        );\n    }\n\n    /**\n     * @notice Transfer token to governor. Intended for recovering tokens stuck in\n     *      the contract, i.e. mistaken sends.\n     *      Also, allows to transfer any AERO left in the contract.\n     * @param _asset Address for the asset\n     * @param _amount Amount of the asset to transfer\n     */\n    function transferToken(address _asset, uint256 _amount)\n        external\n        virtual\n        onlyGovernor\n    {\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n}\n"
    },
    "contracts/harvest/OETHDripper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Dripper } from \"./Dripper.sol\";\n\n/**\n * @title OETH Dripper Contract\n * @author Origin Protocol Inc\n */\ncontract OETHDripper is Dripper {\n    constructor(address _vault, address _token) Dripper(_vault, _token) {}\n}\n"
    },
    "contracts/harvest/OETHFixedRateDripper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { FixedRateDripper } from \"./FixedRateDripper.sol\";\n\n/**\n * @title OETH FixedRateDripper Contract\n * @author Origin Protocol Inc\n */\ncontract OETHFixedRateDripper is FixedRateDripper {\n    constructor(address _vault, address _token)\n        FixedRateDripper(_vault, _token)\n    {}\n}\n"
    },
    "contracts/harvest/OETHHarvester.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractHarvester } from \"./AbstractHarvester.sol\";\n\ncontract OETHHarvester is AbstractHarvester {\n    constructor(address _vault, address _wethAddress)\n        AbstractHarvester(_vault, _wethAddress)\n    {}\n}\n"
    },
    "contracts/harvest/OETHHarvesterSimple.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Strategizable } from \"../governance/Strategizable.sol\";\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Initializable } from \"../utils/Initializable.sol\";\n\n/// @title OETH Harvester Simple Contract\n/// @notice Contract to harvest rewards from strategies\n/// @author Origin Protocol Inc\ncontract OETHHarvesterSimple is Initializable, Strategizable {\n    using SafeERC20 for IERC20;\n\n    ////////////////////////////////////////////////////\n    /// --- CONSTANTS & IMMUTABLES\n    ////////////////////////////////////////////////////\n    /// @notice wrapped native token address (WETH or wS)\n    address public immutable wrappedNativeToken;\n\n    ////////////////////////////////////////////////////\n    /// --- STORAGE\n    ////////////////////////////////////////////////////\n    /// @notice Dripper address\n    address public dripper;\n\n    /// @notice Mapping of supported strategies\n    mapping(address => bool) public supportedStrategies;\n\n    /// @notice Gap for upgrade safety\n    uint256[48] private ___gap;\n\n    ////////////////////////////////////////////////////\n    /// --- EVENTS\n    ////////////////////////////////////////////////////\n    event Harvested(\n        address indexed strategy,\n        address token,\n        uint256 amount,\n        address indexed receiver\n    );\n    event SupportedStrategyUpdated(address strategy, bool status);\n    event DripperUpdated(address dripper);\n\n    ////////////////////////////////////////////////////\n    /// --- CONSTRUCTOR\n    ////////////////////////////////////////////////////\n    constructor(address _wrappedNativeToken) {\n        wrappedNativeToken = _wrappedNativeToken;\n\n        // prevent implementation contract to be governed\n        _setGovernor(address(0));\n    }\n\n    /// @notice Initialize the contract\n    function initialize() external onlyGovernor initializer {\n        // Call it to set `initialized` to true and to prevent the implementation\n        // from getting initialized in future through the proxy\n    }\n\n    ////////////////////////////////////////////////////\n    /// --- MUTATIVE FUNCTIONS\n    ////////////////////////////////////////////////////\n    /// @notice Harvest rewards from a strategy and transfer to strategist or dripper\n    /// @param _strategy Address of the strategy to harvest\n    function harvestAndTransfer(address _strategy) external {\n        _harvestAndTransfer(_strategy);\n    }\n\n    /// @notice Harvest rewards from multiple strategies and transfer to strategist or dripper\n    /// @param _strategies Array of strategy addresses to harvest\n    function harvestAndTransfer(address[] calldata _strategies) external {\n        for (uint256 i = 0; i < _strategies.length; i++) {\n            _harvestAndTransfer(_strategies[i]);\n        }\n    }\n\n    /// @notice Internal logic to harvest rewards from a strategy\n    function _harvestAndTransfer(address _strategy) internal virtual {\n        // Ensure strategy is supported\n        require(supportedStrategies[_strategy], \"Strategy not supported\");\n\n        // Store locally for some gas savings\n        address _strategist = strategistAddr;\n        address _dripper = dripper;\n\n        // Harvest rewards\n        IStrategy(_strategy).collectRewardTokens();\n\n        // Cache reward tokens\n        address[] memory rewardTokens = IStrategy(_strategy)\n            .getRewardTokenAddresses();\n\n        uint256 len = rewardTokens.length;\n        for (uint256 i = 0; i < len; i++) {\n            // Cache balance\n            address token = rewardTokens[i];\n            uint256 balance = IERC20(token).balanceOf(address(this));\n            if (balance > 0) {\n                // Determine receiver\n                address receiver = token == wrappedNativeToken\n                    ? _dripper\n                    : _strategist;\n                require(receiver != address(0), \"Invalid receiver\");\n\n                // Transfer to the Strategist or the Dripper\n                IERC20(token).safeTransfer(receiver, balance);\n                emit Harvested(_strategy, token, balance, receiver);\n            }\n        }\n    }\n\n    ////////////////////////////////////////////////////\n    /// --- GOVERNANCE\n    ////////////////////////////////////////////////////\n    /// @notice Set supported strategy\n    /// @param _strategy Address of the strategy\n    /// @param _isSupported Boolean indicating if strategy is supported\n    function setSupportedStrategy(address _strategy, bool _isSupported)\n        external\n        onlyGovernorOrStrategist\n    {\n        require(_strategy != address(0), \"Invalid strategy\");\n        supportedStrategies[_strategy] = _isSupported;\n        emit SupportedStrategyUpdated(_strategy, _isSupported);\n    }\n\n    /// @notice Transfer tokens to strategist\n    /// @param _asset Address of the token\n    /// @param _amount Amount of tokens to transfer\n    function transferToken(address _asset, uint256 _amount)\n        external\n        onlyGovernorOrStrategist\n    {\n        IERC20(_asset).safeTransfer(strategistAddr, _amount);\n    }\n\n    /// @notice Set the dripper address\n    /// @param _dripper Address of the dripper\n    function setDripper(address _dripper) external onlyGovernor {\n        _setDripper(_dripper);\n    }\n\n    /// @notice Internal logic to set the dripper address\n    function _setDripper(address _dripper) internal {\n        require(_dripper != address(0), \"Invalid dripper\");\n        dripper = _dripper;\n        emit DripperUpdated(_dripper);\n    }\n}\n"
    },
    "contracts/harvest/OSonicHarvester.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { SuperOETHHarvester } from \"./SuperOETHHarvester.sol\";\n\ncontract OSonicHarvester is SuperOETHHarvester {\n    /// @param _wrappedNativeToken Address of the native Wrapped S (wS) token\n    constructor(address _wrappedNativeToken)\n        SuperOETHHarvester(_wrappedNativeToken)\n    {}\n}\n"
    },
    "contracts/harvest/SuperOETHHarvester.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { OETHHarvesterSimple, IERC20, IStrategy, SafeERC20 } from \"./OETHHarvesterSimple.sol\";\n\ncontract SuperOETHHarvester is OETHHarvesterSimple {\n    using SafeERC20 for IERC20;\n\n    constructor(address _wrappedNativeToken)\n        OETHHarvesterSimple(_wrappedNativeToken)\n    {}\n\n    /// @inheritdoc OETHHarvesterSimple\n    function _harvestAndTransfer(address _strategy) internal virtual override {\n        // Ensure strategy is supported\n        require(supportedStrategies[_strategy], \"Strategy not supported\");\n\n        address receiver = strategistAddr;\n        require(receiver != address(0), \"Invalid receiver\");\n\n        // Harvest rewards\n        IStrategy(_strategy).collectRewardTokens();\n\n        // Cache reward tokens\n        address[] memory rewardTokens = IStrategy(_strategy)\n            .getRewardTokenAddresses();\n\n        uint256 len = rewardTokens.length;\n        for (uint256 i = 0; i < len; i++) {\n            // Cache balance\n            address token = rewardTokens[i];\n            uint256 balance = IERC20(token).balanceOf(address(this));\n            if (balance > 0) {\n                // Transfer everything to the strategist\n                IERC20(token).safeTransfer(receiver, balance);\n                emit Harvested(_strategy, token, balance, receiver);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/aerodrome/IAMOStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ICLPool } from \"./ICLPool.sol\";\n\ninterface IAMOStrategy {\n    error NotEnoughWethForSwap(uint256 wethBalance, uint256 requiredWeth);\n    error NotEnoughWethLiquidity(uint256 wethBalance, uint256 requiredWeth);\n    error PoolRebalanceOutOfBounds(\n        uint256 currentPoolWethShare,\n        uint256 allowedWethShareStart,\n        uint256 allowedWethShareEnd\n    );\n    error OutsideExpectedTickRange(int24 currentTick);\n\n    function governor() external view returns (address);\n\n    function rebalance(\n        uint256 _amountToSwap,\n        bool _swapWeth,\n        uint256 _minTokenReceived\n    ) external;\n\n    function clPool() external view returns (ICLPool);\n\n    function vaultAddress() external view returns (address);\n\n    function poolWethShareVarianceAllowed() external view returns (uint256);\n\n    function poolWethShare() external view returns (uint256);\n\n    function tokenId() external view returns (uint256);\n\n    function withdrawAll() external;\n\n    function setAllowedPoolWethShareInterval(\n        uint256 _allowedWethShareStart,\n        uint256 _allowedWethShareEnd\n    ) external;\n\n    function setWithdrawLiquidityShare(uint128 share) external;\n\n    function lowerTick() external view returns (int24);\n\n    function upperTick() external view returns (int24);\n\n    function getPoolX96Price() external view returns (uint160 _sqrtRatioX96);\n\n    function sqrtRatioX96TickLower() external view returns (uint160);\n\n    function sqrtRatioX96TickHigher() external view returns (uint160);\n\n    function tickSpacing() external view returns (int24);\n\n    function allowedWethShareStart() external view returns (uint256);\n\n    function allowedWethShareEnd() external view returns (uint256);\n\n    function claimGovernance() external;\n\n    function transferGovernance(address _governor) external;\n\n    function getPositionPrincipal()\n        external\n        view\n        returns (uint256 _amountWeth, uint256 _amountOethb);\n}\n"
    },
    "contracts/interfaces/aerodrome/ICLGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface ICLGauge {\n    /// @notice Returns the claimable rewards for a given account and tokenId\n    /// @dev Throws if account is not the position owner\n    /// @dev pool.updateRewardsGrowthGlobal() needs to be called first, to return the correct claimable rewards\n    /// @param account The address of the user\n    /// @param tokenId The tokenId of the position\n    /// @return The amount of claimable reward\n    function earned(address account, uint256 tokenId)\n        external\n        view\n        returns (uint256);\n\n    /// @notice Retrieve rewards for all tokens owned by an account\n    /// @dev Throws if not called by the voter\n    /// @param account The account of the user\n    function getReward(address account) external;\n\n    /// @notice Retrieve rewards for a tokenId\n    /// @dev Throws if not called by the position owner\n    /// @param tokenId The tokenId of the position\n    function getReward(uint256 tokenId) external;\n\n    /// @notice Notifies gauge of gauge rewards.\n    /// @param amount Amount of gauge rewards (emissions) to notify. Must be greater than 604_800.\n    function notifyRewardAmount(uint256 amount) external;\n\n    /// @dev Notifies gauge of gauge rewards without distributing its fees.\n    ///      Assumes gauge reward tokens is 18 decimals.\n    ///      If not 18 decimals, rewardRate may have rounding issues.\n    /// @param amount Amount of gauge rewards (emissions) to notify. Must be greater than 604_800.\n    function notifyRewardWithoutClaim(uint256 amount) external;\n\n    /// @notice Used to deposit a CL position into the gauge\n    /// @notice Allows the user to receive emissions instead of fees\n    /// @param tokenId The tokenId of the position\n    function deposit(uint256 tokenId) external;\n\n    /// @notice Used to withdraw a CL position from the gauge\n    /// @notice Allows the user to receive fees instead of emissions\n    /// @notice Outstanding emissions will be collected on withdrawal\n    /// @param tokenId The tokenId of the position\n    function withdraw(uint256 tokenId) external;\n\n    // /// @notice Fetch all tokenIds staked by a given account\n    // /// @param depositor The address of the user\n    // /// @return The tokenIds of the staked positions\n    // function stakedValues(address depositor) external view returns (uint256[] memory);\n\n    // /// @notice Fetch a staked tokenId by index\n    // /// @param depositor The address of the user\n    // /// @param index The index of the staked tokenId\n    // /// @return The tokenId of the staked position\n    // function stakedByIndex(address depositor, uint256 index) external view returns (uint256);\n\n    // /// @notice Check whether a position is staked in the gauge by a certain user\n    // /// @param depositor The address of the user\n    // /// @param tokenId The tokenId of the position\n    // /// @return Whether the position is staked in the gauge\n    // function stakedContains(address depositor, uint256 tokenId) external view returns (bool);\n\n    // /// @notice The amount of positions staked in the gauge by a certain user\n    // /// @param depositor The address of the user\n    // /// @return The amount of positions staked in the gauge\n    // function stakedLength(address depositor) external view returns (uint256);\n\n    function feesVotingReward() external view returns (address);\n}\n"
    },
    "contracts/interfaces/aerodrome/ICLPool.sol": {
      "content": "pragma solidity >=0.5.0;\n\n/// @title The interface for a CL Pool\n/// @notice A CL pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface ICLPool {\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            bool unlocked\n        );\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The gauge corresponding to this pool\n    /// @return The gauge contract address\n    function gauge() external view returns (address);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    /// @dev This value includes staked liquidity\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from\n    /// the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise\n    /// equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n}\n"
    },
    "contracts/interfaces/aerodrome/INonfungiblePositionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Non-fungible token for positions\n/// @notice Wraps CL positions in a non-fungible token interface which allows for them to be transferred\n/// and authorized.\n// slither-disable-start erc20-interface\ninterface INonfungiblePositionManager {\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) external returns (address);\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    /// @notice Returns the position information associated with a given token ID.\n    /// @dev Throws if the token ID is not valid.\n    /// @param tokenId The ID of the token that represents the position\n    /// @return nonce The nonce for permits\n    /// @return operator The address that is approved for spending\n    /// @return token0 The address of the token0 for a specific pool\n    /// @return token1 The address of the token1 for a specific pool\n    /// @return tickSpacing The tick spacing associated with the pool\n    /// @return tickLower The lower end of the tick range for the position\n    /// @return tickUpper The higher end of the tick range for the position\n    /// @return liquidity The liquidity of the position\n    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\n    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\n    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\n    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            int24 tickSpacing,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    struct MintParams {\n        address token0;\n        address token1;\n        int24 tickSpacing;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n        uint160 sqrtPriceX96;\n    }\n\n    /// @notice Creates a new position wrapped in a NFT\n    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\n    /// a method does not exist, i.e. the pool is assumed to be initialized.\n    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\n    /// @return tokenId The ID of the token that represents the minted position\n    /// @return liquidity The amount of liquidity for this position\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function mint(MintParams calldata params)\n        external\n        payable\n        returns (\n            uint256 tokenId,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\n    /// @param params tokenId The ID of the token for which liquidity is being increased,\n    /// amount0Desired The desired amount of token0 to be spent,\n    /// amount1Desired The desired amount of token1 to be spent,\n    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\n    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return liquidity The new liquidity amount as a result of the increase\n    /// @return amount0 The amount of token0 to acheive resulting liquidity\n    /// @return amount1 The amount of token1 to acheive resulting liquidity\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Decreases the amount of liquidity in a position and accounts it to the position\n    /// @param params tokenId The ID of the token for which liquidity is being decreased,\n    /// amount The amount by which liquidity will be decreased,\n    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\n    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return amount0 The amount of token0 accounted to the position's tokens owed\n    /// @return amount1 The amount of token1 accounted to the position's tokens owed\n    /// @dev The use of this function can cause a loss to users of the NonfungiblePositionManager\n    /// @dev for tokens that have very high decimals.\n    /// @dev The amount of tokens necessary for the loss is: 3.4028237e+38.\n    /// @dev This is equivalent to 1e20 value with 18 decimals.\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\n    /// @notice Used to update staked positions before deposit and withdraw\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\n    /// recipient The account that should receive the tokens,\n    /// amount0Max The maximum amount of token0 to collect,\n    /// amount1Max The maximum amount of token1 to collect\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(CollectParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\n    /// must be collected first.\n    /// @param tokenId The ID of the token that is being burned\n    function burn(uint256 tokenId) external payable;\n\n    /// @notice Sets a new Token Descriptor\n    /// @param _tokenDescriptor Address of the new Token Descriptor to be chosen\n    function setTokenDescriptor(address _tokenDescriptor) external;\n\n    /// @notice Sets a new Owner address\n    /// @param _owner Address of the new Owner to be chosen\n    function setOwner(address _owner) external;\n}\n// slither-disable-end erc20-interface\n"
    },
    "contracts/interfaces/aerodrome/IQuoterV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title QuoterV2 Interface\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps.\n/// @notice For each pool also tells you the number of initialized ticks crossed and the sqrt price of the\n///         pool after the swap.\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\ninterface IQuoterV2 {\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool tick spacing\n    /// @param amountIn The amount of the first token to swap\n    /// @return amountOut The amount of the last token that would be received\n    /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\n    /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for\n    ///         each pool in the path\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactInput(bytes memory path, uint256 amountIn)\n        external\n        returns (\n            uint256 amountOut,\n            uint160[] memory sqrtPriceX96AfterList,\n            uint32[] memory initializedTicksCrossedList,\n            uint256 gasEstimate\n        );\n\n    struct QuoteExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        int24 tickSpacing;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n    /// @param params The params for the quote, encoded as `QuoteExactInputSingleParams`\n    /// tokenIn The token being swapped in\n    /// tokenOut The token being swapped out\n    /// tickSpacing The tick spacing of the token pool to consider for the pair\n    /// amountIn The desired input amount\n    /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountOut The amount of `tokenOut` that would be received\n    /// @return sqrtPriceX96After The sqrt price of the pool after the swap\n    /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactInputSingle(QuoteExactInputSingleParams memory params)\n        external\n        returns (\n            uint256 amountOut,\n            uint160 sqrtPriceX96After,\n            uint32 initializedTicksCrossed,\n            uint256 gasEstimate\n        );\n\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool tick spacing.\n    ///        Path must be provided in reverse order\n    /// @param amountOut The amount of the last token to receive\n    /// @return amountIn The amount of first token required to be paid\n    /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\n    /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for\n    ///         each pool in the path\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactOutput(bytes memory path, uint256 amountOut)\n        external\n        returns (\n            uint256 amountIn,\n            uint160[] memory sqrtPriceX96AfterList,\n            uint32[] memory initializedTicksCrossedList,\n            uint256 gasEstimate\n        );\n\n    struct QuoteExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amount;\n        int24 tickSpacing;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\n    /// @param params The params for the quote, encoded as `QuoteExactOutputSingleParams`\n    /// tokenIn The token being swapped in\n    /// tokenOut The token being swapped out\n    /// tickSpacing The tick spacing of the token pool to consider for the pair\n    /// amountOut The desired output amount\n    /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\n    /// @return sqrtPriceX96After The sqrt price of the pool after the swap\n    /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactOutputSingle(QuoteExactOutputSingleParams memory params)\n        external\n        returns (\n            uint256 amountIn,\n            uint160 sqrtPriceX96After,\n            uint32 initializedTicksCrossed,\n            uint256 gasEstimate\n        );\n}\n"
    },
    "contracts/interfaces/aerodrome/ISugarHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\npragma abicoder v2;\n\nimport { INonfungiblePositionManager } from \"./INonfungiblePositionManager.sol\";\n\ninterface ISugarHelper {\n    struct PopulatedTick {\n        int24 tick;\n        uint160 sqrtRatioX96;\n        int128 liquidityNet;\n        uint128 liquidityGross;\n    }\n\n    ///\n    /// Wrappers for LiquidityAmounts\n    ///\n\n    function getAmountsForLiquidity(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) external pure returns (uint256 amount0, uint256 amount1);\n\n    function getLiquidityForAmounts(\n        uint256 amount0,\n        uint256 amount1,\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96\n    ) external pure returns (uint128 liquidity);\n\n    /// @notice Computes the amount of token0 for a given amount of token1 and price range\n    /// @param amount1 Amount of token1 to estimate liquidity\n    /// @param pool Address of the pool to be used\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param tickLow Lower tick boundary\n    /// @param tickLow Upper tick boundary\n    /// @dev   If the given pool address is not the zero address, will fetch `sqrtRatioX96` from pool\n    /// @return amount0 Estimated amount of token0\n    function estimateAmount0(\n        uint256 amount1,\n        address pool,\n        uint160 sqrtRatioX96,\n        int24 tickLow,\n        int24 tickHigh\n    ) external view returns (uint256 amount0);\n\n    /// @notice Computes the amount of token1 for a given amount of token0 and price range\n    /// @param amount0 Amount of token0 to estimate liquidity\n    /// @param pool Address of the pool to be used\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param tickLow Lower tick boundary\n    /// @param tickLow Upper tick boundary\n    /// @dev   If the given pool address is not the zero address, will fetch `sqrtRatioX96` from pool\n    /// @return amount1 Estimated amount of token1\n    function estimateAmount1(\n        uint256 amount0,\n        address pool,\n        uint160 sqrtRatioX96,\n        int24 tickLow,\n        int24 tickHigh\n    ) external view returns (uint256 amount1);\n\n    ///\n    /// Wrappers for PositionValue\n    ///\n\n    function principal(\n        INonfungiblePositionManager positionManager,\n        uint256 tokenId,\n        uint160 sqrtRatioX96\n    ) external view returns (uint256 amount0, uint256 amount1);\n\n    function fees(INonfungiblePositionManager positionManager, uint256 tokenId)\n        external\n        view\n        returns (uint256 amount0, uint256 amount1);\n\n    ///\n    /// Wrappers for TickMath\n    ///\n\n    function getSqrtRatioAtTick(int24 tick)\n        external\n        pure\n        returns (uint160 sqrtRatioX96);\n\n    function getTickAtSqrtRatio(uint160 sqrtRatioX96)\n        external\n        pure\n        returns (int24 tick);\n\n    /// @notice Fetches Tick Data for all populated Ticks in given bitmaps\n    /// @param pool Address of the pool from which to fetch data\n    /// @param startTick Tick from which the first bitmap will be fetched\n    /// @dev   The number of bitmaps fetched by this function should always be `MAX_BITMAPS`,\n    ///        unless there are less than `MAX_BITMAPS` left to iterate through\n    /// @return populatedTicks Array of all Populated Ticks in the provided bitmaps\n    function getPopulatedTicks(address pool, int24 startTick)\n        external\n        view\n        returns (PopulatedTick[] memory populatedTicks);\n}\n"
    },
    "contracts/interfaces/aerodrome/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via CL\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        int24 tickSpacing;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        int24 tickSpacing;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params)\n        external\n        payable\n        returns (uint256 amountIn);\n}\n"
    },
    "contracts/interfaces/balancer/IBalancerVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"../../utils/InitializableAbstractStrategy.sol\";\n\ninterface IBalancerVault {\n    enum WeightedPoolJoinKind {\n        INIT,\n        EXACT_TOKENS_IN_FOR_BPT_OUT,\n        TOKEN_IN_FOR_EXACT_BPT_OUT,\n        ALL_TOKENS_IN_FOR_EXACT_BPT_OUT,\n        ADD_TOKEN\n    }\n\n    enum WeightedPoolExitKind {\n        EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n        EXACT_BPT_IN_FOR_TOKENS_OUT,\n        BPT_IN_FOR_EXACT_TOKENS_OUT,\n        REMOVE_TOKEN\n    }\n\n    /**\n     * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\n     * Pool shares.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\n     * these maximums.\n     *\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\n     * back to the caller (not the sender, which is important for relayers).\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\n     *\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\n     *\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\n     * directly to the Pool's contract, as is `recipient`.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n\n    struct JoinPoolRequest {\n        address[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n\n    /**\n     * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\n     * `getPoolTokenInfo`).\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\n     * it just enforces these minimums.\n     *\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\n     *\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\n     * do so will trigger a revert.\n     *\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\n     * `tokens` array. This array must match the Pool's registered tokens.\n     *\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\n     * passed directly to the Pool's contract.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external;\n\n    struct ExitPoolRequest {\n        address[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n\n    /**\n     * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\n     * the tokens' `balances` changed.\n     *\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\n     *\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\n     * order as passed to `registerTokens`.\n     *\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\n     * instead.\n     */\n    function getPoolTokens(bytes32 poolId)\n        external\n        view\n        returns (\n            IERC20[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangeBlock\n        );\n\n    /**\n     * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\n     * it lets integrators reuse a user's Vault allowance.\n     *\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\n     */\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable;\n\n    struct UserBalanceOp {\n        UserBalanceOpKind kind;\n        address asset;\n        uint256 amount;\n        address sender;\n        address payable recipient;\n    }\n\n    enum UserBalanceOpKind {\n        DEPOSIT_INTERNAL,\n        WITHDRAW_INTERNAL,\n        TRANSFER_INTERNAL,\n        TRANSFER_EXTERNAL\n    }\n\n    enum SwapKind {\n        GIVEN_IN,\n        GIVEN_OUT\n    }\n\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        address assetIn;\n        address assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n\n    function swap(\n        SingleSwap calldata singleSwap,\n        FundManagement calldata funds,\n        uint256 limit,\n        uint256 deadline\n    ) external returns (uint256 amountCalculated);\n\n    function getPoolTokenInfo(bytes32 poolId, address token)\n        external\n        view\n        returns (\n            uint256 cash,\n            uint256 managed,\n            uint256 lastChangeBlock,\n            address assetManager\n        );\n}\n"
    },
    "contracts/interfaces/balancer/IMetaStablePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IRateProvider } from \"./IRateProvider.sol\";\n\ninterface IMetaStablePool {\n    function getRateProviders()\n        external\n        view\n        returns (IRateProvider[] memory providers);\n}\n"
    },
    "contracts/interfaces/balancer/IOracleWeightedPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// The three values that can be queried:\n//\n// - PAIR_PRICE: the price of the tokens in the Pool, expressed as the price of the second token in units of the\n//   first token. For example, if token A is worth $2, and token B is worth $4, the pair price will be 2.0.\n//   Note that the price is computed *including* the tokens decimals. This means that the pair price of a Pool with\n//   DAI and USDC will be close to 1.0, despite DAI having 18 decimals and USDC 6.\n//\n// - BPT_PRICE: the price of the Pool share token (BPT), in units of the first token.\n//   Note that the price is computed *including* the tokens decimals. This means that the BPT price of a Pool with\n//   USDC in which BPT is worth $5 will be 5.0, despite the BPT having 18 decimals and USDC 6.\n//\n// - INVARIANT: the value of the Pool's invariant, which serves as a measure of its liquidity.\nenum Variable {\n    PAIR_PRICE,\n    BPT_PRICE,\n    INVARIANT\n}\n\n/**\n * @dev Information for a Time Weighted Average query.\n *\n * Each query computes the average over a window of duration `secs` seconds that ended `ago` seconds ago. For\n * example, the average over the past 30 minutes is computed by settings secs to 1800 and ago to 0. If secs is 1800\n * and ago is 1800 as well, the average between 60 and 30 minutes ago is computed instead.\n */\nstruct OracleAverageQuery {\n    Variable variable;\n    uint256 secs;\n    uint256 ago;\n}\n\ninterface IOracleWeightedPool {\n    /**\n     * @dev Returns the time average weighted price corresponding to each of `queries`. Prices are represented as 18\n     * decimal fixed point values.\n     */\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n        external\n        view\n        returns (uint256[] memory results);\n}\n"
    },
    "contracts/interfaces/balancer/IRateProvider.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\ninterface IRateProvider {\n    function getRate() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/chainlink/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "contracts/interfaces/IBasicToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBasicToken {\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IBeaconProofs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IBeaconProofs {\n    function verifyValidator(\n        bytes32 beaconBlockRoot,\n        bytes32 pubKeyHash,\n        bytes calldata validatorPubKeyProof,\n        uint64 validatorIndex,\n        address withdrawalAddress\n    ) external view;\n\n    function verifyValidatorWithdrawable(\n        bytes32 beaconBlockRoot,\n        uint64 validatorIndex,\n        bytes32 pubKeyHash,\n        uint64 withdrawableEpoch,\n        bytes calldata withdrawableEpochProof,\n        bytes calldata validatorPubKeyProof\n    ) external view;\n\n    function verifyValidatorWithdrawable(\n        bytes32 beaconBlockRoot,\n        uint64 validatorIndex,\n        uint64 withdrawableEpoch,\n        bytes calldata withdrawableEpochProof\n    ) external view;\n\n    function verifyBalancesContainer(\n        bytes32 beaconBlockRoot,\n        bytes32 balancesContainerLeaf,\n        bytes calldata balancesContainerProof\n    ) external view;\n\n    function verifyValidatorBalance(\n        bytes32 balancesContainerRoot,\n        bytes32 validatorBalanceLeaf,\n        bytes calldata balanceProof,\n        uint64 validatorIndex\n    ) external view returns (uint256 validatorBalance);\n\n    function verifyFirstPendingDeposit(\n        bytes32 beaconBlockRoot,\n        uint64 slot,\n        bytes32 pubKeyHash,\n        bytes calldata firstPendingDepositProof\n    ) external view returns (bool isEmptyDepositQueue);\n}\n"
    },
    "contracts/interfaces/IBuyback.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IBuyback {\n    function swap() external;\n}\n"
    },
    "contracts/interfaces/ICampaignRemoteManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface ICampaignRemoteManager {\n    function createCampaign(\n        CampaignCreationParams memory params,\n        uint256 destinationChainId,\n        uint256 additionalGasLimit,\n        address votemarket\n    ) external payable;\n\n    function manageCampaign(\n        CampaignManagementParams memory params,\n        uint256 destinationChainId,\n        uint256 additionalGasLimit,\n        address votemarket\n    ) external payable;\n\n    function closeCampaign(\n        CampaignClosingParams memory params,\n        uint256 destinationChainId,\n        uint256 additionalGasLimit,\n        address votemarket\n    ) external payable;\n\n    struct CampaignCreationParams {\n        uint256 chainId;\n        address gauge;\n        address manager;\n        address rewardToken;\n        uint8 numberOfPeriods;\n        uint256 maxRewardPerVote;\n        uint256 totalRewardAmount;\n        address[] addresses;\n        address hook;\n        bool isWhitelist;\n    }\n\n    struct CampaignManagementParams {\n        uint256 campaignId;\n        address rewardToken;\n        uint8 numberOfPeriods;\n        uint256 totalRewardAmount;\n        uint256 maxRewardPerVote;\n    }\n\n    struct CampaignClosingParams {\n        uint256 campaignId;\n    }\n}\n"
    },
    "contracts/interfaces/IChildLiquidityGaugeFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\ninterface IChildLiquidityGaugeFactory {\n    event DeployedGauge(\n        address indexed _implementation,\n        address indexed _lp_token,\n        address indexed _deployer,\n        bytes32 _salt,\n        address _gauge\n    );\n    event Minted(\n        address indexed _user,\n        address indexed _gauge,\n        uint256 _new_total\n    );\n    event TransferOwnership(address _old_owner, address _new_owner);\n    event UpdateCallProxy(address _old_call_proxy, address _new_call_proxy);\n    event UpdateImplementation(\n        address _old_implementation,\n        address _new_implementation\n    );\n    event UpdateManager(address _manager);\n    event UpdateMirrored(address indexed _gauge, bool _mirrored);\n    event UpdateRoot(address _factory, address _implementation);\n    event UpdateVotingEscrow(\n        address _old_voting_escrow,\n        address _new_voting_escrow\n    );\n\n    function accept_transfer_ownership() external;\n\n    function call_proxy() external view returns (address);\n\n    function commit_transfer_ownership(address _future_owner) external;\n\n    function crv() external view returns (address);\n\n    function deploy_gauge(address _lp_token, bytes32 _salt)\n        external\n        returns (address);\n\n    function deploy_gauge(\n        address _lp_token,\n        bytes32 _salt,\n        address _manager\n    ) external returns (address);\n\n    function future_owner() external view returns (address);\n\n    function gauge_data(address arg0) external view returns (uint256);\n\n    function get_gauge(uint256 arg0) external view returns (address);\n\n    function get_gauge_count() external view returns (uint256);\n\n    function get_gauge_from_lp_token(address arg0)\n        external\n        view\n        returns (address);\n\n    function get_implementation() external view returns (address);\n\n    function is_mirrored(address _gauge) external view returns (bool);\n\n    function is_valid_gauge(address _gauge) external view returns (bool);\n\n    function last_request(address _gauge) external view returns (uint256);\n\n    function manager() external view returns (address);\n\n    function mint(address _gauge) external;\n\n    function mint_many(address[32] memory _gauges) external;\n\n    function minted(address arg0, address arg1) external view returns (uint256);\n\n    function owner() external view returns (address);\n\n    function root_factory() external view returns (address);\n\n    function root_implementation() external view returns (address);\n\n    function set_call_proxy(address _new_call_proxy) external;\n\n    function set_crv(address _crv) external;\n\n    function set_implementation(address _implementation) external;\n\n    function set_manager(address _new_manager) external;\n\n    function set_mirrored(address _gauge, bool _mirrored) external;\n\n    function set_root(address _factory, address _implementation) external;\n\n    function set_voting_escrow(address _voting_escrow) external;\n\n    function version() external view returns (string memory);\n\n    function voting_escrow() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IComptroller {\n    // Claim all the COMP accrued by specific holders in specific markets for their supplies and/or borrows\n    function claimComp(\n        address[] memory holders,\n        address[] memory cTokens,\n        bool borrowers,\n        bool suppliers\n    ) external;\n\n    function oracle() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IConsolidation.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\ninterface IConsolidationSource {\n    function confirmConsolidation()\n        external\n        returns (uint256 consolidationCount);\n}\n\ninterface IConsolidationTarget {\n    function requestConsolidation(\n        bytes32 lastSourcePubKeyHash,\n        bytes32 targetPubKeyHash\n    ) external;\n}\n"
    },
    "contracts/interfaces/ICurveLiquidityGaugeV6.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\ninterface ICurveLiquidityGaugeV6 {\n    event ApplyOwnership(address admin);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n    event CommitOwnership(address admin);\n    event Deposit(address indexed provider, uint256 value);\n    event SetGaugeManager(address _gauge_manager);\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event UpdateLiquidityLimit(\n        address indexed user,\n        uint256 original_balance,\n        uint256 original_supply,\n        uint256 working_balance,\n        uint256 working_supply\n    );\n    event Withdraw(address indexed provider, uint256 value);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function add_reward(address _reward_token, address _distributor) external;\n\n    function allowance(address arg0, address arg1)\n        external\n        view\n        returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function balanceOf(address arg0) external view returns (uint256);\n\n    function claim_rewards() external;\n\n    function claim_rewards(address _addr) external;\n\n    function claim_rewards(address _addr, address _receiver) external;\n\n    function claimable_reward(address _user, address _reward_token)\n        external\n        view\n        returns (uint256);\n\n    function claimable_tokens(address addr) external returns (uint256);\n\n    function claimed_reward(address _addr, address _token)\n        external\n        view\n        returns (uint256);\n\n    function decimals() external view returns (uint256);\n\n    function decreaseAllowance(address _spender, uint256 _subtracted_value)\n        external\n        returns (bool);\n\n    function deposit(uint256 _value) external;\n\n    function deposit(uint256 _value, address _addr) external;\n\n    function deposit(\n        uint256 _value,\n        address _addr,\n        bool _claim_rewards\n    ) external;\n\n    function deposit_reward_token(address _reward_token, uint256 _amount)\n        external;\n\n    function deposit_reward_token(\n        address _reward_token,\n        uint256 _amount,\n        uint256 _epoch\n    ) external;\n\n    function factory() external view returns (address);\n\n    function future_epoch_time() external view returns (uint256);\n\n    function increaseAllowance(address _spender, uint256 _added_value)\n        external\n        returns (bool);\n\n    function inflation_rate() external view returns (uint256);\n\n    function integrate_checkpoint() external view returns (uint256);\n\n    function integrate_checkpoint_of(address arg0)\n        external\n        view\n        returns (uint256);\n\n    function integrate_fraction(address arg0) external view returns (uint256);\n\n    function integrate_inv_supply(uint256 arg0) external view returns (uint256);\n\n    function integrate_inv_supply_of(address arg0)\n        external\n        view\n        returns (uint256);\n\n    function is_killed() external view returns (bool);\n\n    function kick(address addr) external;\n\n    function lp_token() external view returns (address);\n\n    function manager() external view returns (address);\n\n    function name() external view returns (string memory);\n\n    function nonces(address arg0) external view returns (uint256);\n\n    function period() external view returns (int128);\n\n    function period_timestamp(uint256 arg0) external view returns (uint256);\n\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (bool);\n\n    function reward_count() external view returns (uint256);\n\n    function reward_integral_for(address arg0, address arg1)\n        external\n        view\n        returns (uint256);\n\n    function reward_tokens(uint256 arg0) external view returns (address);\n\n    function rewards_receiver(address arg0) external view returns (address);\n\n    function salt() external view returns (bytes32);\n\n    function set_gauge_manager(address _gauge_manager) external;\n\n    function set_killed(bool _is_killed) external;\n\n    function set_reward_distributor(address _reward_token, address _distributor)\n        external;\n\n    function set_rewards_receiver(address _receiver) external;\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function user_checkpoint(address addr) external returns (bool);\n\n    function version() external view returns (string memory);\n\n    function withdraw(uint256 _value) external;\n\n    function withdraw(uint256 _value, bool _claim_rewards) external;\n\n    function working_balances(address arg0) external view returns (uint256);\n\n    function working_supply() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ICurveMinter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\ninterface ICurveMinter {\n    event Minted(address indexed recipient, address gauge, uint256 minted);\n\n    function allowed_to_mint_for(address arg0, address arg1)\n        external\n        view\n        returns (bool);\n\n    function controller() external view returns (address);\n\n    function mint(address gauge_addr) external;\n\n    function mint_for(address gauge_addr, address _for) external;\n\n    function mint_many(address[8] memory gauge_addrs) external;\n\n    function minted(address arg0, address arg1) external view returns (uint256);\n\n    function toggle_approve_mint(address minting_user) external;\n\n    function token() external view returns (address);\n}\n"
    },
    "contracts/interfaces/ICurveStableSwapNG.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\ninterface ICurveStableSwapNG {\n    event AddLiquidity(\n        address indexed provider,\n        uint256[] token_amounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 token_supply\n    );\n    event ApplyNewFee(uint256 fee, uint256 offpeg_fee_multiplier);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event RampA(\n        uint256 old_A,\n        uint256 new_A,\n        uint256 initial_time,\n        uint256 future_time\n    );\n    event RemoveLiquidity(\n        address indexed provider,\n        uint256[] token_amounts,\n        uint256[] fees,\n        uint256 token_supply\n    );\n    event RemoveLiquidityImbalance(\n        address indexed provider,\n        uint256[] token_amounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 token_supply\n    );\n    event RemoveLiquidityOne(\n        address indexed provider,\n        int128 token_id,\n        uint256 token_amount,\n        uint256 coin_amount,\n        uint256 token_supply\n    );\n    event SetNewMATime(uint256 ma_exp_time, uint256 D_ma_time);\n    event StopRampA(uint256 A, uint256 t);\n    event TokenExchange(\n        address indexed buyer,\n        int128 sold_id,\n        uint256 tokens_sold,\n        int128 bought_id,\n        uint256 tokens_bought\n    );\n    event TokenExchangeUnderlying(\n        address indexed buyer,\n        int128 sold_id,\n        uint256 tokens_sold,\n        int128 bought_id,\n        uint256 tokens_bought\n    );\n    event Transfer(\n        address indexed sender,\n        address indexed receiver,\n        uint256 value\n    );\n\n    function A() external view returns (uint256);\n\n    function A_precise() external view returns (uint256);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function D_ma_time() external view returns (uint256);\n\n    function D_oracle() external view returns (uint256);\n\n    function N_COINS() external view returns (uint256);\n\n    function add_liquidity(uint256[] memory _amounts, uint256 _min_mint_amount)\n        external\n        returns (uint256);\n\n    function add_liquidity(\n        uint256[] memory _amounts,\n        uint256 _min_mint_amount,\n        address _receiver\n    ) external returns (uint256);\n\n    function admin_balances(uint256 arg0) external view returns (uint256);\n\n    function admin_fee() external view returns (uint256);\n\n    function allowance(address arg0, address arg1)\n        external\n        view\n        returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function balanceOf(address arg0) external view returns (uint256);\n\n    function balances(uint256 i) external view returns (uint256);\n\n    function calc_token_amount(uint256[] memory _amounts, bool _is_deposit)\n        external\n        view\n        returns (uint256);\n\n    function calc_withdraw_one_coin(uint256 _burn_amount, int128 i)\n        external\n        view\n        returns (uint256);\n\n    function coins(uint256 arg0) external view returns (address);\n\n    function decimals() external view returns (uint8);\n\n    function dynamic_fee(int128 i, int128 j) external view returns (uint256);\n\n    function ema_price(uint256 i) external view returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy\n    ) external returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy,\n        address _receiver\n    ) external returns (uint256);\n\n    function exchange_received(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy\n    ) external returns (uint256);\n\n    function exchange_received(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy,\n        address _receiver\n    ) external returns (uint256);\n\n    function fee() external view returns (uint256);\n\n    function future_A() external view returns (uint256);\n\n    function future_A_time() external view returns (uint256);\n\n    function get_balances() external view returns (uint256[] memory);\n\n    function get_dx(\n        int128 i,\n        int128 j,\n        uint256 dy\n    ) external view returns (uint256);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function get_p(uint256 i) external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function initial_A() external view returns (uint256);\n\n    function initial_A_time() external view returns (uint256);\n\n    function last_price(uint256 i) external view returns (uint256);\n\n    function ma_exp_time() external view returns (uint256);\n\n    function ma_last_time() external view returns (uint256);\n\n    function name() external view returns (string memory);\n\n    function nonces(address arg0) external view returns (uint256);\n\n    function offpeg_fee_multiplier() external view returns (uint256);\n\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (bool);\n\n    function price_oracle(uint256 i) external view returns (uint256);\n\n    function ramp_A(uint256 _future_A, uint256 _future_time) external;\n\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[] memory _min_amounts\n    ) external returns (uint256[] memory);\n\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[] memory _min_amounts,\n        address _receiver\n    ) external returns (uint256[] memory);\n\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[] memory _min_amounts,\n        address _receiver,\n        bool _claim_admin_fees\n    ) external returns (uint256[] memory);\n\n    function remove_liquidity_imbalance(\n        uint256[] memory _amounts,\n        uint256 _max_burn_amount\n    ) external returns (uint256);\n\n    function remove_liquidity_imbalance(\n        uint256[] memory _amounts,\n        uint256 _max_burn_amount,\n        address _receiver\n    ) external returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_received\n    ) external returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_received,\n        address _receiver\n    ) external returns (uint256);\n\n    function salt() external view returns (bytes32);\n\n    function set_ma_exp_time(uint256 _ma_exp_time, uint256 _D_ma_time) external;\n\n    function set_new_fee(uint256 _new_fee, uint256 _new_offpeg_fee_multiplier)\n        external;\n\n    function stop_ramp_A() external;\n\n    function stored_rates() external view returns (uint256[] memory);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function version() external view returns (string memory);\n\n    function withdraw_admin_fees() external;\n}\n"
    },
    "contracts/interfaces/ICurveXChainLiquidityGauge.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\ninterface ICurveXChainLiquidityGauge {\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n    event Deposit(address indexed provider, uint256 value);\n    event SetGaugeManager(address _gauge_manager);\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event UpdateLiquidityLimit(\n        address indexed user,\n        uint256 original_balance,\n        uint256 original_supply,\n        uint256 working_balance,\n        uint256 working_supply\n    );\n    event Withdraw(address indexed provider, uint256 value);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function add_reward(address _reward_token, address _distributor) external;\n\n    function allowance(address arg0, address arg1)\n        external\n        view\n        returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function balanceOf(address arg0) external view returns (uint256);\n\n    function claim_rewards() external;\n\n    function claim_rewards(address _addr) external;\n\n    function claim_rewards(address _addr, address _receiver) external;\n\n    function claimable_reward(address _user, address _reward_token)\n        external\n        view\n        returns (uint256);\n\n    function claimable_tokens(address addr) external returns (uint256);\n\n    function claimed_reward(address _addr, address _token)\n        external\n        view\n        returns (uint256);\n\n    function decimals() external view returns (uint256);\n\n    function decreaseAllowance(address _spender, uint256 _subtracted_value)\n        external\n        returns (bool);\n\n    function deposit(uint256 _value) external;\n\n    function deposit(uint256 _value, address _addr) external;\n\n    function deposit(\n        uint256 _value,\n        address _addr,\n        bool _claim_rewards\n    ) external;\n\n    function deposit_reward_token(address _reward_token, uint256 _amount)\n        external;\n\n    function deposit_reward_token(\n        address _reward_token,\n        uint256 _amount,\n        uint256 _epoch\n    ) external;\n\n    function factory() external view returns (address);\n\n    function increaseAllowance(address _spender, uint256 _added_value)\n        external\n        returns (bool);\n\n    function inflation_rate(uint256 arg0) external view returns (uint256);\n\n    function initialize(\n        address _lp_token,\n        address _root,\n        address _manager\n    ) external;\n\n    function integrate_checkpoint() external view returns (uint256);\n\n    function integrate_checkpoint_of(address arg0)\n        external\n        view\n        returns (uint256);\n\n    function integrate_fraction(address arg0) external view returns (uint256);\n\n    function integrate_inv_supply(int128 arg0) external view returns (uint256);\n\n    function integrate_inv_supply_of(address arg0)\n        external\n        view\n        returns (uint256);\n\n    function is_killed() external view returns (bool);\n\n    function lp_token() external view returns (address);\n\n    function manager() external view returns (address);\n\n    function name() external view returns (string memory);\n\n    function nonces(address arg0) external view returns (uint256);\n\n    function period() external view returns (int128);\n\n    function period_timestamp(int128 arg0) external view returns (uint256);\n\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (bool);\n\n    function recover_remaining(address _reward_token) external;\n\n    function reward_count() external view returns (uint256);\n\n    function reward_integral_for(address arg0, address arg1)\n        external\n        view\n        returns (uint256);\n\n    function reward_remaining(address arg0) external view returns (uint256);\n\n    function reward_tokens(uint256 arg0) external view returns (address);\n\n    function rewards_receiver(address arg0) external view returns (address);\n\n    function root_gauge() external view returns (address);\n\n    function set_gauge_manager(address _gauge_manager) external;\n\n    function set_killed(bool _is_killed) external;\n\n    function set_manager(address _gauge_manager) external;\n\n    function set_reward_distributor(address _reward_token, address _distributor)\n        external;\n\n    function set_rewards_receiver(address _receiver) external;\n\n    function set_root_gauge(address _root) external;\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function update_voting_escrow() external;\n\n    function user_checkpoint(address addr) external returns (bool);\n\n    function version() external view returns (string memory);\n\n    function voting_escrow() external view returns (address);\n\n    function withdraw(uint256 _value) external;\n\n    function withdraw(uint256 _value, bool _claim_rewards) external;\n\n    function withdraw(\n        uint256 _value,\n        bool _claim_rewards,\n        address _receiver\n    ) external;\n\n    function working_balances(address arg0) external view returns (uint256);\n\n    function working_supply() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ICVXLocker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ICVXLocker {\n    function lock(\n        address _account,\n        uint256 _amount,\n        uint256 _spendRatio\n    ) external;\n\n    function lockedBalanceOf(address _account) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IDepositContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IDepositContract {\n    /// @notice A processed deposit event.\n    event DepositEvent(\n        bytes pubkey,\n        bytes withdrawal_credentials,\n        bytes amount,\n        bytes signature,\n        bytes index\n    );\n\n    /// @notice Submit a Phase 0 DepositData object.\n    /// @param pubkey A BLS12-381 public key.\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\n    /// @param signature A BLS12-381 signature.\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\n    /// Used as a protection against malformed input.\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawal_credentials,\n        bytes calldata signature,\n        bytes32 deposit_data_root\n    ) external payable;\n\n    /// @notice Query the current deposit root hash.\n    /// @return The deposit root hash.\n    function get_deposit_root() external view returns (bytes32);\n\n    /// @notice Query the current deposit count.\n    /// @return The deposit count encoded as a little endian 64-bit number.\n    function get_deposit_count() external view returns (bytes memory);\n}\n"
    },
    "contracts/interfaces/IDripper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IDripper {\n    /// @notice How much funds have dripped out already and are currently\n    //   available to be sent to the vault.\n    /// @return The amount that would be sent if a collect was called\n    function availableFunds() external view returns (uint256);\n\n    /// @notice Collect all dripped funds and send to vault.\n    ///  Recalculate new drip rate.\n    function collect() external;\n\n    /// @notice Collect all dripped funds, send to vault, recalculate new drip\n    ///  rate, and rebase mToken.\n    function collectAndRebase() external;\n\n    /// @notice Change the drip duration. Governor only.\n    /// @param _durationSeconds the number of seconds to drip out the entire\n    ///  balance over if no collects were called during that time.\n    function setDripDuration(uint256 _durationSeconds) external;\n\n    /// @dev Transfer out ERC20 tokens held by the contract. Governor only.\n    /// @param _asset ERC20 token address\n    /// @param _amount amount to transfer\n    function transferToken(address _asset, uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/IEthUsdOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IEthUsdOracle {\n    /**\n     * @notice Returns ETH price in USD.\n     * @return Price in USD with 6 decimal digits.\n     */\n    function ethUsdPrice() external view returns (uint256);\n\n    /**\n     * @notice Returns token price in USD.\n     * @param symbol. Asset symbol. For ex. \"DAI\".\n     * @return Price in USD with 6 decimal digits.\n     */\n    function tokUsdPrice(string calldata symbol)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the asset price in ETH.\n     * @param symbol. Asset symbol. For ex. \"DAI\".\n     * @return Price in ETH with 8 decimal digits.\n     */\n    function tokEthPrice(string calldata symbol)\n        external\n        view\n        returns (uint256);\n}\n\ninterface IViewEthUsdOracle {\n    /**\n     * @notice Returns ETH price in USD.\n     * @return Price in USD with 6 decimal digits.\n     */\n    function ethUsdPrice() external view returns (uint256);\n\n    /**\n     * @notice Returns token price in USD.\n     * @param symbol. Asset symbol. For ex. \"DAI\".\n     * @return Price in USD with 6 decimal digits.\n     */\n    function tokUsdPrice(string calldata symbol)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the asset price in ETH.\n     * @param symbol. Asset symbol. For ex. \"DAI\".\n     * @return Price in ETH with 8 decimal digits.\n     */\n    function tokEthPrice(string calldata symbol)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/interfaces/IFraxETHMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IFraxETHMinter {\n    function submitAndDeposit(address recipient)\n        external\n        payable\n        returns (uint256 shares);\n}\n"
    },
    "contracts/interfaces/IGetExchangeRateToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IGetExchangeRateToken {\n    function getExchangeRate() external view returns (uint256 _exchangeRate);\n}\n"
    },
    "contracts/interfaces/IMinMaxOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IMinMaxOracle {\n    //Assuming 8 decimals\n    function priceMin(string calldata symbol) external view returns (uint256);\n\n    function priceMax(string calldata symbol) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IMockVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IVault } from \"./IVault.sol\";\n\ninterface IMockVault is IVault {\n    function outstandingWithdrawalsAmount() external view returns (uint256);\n\n    function wethAvailable() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IOETHZapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IOETHZapper {\n    function deposit() external payable returns (uint256);\n}\n"
    },
    "contracts/interfaces/IOneInch.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// 1Inch swap data\nstruct SwapDescription {\n    IERC20 srcToken; // contract address of a token to sell\n    IERC20 dstToken; // contract address of a token to buy\n    address payable srcReceiver;\n    address payable dstReceiver; // Receiver of destination currency. default: fromAddress\n    uint256 amount;\n    uint256 minReturnAmount;\n    uint256 flags;\n}\n\n/// @title Interface for making arbitrary calls during swap\ninterface IAggregationExecutor {\n    /// @notice propagates information about original msg.sender and executes arbitrary data\n    function execute(address msgSender) external payable; // 0x4b64e492\n}\n\ninterface IOneInchRouter {\n    /// @notice Performs a swap, delegating all calls encoded in `data` to `executor`.\n    function swap(\n        IAggregationExecutor executor,\n        SwapDescription calldata desc,\n        bytes calldata permit,\n        bytes calldata data\n    ) external returns (uint256 returnAmount, uint256 spentAmount);\n\n    /// @notice Performs swap using Uniswap exchange. Wraps and unwraps ETH if required.\n    function unoswapTo(\n        address payable recipient,\n        IERC20 srcToken,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] calldata pools\n    ) external payable returns (uint256 returnAmount);\n\n    /// @notice Performs swap using Uniswap V3 exchange. Wraps and unwraps ETH if required.\n    function uniswapV3SwapTo(\n        address payable recipient,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] calldata pools\n    ) external payable returns (uint256 returnAmount);\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IOracle {\n    /**\n     * @dev returns the asset price in USD, in 8 decimal digits.\n     *\n     * The version of priceProvider deployed for OETH has 18 decimal digits\n     */\n    function price(address asset) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IOUSD.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IOUSD {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event GovernorshipTransferred(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n    event PendingGovernorshipTransfer(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n    event TotalSupplyUpdatedHighres(\n        uint256 totalSupply,\n        uint256 rebasingCredits,\n        uint256 rebasingCreditsPerToken\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function _totalSupply() external view returns (uint256);\n\n    function allowance(address _owner, address _spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function balanceOf(address _account) external view returns (uint256);\n\n    function burn(address account, uint256 amount) external;\n\n    function changeSupply(uint256 _newTotalSupply) external;\n\n    function claimGovernance() external;\n\n    function creditsBalanceOf(address _account)\n        external\n        view\n        returns (uint256, uint256);\n\n    function creditsBalanceOfHighres(address _account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            bool\n        );\n\n    function decimals() external view returns (uint8);\n\n    function decreaseAllowance(address _spender, uint256 _subtractedValue)\n        external\n        returns (bool);\n\n    function governor() external view returns (address);\n\n    function increaseAllowance(address _spender, uint256 _addedValue)\n        external\n        returns (bool);\n\n    function initialize(\n        string memory _nameArg,\n        string memory _symbolArg,\n        address _vaultAddress\n    ) external;\n\n    function isGovernor() external view returns (bool);\n\n    function isUpgraded(address) external view returns (uint256);\n\n    function mint(address _account, uint256 _amount) external;\n\n    function name() external view returns (string memory);\n\n    function nonRebasingCreditsPerToken(address)\n        external\n        view\n        returns (uint256);\n\n    function nonRebasingSupply() external view returns (uint256);\n\n    function rebaseOptIn() external;\n\n    function rebaseOptOut() external;\n\n    function rebaseState(address) external view returns (uint8);\n\n    function rebasingCredits() external view returns (uint256);\n\n    function rebasingCreditsHighres() external view returns (uint256);\n\n    function rebasingCreditsPerToken() external view returns (uint256);\n\n    function rebasingCreditsPerTokenHighres() external view returns (uint256);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function transferGovernance(address _newGovernor) external;\n\n    function vaultAddress() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IPriceOracle {\n    /**\n     * @dev returns the asset price in USD, 6 decimal digits.\n     * Compatible with the Open Price Feed.\n     */\n    function price(string calldata symbol) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IRETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IRETH {\n    function getEthValue(uint256 _rethAmount) external view returns (uint256);\n\n    function getRethValue(uint256 _ethAmount) external view returns (uint256);\n\n    function getExchangeRate() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/ISafe.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface ISafe {\n    function execTransactionFromModule(\n        address,\n        uint256,\n        bytes memory,\n        uint8\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/ISfrxETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ISfrxETH {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 amount\n    );\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n    event NewRewardsCycle(uint32 indexed cycleEnd, uint256 rewardAmount);\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function allowance(address, address) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function asset() external view returns (address);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function convertToAssets(uint256 shares) external view returns (uint256);\n\n    function convertToShares(uint256 assets) external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function deposit(uint256 assets, address receiver)\n        external\n        returns (uint256 shares);\n\n    function depositWithSignature(\n        uint256 assets,\n        address receiver,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 shares);\n\n    function lastRewardAmount() external view returns (uint192);\n\n    function lastSync() external view returns (uint32);\n\n    function maxDeposit(address) external view returns (uint256);\n\n    function maxMint(address) external view returns (uint256);\n\n    function maxRedeem(address owner) external view returns (uint256);\n\n    function maxWithdraw(address owner) external view returns (uint256);\n\n    function mint(uint256 shares, address receiver)\n        external\n        returns (uint256 assets);\n\n    function name() external view returns (string memory);\n\n    function nonces(address) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function previewDeposit(uint256 assets) external view returns (uint256);\n\n    function previewMint(uint256 shares) external view returns (uint256);\n\n    function previewRedeem(uint256 shares) external view returns (uint256);\n\n    function previewWithdraw(uint256 assets) external view returns (uint256);\n\n    function pricePerShare() external view returns (uint256);\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n\n    function rewardsCycleEnd() external view returns (uint32);\n\n    function rewardsCycleLength() external view returns (uint32);\n\n    function symbol() external view returns (string memory);\n\n    function syncRewards() external;\n\n    function totalAssets() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n}\n"
    },
    "contracts/interfaces/ISSVNetwork.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct Cluster {\n    uint32 validatorCount;\n    uint64 networkFeeIndex;\n    uint64 index;\n    bool active;\n    uint256 balance;\n}\n\ninterface ISSVNetwork {\n    /**********/\n    /* Errors */\n    /**********/\n\n    error CallerNotOwner(); // 0x5cd83192\n    error CallerNotWhitelisted(); // 0x8c6e5d71\n    error FeeTooLow(); // 0x732f9413\n    error FeeExceedsIncreaseLimit(); // 0x958065d9\n    error NoFeeDeclared(); // 0x1d226c30\n    error ApprovalNotWithinTimeframe(); // 0x97e4b518\n    error OperatorDoesNotExist(); // 0x961e3e8c\n    error InsufficientBalance(); // 0xf4d678b8\n    error ValidatorDoesNotExist(); // 0xe51315d2\n    error ClusterNotLiquidatable(); // 0x60300a8d\n    error InvalidPublicKeyLength(); // 0x637297a4\n    error InvalidOperatorIdsLength(); // 0x38186224\n    error ClusterAlreadyEnabled(); // 0x3babafd2\n    error ClusterIsLiquidated(); // 0x95a0cf33\n    error ClusterDoesNotExists(); // 0x185e2b16\n    error IncorrectClusterState(); // 0x12e04c87\n    error UnsortedOperatorsList(); // 0xdd020e25\n    error NewBlockPeriodIsBelowMinimum(); // 0x6e6c9cac\n    error ExceedValidatorLimit(); // 0x6df5ab76\n    error TokenTransferFailed(); // 0x045c4b02\n    error SameFeeChangeNotAllowed(); // 0xc81272f8\n    error FeeIncreaseNotAllowed(); // 0x410a2b6c\n    error NotAuthorized(); // 0xea8e4eb5\n    error OperatorsListNotUnique(); // 0xa5a1ff5d\n    error OperatorAlreadyExists(); // 0x289c9494\n    error TargetModuleDoesNotExist(); // 0x8f9195fb\n    error MaxValueExceeded(); // 0x91aa3017\n    error FeeTooHigh(); // 0xcd4e6167\n    error PublicKeysSharesLengthMismatch(); // 0x9ad467b8\n    error IncorrectValidatorStateWithData(bytes publicKey); // 0x89307938\n    error ValidatorAlreadyExistsWithData(bytes publicKey); // 0x388e7999\n    error EmptyPublicKeysList(); // df83e679\n\n    // legacy errors\n    error ValidatorAlreadyExists(); // 0x8d09a73e\n    error IncorrectValidatorState(); // 0x2feda3c1\n\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    event ClusterDeposited(\n        address indexed owner,\n        uint64[] operatorIds,\n        uint256 value,\n        Cluster cluster\n    );\n    event ClusterLiquidated(\n        address indexed owner,\n        uint64[] operatorIds,\n        Cluster cluster\n    );\n    event ClusterReactivated(\n        address indexed owner,\n        uint64[] operatorIds,\n        Cluster cluster\n    );\n    event ClusterWithdrawn(\n        address indexed owner,\n        uint64[] operatorIds,\n        uint256 value,\n        Cluster cluster\n    );\n    event DeclareOperatorFeePeriodUpdated(uint64 value);\n    event ExecuteOperatorFeePeriodUpdated(uint64 value);\n    event FeeRecipientAddressUpdated(\n        address indexed owner,\n        address recipientAddress\n    );\n    event Initialized(uint8 version);\n    event LiquidationThresholdPeriodUpdated(uint64 value);\n    event MinimumLiquidationCollateralUpdated(uint256 value);\n    event NetworkEarningsWithdrawn(uint256 value, address recipient);\n    event NetworkFeeUpdated(uint256 oldFee, uint256 newFee);\n    event OperatorAdded(\n        uint64 indexed operatorId,\n        address indexed owner,\n        bytes publicKey,\n        uint256 fee\n    );\n    event OperatorFeeDeclarationCancelled(\n        address indexed owner,\n        uint64 indexed operatorId\n    );\n    event OperatorFeeDeclared(\n        address indexed owner,\n        uint64 indexed operatorId,\n        uint256 blockNumber,\n        uint256 fee\n    );\n    event OperatorFeeExecuted(\n        address indexed owner,\n        uint64 indexed operatorId,\n        uint256 blockNumber,\n        uint256 fee\n    );\n    event OperatorFeeIncreaseLimitUpdated(uint64 value);\n    event OperatorMaximumFeeUpdated(uint64 maxFee);\n    event OperatorRemoved(uint64 indexed operatorId);\n    event OperatorWhitelistUpdated(\n        uint64 indexed operatorId,\n        address whitelisted\n    );\n    event OperatorWithdrawn(\n        address indexed owner,\n        uint64 indexed operatorId,\n        uint256 value\n    );\n    event OwnershipTransferStarted(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event Upgraded(address indexed implementation);\n    event ValidatorAdded(\n        address indexed owner,\n        uint64[] operatorIds,\n        bytes publicKey,\n        bytes shares,\n        Cluster cluster\n    );\n    event ValidatorExited(\n        address indexed owner,\n        uint64[] operatorIds,\n        bytes publicKey\n    );\n    event ValidatorRemoved(\n        address indexed owner,\n        uint64[] operatorIds,\n        bytes publicKey,\n        Cluster cluster\n    );\n\n    fallback() external;\n\n    function acceptOwnership() external;\n\n    function cancelDeclaredOperatorFee(uint64 operatorId) external;\n\n    function declareOperatorFee(uint64 operatorId, uint256 fee) external;\n\n    function deposit(\n        address clusterOwner,\n        uint64[] memory operatorIds,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function executeOperatorFee(uint64 operatorId) external;\n\n    function exitValidator(bytes memory publicKey, uint64[] memory operatorIds)\n        external;\n\n    function bulkExitValidator(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds\n    ) external;\n\n    function getVersion() external pure returns (string memory version);\n\n    function initialize(\n        address token_,\n        address ssvOperators_,\n        address ssvClusters_,\n        address ssvDAO_,\n        address ssvViews_,\n        uint64 minimumBlocksBeforeLiquidation_,\n        uint256 minimumLiquidationCollateral_,\n        uint32 validatorsPerOperatorLimit_,\n        uint64 declareOperatorFeePeriod_,\n        uint64 executeOperatorFeePeriod_,\n        uint64 operatorMaxFeeIncrease_\n    ) external;\n\n    function liquidate(\n        address clusterOwner,\n        uint64[] memory operatorIds,\n        Cluster memory cluster\n    ) external;\n\n    function owner() external view returns (address);\n\n    function pendingOwner() external view returns (address);\n\n    function proxiableUUID() external view returns (bytes32);\n\n    function reactivate(\n        uint64[] memory operatorIds,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function reduceOperatorFee(uint64 operatorId, uint256 fee) external;\n\n    function registerOperator(bytes memory publicKey, uint256 fee)\n        external\n        returns (uint64 id);\n\n    function registerValidator(\n        bytes memory publicKey,\n        uint64[] memory operatorIds,\n        bytes memory sharesData,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function bulkRegisterValidator(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds,\n        bytes[] calldata sharesData,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function removeOperator(uint64 operatorId) external;\n\n    function removeValidator(\n        bytes memory publicKey,\n        uint64[] memory operatorIds,\n        Cluster memory cluster\n    ) external;\n\n    function bulkRemoveValidator(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds,\n        Cluster memory cluster\n    ) external;\n\n    function renounceOwnership() external;\n\n    function setFeeRecipientAddress(address recipientAddress) external;\n\n    function setOperatorWhitelist(uint64 operatorId, address whitelisted)\n        external;\n\n    function transferOwnership(address newOwner) external;\n\n    function updateDeclareOperatorFeePeriod(uint64 timeInSeconds) external;\n\n    function updateExecuteOperatorFeePeriod(uint64 timeInSeconds) external;\n\n    function updateLiquidationThresholdPeriod(uint64 blocks) external;\n\n    function updateMaximumOperatorFee(uint64 maxFee) external;\n\n    function updateMinimumLiquidationCollateral(uint256 amount) external;\n\n    function updateModule(uint8 moduleId, address moduleAddress) external;\n\n    function updateNetworkFee(uint256 fee) external;\n\n    function updateOperatorFeeIncreaseLimit(uint64 percentage) external;\n\n    function upgradeTo(address newImplementation) external;\n\n    function upgradeToAndCall(address newImplementation, bytes memory data)\n        external\n        payable;\n\n    function withdraw(\n        uint64[] memory operatorIds,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function withdrawAllOperatorEarnings(uint64 operatorId) external;\n\n    function withdrawNetworkEarnings(uint256 amount) external;\n\n    function withdrawOperatorEarnings(uint64 operatorId, uint256 amount)\n        external;\n}\n"
    },
    "contracts/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Platform interface to integrate with lending platform like Compound, AAVE etc.\n */\ninterface IStrategy {\n    /**\n     * @dev Deposit the given asset to platform\n     * @param _asset asset address\n     * @param _amount Amount to deposit\n     */\n    function deposit(address _asset, uint256 _amount) external;\n\n    /**\n     * @dev Deposit the entire balance of all supported assets in the Strategy\n     *      to the platform\n     */\n    function depositAll() external;\n\n    /**\n     * @dev Withdraw given asset from Lending platform\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external;\n\n    /**\n     * @dev Liquidate all assets in strategy and return them to Vault.\n     */\n    function withdrawAll() external;\n\n    /**\n     * @dev Returns the current balance of the given asset.\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        returns (uint256 balance);\n\n    /**\n     * @dev Returns bool indicating whether strategy supports asset.\n     */\n    function supportsAsset(address _asset) external view returns (bool);\n\n    /**\n     * @dev Collect reward tokens from the Strategy.\n     */\n    function collectRewardTokens() external;\n\n    /**\n     * @dev The address array of the reward tokens for the Strategy.\n     */\n    function getRewardTokenAddresses() external view returns (address[] memory);\n\n    function harvesterAddress() external view returns (address);\n\n    function transferToken(address token, uint256 amount) external;\n\n    function setRewardTokenAddresses(address[] calldata _rewardTokenAddresses)\n        external;\n}\n"
    },
    "contracts/interfaces/ISwapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface ISwapper {\n    /**\n     * @param fromAsset The token address of the asset being sold.\n     * @param toAsset The token address of the asset being purchased.\n     * @param fromAssetAmount The amount of assets being sold.\n     * @param minToAssetAmmount The minimum amount of assets to be purchased.\n     * @param data tx.data returned from 1Inch's /v5.0/1/swap API\n     */\n    function swap(\n        address fromAsset,\n        address toAsset,\n        uint256 fromAssetAmount,\n        uint256 minToAssetAmmount,\n        bytes calldata data\n    ) external returns (uint256 toAssetAmount);\n}\n"
    },
    "contracts/interfaces/ITimelock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface ITimelock {\n    function delay() external view returns (uint256);\n\n    function GRACE_PERIOD() external view returns (uint256);\n\n    function acceptAdmin() external;\n\n    function queuedTransactions(bytes32 hash) external view returns (bool);\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external returns (bytes32);\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external;\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external payable returns (bytes memory);\n}\n"
    },
    "contracts/interfaces/ITimelockController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface ITimelockController {\n    function grantRole(bytes32 role, address account) external;\n\n    function revokeRole(bytes32 role, address account) external;\n\n    function renounceRole(bytes32 role, address account) external;\n\n    function hasRole(bytes32 role, address account)\n        external\n        view\n        returns (bool);\n\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) external payable;\n\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) external;\n\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) external view returns (bytes32);\n\n    function isOperationDone(bytes32 opHash) external view returns (bool);\n\n    function isOperationReady(bytes32 opHash) external view returns (bool);\n\n    function isOperation(bytes32 opHash) external view returns (bool);\n\n    function getMinDelay() external view returns (uint256);\n\n    function updateDelay(uint256 newDelay) external;\n\n    function CANCELLER_ROLE() external view returns (bytes32);\n}\n"
    },
    "contracts/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { VaultStorage } from \"../vault/VaultStorage.sol\";\n\ninterface IVault {\n    // slither-disable-start constable-states\n\n    event AssetSupported(address _asset);\n    event AssetDefaultStrategyUpdated(address _asset, address _strategy);\n    event AssetAllocated(address _asset, address _strategy, uint256 _amount);\n    event StrategyApproved(address _addr);\n    event StrategyRemoved(address _addr);\n    event Mint(address _addr, uint256 _value);\n    event Redeem(address _addr, uint256 _value);\n    event CapitalPaused();\n    event CapitalUnpaused();\n    event RebasePaused();\n    event RebaseUnpaused();\n    event VaultBufferUpdated(uint256 _vaultBuffer);\n    event RedeemFeeUpdated(uint256 _redeemFeeBps);\n    event PriceProviderUpdated(address _priceProvider);\n    event AllocateThresholdUpdated(uint256 _threshold);\n    event RebaseThresholdUpdated(uint256 _threshold);\n    event StrategistUpdated(address _address);\n    event MaxSupplyDiffChanged(uint256 maxSupplyDiff);\n    event YieldDistribution(address _to, uint256 _yield, uint256 _fee);\n    event TrusteeFeeBpsChanged(uint256 _basis);\n    event TrusteeAddressChanged(address _address);\n    event SwapperChanged(address _address);\n    event SwapAllowedUndervalueChanged(uint256 _basis);\n    event SwapSlippageChanged(address _asset, uint256 _basis);\n    event Swapped(\n        address indexed _fromAsset,\n        address indexed _toAsset,\n        uint256 _fromAssetAmount,\n        uint256 _toAssetAmount\n    );\n    event StrategyAddedToMintWhitelist(address indexed strategy);\n    event StrategyRemovedFromMintWhitelist(address indexed strategy);\n    event DripperChanged(address indexed _dripper);\n    event WithdrawalRequested(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount,\n        uint256 _queued\n    );\n    event WithdrawalClaimed(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount\n    );\n    event WithdrawalClaimable(uint256 _claimable, uint256 _newClaimable);\n\n    // Governable.sol\n    function transferGovernance(address _newGovernor) external;\n\n    function claimGovernance() external;\n\n    function governor() external view returns (address);\n\n    function ADMIN_IMPLEMENTATION() external view returns (address);\n\n    // VaultAdmin.sol\n    function setPriceProvider(address _priceProvider) external;\n\n    function priceProvider() external view returns (address);\n\n    function setRedeemFeeBps(uint256 _redeemFeeBps) external;\n\n    function redeemFeeBps() external view returns (uint256);\n\n    function setVaultBuffer(uint256 _vaultBuffer) external;\n\n    function vaultBuffer() external view returns (uint256);\n\n    function setAutoAllocateThreshold(uint256 _threshold) external;\n\n    function autoAllocateThreshold() external view returns (uint256);\n\n    function setRebaseThreshold(uint256 _threshold) external;\n\n    function rebaseThreshold() external view returns (uint256);\n\n    function setStrategistAddr(address _address) external;\n\n    function strategistAddr() external view returns (address);\n\n    function setMaxSupplyDiff(uint256 _maxSupplyDiff) external;\n\n    function maxSupplyDiff() external view returns (uint256);\n\n    function setTrusteeAddress(address _address) external;\n\n    function trusteeAddress() external view returns (address);\n\n    function setTrusteeFeeBps(uint256 _basis) external;\n\n    function trusteeFeeBps() external view returns (uint256);\n\n    function ousdMetaStrategy() external view returns (address);\n\n    function setSwapper(address _swapperAddr) external;\n\n    function setSwapAllowedUndervalue(uint16 _percentageBps) external;\n\n    function setOracleSlippage(address _asset, uint16 _allowedOracleSlippageBps)\n        external;\n\n    function supportAsset(address _asset, uint8 _unitConversion) external;\n\n    function approveStrategy(address _addr) external;\n\n    function removeStrategy(address _addr) external;\n\n    function setAssetDefaultStrategy(address _asset, address _strategy)\n        external;\n\n    function assetDefaultStrategies(address _asset)\n        external\n        view\n        returns (address);\n\n    function pauseRebase() external;\n\n    function unpauseRebase() external;\n\n    function rebasePaused() external view returns (bool);\n\n    function pauseCapital() external;\n\n    function unpauseCapital() external;\n\n    function capitalPaused() external view returns (bool);\n\n    function transferToken(address _asset, uint256 _amount) external;\n\n    function priceUnitMint(address asset) external view returns (uint256);\n\n    function priceUnitRedeem(address asset) external view returns (uint256);\n\n    function withdrawAllFromStrategy(address _strategyAddr) external;\n\n    function withdrawAllFromStrategies() external;\n\n    function withdrawFromStrategy(\n        address _strategyFromAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external;\n\n    function depositToStrategy(\n        address _strategyToAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external;\n\n    // VaultCore.sol\n    function mint(\n        address _asset,\n        uint256 _amount,\n        uint256 _minimumOusdAmount\n    ) external;\n\n    function mintForStrategy(uint256 _amount) external;\n\n    function redeem(uint256 _amount, uint256 _minimumUnitAmount) external;\n\n    function burnForStrategy(uint256 _amount) external;\n\n    function allocate() external;\n\n    function rebase() external;\n\n    function swapCollateral(\n        address fromAsset,\n        address toAsset,\n        uint256 fromAssetAmount,\n        uint256 minToAssetAmount,\n        bytes calldata data\n    ) external returns (uint256 toAssetAmount);\n\n    function totalValue() external view returns (uint256 value);\n\n    function checkBalance(address _asset) external view returns (uint256);\n\n    function calculateRedeemOutputs(uint256 _amount)\n        external\n        view\n        returns (uint256[] memory);\n\n    function getAssetCount() external view returns (uint256);\n\n    function getAssetConfig(address _asset)\n        external\n        view\n        returns (VaultStorage.Asset memory config);\n\n    function getAllAssets() external view returns (address[] memory);\n\n    function getStrategyCount() external view returns (uint256);\n\n    function swapper() external view returns (address);\n\n    function allowedSwapUndervalue() external view returns (uint256);\n\n    function getAllStrategies() external view returns (address[] memory);\n\n    function isSupportedAsset(address _asset) external view returns (bool);\n\n    function netOusdMintForStrategyThreshold() external view returns (uint256);\n\n    function setOusdMetaStrategy(address _ousdMetaStrategy) external;\n\n    function setNetOusdMintForStrategyThreshold(uint256 _threshold) external;\n\n    function netOusdMintedForStrategy() external view returns (int256);\n\n    function setDripper(address _dripper) external;\n\n    function dripper() external view returns (address);\n\n    function weth() external view returns (address);\n\n    function cacheWETHAssetIndex() external;\n\n    function wethAssetIndex() external view returns (uint256);\n\n    function initialize(address, address) external;\n\n    function setAdminImpl(address) external;\n\n    function removeAsset(address _asset) external;\n\n    // These are OETH specific functions\n    function addWithdrawalQueueLiquidity() external;\n\n    function requestWithdrawal(uint256 _amount)\n        external\n        returns (uint256 requestId, uint256 queued);\n\n    function claimWithdrawal(uint256 requestId)\n        external\n        returns (uint256 amount);\n\n    function claimWithdrawals(uint256[] memory requestIds)\n        external\n        returns (uint256[] memory amounts, uint256 totalAmount);\n\n    function withdrawalQueueMetadata()\n        external\n        view\n        returns (VaultStorage.WithdrawalQueueMetadata memory);\n\n    function withdrawalRequests(uint256 requestId)\n        external\n        view\n        returns (VaultStorage.WithdrawalRequest memory);\n\n    // OETHb specific functions\n    function addStrategyToMintWhitelist(address strategyAddr) external;\n\n    function removeStrategyFromMintWhitelist(address strategyAddr) external;\n\n    function isMintWhitelistedStrategy(address strategyAddr)\n        external\n        view\n        returns (bool);\n\n    function withdrawalClaimDelay() external view returns (uint256);\n\n    function setWithdrawalClaimDelay(uint256 newDelay) external;\n\n    function lastRebase() external view returns (uint64);\n\n    function dripDuration() external view returns (uint64);\n\n    function setDripDuration(uint256 _dripDuration) external;\n\n    function rebasePerSecondMax() external view returns (uint64);\n\n    function setRebaseRateMax(uint256 yearlyApr) external;\n\n    function rebasePerSecondTarget() external view returns (uint64);\n\n    function previewYield() external view returns (uint256 yield);\n\n    // slither-disable-end constable-states\n}\n"
    },
    "contracts/interfaces/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWETH9 {\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    function allowance(address, address) external view returns (uint256);\n\n    function approve(address guy, uint256 wad) external returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function deposit() external payable;\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address dst, uint256 wad) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function withdraw(uint256 wad) external;\n}\n"
    },
    "contracts/interfaces/IWstETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWstETH {\n    /**\n     * @notice Get amount of wstETH for a given amount of stETH\n     * @param _stETHAmount amount of stETH\n     * @return Amount of wstETH for a given stETH amount\n     */\n    function getWstETHByStETH(uint256 _stETHAmount)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Get amount of stETH for a given amount of wstETH\n     * @param _wstETHAmount amount of wstETH\n     * @return Amount of stETH for a given wstETH amount\n     */\n    function getStETHByWstETH(uint256 _wstETHAmount)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Get amount of stETH for a one wstETH\n     * @return Amount of stETH for 1 wstETH\n     */\n    function stEthPerToken() external view returns (uint256);\n\n    /**\n     * @notice Get amount of wstETH for a one stETH\n     * @return Amount of wstETH for a 1 stETH\n     */\n    function tokensPerStEth() external view returns (uint256);\n\n    /**\n     * @notice Exchanges stETH to wstETH\n     * @param _stETHAmount amount of stETH to wrap in exchange for wstETH\n     * @dev Requirements:\n     *  - `_stETHAmount` must be non-zero\n     *  - msg.sender must approve at least `_stETHAmount` stETH to this\n     *    contract.\n     *  - msg.sender must have at least `_stETHAmount` of stETH.\n     * User should first approve _stETHAmount to the WstETH contract\n     * @return Amount of wstETH user receives after wrap\n     */\n    function wrap(uint256 _stETHAmount) external returns (uint256);\n\n    /**\n     * @notice Exchanges wstETH to stETH\n     * @param _wstETHAmount amount of wstETH to uwrap in exchange for stETH\n     * @dev Requirements:\n     *  - `_wstETHAmount` must be non-zero\n     *  - msg.sender must have at least `_wstETHAmount` wstETH.\n     * @return Amount of stETH user receives after unwrap\n     */\n    function unwrap(uint256 _wstETHAmount) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/morpho/compound/ICompoundOracle.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.0;\n\ninterface ICompoundOracle {\n    function getUnderlyingPrice(address) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/morpho/ILens.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.0;\n\nimport \"./compound/ICompoundOracle.sol\";\nimport \"./IMorpho.sol\";\n\ninterface ILens {\n    /// STORAGE ///\n\n    function MAX_BASIS_POINTS() external view returns (uint256);\n\n    function WAD() external view returns (uint256);\n\n    function morpho() external view returns (IMorpho);\n\n    function comptroller() external view returns (IComptroller);\n\n    /// GENERAL ///\n\n    function getTotalSupply()\n        external\n        view\n        returns (\n            uint256 p2pSupplyAmount,\n            uint256 poolSupplyAmount,\n            uint256 totalSupplyAmount\n        );\n\n    function getTotalBorrow()\n        external\n        view\n        returns (\n            uint256 p2pBorrowAmount,\n            uint256 poolBorrowAmount,\n            uint256 totalBorrowAmount\n        );\n\n    /// MARKETS ///\n\n    function isMarketCreated(address _poolToken) external view returns (bool);\n\n    function isMarketCreatedAndNotPaused(address _poolToken)\n        external\n        view\n        returns (bool);\n\n    function isMarketCreatedAndNotPausedNorPartiallyPaused(address _poolToken)\n        external\n        view\n        returns (bool);\n\n    function getAllMarkets()\n        external\n        view\n        returns (address[] memory marketsCreated_);\n\n    function getMainMarketData(address _poolToken)\n        external\n        view\n        returns (\n            uint256 avgSupplyRatePerBlock,\n            uint256 avgBorrowRatePerBlock,\n            uint256 p2pSupplyAmount,\n            uint256 p2pBorrowAmount,\n            uint256 poolSupplyAmount,\n            uint256 poolBorrowAmount\n        );\n\n    function getAdvancedMarketData(address _poolToken)\n        external\n        view\n        returns (\n            uint256 p2pSupplyIndex,\n            uint256 p2pBorrowIndex,\n            uint256 poolSupplyIndex,\n            uint256 poolBorrowIndex,\n            uint32 lastUpdateBlockNumber,\n            uint256 p2pSupplyDelta,\n            uint256 p2pBorrowDelta\n        );\n\n    function getMarketConfiguration(address _poolToken)\n        external\n        view\n        returns (\n            address underlying,\n            bool isCreated,\n            bool p2pDisabled,\n            bool isPaused,\n            bool isPartiallyPaused,\n            uint16 reserveFactor,\n            uint16 p2pIndexCursor,\n            uint256 collateralFactor\n        );\n\n    function getTotalMarketSupply(address _poolToken)\n        external\n        view\n        returns (uint256 p2pSupplyAmount, uint256 poolSupplyAmount);\n\n    function getTotalMarketBorrow(address _poolToken)\n        external\n        view\n        returns (uint256 p2pBorrowAmount, uint256 poolBorrowAmount);\n\n    /// INDEXES ///\n\n    function getCurrentP2PSupplyIndex(address _poolToken)\n        external\n        view\n        returns (uint256);\n\n    function getCurrentP2PBorrowIndex(address _poolToken)\n        external\n        view\n        returns (uint256);\n\n    function getCurrentPoolIndexes(address _poolToken)\n        external\n        view\n        returns (\n            uint256 currentPoolSupplyIndex,\n            uint256 currentPoolBorrowIndex\n        );\n\n    function getIndexes(address _poolToken, bool _computeUpdatedIndexes)\n        external\n        view\n        returns (\n            uint256 p2pSupplyIndex,\n            uint256 p2pBorrowIndex,\n            uint256 poolSupplyIndex,\n            uint256 poolBorrowIndex\n        );\n\n    /// USERS ///\n\n    function getEnteredMarkets(address _user)\n        external\n        view\n        returns (address[] memory enteredMarkets);\n\n    function getUserHealthFactor(\n        address _user,\n        address[] calldata _updatedMarkets\n    ) external view returns (uint256);\n\n    function getUserBalanceStates(\n        address _user,\n        address[] calldata _updatedMarkets\n    )\n        external\n        view\n        returns (\n            uint256 collateralValue,\n            uint256 debtValue,\n            uint256 maxDebtValue\n        );\n\n    function getCurrentSupplyBalanceInOf(address _poolToken, address _user)\n        external\n        view\n        returns (\n            uint256 balanceOnPool,\n            uint256 balanceInP2P,\n            uint256 totalBalance\n        );\n\n    function getCurrentBorrowBalanceInOf(address _poolToken, address _user)\n        external\n        view\n        returns (\n            uint256 balanceOnPool,\n            uint256 balanceInP2P,\n            uint256 totalBalance\n        );\n\n    function getUserMaxCapacitiesForAsset(address _user, address _poolToken)\n        external\n        view\n        returns (uint256 withdrawable, uint256 borrowable);\n\n    function getUserHypotheticalBalanceStates(\n        address _user,\n        address _poolToken,\n        uint256 _withdrawnAmount,\n        uint256 _borrowedAmount\n    ) external view returns (uint256 debtValue, uint256 maxDebtValue);\n\n    function getUserLiquidityDataForAsset(\n        address _user,\n        address _poolToken,\n        bool _computeUpdatedIndexes,\n        ICompoundOracle _oracle\n    ) external view returns (Types.AssetLiquidityData memory assetData);\n\n    function isLiquidatable(address _user, address[] memory _updatedMarkets)\n        external\n        view\n        returns (bool);\n\n    function computeLiquidationRepayAmount(\n        address _user,\n        address _poolTokenBorrowed,\n        address _poolTokenCollateral,\n        address[] calldata _updatedMarkets\n    ) external view returns (uint256 toRepay);\n\n    /// RATES ///\n\n    function getAverageSupplyRatePerBlock(address _poolToken)\n        external\n        view\n        returns (\n            uint256 avgSupplyRatePerBlock,\n            uint256 p2pSupplyAmount,\n            uint256 poolSupplyAmount\n        );\n\n    function getAverageBorrowRatePerBlock(address _poolToken)\n        external\n        view\n        returns (\n            uint256 avgBorrowRatePerBlock,\n            uint256 p2pBorrowAmount,\n            uint256 poolBorrowAmount\n        );\n\n    function getNextUserSupplyRatePerBlock(\n        address _poolToken,\n        address _user,\n        uint256 _amount\n    )\n        external\n        view\n        returns (\n            uint256 nextSupplyRatePerBlock,\n            uint256 balanceOnPool,\n            uint256 balanceInP2P,\n            uint256 totalBalance\n        );\n\n    function getNextUserBorrowRatePerBlock(\n        address _poolToken,\n        address _user,\n        uint256 _amount\n    )\n        external\n        view\n        returns (\n            uint256 nextBorrowRatePerBlock,\n            uint256 balanceOnPool,\n            uint256 balanceInP2P,\n            uint256 totalBalance\n        );\n\n    function getCurrentUserSupplyRatePerBlock(address _poolToken, address _user)\n        external\n        view\n        returns (uint256);\n\n    function getCurrentUserBorrowRatePerBlock(address _poolToken, address _user)\n        external\n        view\n        returns (uint256);\n\n    function getRatesPerBlock(address _poolToken)\n        external\n        view\n        returns (\n            uint256 p2pSupplyRate,\n            uint256 p2pBorrowRate,\n            uint256 poolSupplyRate,\n            uint256 poolBorrowRate\n        );\n\n    /// REWARDS ///\n\n    function getUserUnclaimedRewards(\n        address[] calldata _poolTokens,\n        address _user\n    ) external view returns (uint256 unclaimedRewards);\n\n    function getAccruedSupplierComp(\n        address _supplier,\n        address _poolToken,\n        uint256 _balance\n    ) external view returns (uint256);\n\n    function getAccruedBorrowerComp(\n        address _borrower,\n        address _poolToken,\n        uint256 _balance\n    ) external view returns (uint256);\n\n    function getCurrentCompSupplyIndex(address _poolToken)\n        external\n        view\n        returns (uint256);\n\n    function getCurrentCompBorrowIndex(address _poolToken)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/interfaces/morpho/IMorpho.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.0;\n\nimport \"./Types.sol\";\nimport \"../IComptroller.sol\";\nimport \"./compound/ICompoundOracle.sol\";\n\n// prettier-ignore\ninterface IMorpho {\n    function comptroller() external view returns (IComptroller);\n    function supply(address _poolTokenAddress, address _onBehalf, uint256 _amount) external;\n    function supply(address _poolTokenAddress, address _onBehalf, uint256 _amount, uint256 _maxGasForMatching) external;\n    function withdraw(address _poolTokenAddress, uint256 _amount) external;\n    function claimRewards(\n        address[] calldata _cTokenAddresses,\n        bool _tradeForMorphoToken\n    ) external returns (uint256 claimedAmount);\n}\n"
    },
    "contracts/interfaces/morpho/Types.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.0;\n\n/// @title Types.\n/// @author Morpho Labs.\n/// @custom:contact security@morpho.xyz\n/// @dev Common types and structs used in Moprho contracts.\nlibrary Types {\n    /// ENUMS ///\n\n    enum PositionType {\n        SUPPLIERS_IN_P2P,\n        SUPPLIERS_ON_POOL,\n        BORROWERS_IN_P2P,\n        BORROWERS_ON_POOL\n    }\n\n    /// STRUCTS ///\n\n    struct SupplyBalance {\n        uint256 inP2P; // In supplier's peer-to-peer unit, a unit that grows in underlying value, to keep track of the interests earned by suppliers in peer-to-peer. Multiply by the peer-to-peer supply index to get the underlying amount.\n        uint256 onPool; // In cToken. Multiply by the pool supply index to get the underlying amount.\n    }\n\n    struct BorrowBalance {\n        uint256 inP2P; // In borrower's peer-to-peer unit, a unit that grows in underlying value, to keep track of the interests paid by borrowers in peer-to-peer. Multiply by the peer-to-peer borrow index to get the underlying amount.\n        uint256 onPool; // In cdUnit, a unit that grows in value, to keep track of the debt increase when borrowers are on Compound. Multiply by the pool borrow index to get the underlying amount.\n    }\n\n    // Max gas to consume during the matching process for supply, borrow, withdraw and repay functions.\n    struct MaxGasForMatching {\n        uint64 supply;\n        uint64 borrow;\n        uint64 withdraw;\n        uint64 repay;\n    }\n\n    struct Delta {\n        uint256 p2pSupplyDelta; // Difference between the stored peer-to-peer supply amount and the real peer-to-peer supply amount (in pool supply unit).\n        uint256 p2pBorrowDelta; // Difference between the stored peer-to-peer borrow amount and the real peer-to-peer borrow amount (in pool borrow unit).\n        uint256 p2pSupplyAmount; // Sum of all stored peer-to-peer supply (in peer-to-peer supply unit).\n        uint256 p2pBorrowAmount; // Sum of all stored peer-to-peer borrow (in peer-to-peer borrow unit).\n    }\n\n    struct AssetLiquidityData {\n        uint256 collateralValue; // The collateral value of the asset.\n        uint256 maxDebtValue; // The maximum possible debt value of the asset.\n        uint256 debtValue; // The debt value of the asset.\n        uint256 underlyingPrice; // The price of the token.\n        uint256 collateralFactor; // The liquidation threshold applied on this token.\n    }\n\n    struct LiquidityData {\n        uint256 collateralValue; // The collateral value.\n        uint256 maxDebtValue; // The maximum debt value possible.\n        uint256 debtValue; // The debt value.\n    }\n\n    // Variables are packed together to save gas (will not exceed their limit during Morpho's lifetime).\n    struct LastPoolIndexes {\n        uint32 lastUpdateBlockNumber; // The last time the peer-to-peer indexes were updated.\n        uint112 lastSupplyPoolIndex; // Last pool supply index.\n        uint112 lastBorrowPoolIndex; // Last pool borrow index.\n    }\n\n    struct MarketParameters {\n        uint16 reserveFactor; // Proportion of the interest earned by users sent to the DAO for each market, in basis point (100% = 10 000). The value is set at market creation.\n        uint16 p2pIndexCursor; // Position of the peer-to-peer rate in the pool's spread. Determine the weights of the weighted arithmetic average in the indexes computations ((1 - p2pIndexCursor) * r^S + p2pIndexCursor * r^B) (in basis point).\n    }\n\n    struct MarketStatus {\n        bool isCreated; // Whether or not this market is created.\n        bool isPaused; // Whether the market is paused or not (all entry points on Morpho are frozen; supply, borrow, withdraw, repay and liquidate).\n        bool isPartiallyPaused; // Whether the market is partially paused or not (only supply and borrow are frozen).\n    }\n}\n"
    },
    "contracts/interfaces/plume/IFeeRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// As the copyright holder of this work, Ubiquity Labs retains\n// the right to distribute, use, and modify this code under any license of\n// their choosing, in addition to the terms of the GPL-v2 or later.\npragma solidity ^0.8.25;\n\ninterface IFeeRegistry {\n    function registerFee(\n        bool isTokenA,\n        uint32 binId,\n        uint256 binFeeInQuote\n    ) external;\n}\n"
    },
    "contracts/interfaces/plume/ILiquidityRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// As the copyright holder of this work, Ubiquity Labs retains\n// the right to distribute, use, and modify this code under any license of\n// their choosing, in addition to the terms of the GPL-v2 or later.\npragma solidity ^0.8.25;\n\nimport { IMaverickV2Pool } from \"./IMaverickV2Pool.sol\";\n\ninterface ILiquidityRegistry {\n    function notifyBinLiquidity(\n        IMaverickV2Pool pool,\n        uint256 tokenId,\n        uint32 binId,\n        uint256 currentBinLpBalance\n    ) external;\n}\n"
    },
    "contracts/interfaces/plume/IMaverickV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// As the copyright holder of this work, Ubiquity Labs retains\n// the right to distribute, use, and modify this code under any license of\n// their choosing, in addition to the terms of the GPL-v2 or later.\npragma solidity ^0.8.25;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IFeeRegistry } from \"./IFeeRegistry.sol\";\nimport { IMaverickV2Pool } from \"./IMaverickV2Pool.sol\";\n\ninterface IMaverickV2Factory {\n    error FactorAlreadyInitialized();\n    error FactorNotInitialized();\n    error FactoryInvalidTokenOrder(IERC20 _tokenA, IERC20 _tokenB);\n    error FactoryInvalidFee();\n    error FactoryInvalidKinds(uint8 kinds);\n    error FactoryInvalidTickSpacing(uint256 tickSpacing);\n    error FactoryInvalidLookback(uint256 lookback);\n    error FactoryInvalidTokenDecimals(uint8 decimalsA, uint8 decimalsB);\n    error FactoryPoolAlreadyExists(\n        uint256 feeAIn,\n        uint256 feeBIn,\n        uint256 tickSpacing,\n        uint256 lookback,\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint8 kinds,\n        address accessor\n    );\n    error FactoryAccessorMustBeNonZero();\n    error NotImplemented();\n\n    event PoolCreated(\n        IMaverickV2Pool poolAddress,\n        uint8 protocolFeeRatio,\n        uint256 feeAIn,\n        uint256 feeBIn,\n        uint256 tickSpacing,\n        uint256 lookback,\n        int32 activeTick,\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint8 kinds,\n        address accessor\n    );\n    event SetFactoryProtocolFeeReceiver(address receiver);\n    event SetFactoryProtocolFeeRegistry(IFeeRegistry registry);\n\n    struct DeployParameters {\n        uint64 feeAIn;\n        uint64 feeBIn;\n        uint32 lookback;\n        int32 activeTick;\n        uint64 tokenAScale;\n        uint64 tokenBScale;\n        // slot\n        IERC20 tokenA;\n        // slot\n        IERC20 tokenB;\n        // slot\n        uint16 tickSpacing;\n        uint8 options;\n        address accessor;\n    }\n\n    /**\n     * @notice Called by deployer library to initialize a pool.\n     */\n    function deployParameters()\n        external\n        view\n        returns (\n            uint64 feeAIn,\n            uint64 feeBIn,\n            uint32 lookback,\n            int32 activeTick,\n            uint64 tokenAScale,\n            uint64 tokenBScale,\n            // slot\n            IERC20 tokenA,\n            // slot\n            IERC20 tokenB,\n            // slot\n            uint16 tickSpacing,\n            uint8 options,\n            address accessor\n        );\n\n    /**\n     * @notice Create a new MaverickV2Pool with symmetric swap fees.\n     * @param fee Fraction of the pool swap amount that is retained as an LP in\n     * D18 scale.\n     * @param tickSpacing Tick spacing of pool where 1.0001^tickSpacing is the\n     * bin width.\n     * @param lookback Pool lookback in seconds.\n     * @param tokenA Address of tokenA.\n     * @param tokenB Address of tokenB.\n     * @param activeTick Tick position that contains the active bins.\n     * @param kinds 1-15 number to represent the active kinds\n     * 0b0001 = static;\n     * 0b0010 = right;\n     * 0b0100 = left;\n     * 0b1000 = both.\n     * E.g. a pool with all 4 modes will have kinds = b1111 = 15\n     */\n    function create(\n        uint64 fee,\n        uint16 tickSpacing,\n        uint32 lookback,\n        IERC20 tokenA,\n        IERC20 tokenB,\n        int32 activeTick,\n        uint8 kinds\n    ) external returns (IMaverickV2Pool);\n\n    /**\n     * @notice Create a new MaverickV2Pool.\n     * @param feeAIn Fraction of the pool swap amount for tokenA-input swaps\n     * that is retained as an LP in D18 scale.\n     * @param feeBIn Fraction of the pool swap amount for tokenB-input swaps\n     * that is retained as an LP in D18 scale.\n     * @param tickSpacing Tick spacing of pool where 1.0001^tickSpacing is the\n     * bin width.\n     * @param lookback Pool lookback in seconds.\n     * @param tokenA Address of tokenA.\n     * @param tokenB Address of tokenB.\n     * @param activeTick Tick position that contains the active bins.\n     * @param kinds 1-15 number to represent the active kinds\n     * 0b0001 = static;\n     * 0b0010 = right;\n     * 0b0100 = left;\n     * 0b1000 = both.\n     * e.g. a pool with all 4 modes will have kinds = b1111 = 15\n     */\n    function create(\n        uint64 feeAIn,\n        uint64 feeBIn,\n        uint16 tickSpacing,\n        uint32 lookback,\n        IERC20 tokenA,\n        IERC20 tokenB,\n        int32 activeTick,\n        uint8 kinds\n    ) external returns (IMaverickV2Pool);\n\n    /**\n     * @notice Bool indicating whether the pool was deployed from this factory.\n     */\n    function isFactoryPool(IMaverickV2Pool pool) external view returns (bool);\n\n    /**\n     * @notice Address that receives the protocol fee\n     */\n    function protocolFeeReceiver() external view returns (address);\n\n    /**\n     * @notice Address notified on swaps of the protocol fee\n     */\n    function protocolFeeRegistry() external view returns (IFeeRegistry);\n\n    /**\n     * @notice Lookup a pool for given parameters.\n     */\n    function lookup(\n        uint256 feeAIn,\n        uint256 feeBIn,\n        uint256 tickSpacing,\n        uint256 lookback,\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint8 kinds\n    ) external view returns (IMaverickV2Pool);\n\n    /**\n     * @notice Lookup a pool for given parameters.\n     */\n    function lookup(\n        IERC20 _tokenA,\n        IERC20 _tokenB,\n        uint256 startIndex,\n        uint256 endIndex\n    ) external view returns (IMaverickV2Pool[] memory pools);\n\n    /**\n     * @notice Lookup a pool for given parameters.\n     */\n    function lookup(uint256 startIndex, uint256 endIndex)\n        external\n        view\n        returns (IMaverickV2Pool[] memory pools);\n\n    /**\n     * @notice Count of permissionless pools.\n     */\n    function poolCount() external view returns (uint256 _poolCount);\n\n    /**\n     * @notice Count of pools for a given accessor and token pair.  For\n     * permissionless pools, pass `accessor = address(0)`.\n     */\n    function poolByTokenCount(\n        IERC20 _tokenA,\n        IERC20 _tokenB,\n        address accessor\n    ) external view returns (uint256 _poolCount);\n\n    /**\n     * @notice Get the current factory owner.\n     */\n    function owner() external view returns (address);\n}\n"
    },
    "contracts/interfaces/plume/IMaverickV2LiquidityManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.25;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IMaverickV2Pool } from \"./IMaverickV2Pool.sol\";\n\nimport { IMaverickV2Position } from \"./IMaverickV2Position.sol\";\nimport { IMaverickV2PoolLens } from \"./IMaverickV2PoolLens.sol\";\n\ninterface IMaverickV2LiquidityManager {\n    error LiquidityManagerNotFactoryPool();\n    error LiquidityManagerNotTokenIdOwner();\n\n    /**\n     * @notice Maverick V2 NFT position contract that tracks NFT-based\n     * liquditiy positions.\n     */\n    function position() external view returns (IMaverickV2Position);\n\n    /**\n     * @notice Create Maverick V2 pool.  Function is a pass through to the pool\n     * factory and is provided here so that is can be assembled as part of a\n     * multicall transaction.\n     */\n    function createPool(\n        uint64 fee,\n        uint16 tickSpacing,\n        uint32 lookback,\n        IERC20 tokenA,\n        IERC20 tokenB,\n        int32 activeTick,\n        uint8 kinds\n    ) external payable returns (IMaverickV2Pool pool);\n\n    /**\n     * @notice Add Liquidity position NFT for msg.sender by specifying\n     * msg.sender's token index.\n     * @dev Token index is different from tokenId.\n     * On the Position NFT contract a user can own multiple NFT tokenIds and\n     * these are indexes by an enumeration index which is the `index` input\n     * here.\n     *\n     * See addLiquidity for a description of the add params.\n     */\n    function addPositionLiquidityToSenderByTokenIndex(\n        IMaverickV2Pool pool,\n        uint256 index,\n        bytes memory packedSqrtPriceBreaks,\n        bytes[] memory packedArgs\n    )\n        external\n        payable\n        returns (\n            uint256 tokenAAmount,\n            uint256 tokenBAmount,\n            uint32[] memory binIds\n        );\n\n    /**\n     * @notice Mint new tokenId in the Position NFt contract to msg.sender.\n     * Both mints an NFT and adds liquidity to the pool that is held by the\n     * NFT.\n     */\n    function mintPositionNftToSender(\n        IMaverickV2Pool pool,\n        bytes calldata packedSqrtPriceBreaks,\n        bytes[] calldata packedArgs\n    )\n        external\n        payable\n        returns (\n            uint256 tokenAAmount,\n            uint256 tokenBAmount,\n            uint32[] memory binIds,\n            uint256 tokenId\n        );\n\n    /**\n     * @notice Donates liqudity to a pool that is held by the position contract\n     * and will never be retrievable.  Can be used to start a pool and ensure\n     * there will always be a base level of liquditiy in the pool.\n     */\n    function donateLiquidity(\n        IMaverickV2Pool pool,\n        IMaverickV2Pool.AddLiquidityParams memory args\n    ) external payable;\n\n    /**\n     * @notice Packs sqrtPrice breaks array with this format: [length,\n     * array[0], array[1],..., array[length-1]] where length is 1 byte.\n     */\n    function packUint88Array(uint88[] memory fullArray)\n        external\n        pure\n        returns (bytes memory packedArray);\n\n    /**\n     * @notice Packs addLiquidity paramters array element-wise.\n     */\n    function packAddLiquidityArgsArray(\n        IMaverickV2Pool.AddLiquidityParams[] memory args\n    ) external pure returns (bytes[] memory argsPacked);\n}\n"
    },
    "contracts/interfaces/plume/IMaverickV2Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// As the copyright holder of this work, Ubiquity Labs retains\n// the right to distribute, use, and modify this code under any license of\n// their choosing, in addition to the terms of the GPL-v2 or later.\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IMaverickV2Factory } from \"./IMaverickV2Factory.sol\";\n\ninterface IMaverickV2Pool {\n    error PoolZeroLiquidityAdded();\n    error PoolMinimumLiquidityNotMet();\n    error PoolLocked();\n    error PoolInvalidFee();\n    error PoolTicksNotSorted(uint256 index, int256 previousTick, int256 tick);\n    error PoolTicksAmountsLengthMismatch(\n        uint256 ticksLength,\n        uint256 amountsLength\n    );\n    error PoolBinIdsAmountsLengthMismatch(\n        uint256 binIdsLength,\n        uint256 amountsLength\n    );\n    error PoolKindNotSupported(uint256 kinds, uint256 kind);\n    error PoolInsufficientBalance(\n        uint256 deltaLpAmount,\n        uint256 accountBalance\n    );\n    error PoolReservesExceedMaximum(uint256 amount);\n    error PoolValueExceedsBits(uint256 amount, uint256 bits);\n    error PoolTickMaxExceeded(uint256 tick);\n    error PoolMigrateBinFirst();\n    error PoolCurrentTickBeyondSwapLimit(int32 startingTick);\n    error PoolSenderNotAccessor(address sender_, address accessor);\n    error PoolSenderNotFactory(address sender_, address accessor);\n    error PoolFunctionNotImplemented();\n    error PoolTokenNotSolvent(\n        uint256 internalReserve,\n        uint256 tokenBalance,\n        IERC20 token\n    );\n    error PoolNoProtocolFeeReceiverSet();\n\n    event PoolSwap(\n        address sender,\n        address recipient,\n        SwapParams params,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    event PoolFlashLoan(\n        address sender,\n        address recipient,\n        uint256 amountA,\n        uint256 amountB\n    );\n    event PoolProtocolFeeCollected(IERC20 token, uint256 protocolFee);\n\n    event PoolAddLiquidity(\n        address sender,\n        address recipient,\n        uint256 subaccount,\n        AddLiquidityParams params,\n        uint256 tokenAAmount,\n        uint256 tokenBAmount,\n        uint32[] binIds\n    );\n\n    event PoolMigrateBinsUpStack(\n        address sender,\n        uint32 binId,\n        uint32 maxRecursion\n    );\n\n    event PoolRemoveLiquidity(\n        address sender,\n        address recipient,\n        uint256 subaccount,\n        RemoveLiquidityParams params,\n        uint256 tokenAOut,\n        uint256 tokenBOut\n    );\n\n    event PoolTickState(int32 tick, uint256 reserveA, uint256 reserveB);\n    event PoolTickBinUpdate(int32 tick, uint8 kind, uint32 binId);\n    event PoolSqrtPrice(uint256 sqrtPrice);\n\n    /**\n     * @notice Tick state parameters.\n     */\n    struct TickState {\n        uint128 reserveA;\n        uint128 reserveB;\n        uint128 totalSupply;\n        uint32[4] binIdsByTick;\n    }\n\n    /**\n     * @notice Tick data parameters.\n     * @param currentReserveA Current reserve of token A.\n     * @param currentReserveB Current reserve of token B.\n     * @param currentLiquidity Current liquidity amount.\n     */\n    struct TickData {\n        uint256 currentReserveA;\n        uint256 currentReserveB;\n        uint256 currentLiquidity;\n    }\n\n    /**\n     * @notice Bin state parameters.\n     * @param mergeBinBalance LP token balance that this bin possesses of the merge bin.\n     * @param mergeId Bin ID of the bin that this bin has merged into.\n     * @param totalSupply Total amount of LP tokens in this bin.\n     * @param kind One of the 4 kinds (0=static, 1=right, 2=left, 3=both).\n     * @param tick The lower price tick of the bin in its current state.\n     * @param tickBalance Balance of the tick.\n     */\n    struct BinState {\n        uint128 mergeBinBalance;\n        uint128 tickBalance;\n        uint128 totalSupply;\n        uint8 kind;\n        int32 tick;\n        uint32 mergeId;\n    }\n\n    /**\n     * @notice Parameters for swap.\n     * @param amount Amount of the token that is either the input if exactOutput is false\n     * or the output if exactOutput is true.\n     * @param tokenAIn Boolean indicating whether tokenA is the input.\n     * @param exactOutput Boolean indicating whether the amount specified is\n     * the exact output amount (true).\n     * @param tickLimit The furthest tick a swap will execute in. If no limit\n     * is desired, value should be set to type(int32).max for a tokenAIn swap\n     * and type(int32).min for a swap where tokenB is the input.\n     */\n    struct SwapParams {\n        uint256 amount;\n        bool tokenAIn;\n        bool exactOutput;\n        int32 tickLimit;\n    }\n\n    /**\n     * @notice Parameters associated with adding liquidity.\n     * @param kind One of the 4 kinds (0=static, 1=right, 2=left, 3=both).\n     * @param ticks Array of ticks to add liquidity to.\n     * @param amounts Array of bin LP amounts to add.\n     */\n    struct AddLiquidityParams {\n        uint8 kind;\n        int32[] ticks;\n        uint128[] amounts;\n    }\n\n    /**\n     * @notice Parameters for each bin that will have liquidity removed.\n     * @param binIds Index array of the bins losing liquidity.\n     * @param amounts Array of bin LP amounts to remove.\n     */\n    struct RemoveLiquidityParams {\n        uint32[] binIds;\n        uint128[] amounts;\n    }\n\n    /**\n     * @notice State of the pool.\n     * @param reserveA Pool tokenA balanceOf at end of last operation\n     * @param reserveB Pool tokenB balanceOf at end of last operation\n     * @param lastTwaD8 Value of log time weighted average price at last block.\n     * Value is 8-decimal scale and is in the fractional tick domain.  E.g. a\n     * value of 12.3e8 indicates the TWAP was 3/10ths of the way into the 12th\n     * tick.\n     * @param lastLogPriceD8 Value of log price at last block. Value is\n     * 8-decimal scale and is in the fractional tick domain.  E.g. a value of\n     * 12.3e8 indicates the price was 3/10ths of the way into the 12th tick.\n     * @param lastTimestamp Last block.timestamp value in seconds for latest\n     * swap transaction.\n     * @param activeTick Current tick position that contains the active bins.\n     * @param isLocked Pool isLocked, E.g., locked or unlocked; isLocked values\n     * defined in Pool.sol.\n     * @param binCounter Index of the last bin created.\n     * @param protocolFeeRatioD3 Ratio of the swap fee that is kept for the\n     * protocol.\n     */\n    struct State {\n        uint128 reserveA;\n        uint128 reserveB;\n        int64 lastTwaD8;\n        int64 lastLogPriceD8;\n        uint40 lastTimestamp;\n        int32 activeTick;\n        bool isLocked;\n        uint32 binCounter;\n        uint8 protocolFeeRatioD3;\n    }\n\n    /**\n     * @notice Internal data used for data passing between Pool and Bin code.\n     */\n    struct BinDelta {\n        uint128 deltaA;\n        uint128 deltaB;\n    }\n\n    /**\n     * @notice 1-15 number to represent the active kinds.\n     * @notice 0b0001 = static;\n     * @notice 0b0010 = right;\n     * @notice 0b0100 = left;\n     * @notice 0b1000 = both;\n     *\n     * E.g. a pool with all 4 modes will have kinds = b1111 = 15\n     */\n    function kinds() external view returns (uint8 _kinds);\n\n    /**\n     * @notice Pool swap fee for the given direction (A-in or B-in swap) in\n     * 18-decimal format. E.g. 0.01e18 is a 1% swap fee.\n     */\n    function fee(bool tokenAIn) external view returns (uint256);\n\n    /**\n     * @notice TickSpacing of pool where 1.0001^tickSpacing is the bin width.\n     */\n    function tickSpacing() external view returns (uint256);\n\n    /**\n     * @notice Lookback period of pool in seconds.\n     */\n    function lookback() external view returns (uint256);\n\n    /**\n     * @notice Address of Pool accessor.  This is Zero address for\n     * permissionless pools.\n     */\n    function accessor() external view returns (address);\n\n    /**\n     * @notice Pool tokenA.  Address of tokenA is such that tokenA < tokenB.\n     */\n    function tokenA() external view returns (IERC20);\n\n    /**\n     * @notice Pool tokenB.\n     */\n    function tokenB() external view returns (IERC20);\n\n    /**\n     * @notice Deploying factory of the pool and also contract that has ability\n     * to set and collect protocol fees for the pool.\n     */\n    function factory() external view returns (IMaverickV2Factory);\n\n    /**\n     * @notice Most significant bit of scale value is a flag to indicate whether\n     * tokenA has more or less than 18 decimals.  Scale is used in conjuction\n     * with Math.toScale/Math.fromScale functions to convert from token amounts\n     * to D18 scale internal pool accounting.\n     */\n    function tokenAScale() external view returns (uint256);\n\n    /**\n     * @notice Most significant bit of scale value is a flag to indicate whether\n     * tokenA has more or less than 18 decimals.  Scale is used in conjuction\n     * with Math.toScale/Math.fromScale functions to convert from token amounts\n     * to D18 scale internal pool accounting.\n     */\n    function tokenBScale() external view returns (uint256);\n\n    /**\n     * @notice ID of bin at input tick position and kind.\n     */\n    function binIdByTickKind(int32 tick, uint256 kind)\n        external\n        view\n        returns (uint32);\n\n    /**\n     * @notice Accumulated tokenA protocol fee.\n     */\n    function protocolFeeA() external view returns (uint128);\n\n    /**\n     * @notice Accumulated tokenB protocol fee.\n     */\n    function protocolFeeB() external view returns (uint128);\n\n    /**\n     * @notice Lending fee rate on flash loans.\n     */\n    function lendingFeeRateD18() external view returns (uint256);\n\n    /**\n     * @notice External function to get the current time-weighted average price.\n     */\n    function getCurrentTwa() external view returns (int256);\n\n    /**\n     * @notice External function to get the state of the pool.\n     */\n    function getState() external view returns (State memory);\n\n    /**\n     * @notice Return state of Bin at input binId.\n     */\n    function getBin(uint32 binId) external view returns (BinState memory bin);\n\n    /**\n     * @notice Return state of Tick at input tick position.\n     */\n    function getTick(int32 tick)\n        external\n        view\n        returns (TickState memory tickState);\n\n    /**\n     * @notice Retrieves the balance of a user within a bin.\n     * @param user The user's address.\n     * @param subaccount The subaccount for the user.\n     * @param binId The ID of the bin.\n     */\n    function balanceOf(\n        address user,\n        uint256 subaccount,\n        uint32 binId\n    ) external view returns (uint128 lpToken);\n\n    /**\n     * @notice Add liquidity to a pool. This function allows users to deposit\n     * tokens into a liquidity pool.\n     * @dev This function will call `maverickV2AddLiquidityCallback` on the\n     * calling contract to collect the tokenA/tokenB payment.\n     * @param recipient The account that will receive credit for the added liquidity.\n     * @param subaccount The account that will receive credit for the added liquidity.\n     * @param params Parameters containing the details for adding liquidity,\n     * such as token types and amounts.\n     * @param data Bytes information that gets passed to the callback.\n     * @return tokenAAmount The amount of token A added to the pool.\n     * @return tokenBAmount The amount of token B added to the pool.\n     * @return binIds An array of bin IDs where the liquidity is stored.\n     */\n    function addLiquidity(\n        address recipient,\n        uint256 subaccount,\n        AddLiquidityParams calldata params,\n        bytes calldata data\n    )\n        external\n        returns (\n            uint256 tokenAAmount,\n            uint256 tokenBAmount,\n            uint32[] memory binIds\n        );\n\n    /**\n     * @notice Removes liquidity from the pool.\n     * @dev Liquidy can only be removed from a bin that is either unmerged or\n     * has a mergeId of an unmerged bin.  If a bin is merged more than one\n     * level deep, it must be migrated up the merge stack to the root bin\n     * before liquidity removal.\n     * @param recipient The address to receive the tokens.\n     * @param subaccount The subaccount for the recipient.\n     * @param params The parameters for removing liquidity.\n     * @return tokenAOut The amount of token A received.\n     * @return tokenBOut The amount of token B received.\n     */\n    function removeLiquidity(\n        address recipient,\n        uint256 subaccount,\n        RemoveLiquidityParams calldata params\n    ) external returns (uint256 tokenAOut, uint256 tokenBOut);\n\n    /**\n     * @notice Migrate bins up the linked list of merged bins so that its\n     * mergeId is the currrent active bin.\n     * @dev Liquidy can only be removed from a bin that is either unmerged or\n     * has a mergeId of an unmerged bin.  If a bin is merged more than one\n     * level deep, it must be migrated up the merge stack to the root bin\n     * before liquidity removal.\n     * @param binId The ID of the bin to migrate.\n     * @param maxRecursion The maximum recursion depth for the migration.\n     */\n    function migrateBinUpStack(uint32 binId, uint32 maxRecursion) external;\n\n    /**\n     * @notice Swap tokenA/tokenB assets in the pool.  The swap user has two\n     * options for funding their swap.\n     * - The user can push the input token amount to the pool before calling\n     * the swap function. In order to avoid having the pool call the callback,\n     * the user should pass a zero-length `data` bytes object with the swap\n     * call.\n     * - The user can send the input token amount to the pool when the pool\n     * calls the `maverickV2SwapCallback` function on the calling contract.\n     * That callback has input parameters that specify the token address of the\n     * input token, the input and output amounts, and the bytes data sent to\n     * the swap function.\n     * @dev  If the users elects to do a callback-based swap, the output\n     * assets will be sent before the callback is called, allowing the user to\n     * execute flash swaps.  However, the pool does have reentrancy protection,\n     * so a swapper will not be able to interact with the same pool again\n     * while they are in the callback function.\n     * @param recipient The address to receive the output tokens.\n     * @param params Parameters containing the details of the swap\n     * @param data Bytes information that gets passed to the callback.\n     */\n    function swap(\n        address recipient,\n        SwapParams memory params,\n        bytes calldata data\n    ) external returns (uint256 amountIn, uint256 amountOut);\n\n    /**\n     * @notice Loan tokenA/tokenB assets from the pool to recipient. The fee\n     * rate of a loan is determined by `lendingFeeRateD18`, which is set at the\n     * protocol level by the factory.  This function calls\n     * `maverickV2FlashLoanCallback` on the calling contract.  At the end of\n     * the callback, the caller must pay back the loan with fee (if there is a\n     * fee).\n     * @param recipient The address to receive the loaned tokens.\n     * @param amountB Loan amount of tokenA sent to recipient.\n     * @param amountB Loan amount of tokenB sent to recipient.\n     * @param data Bytes information that gets passed to the callback.\n     */\n    function flashLoan(\n        address recipient,\n        uint256 amountA,\n        uint256 amountB,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice Distributes accumulated protocol fee to factory protocolFeeReceiver\n     */\n    function distributeFees(bool isTokenA)\n        external\n        returns (uint256 protocolFee, IERC20 token);\n}\n"
    },
    "contracts/interfaces/plume/IMaverickV2PoolLens.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.25;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IMaverickV2Factory } from \"./IMaverickV2Factory.sol\";\nimport { IMaverickV2Pool } from \"./IMaverickV2Pool.sol\";\n\ninterface IMaverickV2PoolLens {\n    error LensTargetPriceOutOfBounds(\n        uint256 targetSqrtPrice,\n        uint256 sqrtLowerTickPrice,\n        uint256 sqrtUpperTickPrice\n    );\n    error LensTooLittleLiquidity(\n        uint256 relativeLiquidityAmount,\n        uint256 deltaA,\n        uint256 deltaB\n    );\n    error LensTargetingTokenWithNoDelta(\n        bool targetIsA,\n        uint256 deltaA,\n        uint256 deltaB\n    );\n\n    /**\n     * @notice Add liquidity slippage parameters for a distribution of liquidity.\n     * @param pool Pool where liquidity is being added.\n     * @param kind Bin kind; all bins must have the same kind in a given call\n     * to addLiquidity.\n     * @param ticks Array of tick values to add liquidity to.\n     * @param relativeLiquidityAmounts Relative liquidity amounts for the\n     * specified ticks.  Liquidity in this case is not bin LP balance, it is\n     * the bin liquidity as defined by liquidity = deltaA / (sqrt(upper) -\n     * sqrt(lower)) or deltaB = liquidity / sqrt(lower) - liquidity /\n     * sqrt(upper).\n     * @param addSpec Slippage specification.\n     */\n    struct AddParamsViewInputs {\n        IMaverickV2Pool pool;\n        uint8 kind;\n        int32[] ticks;\n        uint128[] relativeLiquidityAmounts;\n        AddParamsSpecification addSpec;\n    }\n\n    /**\n     * @notice Multi-price add param specification.\n     * @param slippageFactorD18 Max slippage allowed as a percent in D18 scale. e.g. 1% slippage is 0.01e18\n     * @param numberOfPriceBreaksPerSide Number of price break values on either\n     * side of current price.\n     * @param targetAmount Target token contribution amount in tokenA if\n     * targetIsA is true, otherwise this is the target amount for tokenB.\n     * @param targetIsA  Indicates if the target amount is for tokenA or tokenB\n     */\n    struct AddParamsSpecification {\n        uint256 slippageFactorD18;\n        uint256 numberOfPriceBreaksPerSide;\n        uint256 targetAmount;\n        bool targetIsA;\n    }\n\n    /**\n     * @notice Specification for deriving create pool parameters. Creating a\n     * pool in the liquidity manager has several steps:\n     *\n     * - Deploy pool\n     * - Donate a small amount of initial liquidity in the activeTick\n     * - Execute a small swap to set the pool price to the desired value\n     * - Add liquidity\n     *\n     * In order to execute these steps, the caller must specify the parameters\n     * of each step.  The PoolLens has helper function to derive the values\n     * used by the LiquidityManager, but this struct is the input to that\n     * helper function and represents the core intent of the pool creator.\n     *\n     * @param fee Fraction of the pool swap amount that is retained as an LP in\n     * D18 scale.\n     * @param tickSpacing Tick spacing of pool where 1.0001^tickSpacing is the\n     * bin width.\n     * @param lookback Pool lookback in seconds.\n     * @param tokenA Address of tokenA.\n     * @param tokenB Address of tokenB.\n     * @param activeTick Tick position that contains the active bins.\n     * @param kinds 1-15 number to represent the active kinds\n     * 0b0001 = static;\n     * 0b0010 = right;\n     * 0b0100 = left;\n     * 0b1000 = both.\n     * e.g. a pool with all 4 modes will have kinds = b1111 = 15\n     * @param initialTargetB Amount of B to be donated to the pool after pool\n     * create.  This amount needs to be big enough to meet the minimum bin\n     * liquidity.\n     * @param sqrtPrice Target sqrt price of the pool.\n     * @param kind Bin kind; all bins must have the same kind in a given call\n     * to addLiquidity.\n     * @param ticks Array of tick values to add liquidity to.\n     * @param relativeLiquidityAmounts Relative liquidity amounts for the\n     * specified ticks.  Liquidity in this case is not bin LP balance, it is\n     * the bin liquidity as defined by liquidity = deltaA / (sqrt(upper) -\n     * sqrt(lower)) or deltaB = liquidity / sqrt(lower) - liquidity /\n     * sqrt(upper).\n     * @param targetAmount Target token contribution amount in tokenA if\n     * targetIsA is true, otherwise this is the target amount for tokenB.\n     * @param targetIsA  Indicates if the target amount is for tokenA or tokenB\n     */\n    struct CreateAndAddParamsViewInputs {\n        uint64 feeAIn;\n        uint64 feeBIn;\n        uint16 tickSpacing;\n        uint32 lookback;\n        IERC20 tokenA;\n        IERC20 tokenB;\n        int32 activeTick;\n        uint8 kinds;\n        // donate params\n        uint256 initialTargetB;\n        uint256 sqrtPrice;\n        // add target\n        uint8 kind;\n        int32[] ticks;\n        uint128[] relativeLiquidityAmounts;\n        uint256 targetAmount;\n        bool targetIsA;\n    }\n\n    struct Output {\n        uint256 deltaAOut;\n        uint256 deltaBOut;\n        uint256[] deltaAs;\n        uint256[] deltaBs;\n        uint128[] deltaLpBalances;\n    }\n\n    struct Reserves {\n        uint256 amountA;\n        uint256 amountB;\n    }\n\n    struct BinPositionKinds {\n        uint128[4] values;\n    }\n\n    struct PoolState {\n        IMaverickV2Pool.TickState[] tickStateMapping;\n        IMaverickV2Pool.BinState[] binStateMapping;\n        BinPositionKinds[] binIdByTickKindMapping;\n        IMaverickV2Pool.State state;\n        Reserves protocolFees;\n    }\n\n    struct BoostedPositionSpecification {\n        IMaverickV2Pool pool;\n        uint32[] binIds;\n        uint128[] ratios;\n        uint8 kind;\n    }\n\n    struct CreateAndAddParamsInputs {\n        uint64 feeAIn;\n        uint64 feeBIn;\n        uint16 tickSpacing;\n        uint32 lookback;\n        IERC20 tokenA;\n        IERC20 tokenB;\n        int32 activeTick;\n        uint8 kinds;\n        // donate params\n        IMaverickV2Pool.AddLiquidityParams donateParams;\n        // swap params\n        uint256 swapAmount;\n        // add params\n        IMaverickV2Pool.AddLiquidityParams addParams;\n        bytes[] packedAddParams;\n        uint256 deltaAOut;\n        uint256 deltaBOut;\n        uint256 preAddReserveA;\n        uint256 preAddReserveB;\n    }\n\n    struct TickDeltas {\n        uint256 deltaAOut;\n        uint256 deltaBOut;\n        uint256[] deltaAs;\n        uint256[] deltaBs;\n    }\n\n    /**\n     * @notice Converts add parameter slippage specification into add\n     * parameters.  The return values are given in both raw format and as packed\n     * values that can be used in the LiquidityManager contract.\n     */\n    function getAddLiquidityParams(AddParamsViewInputs memory params)\n        external\n        view\n        returns (\n            bytes memory packedSqrtPriceBreaks,\n            bytes[] memory packedArgs,\n            uint88[] memory sqrtPriceBreaks,\n            IMaverickV2Pool.AddLiquidityParams[] memory addParams,\n            IMaverickV2PoolLens.TickDeltas[] memory tickDeltas\n        );\n\n    /**\n     * @notice Converts add parameter slippage specification and new pool\n     * specification into CreateAndAddParamsInputs parameters that can be used in the\n     * LiquidityManager contract.\n     */\n    function getCreatePoolAtPriceAndAddLiquidityParams(\n        CreateAndAddParamsViewInputs memory params\n    ) external view returns (CreateAndAddParamsInputs memory output);\n\n    /**\n     * @notice View function that provides information about pool ticks within\n     * a tick radius from the activeTick. Ticks with no reserves are not\n     * included in part o f the return array.\n     */\n    function getTicksAroundActive(IMaverickV2Pool pool, int32 tickRadius)\n        external\n        view\n        returns (\n            int32[] memory ticks,\n            IMaverickV2Pool.TickState[] memory tickStates\n        );\n\n    /**\n     * @notice View function that provides information about pool ticks within\n     * a range. Ticks with no reserves are not included in part o f the return\n     * array.\n     */\n    function getTicks(\n        IMaverickV2Pool pool,\n        int32 tickStart,\n        int32 tickEnd\n    )\n        external\n        view\n        returns (\n            int32[] memory ticks,\n            IMaverickV2Pool.TickState[] memory tickStates\n        );\n\n    /**\n     * @notice View function that provides information about pool ticks within\n     * a range.  Information returned includes all pool state needed to emulate\n     * a swap off chain. Ticks with no reserves are not included in part o f\n     * the return array.\n     */\n    function getTicksAroundActiveWLiquidity(\n        IMaverickV2Pool pool,\n        int32 tickRadius\n    )\n        external\n        view\n        returns (\n            int32[] memory ticks,\n            IMaverickV2Pool.TickState[] memory tickStates,\n            uint256[] memory liquidities,\n            uint256[] memory sqrtLowerTickPrices,\n            uint256[] memory sqrtUpperTickPrices,\n            IMaverickV2Pool.State memory poolState,\n            uint256 sqrtPrice,\n            uint256 feeAIn,\n            uint256 feeBIn\n        );\n\n    /**\n     * @notice View function that provides pool state information.\n     */\n    function getFullPoolState(\n        IMaverickV2Pool pool,\n        uint32 binStart,\n        uint32 binEnd\n    ) external view returns (PoolState memory poolState);\n\n    /**\n     * @notice View function that provides price and liquidity of a given tick.\n     */\n    function getTickSqrtPriceAndL(IMaverickV2Pool pool, int32 tick)\n        external\n        view\n        returns (uint256 sqrtPrice, uint256 liquidity);\n\n    /**\n     * @notice Pool sqrt price.\n     */\n    function getPoolSqrtPrice(IMaverickV2Pool pool)\n        external\n        view\n        returns (uint256 sqrtPrice);\n\n    /**\n     * @notice Pool price.\n     */\n    function getPoolPrice(IMaverickV2Pool pool)\n        external\n        view\n        returns (uint256 price);\n\n    /**\n     * @notice Token scale of two tokens in a pool.\n     */\n    function tokenScales(IMaverickV2Pool pool)\n        external\n        view\n        returns (uint256 tokenAScale, uint256 tokenBScale);\n}\n"
    },
    "contracts/interfaces/plume/IMaverickV2Position.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.25;\n\nimport { IMaverickV2Factory } from \"./IMaverickV2Factory.sol\";\nimport { IMaverickV2Pool } from \"./IMaverickV2Pool.sol\";\nimport { ILiquidityRegistry } from \"./ILiquidityRegistry.sol\";\n\ninterface IMaverickV2Position {\n    event PositionClearData(uint256 indexed tokenId);\n    event PositionSetData(\n        uint256 indexed tokenId,\n        uint256 index,\n        PositionPoolBinIds newData\n    );\n    event SetLpReward(ILiquidityRegistry lpReward);\n\n    error PositionDuplicatePool(uint256 index, IMaverickV2Pool pool);\n    error PositionNotFactoryPool();\n    error PositionPermissionedLiquidityPool();\n\n    struct PositionPoolBinIds {\n        IMaverickV2Pool pool;\n        uint32[] binIds;\n    }\n\n    struct PositionFullInformation {\n        PositionPoolBinIds poolBinIds;\n        uint256 amountA;\n        uint256 amountB;\n        uint256[] binAAmounts;\n        uint256[] binBAmounts;\n        int32[] ticks;\n        uint256[] liquidities;\n    }\n\n    /**\n     * @notice Factory that tracks lp rewards.\n     */\n    function lpReward() external view returns (ILiquidityRegistry);\n\n    /**\n     * @notice Pool factory.\n     */\n    function factory() external view returns (IMaverickV2Factory);\n\n    /**\n     * @notice Mint NFT that holds liquidity in a Maverick V2 Pool. To mint\n     * liquidity to an NFT, add liquidity to bins in a pool where the\n     * add liquidity recipient is this contract and the subaccount is the\n     * tokenId. LiquidityManager can be used to simplify minting Position NFTs.\n     */\n    function mint(\n        address recipient,\n        IMaverickV2Pool pool,\n        uint32[] memory binIds\n    ) external returns (uint256 tokenId);\n\n    /**\n     * @notice Overwrites tokenId pool/binId information for a given data index.\n     */\n    function setTokenIdData(\n        uint256 tokenId,\n        uint256 index,\n        IMaverickV2Pool pool,\n        uint32[] memory binIds\n    ) external;\n\n    /**\n     * @notice Overwrites entire pool/binId data set for a given tokenId.\n     */\n    function setTokenIdData(uint256 tokenId, PositionPoolBinIds[] memory data)\n        external;\n\n    /**\n     * @notice Append new pool/binIds data array to tokenId.\n     */\n    function appendTokenIdData(\n        uint256 tokenId,\n        IMaverickV2Pool pool,\n        uint32[] memory binIds\n    ) external;\n\n    /**\n     * @notice Get array pool/binIds data for a given tokenId.\n     */\n    function getTokenIdData(uint256 tokenId)\n        external\n        view\n        returns (PositionPoolBinIds[] memory);\n\n    /**\n     * @notice Get value from array of pool/binIds data for a given tokenId.\n     */\n    function getTokenIdData(uint256 tokenId, uint256 index)\n        external\n        view\n        returns (PositionPoolBinIds memory);\n\n    /**\n     * @notice Length of array of pool/binIds data for a given tokenId.\n     */\n    function tokenIdDataLength(uint256 tokenId)\n        external\n        view\n        returns (uint256 length);\n\n    /**\n     * @notice Remove liquidity from tokenId for a given pool.  User can\n     * specify arbitrary bins to remove from for their subaccount in the pool\n     * even if those bins are not in the tokenIdData set.\n     */\n    function removeLiquidity(\n        uint256 tokenId,\n        address recipient,\n        IMaverickV2Pool pool,\n        IMaverickV2Pool.RemoveLiquidityParams memory params\n    ) external returns (uint256 tokenAAmount, uint256 tokenBAmount);\n\n    /**\n     * @notice Remove liquidity from tokenId for a given pool to sender.  User\n     * can specify arbitrary bins to remove from for their subaccount in the\n     * pool even if those bins are not in the tokenIdData set.\n     */\n    function removeLiquidityToSender(\n        uint256 tokenId,\n        IMaverickV2Pool pool,\n        IMaverickV2Pool.RemoveLiquidityParams memory params\n    ) external returns (uint256 tokenAAmount, uint256 tokenBAmount);\n\n    /**\n     * @notice NFT asset information for a given range of pool/binIds indexes.\n     * This function only returns the liquidity in the pools/binIds stored as\n     * part of the tokenIdData, but it is possible that the NFT has additional\n     * liquidity in pools/binIds that have not been recorded.\n     */\n    function tokenIdPositionInformation(\n        uint256 tokenId,\n        uint256 startIndex,\n        uint256 stopIndex\n    ) external view returns (PositionFullInformation[] memory output);\n\n    /**\n     * @notice NFT asset information for a given pool/binIds index. This\n     * function only returns the liquidity in the pools/binIds stored as part\n     * of the tokenIdData, but it is possible that the NFT has additional\n     * liquidity in pools/binIds that have not been recorded.\n     */\n    function tokenIdPositionInformation(uint256 tokenId, uint256 index)\n        external\n        view\n        returns (PositionFullInformation memory output);\n\n    /**\n     * @notice Get remove parameters for removing a fractional part of the\n     * liquidity owned by a given tokenId.  The fractional factor to remove is\n     * given by proporationD18 in 18-decimal scale.\n     */\n    function getRemoveParams(\n        uint256 tokenId,\n        uint256 index,\n        uint256 proportionD18\n    )\n        external\n        view\n        returns (IMaverickV2Pool.RemoveLiquidityParams memory params);\n\n    /**\n     * @notice Register the bin balances in the nft with the LpReward contract.\n     */\n    function checkpointBinLpBalance(\n        uint256 tokenId,\n        IMaverickV2Pool pool,\n        uint32[] memory binIds\n    ) external;\n}\n"
    },
    "contracts/interfaces/plume/IMaverickV2Quoter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.25;\n\nimport { IMaverickV2Pool } from \"./IMaverickV2Pool.sol\";\n\ninterface IMaverickV2Quoter {\n    error QuoterInvalidSwap();\n    error QuoterInvalidAddLiquidity();\n\n    /**\n     * @notice Calculates a swap on a MaverickV2Pool and returns the resulting\n     * amount and estimated gas.  The gas estimate is only a rough estimate and\n     * may not match a swap's gas.\n     * @param pool The MaverickV2Pool to swap on.\n     * @param amount The input amount.\n     * @param tokenAIn Indicates if token A is the input token.\n     * @param exactOutput Indicates if the amount is the output amount (true)\n     * or input amount (false). If the tickLimit is reached, the full value of\n     * the exactOutput may not be returned because the pool will stop swapping\n     * before the whole order is filled.\n     * @param tickLimit The tick limit for the swap. Once the swap lands in\n     * this tick, it will stop and return the output amount swapped up to that\n     * tick.\n     */\n    function calculateSwap(\n        IMaverickV2Pool pool,\n        uint128 amount,\n        bool tokenAIn,\n        bool exactOutput,\n        int32 tickLimit\n    )\n        external\n        returns (\n            uint256 amountIn,\n            uint256 amountOut,\n            uint256 gasEstimate\n        );\n\n    /**\n     * @notice Calculates a multihop swap and returns the resulting amount and\n     * estimated gas. The gas estimate is only a rough estimate and\n     * may not match a swap's gas.\n     * @param path The path of pools to swap through. Path is given by an\n     * packed array of (pool, tokenAIn) tuples. So each step in the path is 160\n     * + 8 = 168 bits of data. e.g. path = abi.encodePacked(pool1, true, pool2, false);\n     * @param amount The input amount.\n     * @param exactOutput A boolean indicating if exact output is required.\n     */\n    function calculateMultiHopSwap(\n        bytes memory path,\n        uint256 amount,\n        bool exactOutput\n    ) external returns (uint256 returnAmount, uint256 gasEstimate);\n\n    /**\n     * @notice Computes the token amounts required for a given set of\n     * addLiquidity parameters. The gas estimate is only a rough estimate and\n     * may not match a add's gas.\n     */\n    function calculateAddLiquidity(\n        IMaverickV2Pool pool,\n        IMaverickV2Pool.AddLiquidityParams calldata params\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 gasEstimate\n        );\n\n    /**\n     * @notice Pool's sqrt price.\n     */\n    function poolSqrtPrice(IMaverickV2Pool pool)\n        external\n        view\n        returns (uint256 sqrtPrice);\n}\n"
    },
    "contracts/interfaces/plume/IPoolDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport { IMaverickV2Pool } from \"./IMaverickV2Pool.sol\";\n\ninterface IPoolDistributor {\n    function rewardToken() external view returns (address);\n\n    function claimLp(\n        address recipient,\n        uint256 tokenId,\n        IMaverickV2Pool pool,\n        uint32[] memory binIds,\n        uint256 epoch\n    ) external returns (uint256 amount);\n}\n"
    },
    "contracts/interfaces/plume/IVotingDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\ninterface IVotingDistributor {\n    function lastEpoch() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/poolBooster/IMerklDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IMerklDistributor {\n    struct CampaignParameters {\n        // POPULATED ONCE CREATED\n\n        // ID of the campaign. This can be left as a null bytes32 when creating campaigns\n        // on Merkl.\n        bytes32 campaignId;\n        // CHOSEN BY CAMPAIGN CREATOR\n\n        // Address of the campaign creator, if marked as address(0), it will be overriden with the\n        // address of the `msg.sender` creating the campaign\n        address creator;\n        // Address of the token used as a reward\n        address rewardToken;\n        // Amount of `rewardToken` to distribute across all the epochs\n        // Amount distributed per epoch is `amount/numEpoch`\n        uint256 amount;\n        // Type of campaign\n        uint32 campaignType;\n        // Timestamp at which the campaign should start\n        uint32 startTimestamp;\n        // Duration of the campaign in seconds. Has to be a multiple of EPOCH = 3600\n        uint32 duration;\n        // Extra data to pass to specify the campaign\n        bytes campaignData;\n    }\n\n    function createCampaign(CampaignParameters memory newCampaign)\n        external\n        returns (bytes32);\n\n    function signAndCreateCampaign(\n        CampaignParameters memory newCampaign,\n        bytes memory _signature\n    ) external returns (bytes32);\n\n    function sign(bytes memory _signature) external;\n\n    function rewardTokenMinAmounts(address _rewardToken)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/interfaces/poolBooster/IPoolBoostCentralRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IPoolBoostCentralRegistry {\n    /**\n     * @dev all the supported pool booster types are listed here. It is possible\n     *      to have multiple versions of the factory that supports the same type of\n     *      pool booster. Factories are immutable and this can happen when a factory\n     *      or related pool booster required code update.\n     *      e.g. \"PoolBoosterSwapxDouble\" & \"PoolBoosterSwapxDouble_v2\"\n     */\n    enum PoolBoosterType {\n        // Supports bribing 2 contracts per pool. Appropriate for Ichi vault concentrated\n        // liquidity pools where (which is expected in most/all cases) both pool gauges\n        // require bribing.\n        SwapXDoubleBooster,\n        // Supports bribing a single contract per pool. Appropriate for Classic Stable &\n        // Classic Volatile pools and Ichi vaults where only 1 side (1 of the 2 gauges)\n        // needs bribing\n        SwapXSingleBooster,\n        // Supports bribing a single contract per pool. Appropriate for Metropolis pools\n        MetropolisBooster,\n        // Supports creating a Merkl campaign.\n        MerklBooster\n    }\n\n    struct PoolBoosterEntry {\n        address boosterAddress;\n        address ammPoolAddress;\n        PoolBoosterType boosterType;\n    }\n\n    event PoolBoosterCreated(\n        address poolBoosterAddress,\n        address ammPoolAddress,\n        PoolBoosterType poolBoosterType,\n        address factoryAddress\n    );\n    event PoolBoosterRemoved(address poolBoosterAddress);\n\n    function emitPoolBoosterCreated(\n        address _poolBoosterAddress,\n        address _ammPoolAddress,\n        PoolBoosterType _boosterType\n    ) external;\n\n    function emitPoolBoosterRemoved(address _poolBoosterAddress) external;\n}\n"
    },
    "contracts/interfaces/poolBooster/IPoolBooster.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IPoolBooster {\n    event BribeExecuted(uint256 amount);\n\n    /// @notice Execute the bribe action\n    function bribe() external;\n}\n"
    },
    "contracts/interfaces/poolBooster/ISwapXAlgebraBribe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBribe {\n    /// @notice Notify a bribe amount\n    /// @dev    Rewards are saved into NEXT EPOCH mapping.\n    function notifyRewardAmount(address _rewardsToken, uint256 reward) external;\n}\n"
    },
    "contracts/interfaces/sonic/INodeDriver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ninterface INodeDriver {\n    /// Seal epoch. Called BEFORE epoch sealing made by the client itself.\n    function sealEpoch(\n        uint256[] calldata offlineTimes,\n        uint256[] calldata offlineBlocks,\n        uint256[] calldata uptimes,\n        uint256[] calldata originatedTxsFee\n    ) external;\n}\n"
    },
    "contracts/interfaces/sonic/ISFC.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n/**\n * @title Special Fee Contract for Sonic network\n * @notice The SFC maintains a list of validators and delegators and distributes rewards to them.\n * @custom:security-contact security@fantom.foundation\n */\ninterface ISFC {\n    error StakeIsFullySlashed();\n\n    event CreatedValidator(\n        uint256 indexed validatorID,\n        address indexed auth,\n        uint256 createdEpoch,\n        uint256 createdTime\n    );\n    event Delegated(\n        address indexed delegator,\n        uint256 indexed validatorID,\n        uint256 amount\n    );\n    event Undelegated(\n        address indexed delegator,\n        uint256 indexed validatorID,\n        uint256 indexed wrID,\n        uint256 amount\n    );\n    event Withdrawn(\n        address indexed delegator,\n        uint256 indexed validatorID,\n        uint256 indexed wrID,\n        uint256 amount,\n        uint256 penalty\n    );\n    event ClaimedRewards(\n        address indexed delegator,\n        uint256 indexed validatorID,\n        uint256 rewards\n    );\n    event RestakedRewards(\n        address indexed delegator,\n        uint256 indexed validatorID,\n        uint256 rewards\n    );\n    event BurntFTM(uint256 amount);\n    event UpdatedSlashingRefundRatio(\n        uint256 indexed validatorID,\n        uint256 refundRatio\n    );\n    event RefundedSlashedLegacyDelegation(\n        address indexed delegator,\n        uint256 indexed validatorID,\n        uint256 amount\n    );\n\n    event DeactivatedValidator(\n        uint256 indexed validatorID,\n        uint256 deactivatedEpoch,\n        uint256 deactivatedTime\n    );\n    event ChangedValidatorStatus(uint256 indexed validatorID, uint256 status);\n    event AnnouncedRedirection(address indexed from, address indexed to);\n\n    function currentSealedEpoch() external view returns (uint256);\n\n    function getEpochSnapshot(uint256 epoch)\n        external\n        view\n        returns (\n            uint256 endTime,\n            uint256 endBlock,\n            uint256 epochFee,\n            uint256 baseRewardPerSecond,\n            uint256 totalStake,\n            uint256 totalSupply\n        );\n\n    function getStake(address delegator, uint256 validatorID)\n        external\n        view\n        returns (uint256);\n\n    function getValidator(uint256 validatorID)\n        external\n        view\n        returns (\n            uint256 status,\n            uint256 receivedStake,\n            address auth,\n            uint256 createdEpoch,\n            uint256 createdTime,\n            uint256 deactivatedTime,\n            uint256 deactivatedEpoch\n        );\n\n    function getValidatorID(address auth) external view returns (uint256);\n\n    function getValidatorPubkey(uint256 validatorID)\n        external\n        view\n        returns (bytes memory);\n\n    function pubkeyAddressvalidatorID(address pubkeyAddress)\n        external\n        view\n        returns (uint256);\n\n    function getWithdrawalRequest(\n        address delegator,\n        uint256 validatorID,\n        uint256 wrID\n    )\n        external\n        view\n        returns (\n            uint256 epoch,\n            uint256 time,\n            uint256 amount\n        );\n\n    function isOwner() external view returns (bool);\n\n    function lastValidatorID() external view returns (uint256);\n\n    function minGasPrice() external view returns (uint256);\n\n    function owner() external view returns (address);\n\n    function renounceOwnership() external;\n\n    function slashingRefundRatio(uint256 validatorID)\n        external\n        view\n        returns (uint256);\n\n    function stashedRewardsUntilEpoch(address delegator, uint256 validatorID)\n        external\n        view\n        returns (uint256);\n\n    function totalActiveStake() external view returns (uint256);\n\n    function totalStake() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function transferOwnership(address newOwner) external;\n\n    function treasuryAddress() external view returns (address);\n\n    function version() external pure returns (bytes3);\n\n    function currentEpoch() external view returns (uint256);\n\n    function updateConstsAddress(address v) external;\n\n    function constsAddress() external view returns (address);\n\n    function getEpochValidatorIDs(uint256 epoch)\n        external\n        view\n        returns (uint256[] memory);\n\n    function getEpochReceivedStake(uint256 epoch, uint256 validatorID)\n        external\n        view\n        returns (uint256);\n\n    function getEpochAccumulatedRewardPerToken(\n        uint256 epoch,\n        uint256 validatorID\n    ) external view returns (uint256);\n\n    function getEpochAccumulatedUptime(uint256 epoch, uint256 validatorID)\n        external\n        view\n        returns (uint256);\n\n    function getEpochAverageUptime(uint256 epoch, uint256 validatorID)\n        external\n        view\n        returns (uint32);\n\n    function getEpochAccumulatedOriginatedTxsFee(\n        uint256 epoch,\n        uint256 validatorID\n    ) external view returns (uint256);\n\n    function getEpochOfflineTime(uint256 epoch, uint256 validatorID)\n        external\n        view\n        returns (uint256);\n\n    function getEpochOfflineBlocks(uint256 epoch, uint256 validatorID)\n        external\n        view\n        returns (uint256);\n\n    function getEpochEndBlock(uint256 epoch) external view returns (uint256);\n\n    function rewardsStash(address delegator, uint256 validatorID)\n        external\n        view\n        returns (uint256);\n\n    function createValidator(bytes calldata pubkey) external payable;\n\n    function getSelfStake(uint256 validatorID) external view returns (uint256);\n\n    function delegate(uint256 validatorID) external payable;\n\n    function undelegate(\n        uint256 validatorID,\n        uint256 wrID,\n        uint256 amount\n    ) external;\n\n    function isSlashed(uint256 validatorID) external view returns (bool);\n\n    function withdraw(uint256 validatorID, uint256 wrID) external;\n\n    function deactivateValidator(uint256 validatorID, uint256 status) external;\n\n    function pendingRewards(address delegator, uint256 validatorID)\n        external\n        view\n        returns (uint256);\n\n    function stashRewards(address delegator, uint256 validatorID) external;\n\n    function claimRewards(uint256 validatorID) external;\n\n    function restakeRewards(uint256 validatorID) external;\n\n    function updateSlashingRefundRatio(uint256 validatorID, uint256 refundRatio)\n        external;\n\n    function updateTreasuryAddress(address v) external;\n\n    function burnFTM(uint256 amount) external;\n\n    function sealEpoch(\n        uint256[] calldata offlineTime,\n        uint256[] calldata offlineBlocks,\n        uint256[] calldata uptimes,\n        uint256[] calldata originatedTxsFee\n    ) external;\n\n    function sealEpochValidators(uint256[] calldata nextValidatorIDs) external;\n\n    function initialize(\n        uint256 sealedEpoch,\n        uint256 _totalSupply,\n        address nodeDriver,\n        address consts,\n        address _owner\n    ) external;\n\n    function setGenesisValidator(\n        address auth,\n        uint256 validatorID,\n        bytes calldata pubkey,\n        uint256 createdTime\n    ) external;\n\n    function setGenesisDelegation(\n        address delegator,\n        uint256 validatorID,\n        uint256 stake\n    ) external;\n\n    function updateStakeSubscriberAddress(address v) external;\n\n    function stakeSubscriberAddress() external view returns (address);\n\n    function setRedirectionAuthorizer(address v) external;\n\n    function announceRedirection(address to) external;\n\n    function initiateRedirection(address from, address to) external;\n\n    function redirect(address to) external;\n}\n"
    },
    "contracts/interfaces/sonic/ISwapXGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IGauge {\n    function owner() external view returns (address);\n\n    function TOKEN() external view returns (address);\n\n    function DISTRIBUTION() external view returns (address);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function claimFees() external returns (uint256 claimed0, uint256 claimed1);\n\n    function deposit(uint256 amount) external;\n\n    function depositAll() external;\n\n    function earned(address account) external view returns (uint256);\n\n    function getReward() external;\n\n    function getReward(address _user) external;\n\n    function isForPair() external view returns (bool);\n\n    function lastTimeRewardApplicable() external view returns (uint256);\n\n    function lastUpdateTime() external view returns (uint256);\n\n    function notifyRewardAmount(address token, uint256 reward) external;\n\n    function periodFinish() external view returns (uint256);\n\n    function rewardForDuration() external view returns (uint256);\n\n    function rewardPerToken() external view returns (uint256);\n\n    function rewardPerTokenStored() external view returns (uint256);\n\n    function rewardRate() external view returns (uint256);\n\n    function rewardToken() external view returns (address);\n\n    function rewards(address) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function userRewardPerTokenPaid(address) external view returns (uint256);\n\n    function withdraw(uint256 amount) external;\n\n    function withdrawAll() external;\n\n    function withdrawAllAndHarvest() external;\n\n    function withdrawExcess(address token, uint256 amount) external;\n\n    function emergency() external returns (bool);\n\n    function emergencyWithdraw() external;\n\n    function activateEmergencyMode() external;\n\n    function stopEmergencyMode() external;\n}\n"
    },
    "contracts/interfaces/sonic/ISwapXPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPair {\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Claim(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    function metadata()\n        external\n        view\n        returns (\n            uint256 dec0,\n            uint256 dec1,\n            uint256 r0,\n            uint256 r1,\n            bool st,\n            address t0,\n            address t1\n        );\n\n    function claimFees() external returns (uint256, uint256);\n\n    function tokens() external view returns (address, address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function burn(address to)\n        external\n        returns (uint256 amount0, uint256 amount1);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint256 _reserve0,\n            uint256 _reserve1,\n            uint256 _blockTimestampLast\n        );\n\n    function getAmountOut(uint256, address) external view returns (uint256);\n\n    // ERC20 methods\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function claimable0(address _user) external view returns (uint256);\n\n    function claimable1(address _user) external view returns (uint256);\n\n    function isStable() external view returns (bool);\n\n    function skim(address to) external;\n\n    function sync() external;\n}\n"
    },
    "contracts/interfaces/sonic/IVoterV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IVoterV3 {\n    /// @notice create a gauge\n    function createGauge(address _pool, uint256 _gaugeType)\n        external\n        returns (\n            address _gauge,\n            address _internal_bribe,\n            address _external_bribe\n        );\n\n    function gauges(address _pool) external view returns (address _gauge);\n}\n"
    },
    "contracts/interfaces/sonic/IWrappedSonic.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWrappedSonic {\n    event Deposit(address indexed account, uint256 value);\n    event Withdrawal(address indexed account, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function deposit() external payable;\n\n    function depositFor(address account) external payable returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function withdraw(uint256 value) external;\n\n    function withdrawTo(address account, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/interfaces/Tether.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// slither-disable-start erc20-interface\ninterface Tether {\n    function transfer(address to, uint256 value) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external;\n\n    function balanceOf(address) external view returns (uint256);\n\n    function approve(address _spender, uint256 _value) external;\n}\n// slither-disable-end erc20-interface\n"
    },
    "contracts/interfaces/uniswap/IUniswapUniversalRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUniswapUniversalRouter {\n    /// @notice Executes encoded commands along with provided inputs. Reverts if deadline has expired.\n    /// @param commands A set of concatenated commands, each 1 byte in length\n    /// @param inputs An array of byte strings containing abi encoded inputs for each command\n    /// @param deadline The deadline by which the transaction must be executed\n    function execute(\n        bytes calldata commands,\n        bytes[] calldata inputs,\n        uint256 deadline\n    ) external payable;\n\n    function execute(bytes calldata commands, bytes[] calldata inputs)\n        external\n        payable;\n}\n"
    },
    "contracts/interfaces/uniswap/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Pair {\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function sync() external;\n}\n"
    },
    "contracts/interfaces/uniswap/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Router {\n    function WETH() external pure returns (address);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n}\n"
    },
    "contracts/interfaces/uniswap/IUniswapV3Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// -- Solididy v0.5.x compatible interface\ninterface IUniswapV3Router {\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n}\n"
    },
    "contracts/mocks/beacon/ExecutionLayerConsolidation.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { GeneralPurposeToConsensusLayerRequest } from \"./GeneralPurposeToConsensusLayerRequest.sol\";\n\ncontract ExecutionLayerConsolidation is GeneralPurposeToConsensusLayerRequest {\n    event ConsolidationRequestIssued(bytes sourceKey, bytes targetKey);\n    bytes public lastSource;\n    bytes public lastTarget;\n\n    function handleRequest(bytes calldata data) internal override {\n        // parameters should consist of twice the 48 bytes for 2 public keys\n        require(data.length == 96, \"Invalid Consolidation data\");\n        lastSource = data[:48];\n        lastTarget = data[48:];\n\n        emit ConsolidationRequestIssued(lastSource, lastTarget);\n    }\n}\n"
    },
    "contracts/mocks/beacon/ExecutionLayerWithdrawal.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { GeneralPurposeToConsensusLayerRequest } from \"./GeneralPurposeToConsensusLayerRequest.sol\";\n\ncontract ExecutionLayerWithdrawal is GeneralPurposeToConsensusLayerRequest {\n    event WithdrawalRequestIssued(bytes publicKey, uint64 amount);\n\n    bytes public lastPublicKey;\n    uint64 public lastAmount;\n\n    function handleRequest(bytes calldata data) internal override {\n        // parameters should consist of 48 bytes for public key and 8 bytes for uint64 amount\n        require(data.length == 56, \"Invalid Withdrawal data\");\n        lastPublicKey = data[:48];\n        lastAmount = uint64(bytes8(data[48:]));\n        emit WithdrawalRequestIssued(lastPublicKey, lastAmount);\n    }\n}\n"
    },
    "contracts/mocks/beacon/GeneralPurposeToConsensusLayerRequest.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nabstract contract GeneralPurposeToConsensusLayerRequest {\n    // solhint-disable no-complex-fallback\n    fallback() external payable {\n        // fee requested\n        if (msg.data.length == 0) {\n            uint256 fee = _fee();\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // Return a uint256 value\n                mstore(0, fee)\n                return(0, 32) // Return 32 bytes from memory\n            }\n        }\n\n        // else handle request\n        handleRequest(msg.data);\n    }\n\n    /***************************************\n                 Abstract\n    ****************************************/\n\n    function _fee() internal virtual returns (uint256) {\n        return 1;\n    }\n\n    function handleRequest(bytes calldata data) internal virtual;\n}\n"
    },
    "contracts/mocks/BurnableERC20.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IBurnableERC20 {\n    function burn(uint256 value) external returns (bool);\n\n    function burnFrom(address account, uint256 value) external returns (bool);\n}\n\n/**\n * @title BurnableERC20\n * @dev Exposes the burn function of ERC20 for tests\n */\nabstract contract BurnableERC20 is IBurnableERC20, ERC20 {\n    /**\n     * @dev Function to burn tokens\n     * @param value The amount of tokens to burn.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function burn(uint256 value) public virtual override returns (bool) {\n        _burn(msg.sender, value);\n        return true;\n    }\n\n    /**\n     * @dev Function to burn tokens from a specific account\n     * @param account The address with the tokens to burn.\n     * @param value The amount of tokens to burn.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function burnFrom(address account, uint256 value)\n        public\n        override\n        returns (bool)\n    {\n        _burn(account, value);\n        return true;\n    }\n}\n"
    },
    "contracts/mocks/curve/Mock3CRV.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ERC20, MintableERC20 } from \"../MintableERC20.sol\";\nimport { BurnableERC20 } from \"../BurnableERC20.sol\";\n\ncontract Mock3CRV is MintableERC20, BurnableERC20 {\n    constructor() ERC20(\"Curve.fi DAI/USDC/USDT\", \"3Crv\") {}\n\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n}\n"
    },
    "contracts/mocks/curve/MockBooster.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { MockRewardPool } from \"./MockRewardPool.sol\";\n\nimport { IRewardStaking } from \"../../strategies/IRewardStaking.sol\";\nimport { IMintableERC20, MintableERC20, ERC20 } from \"../MintableERC20.sol\";\nimport { IBurnableERC20, BurnableERC20 } from \"../BurnableERC20.sol\";\n\ncontract MockDepositToken is MintableERC20, BurnableERC20 {\n    constructor() ERC20(\"DCVX\", \"CVX Deposit Token\") {}\n}\n\ncontract MockBooster {\n    using SafeERC20 for IERC20;\n\n    struct PoolInfo {\n        address lptoken;\n        address token;\n        address crvRewards;\n    }\n\n    address public minter; // this is CVx for the booster on live\n    address public crv; // Curve rewards token\n    address public cvx; // Convex rewards token\n    mapping(uint256 => PoolInfo) public poolInfo;\n\n    constructor(\n        address _rewardsMinter,\n        address _crv,\n        address _cvx\n    ) public {\n        minter = _rewardsMinter;\n        crv = _crv;\n        cvx = _cvx;\n    }\n\n    function setPool(uint256 pid, address _lpToken)\n        external\n        returns (address rewards)\n    {\n        address token = address(new MockDepositToken());\n        // Deploy a new Convex Rewards Pool\n        rewards = address(\n            new MockRewardPool(pid, token, crv, cvx, address(this))\n        );\n\n        poolInfo[pid] = PoolInfo({\n            lptoken: _lpToken,\n            token: token,\n            crvRewards: rewards\n        });\n    }\n\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool _stake\n    ) public returns (bool) {\n        PoolInfo storage pool = poolInfo[_pid];\n\n        address lptoken = pool.lptoken;\n\n        // hold on to the Curve LP tokens\n        IERC20(lptoken).safeTransferFrom(msg.sender, address(this), _amount);\n\n        address token = pool.token;\n        if (_stake) {\n            // mint Convex pool LP tokens and stake in rewards contract on user behalf\n            IMintableERC20(token).mint(_amount);\n            address rewardContract = pool.crvRewards;\n            IERC20(token).safeApprove(rewardContract, 0);\n            IERC20(token).safeApprove(rewardContract, _amount);\n            IRewardStaking(rewardContract).stakeFor(msg.sender, _amount);\n        } else {\n            // mint Convex pool LP tokens and send to user\n            IMintableERC20(token).mint(_amount);\n            IERC20(token).transfer(msg.sender, _amount);\n        }\n        return true;\n    }\n\n    // Deposit all Curve LP tokens and stake\n    function depositAll(uint256 _pid, bool _stake) external returns (bool) {\n        address lptoken = poolInfo[_pid].lptoken;\n        uint256 balance = IERC20(lptoken).balanceOf(msg.sender);\n        deposit(_pid, balance, _stake);\n        return true;\n    }\n\n    // withdraw Curve LP tokens\n    function _withdraw(\n        uint256 _pid,\n        uint256 _amount,\n        address _from,\n        address _to\n    ) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n\n        // burn the Convex pool LP tokens\n        IBurnableERC20(pool.token).burnFrom(_from, _amount);\n\n        // return the Curve LP tokens\n        IERC20(pool.lptoken).safeTransfer(_to, _amount);\n    }\n\n    // withdraw Curve LP tokens\n    function withdraw(uint256 _pid, uint256 _amount) public returns (bool) {\n        _withdraw(_pid, _amount, msg.sender, msg.sender);\n        return true;\n    }\n\n    // withdraw all Curve LP tokens\n    function withdrawAll(uint256 _pid) public returns (bool) {\n        address token = poolInfo[_pid].token;\n        uint256 userBal = IERC20(token).balanceOf(msg.sender);\n        withdraw(_pid, userBal);\n        return true;\n    }\n\n    // allow reward contracts to send here and withdraw to user\n    function withdrawTo(\n        uint256 _pid,\n        uint256 _amount,\n        address _to\n    ) external returns (bool) {\n        address rewardContract = poolInfo[_pid].crvRewards;\n        require(msg.sender == rewardContract, \"!auth\");\n\n        _withdraw(_pid, _amount, msg.sender, _to);\n        return true;\n    }\n\n    // callback from reward contract when crv is received.\n    function rewardClaimed(\n        uint256 _pid,\n        // solhint-disable-next-line no-unused-vars\n        address _address,\n        uint256 _amount\n    ) external returns (bool) {\n        address rewardContract = poolInfo[_pid].crvRewards;\n        require(msg.sender == rewardContract, \"!auth\");\n\n        //mint reward tokens\n        // and transfer it\n        IMintableERC20(minter).mint(_amount);\n        IERC20(minter).transfer(msg.sender, _amount);\n        return true;\n    }\n}\n"
    },
    "contracts/mocks/curve/MockCRV.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../MintableERC20.sol\";\n\ncontract MockCRV is MintableERC20 {\n    constructor() ERC20(\"Curve DAO Token\", \"CRV\") {}\n\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n}\n"
    },
    "contracts/mocks/curve/MockCRVMinter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IMintableERC20 } from \"../MintableERC20.sol\";\n\ncontract MockCRVMinter {\n    address crv;\n\n    constructor(address _crv) {\n        crv = _crv;\n    }\n\n    function mint(address _address) external {\n        uint256 amount = 2e18;\n        IMintableERC20(crv).mint(amount);\n        IERC20(crv).transfer(_address, amount);\n    }\n}\n"
    },
    "contracts/mocks/curve/MockCurveAbstractMetapool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { MintableERC20, IMintableERC20 } from \"../MintableERC20.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\nimport \"../../utils/Helpers.sol\";\n\nabstract contract MockCurveAbstractMetapool is MintableERC20 {\n    using StableMath for uint256;\n\n    address[] public coins;\n    uint256[2] public balances;\n\n    // Returns the same amount of LP tokens in 1e18 decimals\n    function add_liquidity(uint256[2] calldata _amounts, uint256 _minAmount)\n        external\n        returns (uint256 lpAmount)\n    {\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            if (_amounts[i] > 0) {\n                IERC20(coins[i]).transferFrom(\n                    msg.sender,\n                    address(this),\n                    _amounts[i]\n                );\n                uint256 assetDecimals = Helpers.getDecimals(coins[i]);\n                // Convert to 1e18 and add to sum\n                lpAmount += _amounts[i].scaleBy(18, assetDecimals);\n                balances[i] = balances[i] + _amounts[i];\n            }\n        }\n        // Hacky way of simulating slippage to check _minAmount\n        if (lpAmount == 29000e18) lpAmount = 14500e18;\n        require(lpAmount >= _minAmount, \"Slippage ruined your day\");\n        // Send LP token to sender, e.g. 3CRV\n        _mint(msg.sender, lpAmount);\n    }\n\n    // Dumb implementation that returns the same amount\n    function calc_withdraw_one_coin(uint256 _amount, int128 _index)\n        public\n        view\n        returns (uint256 lpAmount)\n    {\n        uint256 assetDecimals = Helpers.getDecimals(coins[uint128(_index)]);\n        lpAmount = _amount.scaleBy(assetDecimals, 18);\n    }\n\n    function remove_liquidity_one_coin(\n        uint256 _lpAmount,\n        int128 _index,\n        // solhint-disable-next-line no-unused-vars\n        uint256 _minAmount\n    ) external returns (uint256 amount) {\n        _burn(msg.sender, _lpAmount);\n        uint256[] memory amounts = new uint256[](coins.length);\n        amounts[uint128(_index)] = _lpAmount;\n        amount = calc_withdraw_one_coin(_lpAmount, _index);\n        balances[uint128(_index)] -= amount;\n        IERC20(coins[uint128(_index)]).transfer(msg.sender, amount);\n    }\n\n    function get_virtual_price() external pure returns (uint256) {\n        return 1e18;\n    }\n\n    // solhint-disable-next-line no-unused-vars\n    function remove_liquidity(uint256 _amount, uint256[2] memory _min_amounts)\n        public\n        returns (uint256[2] memory amounts)\n    {\n        _burn(msg.sender, _amount);\n        uint256 totalSupply = totalSupply();\n        for (uint256 i = 0; i < 2; i++) {\n            amounts[i] = totalSupply > 0\n                ? (_amount * IERC20(coins[i]).balanceOf(address(this))) /\n                    totalSupply\n                : IERC20(coins[i]).balanceOf(address(this));\n            balances[i] -= amounts[i];\n            IERC20(coins[i]).transfer(msg.sender, amounts[i]);\n        }\n    }\n\n    function remove_liquidity_imbalance(\n        uint256[2] memory _amounts,\n        uint256 _max_burned_tokens\n    ) public returns (uint256) {\n        return\n            _remove_liquidity_imbalance(\n                _amounts,\n                _max_burned_tokens,\n                msg.sender\n            );\n    }\n\n    function remove_liquidity_imbalance(\n        uint256[2] memory _amounts,\n        uint256 _max_burned_tokens,\n        address _reveiver\n    ) public returns (uint256) {\n        return\n            _remove_liquidity_imbalance(\n                _amounts,\n                _max_burned_tokens,\n                _reveiver\n            );\n    }\n\n    function _remove_liquidity_imbalance(\n        uint256[2] memory _amounts,\n        uint256 _max_burned_tokens,\n        address _reveiver\n    ) internal returns (uint256 lpTokens) {\n        lpTokens = _max_burned_tokens;\n        _burn(msg.sender, lpTokens);\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            balances[i] -= _amounts[i];\n            if (_amounts[i] > 0) {\n                IERC20(coins[i]).transfer(_reveiver, _amounts[i]);\n            }\n        }\n    }\n\n    // Dumb implementation that sums the scaled amounts\n    function calc_token_amount(uint256[2] memory _amounts, bool)\n        public\n        view\n        returns (uint256 lpTokens)\n    {\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            uint256 assetDecimals = Helpers.getDecimals(coins[i]);\n            // Convert to 1e18 and add to lpTokens\n            lpTokens += _amounts[i].scaleBy(18, assetDecimals);\n        }\n    }\n\n    /// @notice 0.02% fee\n    function fee() external pure returns (uint256) {\n        return 2000000;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n\n    function burnFrom(address from, uint256 value) public {\n        _burn(from, value);\n    }\n}\n"
    },
    "contracts/mocks/curve/MockCurveGauge.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { ICurveGauge } from \"../../strategies/ICurveGauge.sol\";\n\ncontract MockCurveGauge is ICurveGauge {\n    mapping(address => uint256) private _balances;\n    address lpToken;\n\n    constructor(address _lpToken) {\n        lpToken = _lpToken;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function deposit(uint256 _value, address _account) external override {\n        IERC20(lpToken).transferFrom(msg.sender, address(this), _value);\n        _balances[_account] += _value;\n    }\n\n    function withdraw(uint256 _value) external override {\n        IERC20(lpToken).transfer(msg.sender, _value);\n        // solhint-disable-next-line reentrancy\n        _balances[msg.sender] -= _value;\n    }\n}\n"
    },
    "contracts/mocks/curve/MockCurveMetapool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { MockCurveAbstractMetapool } from \"./MockCurveAbstractMetapool.sol\";\nimport \"../MintableERC20.sol\";\n\ncontract MockCurveMetapool is MockCurveAbstractMetapool {\n    constructor(address[2] memory _coins)\n        ERC20(\"Curve.fi 3pool/OUSD metapool\", \"3crv_OUSD\")\n    {\n        coins = _coins;\n    }\n}\n"
    },
    "contracts/mocks/curve/MockCurvePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IBurnableERC20 } from \"../BurnableERC20.sol\";\n\nimport { IMintableERC20 } from \"../MintableERC20.sol\";\nimport { ICurvePool } from \"../../strategies/ICurvePool.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\nimport \"../../utils/Helpers.sol\";\n\ncontract MockCurvePool {\n    using StableMath for uint256;\n\n    address[] public coins;\n    uint256[3] public balances;\n    address lpToken;\n    uint256 public slippage = 1 ether;\n\n    constructor(address[3] memory _coins, address _lpToken) {\n        coins = _coins;\n        lpToken = _lpToken;\n    }\n\n    function setCoins(address[] memory _coins) external {\n        coins = _coins;\n    }\n\n    // Returns the same amount of LP tokens in 1e18 decimals\n    function add_liquidity(uint256[3] calldata _amounts, uint256 _minAmount)\n        external\n    {\n        uint256 sum = 0;\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            if (_amounts[i] > 0) {\n                IERC20(coins[i]).transferFrom(\n                    msg.sender,\n                    address(this),\n                    _amounts[i]\n                );\n                uint256 assetDecimals = Helpers.getDecimals(coins[i]);\n                // Convert to 1e18 and add to sum\n                sum += _amounts[i].scaleBy(18, assetDecimals);\n                balances[i] = balances[i] + _amounts[i];\n            }\n        }\n        // Hacky way of simulating slippage to check _minAmount\n        if (sum == 29000e18) sum = 14500e18;\n        require(sum >= _minAmount, \"Slippage ruined your day\");\n        // Send LP token to sender, e.g. 3CRV\n        IMintableERC20(lpToken).mint(sum);\n        IERC20(lpToken).transfer(msg.sender, sum);\n    }\n\n    // Dumb implementation that returns the same amount\n    function calc_withdraw_one_coin(uint256 _amount, int128 _index)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 assetDecimals = Helpers.getDecimals(coins[uint128(_index)]);\n        return _amount.scaleBy(assetDecimals, 18);\n    }\n\n    function remove_liquidity_one_coin(\n        uint256 _amount,\n        int128 _index,\n        // solhint-disable-next-line no-unused-vars\n        uint256 _minAmount\n    ) external {\n        // Burn the Curve LP tokens\n        IBurnableERC20(lpToken).burnFrom(msg.sender, _amount);\n        uint256[] memory amounts = new uint256[](coins.length);\n        amounts[uint128(_index)] = _amount;\n        uint256 coinAmount = calc_withdraw_one_coin(_amount, _index);\n        balances[uint128(_index)] -= coinAmount;\n        IERC20(coins[uint128(_index)]).transfer(msg.sender, coinAmount);\n    }\n\n    function get_virtual_price() external pure returns (uint256) {\n        return 1e18;\n    }\n\n    // solhint-disable-next-line no-unused-vars\n    function remove_liquidity(uint256 _lpAmount, uint256[3] memory _min_amounts)\n        public\n    {\n        // Burn the Curve LP tokens\n        IBurnableERC20(lpToken).burnFrom(msg.sender, _lpAmount);\n        uint256 totalSupply = IERC20(lpToken).totalSupply();\n        for (uint256 i = 0; i < 3; i++) {\n            uint256 coinAmount = totalSupply > 0\n                ? (_lpAmount * IERC20(coins[i]).balanceOf(address(this))) /\n                    totalSupply\n                : IERC20(coins[i]).balanceOf(address(this));\n            balances[i] -= coinAmount;\n            IERC20(coins[i]).transfer(msg.sender, coinAmount);\n        }\n    }\n\n    function remove_liquidity_imbalance(\n        uint256[3] memory _amounts,\n        uint256 _max_burned_tokens\n    ) public {\n        // Burn the Curve LP tokens\n        IBurnableERC20(lpToken).burnFrom(msg.sender, _max_burned_tokens);\n        // For each coin, transfer to the caller\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            balances[i] -= _amounts[i];\n            if (_amounts[i] > 0) {\n                IERC20(coins[i]).transfer(msg.sender, _amounts[i]);\n            }\n        }\n    }\n\n    // Dumb implementation that sums the scaled amounts\n    function calc_token_amount(uint256[3] memory _amounts, bool)\n        public\n        view\n        returns (uint256 lpTokens)\n    {\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            uint256 assetDecimals = Helpers.getDecimals(coins[i]);\n            // Convert to 1e18 and add to lpTokens\n            lpTokens += _amounts[i].scaleBy(18, assetDecimals);\n        }\n    }\n\n    function fee() external pure returns (uint256) {\n        return 1000000;\n    }\n\n    function exchange(\n        uint256 coin0,\n        uint256 coin1,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) external returns (uint256 amountOut) {\n        IERC20(coins[coin0]).transferFrom(msg.sender, address(this), amountIn);\n        amountOut = (minAmountOut * slippage) / 1 ether;\n        require(amountOut >= minAmountOut, \"Slippage error\");\n        IMintableERC20(coins[coin1]).mintTo(msg.sender, amountOut);\n    }\n\n    function setSlippage(uint256 _slippage) external {\n        slippage = _slippage;\n    }\n}\n"
    },
    "contracts/mocks/curve/MockCVX.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../MintableERC20.sol\";\n\ncontract MockCVX is MintableERC20 {\n    constructor() ERC20(\"CVX\", \"CVX DAO Token\") {}\n}\n"
    },
    "contracts/mocks/curve/MockRewardPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IMintableERC20 } from \"../MintableERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ninterface IDeposit {\n    function poolInfo(uint256)\n        external\n        view\n        returns (\n            address,\n            address,\n            address,\n            address,\n            address,\n            bool\n        );\n\n    function rewardClaimed(\n        uint256,\n        address,\n        uint256\n    ) external;\n\n    function withdrawTo(\n        uint256,\n        uint256,\n        address\n    ) external;\n}\n\ncontract MockRewardPool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public pid;\n    address public stakingToken;\n    address public rewardTokenA;\n    address public rewardTokenB;\n    address public operator;\n\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) private _balances;\n    mapping(address => uint256) public rewards;\n\n    constructor(\n        uint256 _pid,\n        address _stakingToken,\n        address _rewardTokenA,\n        address _rewardTokenB,\n        address _operator\n    ) public {\n        pid = _pid;\n        stakingToken = _stakingToken;\n        rewardTokenA = _rewardTokenA;\n        rewardTokenB = _rewardTokenB;\n        operator = _operator;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function stakeFor(address _for, uint256 _amount) public returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //give to _for\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[_for] = _balances[_for].add(_amount);\n\n        //take away from sender\n        IERC20(stakingToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        return true;\n    }\n\n    function withdrawAndUnwrap(uint256 amount, bool claim)\n        public\n        returns (bool)\n    {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        //tell operator to withdraw from here directly to user\n        IDeposit(operator).withdrawTo(pid, amount, msg.sender);\n\n        //get rewards too\n        if (claim) {\n            getReward(msg.sender, true);\n        }\n        return true;\n    }\n\n    function withdrawAllAndUnwrap(bool claim) external {\n        withdrawAndUnwrap(_balances[msg.sender], claim);\n    }\n\n    // solhint-disable-next-line no-unused-vars\n    function getReward(address _account, bool _claimExtras)\n        public\n        returns (bool)\n    {\n        IMintableERC20(rewardTokenA).mint(2 * 1e18);\n        IERC20(rewardTokenA).transfer(_account, 2 * 1e18);\n\n        IMintableERC20(rewardTokenB).mint(3 * 1e18);\n        IERC20(rewardTokenB).transfer(_account, 3 * 1e18);\n\n        return true;\n    }\n\n    function getReward() public returns (bool) {\n        getReward(msg.sender, true);\n    }\n}\n"
    },
    "contracts/mocks/ForceEtherSender.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ncontract ForceEtherSender {\n    // Constructor to optionally receive Ether upon deployment\n    constructor() payable {}\n\n    // Function to allow the contract to receive Ether\n    receive() external payable {}\n\n    // Function to self-destruct and force-send Ether to an address\n    function forceSend(address payable recipient) external {\n        // Requires that the contract has a balance greater than 0\n        require(address(this).balance > 0, \"No Ether to send\");\n\n        // selfdestruct sends all Ether held by the contract to the recipient\n        selfdestruct(recipient);\n    }\n}\n"
    },
    "contracts/mocks/MintableERC20.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IMintableERC20 {\n    function mint(uint256 value) external;\n\n    function mintTo(address to, uint256 value) external;\n}\n\n/**\n * @title MintableERC20\n * @dev Exposes the mint function of ERC20 for tests\n */\nabstract contract MintableERC20 is IMintableERC20, ERC20 {\n    /**\n     * @dev Function to mint tokens\n     * @param _value The amount of tokens to mint.\n     */\n    function mint(uint256 _value) public virtual override {\n        _mint(msg.sender, _value);\n    }\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to Address to mint to.\n     * @param _value The amount of tokens to mint.\n     */\n    function mintTo(address _to, uint256 _value) public virtual override {\n        _mint(_to, _value);\n    }\n}\n"
    },
    "contracts/mocks/Mock1InchSwapRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { SwapDescription } from \"../interfaces/IOneInch.sol\";\n\ncontract Mock1InchSwapRouter {\n    using SafeERC20 for IERC20;\n\n    event MockSwap(address executor, bytes permitData, bytes executorData);\n\n    event MockSwapDesc(\n        address srcToken,\n        address dstToken,\n        address srcReceiver,\n        address dstReceiver,\n        uint256 amount,\n        uint256 minReturnAmount,\n        uint256 flags\n    );\n\n    event MockUnoswapTo(\n        address recipient,\n        address srcToken,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] pools\n    );\n\n    event MockUniswapV3SwapTo(\n        address recipient,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] pools\n    );\n\n    /**\n     * @dev transfers the shource asset and returns the minReturnAmount of the destination asset.\n     */\n    function swap(\n        address executor,\n        SwapDescription calldata desc,\n        bytes calldata permitData,\n        bytes calldata executorData\n    ) public returns (uint256 returnAmount, uint256 spentAmount) {\n        // Transfer the source tokens to the receiver contract\n        IERC20(desc.srcToken).safeTransferFrom(\n            msg.sender,\n            desc.srcReceiver,\n            desc.amount\n        );\n\n        // Transfer the destination tokens to the recipient\n        IERC20(desc.dstToken).safeTransfer(\n            desc.dstReceiver,\n            desc.minReturnAmount\n        );\n\n        emit MockSwap(executor, permitData, executorData);\n        _swapDesc(desc);\n        returnAmount = 0;\n        spentAmount = 0;\n    }\n\n    function _swapDesc(SwapDescription calldata desc) public {\n        emit MockSwapDesc(\n            address(desc.srcToken),\n            address(desc.dstToken),\n            desc.srcReceiver,\n            desc.dstReceiver,\n            desc.amount,\n            desc.minReturnAmount,\n            desc.flags\n        );\n    }\n\n    /**\n     * @dev only transfers the source asset to this contract.\n     * Ideally it would return the destination asset but that's encoded in the pools array.\n     */\n    function unoswapTo(\n        address payable recipient,\n        address srcToken,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] calldata pools\n    ) public returns (uint256 returnAmount) {\n        // transfer the from asset from the caller\n        IERC20(srcToken).safeTransferFrom(msg.sender, address(this), amount);\n\n        emit MockUnoswapTo(recipient, srcToken, amount, minReturn, pools);\n        returnAmount = 0;\n    }\n\n    /**\n     * @dev does not do any transfers. Just emits MockUniswapV3SwapTo.\n     */\n    function uniswapV3SwapTo(\n        address payable recipient,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] calldata pools\n    ) public returns (uint256 returnAmount) {\n        emit MockUniswapV3SwapTo(recipient, amount, minReturn, pools);\n        returnAmount = 0;\n    }\n}\n"
    },
    "contracts/mocks/MockAave.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20, ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { MintableERC20 } from \"./MintableERC20.sol\";\nimport { IAaveLendingPool, ILendingPoolAddressesProvider } from \"../strategies/IAave.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\n// 1. User calls 'getLendingPool'\n// 2. User calls 'deposit' (Aave)\n//  - Deposit their underlying\n//  - Mint aToken to them\n// 3. User calls redeem (aToken)\n//  - Retrieve their aToken\n//  - Return equal amount of underlying\n\ncontract MockAToken is MintableERC20 {\n    address public lendingPool;\n    IERC20 public underlyingToken;\n    using SafeERC20 for IERC20;\n\n    constructor(\n        address _lendingPool,\n        string memory _name,\n        string memory _symbol,\n        IERC20 _underlyingToken\n    ) ERC20(_name, _symbol) {\n        lendingPool = _lendingPool;\n        underlyingToken = _underlyingToken;\n        // addMinter(_lendingPool);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return ERC20(address(underlyingToken)).decimals();\n    }\n\n    function poolRedeem(uint256 _amount, address _to) external {\n        require(msg.sender == lendingPool, \"pool only\");\n        // Redeem these a Tokens\n        _burn(_to, _amount);\n        // For the underlying\n        underlyingToken.safeTransferFrom(lendingPool, _to, _amount);\n    }\n}\n\ncontract MockAave is IAaveLendingPool, ILendingPoolAddressesProvider {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    mapping(address => address) reserveToAToken;\n    address pool = address(this);\n    address payable core = payable(address(this));\n    uint256 factor;\n\n    function addAToken(address _aToken, address _underlying) public {\n        IERC20(_underlying).safeApprove(_aToken, 0);\n        IERC20(_underlying).safeApprove(_aToken, type(uint256).max);\n        reserveToAToken[_underlying] = _aToken;\n    }\n\n    // set the reserve factor / basically the interest on deposit\n    // in 18 precision\n    // so 0.5% would be 5 * 10 ^ 15\n    function setFactor(uint256 factor_) public {\n        factor = factor_;\n    }\n\n    function deposit(\n        address _reserve,\n        uint256 _amount,\n        address _to,\n        uint16 /*_referralCode*/\n    ) external override {\n        uint256 previousBal = IERC20(reserveToAToken[_reserve]).balanceOf(\n            msg.sender\n        );\n        uint256 interest = previousBal.mulTruncate(factor);\n        MintableERC20(reserveToAToken[_reserve]).mintTo(msg.sender, interest);\n        // Take their reserve\n        IERC20(_reserve).safeTransferFrom(msg.sender, address(this), _amount);\n        // Credit them with aToken\n        MintableERC20(reserveToAToken[_reserve]).mintTo(_to, _amount);\n    }\n\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external override returns (uint256) {\n        MockAToken atoken = MockAToken(reserveToAToken[asset]);\n        atoken.poolRedeem(amount, to);\n        return amount;\n    }\n\n    function getLendingPool() external view override returns (address) {\n        return pool;\n    }\n}\n"
    },
    "contracts/mocks/MockAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { MockStkAave } from \"./MockStkAave.sol\";\n\ncontract MockAaveIncentivesController {\n    mapping(address => uint256) private rewards;\n    MockStkAave public REWARD_TOKEN;\n\n    constructor(address _reward_token) {\n        REWARD_TOKEN = MockStkAave(_reward_token);\n    }\n\n    function setRewardsBalance(address user, uint256 amount) external {\n        rewards[user] = amount;\n    }\n\n    /**\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n     * @param user The address of the user\n     * @return The rewards\n     **/\n    // solhint-disable-next-line no-unused-vars\n    function getRewardsBalance(address[] calldata assets, address user)\n        external\n        view\n        returns (uint256)\n    {\n        return rewards[user];\n    }\n\n    /**\n     * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\n     * @param amount Amount of rewards to claim\n     * @param to Address that will be receiving the rewards\n     * @return Rewards claimed\n     **/\n    function claimRewards(\n        // solhint-disable-next-line no-unused-vars\n        address[] calldata assets,\n        uint256 amount,\n        address to\n    ) external returns (uint256) {\n        require(amount > 0);\n        require(rewards[to] == amount);\n        REWARD_TOKEN.mint(amount);\n        require(REWARD_TOKEN.transfer(to, amount));\n        // solhint-disable-next-line reentrancy\n        rewards[to] = 0;\n        return amount;\n    }\n}\n"
    },
    "contracts/mocks/MockAAVEToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockAAVEToken is MintableERC20 {\n    constructor() ERC20(\"AAVE\", \"AAVE\") {}\n}\n"
    },
    "contracts/mocks/MockAero.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockAero is MintableERC20 {\n    constructor() ERC20(\"Aerodrome\", \"AERO\") {}\n\n    function deposit() external payable {\n        _mint(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) external {\n        _burn(msg.sender, wad);\n        payable(msg.sender).transfer(wad);\n    }\n}\n"
    },
    "contracts/mocks/MockAura.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockAura is MintableERC20 {\n    constructor() ERC20(\"Aura\", \"AURA\") {}\n}\n"
    },
    "contracts/mocks/MockBAL.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockBAL is MintableERC20 {\n    constructor() ERC20(\"Balancer\", \"BAL\") {}\n}\n"
    },
    "contracts/mocks/MockBalancerVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IBalancerVault } from \"../interfaces/balancer/IBalancerVault.sol\";\nimport { MintableERC20 } from \"./MintableERC20.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\n// import \"hardhat/console.sol\";\n\ncontract MockBalancerVault {\n    using StableMath for uint256;\n    uint256 public slippage = 1 ether;\n    bool public transferDisabled = false;\n    bool public slippageErrorDisabled = false;\n\n    function swap(\n        IBalancerVault.SingleSwap calldata singleSwap,\n        IBalancerVault.FundManagement calldata funds,\n        uint256 minAmountOut,\n        uint256\n    ) external returns (uint256 amountCalculated) {\n        amountCalculated = (minAmountOut * slippage) / 1 ether;\n        if (!slippageErrorDisabled) {\n            require(amountCalculated >= minAmountOut, \"Slippage error\");\n        }\n        IERC20(singleSwap.assetIn).transferFrom(\n            funds.sender,\n            address(this),\n            singleSwap.amount\n        );\n        if (!transferDisabled) {\n            MintableERC20(singleSwap.assetOut).mintTo(\n                funds.recipient,\n                amountCalculated\n            );\n        }\n    }\n\n    function setSlippage(uint256 _slippage) external {\n        slippage = _slippage;\n    }\n\n    function getPoolTokenInfo(bytes32 poolId, address token)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            address\n        )\n    {}\n\n    function disableTransfer() external {\n        transferDisabled = true;\n    }\n\n    function disableSlippageError() external {\n        slippageErrorDisabled = true;\n    }\n}\n"
    },
    "contracts/mocks/MockBeaconConsolidation.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { BeaconConsolidation } from \"../beacon/BeaconConsolidation.sol\";\n\ncontract MockBeaconConsolidation {\n    function fee() external view returns (uint256) {\n        return BeaconConsolidation.fee();\n    }\n\n    function request(bytes calldata source, bytes calldata target)\n        external\n        returns (uint256 fee_)\n    {\n        return BeaconConsolidation.request(source, target);\n    }\n}\n"
    },
    "contracts/mocks/MockBeaconProofs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { BeaconProofsLib } from \"../beacon/BeaconProofsLib.sol\";\nimport { BeaconProofs } from \"../beacon/BeaconProofs.sol\";\n\ncontract MockBeaconProofs is BeaconProofs {\n    function concatGenIndices(\n        uint256 index1,\n        uint256 height2,\n        uint256 index2\n    ) external pure returns (uint256 genIndex) {\n        return BeaconProofsLib.concatGenIndices(index1, height2, index2);\n    }\n}\n"
    },
    "contracts/mocks/MockBeaconRoots.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { BeaconRoots } from \"../beacon/BeaconRoots.sol\";\n\ncontract MockBeaconRoots {\n    // Mapping to simulate the ring buffer: timestamp => beacon block root\n    mapping(uint256 => bytes32) internal _beaconRoots;\n\n    // Event to log when a new root is set (for testing)\n    event RootSet(uint256 indexed timestamp, bytes32 root);\n\n    // Fallback function to handle raw 32-byte timestamp input\n    // solhint-disable no-complex-fallback\n    fallback() external {\n        // Ensure input is exactly 32 bytes (big-endian encoded timestamp)\n        require(msg.data.length == 32, \"Input must be 32 bytes\");\n\n        // Decode the 32-byte input as a uint256 timestamp (big-endian)\n        uint256 timestamp = abi.decode(msg.data, (uint256));\n\n        // Don't do any validation of timestamp so we can test any block\n\n        // Retrieve the root. Will return bytes32(0) if not set.\n        bytes32 root = _beaconRoots[timestamp];\n\n        // Return the 32-byte root directly\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(0, root)\n            return(0, 32)\n        }\n    }\n\n    // Mock function to set a beacon block root (for testing)\n    function setBeaconRoot(uint256 timestamp, bytes32 root) external {\n        require(timestamp > 0, \"Invalid timestamp\");\n        require(root != bytes32(0), \"Invalid root\");\n\n        // Store the root at the given timestamp\n        _beaconRoots[timestamp] = root;\n\n        emit RootSet(timestamp, root);\n    }\n\n    function setBeaconRoot(bytes32 root) external {\n        require(root != bytes32(0), \"Invalid root\");\n\n        // Store the root at the given timestamp\n        _beaconRoots[block.timestamp] = root;\n\n        emit RootSet(block.timestamp, root);\n    }\n\n    function parentBlockRoot(uint64 timestamp)\n        external\n        view\n        returns (bytes32 parentRoot)\n    {\n        return BeaconRoots.parentBlockRoot(timestamp);\n    }\n\n    function latestBlockRoot()\n        external\n        view\n        returns (bytes32 parentRoot, uint64 timestamp)\n    {\n        timestamp = uint64(block.timestamp);\n        parentRoot = BeaconRoots.parentBlockRoot(timestamp);\n    }\n}\n"
    },
    "contracts/mocks/MockChainlinkOracleFeed.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\n\ncontract MockChainlinkOracleFeed is AggregatorV3Interface {\n    int256 price;\n    uint8 numDecimals;\n\n    constructor(int256 _price, uint8 _decimals) {\n        price = _price;\n        numDecimals = _decimals;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return numDecimals;\n    }\n\n    function description() external pure override returns (string memory) {\n        return \"MockOracleEthFeed\";\n    }\n\n    function version() external pure override returns (uint256) {\n        return 1;\n    }\n\n    function setPrice(int256 _price) public {\n        price = _price;\n    }\n\n    function setDecimals(uint8 _decimals) public {\n        numDecimals = _decimals;\n    }\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        roundId = _roundId;\n        answer = price;\n        startedAt = 0;\n        updatedAt = 0;\n        answeredInRound = 0;\n    }\n\n    function latestRoundData()\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        roundId = 0;\n        answer = price;\n        startedAt = 0;\n        updatedAt = block.timestamp;\n        answeredInRound = 0;\n    }\n}\n"
    },
    "contracts/mocks/MockCOMP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockCOMP is MintableERC20 {\n    constructor() ERC20(\"COMP\", \"COMP\") {}\n}\n"
    },
    "contracts/mocks/MockComptroller.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ncontract MockComptroller {\n    // Claim all the COMP accrued by specific holders in specific markets for their supplies and/or borrows\n    function claimComp(\n        address[] memory holders,\n        address[] memory cTokens,\n        bool borrowers,\n        bool suppliers\n    ) external {}\n}\n"
    },
    "contracts/mocks/MockCToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20, ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { ICERC20 } from \"../strategies/ICompound.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\ncontract MockCToken is ICERC20, ERC20 {\n    using StableMath for uint256;\n\n    IERC20 public underlyingToken;\n    // underlying = cToken * exchangeRate\n    // cToken = underlying / exchangeRate\n    uint256 exchangeRate;\n    address public override comptroller;\n\n    constructor(ERC20 _underlyingToken, address _comptroller)\n        ERC20(\"cMock\", \"cMK\")\n    {\n        uint8 underlyingDecimals = _underlyingToken.decimals();\n        // if has 18 dp, exchange rate should be 1e26\n        // if has 8 dp, exchange rate should be 1e18\n        if (underlyingDecimals > 8) {\n            exchangeRate = 10**uint256(18 + underlyingDecimals - 10);\n        } else if (underlyingDecimals < 8) {\n            // e.g. 18-8+6 = 16\n            exchangeRate = 10**uint256(18 - 8 + underlyingDecimals);\n        } else {\n            exchangeRate = 1e18;\n        }\n        underlyingToken = _underlyingToken;\n        comptroller = _comptroller;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return 8;\n    }\n\n    function mint(uint256 mintAmount) public override returns (uint256) {\n        // Credit them with cToken\n        _mint(msg.sender, mintAmount.divPrecisely(exchangeRate));\n        // Take their reserve\n        underlyingToken.transferFrom(msg.sender, address(this), mintAmount);\n        return 0;\n    }\n\n    function redeem(uint256 redeemAmount) external override returns (uint256) {\n        uint256 tokenAmount = redeemAmount.mulTruncate(exchangeRate);\n        // Burn the cToken\n        _burn(msg.sender, redeemAmount);\n        // Transfer underlying to caller\n        underlyingToken.transfer(msg.sender, tokenAmount);\n        return 0;\n    }\n\n    function redeemUnderlying(uint256 redeemAmount)\n        external\n        override\n        returns (uint256)\n    {\n        uint256 cTokens = redeemAmount.divPrecisely(exchangeRate);\n        // Burn the cToken\n        _burn(msg.sender, cTokens);\n        // Transfer underlying to caller\n        underlyingToken.transfer(msg.sender, redeemAmount);\n        return 0;\n    }\n\n    function balanceOfUnderlying(address owner)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 cTokenBal = this.balanceOf(owner);\n        return cTokenBal.mulTruncate(exchangeRate);\n    }\n\n    function balanceOf(address owner)\n        public\n        view\n        override(ICERC20, ERC20)\n        returns (uint256)\n    {\n        return ERC20.balanceOf(owner);\n    }\n\n    function updateExchangeRate()\n        internal\n        view\n        returns (uint256 newExchangeRate)\n    {\n        uint256 factor = 100002 * (10**13); // 0.002%\n        newExchangeRate = exchangeRate.mulTruncate(factor);\n    }\n\n    function exchangeRateStored() external view override returns (uint256) {\n        return exchangeRate;\n    }\n\n    function supplyRatePerBlock() external pure override returns (uint256) {\n        return 141 * (10**8);\n    }\n}\n"
    },
    "contracts/mocks/MockCVXLocker.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockCVXLocker {\n    address public immutable cvx;\n    mapping(address => uint256) public lockedBalanceOf;\n\n    constructor(address _cvx) {\n        cvx = _cvx;\n    }\n\n    function lock(\n        address _account,\n        uint256 _amount,\n        uint256\n    ) external {\n        lockedBalanceOf[_account] += _amount;\n        ERC20(cvx).transferFrom(msg.sender, address(this), _amount);\n    }\n\n    function unlockAllTokens(address _account) external {\n        lockedBalanceOf[_account] = 0;\n        ERC20(cvx).transfer(_account, lockedBalanceOf[_account]);\n    }\n}\n"
    },
    "contracts/mocks/MockDAI.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockDAI is MintableERC20 {\n    constructor() ERC20(\"DAI\", \"DAI\") {}\n}\n"
    },
    "contracts/mocks/MockDepositContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IDepositContract } from \"./../interfaces/IDepositContract.sol\";\n\ncontract MockDepositContract is IDepositContract {\n    uint256 deposit_count;\n\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawal_credentials,\n        bytes calldata signature,\n        bytes32 deposit_data_root\n    ) external payable override {\n        require(pubkey.length == 48, \"DepositContract: invalid pubkey length\");\n        require(\n            withdrawal_credentials.length == 32,\n            \"DepositContract: invalid withdrawal_credentials length\"\n        );\n        require(\n            signature.length == 96,\n            \"DepositContract: invalid signature length\"\n        );\n\n        // Check deposit amount\n        require(msg.value >= 1 ether, \"DepositContract: deposit value too low\");\n        require(\n            msg.value % 1 gwei == 0,\n            \"DepositContract: deposit value not multiple of gwei\"\n        );\n        uint256 deposit_amount = msg.value / 1 gwei;\n        require(\n            deposit_amount <= type(uint64).max,\n            \"DepositContract: deposit value too high\"\n        );\n\n        // Emit `DepositEvent` log\n        bytes memory amount = to_little_endian_64(uint64(deposit_amount));\n        emit DepositEvent(\n            pubkey,\n            withdrawal_credentials,\n            amount,\n            signature,\n            to_little_endian_64(uint64(deposit_count))\n        );\n        require(\n            deposit_data_root != 0,\n            \"DepositContract: invalid deposit_data_root\"\n        );\n    }\n\n    function get_deposit_root() external view override returns (bytes32) {\n        // just return some bytes32\n        return sha256(abi.encodePacked(deposit_count, bytes16(0)));\n    }\n\n    /// @notice Query the current deposit count.\n    /// @return The deposit count encoded as a little endian 64-bit number.\n    function get_deposit_count() external view override returns (bytes memory) {\n        return to_little_endian_64(uint64(deposit_count));\n    }\n\n    function to_little_endian_64(uint64 value)\n        internal\n        pure\n        returns (bytes memory ret)\n    {\n        ret = new bytes(8);\n        bytes8 bytesValue = bytes8(value);\n        // Byteswapping during copying to bytes.\n        ret[0] = bytesValue[7];\n        ret[1] = bytesValue[6];\n        ret[2] = bytesValue[5];\n        ret[3] = bytesValue[4];\n        ret[4] = bytesValue[3];\n        ret[5] = bytesValue[2];\n        ret[6] = bytesValue[1];\n        ret[7] = bytesValue[0];\n    }\n}\n"
    },
    "contracts/mocks/MockEvilDAI.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract MockEvilDAI is MintableERC20 {\n    address host;\n    address realCoin;\n\n    constructor(address _host, address _realCoin) ERC20(\"DAI\", \"DAI\") {\n        host = _host;\n        realCoin = _realCoin;\n    }\n\n    function transferFrom(\n        // solhint-disable-next-line no-unused-vars\n        address _from,\n        // solhint-disable-next-line no-unused-vars\n        address _to,\n        uint256 _amount\n    ) public override returns (bool) {\n        // call mint again!\n        if (_amount != 69) {\n            IVault(host).mint(address(this), 69, 0);\n        }\n        return true;\n    }\n}\n"
    },
    "contracts/mocks/MockEvilReentrantContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { IRateProvider } from \"../interfaces/balancer/IRateProvider.sol\";\n\nimport { IBalancerVault } from \"../interfaces/balancer/IBalancerVault.sol\";\nimport { IERC20 } from \"../utils/InitializableAbstractStrategy.sol\";\n\nimport { StableMath } from \"../utils/StableMath.sol\";\n\ncontract MockEvilReentrantContract {\n    using StableMath for uint256;\n\n    IBalancerVault public immutable balancerVault;\n    IERC20 public immutable reth;\n    IERC20 public immutable weth;\n    IVault public immutable oethVault;\n    address public immutable poolAddress;\n    bytes32 public immutable balancerPoolId;\n\n    constructor(\n        address _balancerVault,\n        address _oethVault,\n        address _reth,\n        address _weth,\n        address _poolAddress,\n        bytes32 _poolId\n    ) {\n        balancerVault = IBalancerVault(_balancerVault);\n        oethVault = IVault(_oethVault);\n        reth = IERC20(_reth);\n        weth = IERC20(_weth);\n        poolAddress = _poolAddress;\n        balancerPoolId = _poolId;\n    }\n\n    function doEvilStuff() public {\n        address priceProvider = oethVault.priceProvider();\n        uint256 rethPrice = IOracle(priceProvider).price(address(reth));\n\n        // 1. Join pool\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = uint256(10 ether);\n        amounts[1] = rethPrice * 10;\n\n        address[] memory assets = new address[](2);\n        assets[0] = address(reth);\n        assets[1] = address(weth);\n\n        uint256 minBPT = getBPTExpected(assets, amounts).mulTruncate(\n            0.99 ether\n        );\n\n        bytes memory joinUserData = abi.encode(\n            IBalancerVault.WeightedPoolJoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n            amounts,\n            minBPT\n        );\n\n        IBalancerVault.JoinPoolRequest memory joinRequest = IBalancerVault\n            .JoinPoolRequest(assets, amounts, joinUserData, false);\n\n        balancerVault.joinPool(\n            balancerPoolId,\n            address(this),\n            address(this),\n            joinRequest\n        );\n\n        uint256 bptTokenBalance = IERC20(poolAddress).balanceOf(address(this));\n\n        // 2. Redeem as ETH\n        bytes memory exitUserData = abi.encode(\n            IBalancerVault.WeightedPoolExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n            bptTokenBalance,\n            1\n        );\n\n        assets[1] = address(0); // Receive ETH instead of WETH\n        uint256[] memory exitAmounts = new uint256[](2);\n        exitAmounts[1] = 15 ether;\n        IBalancerVault.ExitPoolRequest memory exitRequest = IBalancerVault\n            .ExitPoolRequest(assets, exitAmounts, exitUserData, false);\n\n        balancerVault.exitPool(\n            balancerPoolId,\n            address(this),\n            payable(address(this)),\n            exitRequest\n        );\n        bptTokenBalance = IERC20(poolAddress).balanceOf(address(this));\n    }\n\n    function getBPTExpected(address[] memory _assets, uint256[] memory _amounts)\n        internal\n        view\n        virtual\n        returns (uint256 bptExpected)\n    {\n        // Get the oracle from the OETH Vault\n        address priceProvider = oethVault.priceProvider();\n\n        for (uint256 i = 0; i < _assets.length; ++i) {\n            uint256 strategyAssetMarketPrice = IOracle(priceProvider).price(\n                _assets[i]\n            );\n            // convert asset amount to ETH amount\n            bptExpected =\n                bptExpected +\n                _amounts[i].mulTruncate(strategyAssetMarketPrice);\n        }\n\n        uint256 bptRate = IRateProvider(poolAddress).getRate();\n        // Convert ETH amount to BPT amount\n        bptExpected = bptExpected.divPrecisely(bptRate);\n    }\n\n    function approveAllTokens() public {\n        // Approve all tokens\n        weth.approve(address(oethVault), type(uint256).max);\n        reth.approve(poolAddress, type(uint256).max);\n        weth.approve(poolAddress, type(uint256).max);\n        reth.approve(address(balancerVault), type(uint256).max);\n        weth.approve(address(balancerVault), type(uint256).max);\n    }\n\n    receive() external payable {\n        // 3. Try to mint OETH\n        oethVault.mint(address(weth), 1 ether, 0.9 ether);\n    }\n}\n"
    },
    "contracts/mocks/MockfrxETH.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockfrxETH is MintableERC20 {\n    constructor() ERC20(\"frxETH\", \"frxETH\") {}\n}\n"
    },
    "contracts/mocks/MockFrxETHMinter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockFrxETHMinter {\n    address public immutable frxETH;\n    address public immutable sfrxETH;\n\n    constructor(address _frxETH, address _sfrxETH) {\n        frxETH = _frxETH;\n        sfrxETH = _sfrxETH;\n    }\n\n    function submitAndDeposit(address recipient)\n        external\n        payable\n        returns (uint256 shares)\n    {\n        IMintableERC20(frxETH).mintTo(sfrxETH, msg.value);\n        IMintableERC20(sfrxETH).mintTo(recipient, msg.value);\n        shares = msg.value;\n    }\n}\n"
    },
    "contracts/mocks/MockLimitedWrappedOusd.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { WrappedOusd } from \"../token/WrappedOusd.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockLimitedWrappedOusd is WrappedOusd {\n    constructor(ERC20 underlying_) WrappedOusd(underlying_) {}\n\n    function maxDeposit(address)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return 1e18;\n    }\n}\n"
    },
    "contracts/mocks/MockMaverickDistributor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IMaverickV2Pool } from \"../interfaces/plume/IMaverickV2Pool.sol\";\n\ncontract MockMaverickDistributor {\n    IERC20 public immutable rewardToken;\n\n    uint256 public lastEpoch;\n    uint256 public rewardAmount;\n\n    constructor(address _rewardToken) {\n        rewardToken = IERC20(_rewardToken);\n    }\n\n    function setLastEpoch(uint256 _epoch) external {\n        lastEpoch = _epoch;\n    }\n\n    function setRewardTokenAmount(uint256 _amount) external {\n        rewardAmount = _amount;\n    }\n\n    function claimLp(\n        address recipient,\n        uint256,\n        IMaverickV2Pool,\n        uint32[] memory,\n        uint256\n    ) external returns (uint256 amount) {\n        rewardToken.transfer(recipient, rewardAmount);\n        return rewardAmount;\n    }\n}\n"
    },
    "contracts/mocks/MockMetadataToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n// IERC20Metadata is used in the resolveAsset function in contracts/utils/assets.js\n// We just need to import it here to make its ABI available to Hardhat\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n"
    },
    "contracts/mocks/MockMintableUniswapPair.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\nimport \"./MockUniswapPair.sol\";\n\ncontract MockMintableUniswapPair is MockUniswapPair, MintableERC20 {\n    constructor(\n        address _token0,\n        address _token1,\n        uint112 _reserve0,\n        uint112 _reserve1\n    )\n        MockUniswapPair(_token0, _token1, _reserve0, _reserve1)\n        ERC20(\"Uniswap V2\", \"UNI-v2\")\n    {}\n\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n}\n"
    },
    "contracts/mocks/MockNonRebasing.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IVault } from \"../interfaces/IVault.sol\";\n\nimport { OUSD } from \"../token/OUSD.sol\";\n\ncontract MockNonRebasing {\n    OUSD oUSD;\n\n    function setOUSD(address _oUSDAddress) public {\n        oUSD = OUSD(_oUSDAddress);\n    }\n\n    function rebaseOptIn() public {\n        oUSD.rebaseOptIn();\n    }\n\n    function rebaseOptOut() public {\n        oUSD.rebaseOptOut();\n    }\n\n    function transfer(address _to, uint256 _value) public {\n        oUSD.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public {\n        oUSD.transferFrom(_from, _to, _value);\n    }\n\n    function approve(address _spender, uint256 _addedValue) public {\n        oUSD.approve(_spender, _addedValue);\n    }\n\n    function mintOusd(\n        address _vaultContract,\n        address _asset,\n        uint256 _amount\n    ) public {\n        IVault(_vaultContract).mint(_asset, _amount, 0);\n    }\n\n    function redeemOusd(address _vaultContract, uint256 _amount) public {\n        IVault(_vaultContract).redeem(_amount, 0);\n    }\n\n    function approveFor(\n        address _contract,\n        address _spender,\n        uint256 _addedValue\n    ) public {\n        IERC20(_contract).approve(_spender, _addedValue);\n    }\n}\n"
    },
    "contracts/mocks/MockNonStandardToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"./MintableERC20.sol\";\n\n/**\n * Mock token contract to simulate tokens that don't\n * throw/revert when a transfer/transferFrom call fails\n */\ncontract MockNonStandardToken is MintableERC20 {\n    using SafeMath for uint256;\n\n    constructor() ERC20(\"NonStandardToken\", \"NonStandardToken\") {}\n\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n\n    function transfer(address recipient, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        if (balanceOf(msg.sender) < amount) {\n            // Fail silently\n            return false;\n        }\n\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        if (balanceOf(sender) < amount) {\n            // Fail silently\n            return false;\n        }\n\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            allowance(sender, _msgSender()).sub(\n                amount,\n                \"ERC20: transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n}\n"
    },
    "contracts/mocks/MockOETHVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { OETHVaultCore } from \"../vault/OETHVaultCore.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport \"../utils/Helpers.sol\";\n\ncontract MockOETHVault is OETHVaultCore {\n    using StableMath for uint256;\n\n    constructor(address _weth) OETHVaultCore(_weth) {\n        _setGovernor(msg.sender);\n    }\n\n    function supportAsset(address asset) external {\n        assets[asset] = Asset({\n            isSupported: true,\n            unitConversion: UnitConversion(0),\n            decimals: 18,\n            allowedOracleSlippageBps: 0\n        });\n\n        allAssets.push(asset);\n    }\n}\n"
    },
    "contracts/mocks/MockOETHVaultAdmin.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { OETHVaultAdmin } from \"../vault/OETHVaultAdmin.sol\";\n\ncontract MockOETHVaultAdmin is OETHVaultAdmin {\n    constructor(address _weth) OETHVaultAdmin(_weth) {}\n\n    // fetches the WETH amount in outstanding withdrawals\n    function outstandingWithdrawalsAmount()\n        external\n        view\n        returns (uint256 wethAmount)\n    {\n        WithdrawalQueueMetadata memory queue = withdrawalQueueMetadata;\n\n        // The amount of WETH that is still to be claimed in the withdrawal queue\n        wethAmount = queue.queued - queue.claimed;\n    }\n\n    function wethAvailable() external view returns (uint256) {\n        return _wethAvailable();\n    }\n}\n"
    },
    "contracts/mocks/MockOGN.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./BurnableERC20.sol\";\nimport \"./MintableERC20.sol\";\n\n/**\n * @title Origin token (OGN).\n *\n * @dev Token that allows minting and burning.\n * @dev Important note:\n * @dev   There is a known race condition in the ERC20 standard on the approve() method.\n * @dev   See details: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n * @dev   The Origin token contract implements the increaseApproval() and decreaseApproval() methods.\n * @dev   It is strongly recommended to use those methods rather than approve()\n * @dev   when updating the token allowance.\n */\ncontract MockOGN is MintableERC20, BurnableERC20 {\n    event SetWhitelistExpiration(uint256 expiration);\n    event AllowedTransactorAdded(address sender);\n    event AllowedTransactorRemoved(address sender);\n    event AddCallSpenderWhitelist(address enabler, address spender);\n    event RemoveCallSpenderWhitelist(address disabler, address spender);\n\n    mapping(address => bool) public callSpenderWhitelist;\n    address public owner = msg.sender;\n    // UNIX timestamp (in seconds) after which this whitelist no longer applies\n    uint256 public whitelistExpiration;\n    // While the whitelist is active, either the sender or recipient must be\n    // in allowedTransactors.\n    mapping(address => bool) public allowedTransactors;\n\n    // @dev Constructor that gives msg.sender all initial tokens.\n    constructor(uint256 _initialSupply) ERC20(\"OriginToken\", \"OGN\") {\n        owner = msg.sender;\n        _mint(owner, _initialSupply);\n    }\n\n    //\n    // approveAndCall methods\n    //\n\n    // @dev Add spender to whitelist of spenders for approveAndCall\n    // @param _spender Address to add\n    function addCallSpenderWhitelist(address _spender) public onlyOwner {\n        callSpenderWhitelist[_spender] = true;\n        emit AddCallSpenderWhitelist(msg.sender, _spender);\n    }\n\n    // @dev Remove spender from whitelist of spenders for approveAndCall\n    // @param _spender Address to remove\n    function removeCallSpenderWhitelist(address _spender) public onlyOwner {\n        delete callSpenderWhitelist[_spender];\n        emit RemoveCallSpenderWhitelist(msg.sender, _spender);\n    }\n\n    // @dev Approve transfer of tokens and make a contract call in a single\n    // @dev transaction. This allows a DApp to avoid requiring two MetaMask\n    // @dev approvals for a single logical action, such as creating a listing,\n    // @dev which requires the seller to approve a token transfer and the\n    // @dev marketplace contract to transfer tokens from the seller.\n    //\n    // @dev This is based on the ERC827 function approveAndCall and avoids\n    // @dev security issues by only working with a whitelisted set of _spender\n    // @dev addresses. The other difference is that the combination of this\n    // @dev function ensures that the proxied function call receives the\n    // @dev msg.sender for this function as its first parameter.\n    //\n    // @param _spender The address that will spend the funds.\n    // @param _value The amount of tokens to be spent.\n    // @param _selector Function selector for function to be called.\n    // @param _callParams Packed, encoded parameters, omitting the first parameter which is always msg.sender\n    function approveAndCallWithSender(\n        address _spender,\n        uint256 _value,\n        bytes4 _selector,\n        bytes memory _callParams\n    ) public payable returns (bool) {\n        require(_spender != address(this), \"token contract can't be approved\");\n        require(callSpenderWhitelist[_spender], \"spender not in whitelist\");\n\n        require(super.approve(_spender, _value), \"approve failed\");\n\n        bytes memory callData = abi.encodePacked(\n            _selector,\n            uint256(uint160(msg.sender)),\n            _callParams\n        );\n        // solium-disable-next-line security/no-call-value\n        (bool success, ) = _spender.call{ value: msg.value }(callData);\n        require(success, \"proxied call failed\");\n        return true;\n    }\n\n    //\n    // Functions for maintaining whitelist\n    //\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    modifier allowedTransfer(address _from, address _to) {\n        require(\n            // solium-disable-next-line operator-whitespace\n            !whitelistActive() ||\n                allowedTransactors[_from] ||\n                allowedTransactors[_to],\n            \"neither sender nor recipient are allowed\"\n        );\n        _;\n    }\n\n    function whitelistActive() public view returns (bool) {\n        return block.timestamp < whitelistExpiration;\n    }\n\n    function addAllowedTransactor(address _transactor) public onlyOwner {\n        emit AllowedTransactorAdded(_transactor);\n        allowedTransactors[_transactor] = true;\n    }\n\n    function removeAllowedTransactor(address _transactor) public onlyOwner {\n        emit AllowedTransactorRemoved(_transactor);\n        delete allowedTransactors[_transactor];\n    }\n\n    /**\n     * @dev Set the whitelist expiration, after which the whitelist no longer\n     * applies.\n     */\n    function setWhitelistExpiration(uint256 _expiration) public onlyOwner {\n        // allow only if whitelist expiration hasn't yet been set, or if the\n        // whitelist expiration hasn't passed yet\n        require(\n            whitelistExpiration == 0 || whitelistActive(),\n            \"an expired whitelist cannot be extended\"\n        );\n        // prevent possible mistakes in calling this function\n        require(\n            _expiration >= block.timestamp + 1 days,\n            \"whitelist expiration not far enough into the future\"\n        );\n        emit SetWhitelistExpiration(_expiration);\n        whitelistExpiration = _expiration;\n    }\n\n    //\n    // ERC20 transfer functions that have been overridden to enforce the\n    // whitelist.\n    //\n\n    function transfer(address _to, uint256 _value)\n        public\n        override\n        allowedTransfer(msg.sender, _to)\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public override allowedTransfer(_from, _to) returns (bool) {\n        return super.transferFrom(_from, _to, _value);\n    }\n}\n"
    },
    "contracts/mocks/MockOGV.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockOGV is MintableERC20 {\n    constructor() ERC20(\"OGV\", \"OGV\") {}\n}\n"
    },
    "contracts/mocks/MockOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IPriceOracle.sol\";\nimport \"../interfaces/IMinMaxOracle.sol\";\n\n/**\n * Mock of both price Oracle and min max oracles\n */\ncontract MockOracle is IPriceOracle, IMinMaxOracle {\n    mapping(bytes32 => uint256) prices;\n    mapping(bytes32 => uint256[]) pricesMinMax;\n    uint256 ethMin;\n    uint256 ethMax;\n\n    /**\n     * @dev returns the asset price in USD, 6 decimal digits.\n     * Compatible with the Open Price Feed.\n     */\n    function price(string calldata symbol)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return prices[keccak256(abi.encodePacked(symbol))];\n    }\n\n    /**\n     * @dev sets the price of the asset in USD, 6 decimal digits\n     *\n     */\n    function setPrice(string calldata symbol, uint256 _price) external {\n        prices[keccak256(abi.encodePacked(symbol))] = _price;\n    }\n\n    /**\n     * @dev sets the min and max price of ETH in USD, 6 decimal digits\n     *\n     */\n    function setEthPriceMinMax(uint256 _min, uint256 _max) external {\n        ethMin = _min;\n        ethMax = _max;\n    }\n\n    /**\n     * @dev sets the prices Min Max for a specific symbol in ETH, 8 decimal digits\n     *\n     */\n    function setTokPriceMinMax(\n        string calldata symbol,\n        uint256 _min,\n        uint256 _max\n    ) external {\n        pricesMinMax[keccak256(abi.encodePacked(symbol))] = [_min, _max];\n    }\n\n    /**\n     * @dev get the price of asset in ETH, 8 decimal digits.\n     */\n    function priceMin(string calldata symbol)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256[] storage pMinMax = pricesMinMax[\n            keccak256(abi.encodePacked(symbol))\n        ];\n        return (pMinMax[0] * ethMin) / 1e6;\n    }\n\n    /**\n     * @dev get the price of asset in USD, 8 decimal digits.\n     * Not needed for now\n     */\n    function priceMax(string calldata symbol)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256[] storage pMinMax = pricesMinMax[\n            keccak256(abi.encodePacked(symbol))\n        ];\n        return (pMinMax[1] * ethMax) / 1e6;\n    }\n}\n"
    },
    "contracts/mocks/MockOracleRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { AbstractOracleRouter } from \"../oracle/AbstractOracleRouter.sol\";\n\n// @notice Oracle Router required for testing environment\ncontract MockOracleRouter is AbstractOracleRouter {\n    struct FeedMetadata {\n        address feedAddress;\n        uint256 maxStaleness;\n    }\n\n    mapping(address => FeedMetadata) public assetToFeedMetadata;\n\n    /* @dev Override feed and maxStaleness information for a particular asset\n     * @param _asset the asset to override feed for\n     * @param _feed new feed\n     * @param _maxStaleness new maximum time allowed for feed data to be stale\n     */\n    function setFeed(\n        address _asset,\n        address _feed,\n        uint256 _maxStaleness\n    ) external {\n        assetToFeedMetadata[_asset] = FeedMetadata(_feed, _maxStaleness);\n    }\n\n    /*\n     * The dev version of the Oracle doesn't need to gas optimize and cache the decimals\n     */\n    function getDecimals(address _feed) internal view override returns (uint8) {\n        require(_feed != address(0), \"Asset not available\");\n        require(_feed != FIXED_PRICE, \"Fixed price feeds not supported\");\n\n        return AggregatorV3Interface(_feed).decimals();\n    }\n\n    /**\n     * @dev The price feed contract to use for a particular asset along with\n     *      maximum data staleness\n     * @param asset address of the asset\n     * @return feedAddress address of the price feed for the asset\n     * @return maxStaleness maximum acceptable data staleness duration\n     */\n    function feedMetadata(address asset)\n        internal\n        view\n        override\n        returns (address feedAddress, uint256 maxStaleness)\n    {\n        FeedMetadata storage fm = assetToFeedMetadata[asset];\n        feedAddress = fm.feedAddress;\n        maxStaleness = fm.maxStaleness;\n    }\n}\n"
    },
    "contracts/mocks/MockOracleRouterNoStale.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { OracleRouter } from \"../oracle/OracleRouter.sol\";\nimport { OETHOracleRouter } from \"../oracle/OETHOracleRouter.sol\";\n\n// @notice Oracle Router used to bypass staleness\ncontract MockOracleRouterNoStale is OracleRouter {\n    function feedMetadata(address asset)\n        internal\n        pure\n        virtual\n        override\n        returns (address feedAddress, uint256 maxStaleness)\n    {\n        (feedAddress, ) = super.feedMetadata(asset);\n        maxStaleness = 365 days;\n    }\n}\n\n// @notice Oracle Router used to bypass staleness\ncontract MockOETHOracleRouterNoStale is OETHOracleRouter {\n    constructor() OETHOracleRouter() {}\n\n    function feedMetadata(address asset)\n        internal\n        view\n        virtual\n        override\n        returns (address feedAddress, uint256 maxStaleness)\n    {\n        (feedAddress, ) = super.feedMetadata(asset);\n        maxStaleness = 365 days;\n    }\n}\n"
    },
    "contracts/mocks/MockOracleWeightedPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Variable, OracleAverageQuery, IOracleWeightedPool } from \"../interfaces/balancer/IOracleWeightedPool.sol\";\n\ncontract MockOracleWeightedPool is IOracleWeightedPool {\n    uint256[] public nextResults;\n\n    constructor() {\n        nextResults = [1 ether, 1 ether];\n    }\n\n    function getTimeWeightedAverage(OracleAverageQuery[] memory)\n        external\n        view\n        override\n        returns (uint256[] memory results)\n    {\n        return nextResults;\n    }\n\n    function setNextResults(uint256[] calldata results) external {\n        nextResults = results;\n    }\n}\n"
    },
    "contracts/mocks/MockPartialWithdrawal.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { PartialWithdrawal } from \"../beacon/PartialWithdrawal.sol\";\n\ncontract MockPartialWithdrawal {\n    function fee() external view returns (uint256) {\n        return PartialWithdrawal.fee();\n    }\n\n    function request(bytes calldata validatorPubKey, uint64 amount)\n        external\n        returns (uint256 fee_)\n    {\n        return PartialWithdrawal.request(validatorPubKey, amount);\n    }\n}\n"
    },
    "contracts/mocks/MockRebornMinter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n// solhint-disable-next-line no-console\nimport \"hardhat/console.sol\";\n\ncontract Sanctum {\n    address public asset;\n    address public vault;\n    address public reborner;\n    bool public shouldAttack = false;\n    // should selfdestruct in the constructor\n    bool public shouldDestruct = false;\n    uint256 public targetMethod;\n    address public ousdContract;\n\n    constructor(address _asset, address _vault) {\n        asset = _asset;\n        vault = _vault;\n    }\n\n    function deploy(uint256 salt, bytes memory bytecode)\n        public\n        returns (address addr)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n    }\n\n    function computeAddress(uint256 salt, bytes memory bytecode)\n        public\n        view\n        returns (address)\n    {\n        bytes32 bytecodeHashHash = keccak256(bytecode);\n        bytes32 _data = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                salt,\n                bytecodeHashHash\n            )\n        );\n        return address(bytes20(_data << 96));\n    }\n\n    function setShouldAttack(bool _shouldAttack) public {\n        shouldAttack = _shouldAttack;\n    }\n\n    // should call selfdestruct in the constructor\n    function setShouldDesctruct(bool _shouldDestruct) public {\n        shouldDestruct = _shouldDestruct;\n    }\n\n    function setTargetMethod(uint256 target) public {\n        targetMethod = target;\n    }\n\n    function setOUSDAddress(address _ousdContract) public {\n        ousdContract = _ousdContract;\n    }\n}\n\ncontract Reborner {\n    Sanctum sanctum;\n    bool logging = false;\n\n    constructor(address _sanctum) {\n        log(\"We are created...\");\n        sanctum = Sanctum(_sanctum);\n        if (sanctum.shouldAttack()) {\n            log(\"We are attacking now...\");\n\n            uint256 target = sanctum.targetMethod();\n\n            if (target == 1) {\n                redeem();\n            } else if (target == 2) {\n                transfer();\n            } else {\n                mint();\n            }\n        }\n\n        if (sanctum.shouldDestruct()) {\n            bye();\n        }\n    }\n\n    function mint() public {\n        log(\"We are attempting to mint..\");\n        address asset = sanctum.asset();\n        address vault = sanctum.vault();\n        IERC20(asset).approve(vault, 1e18);\n        IVault(vault).mint(asset, 1e18, 0);\n        log(\"We are now minting..\");\n    }\n\n    function redeem() public {\n        log(\"We are attempting to redeem..\");\n        address vault = sanctum.vault();\n        IVault(vault).redeem(1e18, 1e18);\n        log(\"We are now redeeming..\");\n    }\n\n    function transfer() public {\n        log(\"We are attempting to transfer..\");\n        address ousd = sanctum.ousdContract();\n        require(IERC20(ousd).transfer(address(1), 1e18), \"transfer failed\");\n        log(\"We are now transfering..\");\n    }\n\n    function bye() public {\n        log(\"We are now destructing..\");\n        selfdestruct(payable(msg.sender));\n    }\n\n    function log(string memory message) internal view {\n        if (logging) {\n            // solhint-disable-next-line no-console\n            console.log(message);\n        }\n    }\n}\n"
    },
    "contracts/mocks/MockRETH.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\nimport \"../interfaces/IGetExchangeRateToken.sol\";\n\ncontract MockRETH is MintableERC20, IGetExchangeRateToken {\n    uint256 private exchangeRate = 12e17;\n\n    constructor() ERC20(\"Rocket Pool ETH\", \"rETH\") {}\n\n    function getExchangeRate() external view override returns (uint256) {\n        return exchangeRate;\n    }\n\n    function setExchangeRate(uint256 _rate) external {\n        exchangeRate = _rate;\n    }\n}\n"
    },
    "contracts/mocks/MockRoosterAMOStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Rooster AMO strategy exposing extra functionality\n * @author Origin Protocol Inc\n */\n\nimport { RoosterAMOStrategy } from \"../strategies/plume/RoosterAMOStrategy.sol\";\nimport { IMaverickV2Pool } from \"../interfaces/plume/IMaverickV2Pool.sol\";\n\ncontract MockRoosterAMOStrategy is RoosterAMOStrategy {\n    constructor(\n        BaseStrategyConfig memory _stratConfig,\n        address _wethAddress,\n        address _oethpAddress,\n        address _liquidityManager,\n        address _poolLens,\n        address _maverickPosition,\n        address _maverickQuoter,\n        address _mPool,\n        bool _upperTickAtParity,\n        address _votingDistributor,\n        address _poolDistributor\n    )\n        RoosterAMOStrategy(\n            _stratConfig,\n            _wethAddress,\n            _oethpAddress,\n            _liquidityManager,\n            _poolLens,\n            _maverickPosition,\n            _maverickQuoter,\n            _mPool,\n            _upperTickAtParity,\n            _votingDistributor,\n            _poolDistributor\n        )\n    {}\n\n    function getCurrentWethShare() external view returns (uint256) {\n        uint256 _currentPrice = getPoolSqrtPrice();\n\n        return _getWethShare(_currentPrice);\n    }\n}\n"
    },
    "contracts/mocks/MockSFC.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockSFC {\n    error ZeroAmount();\n    error TransferFailed();\n    error StakeIsFullySlashed();\n\n    // Mapping of delegator address to validator ID to amount delegated\n    mapping(address => mapping(uint256 => uint256)) public delegations;\n    // Mapping of delegator address to validator ID to withdrawal request ID to amount\n    mapping(address => mapping(uint256 => mapping(uint256 => uint256)))\n        public withdraws;\n    // validator ID -> slashing refund ratio (allows to withdraw slashed stake)\n    mapping(uint256 => uint256) public slashingRefundRatio;\n\n    function getStake(address delegator, uint256 validatorID)\n        external\n        view\n        returns (uint256)\n    {\n        return delegations[delegator][validatorID];\n    }\n\n    function delegate(uint256 validatorID) external payable {\n        if (msg.value == 0) {\n            revert ZeroAmount();\n        }\n        delegations[msg.sender][validatorID] += msg.value;\n    }\n\n    function undelegate(\n        uint256 validatorID,\n        uint256 wrID,\n        uint256 amount\n    ) external {\n        require(\n            delegations[msg.sender][validatorID] >= amount,\n            \"insufficient stake\"\n        );\n        require(\n            withdraws[msg.sender][validatorID][wrID] == 0,\n            \"withdrawal request already exists\"\n        );\n\n        delegations[msg.sender][validatorID] -= amount;\n        withdraws[msg.sender][validatorID][wrID] = amount;\n    }\n\n    function withdraw(uint256 validatorID, uint256 wrID) external {\n        require(withdraws[msg.sender][validatorID][wrID] > 0, \"no withdrawal\");\n\n        uint256 withdrawAmount = withdraws[msg.sender][validatorID][wrID];\n        uint256 penalty = (withdrawAmount *\n            (1e18 - slashingRefundRatio[validatorID])) / 1e18;\n\n        if (penalty >= withdrawAmount) {\n            revert StakeIsFullySlashed();\n        }\n\n        (bool sent, ) = msg.sender.call{ value: withdrawAmount - penalty }(\"\");\n        if (!sent) {\n            revert TransferFailed();\n        }\n    }\n\n    function pendingRewards(address delegator, uint256 validatorID)\n        external\n        view\n        returns (uint256)\n    {}\n\n    function claimRewards(uint256 validatorID) external {}\n\n    function restakeRewards(uint256 validatorID) external {}\n\n    /// @param refundRatio the percentage of the staked amount that can be refunded. 0.1e18 = 10%, 1e18 = 100%\n    function slashValidator(uint256 validatorID, uint256 refundRatio) external {\n        require(refundRatio <= 1e18, \"invalid refund ratio\");\n        slashingRefundRatio[validatorID] = refundRatio;\n    }\n}\n"
    },
    "contracts/mocks/MocksfrxETH.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MocksfrxETH is MintableERC20 {\n    address public frxETH;\n\n    constructor(address _frxETH) ERC20(\"sfrxETH\", \"sfrxETH\") {\n        frxETH = _frxETH;\n    }\n\n    function setMockfrxETHAddress(address _frxETH) external {\n        frxETH = _frxETH;\n    }\n\n    function deposit(uint256 assets, address receiver)\n        external\n        returns (uint256 shares)\n    {\n        ERC20(frxETH).transferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, assets);\n\n        return assets;\n    }\n\n    function maxWithdraw(address owner) external view returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    function setMaxWithdrawableBalance(address owner, uint256 balance)\n        external\n    {\n        uint256 currentBalance = balanceOf(owner);\n        if (currentBalance > balance) {\n            _burn(owner, currentBalance - balance);\n        } else if (balance > currentBalance) {\n            _mint(owner, balance - currentBalance);\n        }\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets) {\n        _burn(owner, shares);\n\n        ERC20(frxETH).transfer(receiver, shares);\n\n        assets = shares;\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares) {\n        _burn(owner, assets);\n\n        ERC20(frxETH).transfer(receiver, assets);\n\n        shares = assets;\n    }\n\n    function submitAndDeposit(address recipient)\n        external\n        payable\n        returns (uint256 shares)\n    {\n        _mint(recipient, msg.value);\n        shares = msg.value;\n    }\n}\n"
    },
    "contracts/mocks/MockSSV.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockSSV is MintableERC20 {\n    constructor() ERC20(\"SSV Token\", \"SSV\") {}\n}\n"
    },
    "contracts/mocks/MockSSVNetwork.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Cluster } from \"./../interfaces/ISSVNetwork.sol\";\n\ncontract MockSSVNetwork {\n    function registerValidator(\n        bytes calldata publicKey,\n        uint64[] calldata operatorIds,\n        bytes calldata sharesData,\n        uint256 amount,\n        Cluster memory cluster\n    ) external {}\n\n    function bulkRegisterValidator(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds,\n        bytes[] calldata sharesData,\n        uint256 amount,\n        Cluster memory cluster\n    ) external {}\n\n    function exitValidator(\n        bytes calldata publicKey,\n        uint64[] calldata operatorIds\n    ) external {}\n\n    function removeValidator(\n        bytes calldata publicKey,\n        uint64[] calldata operatorIds,\n        Cluster memory cluster\n    ) external {}\n\n    function deposit(\n        address clusterOwner,\n        uint64[] calldata operatorIds,\n        uint256 amount,\n        Cluster memory cluster\n    ) external {}\n\n    function setFeeRecipientAddress(address recipient) external {}\n}\n"
    },
    "contracts/mocks/MockstETH.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockstETH is MintableERC20 {\n    constructor() ERC20(\"stETH\", \"stETH\") {}\n}\n"
    },
    "contracts/mocks/MockStkAave.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./MintableERC20.sol\";\n\ncontract MockStkAave is MintableERC20 {\n    uint256 public COOLDOWN_SECONDS = 864000;\n    uint256 public UNSTAKE_WINDOW = 172800;\n    address public STAKED_TOKEN;\n\n    mapping(address => uint256) public stakerRewardsToClaim;\n    mapping(address => uint256) public stakersCooldowns;\n\n    using SafeERC20 for IERC20;\n\n    constructor(address _stakedToken) ERC20(\"Staked Aave\", \"stkAAVE\") {\n        STAKED_TOKEN = _stakedToken;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n\n    function setStakedToken(address _stakedToken) external {\n        STAKED_TOKEN = _stakedToken;\n    }\n\n    /**\n     * @dev Redeems staked tokens, and stop earning rewards\n     * @param to Address to redeem to\n     * @param amount Amount to redeem\n     **/\n    function redeem(address to, uint256 amount) external {\n        uint256 cooldownStartTimestamp = stakersCooldowns[msg.sender];\n        uint256 windowStart = cooldownStartTimestamp + COOLDOWN_SECONDS;\n        require(amount != 0, \"INVALID_ZERO_AMOUNT\");\n        require(block.timestamp > windowStart, \"INSUFFICIENT_COOLDOWN\");\n        require(\n            block.timestamp - windowStart <= UNSTAKE_WINDOW,\n            \"UNSTAKE_WINDOW_FINISHED\"\n        );\n        uint256 balanceOfMessageSender = balanceOf(msg.sender);\n        uint256 amountToRedeem = (amount > balanceOfMessageSender)\n            ? balanceOfMessageSender\n            : amount;\n\n        stakersCooldowns[msg.sender] = 0;\n        _burn(msg.sender, amountToRedeem);\n        IERC20(STAKED_TOKEN).safeTransfer(to, amountToRedeem);\n    }\n\n    /**\n     * @dev Activates the cooldown period to unstake\n     * - It can't be called if the user is not staking\n     **/\n    function cooldown() external {\n        require(balanceOf(msg.sender) != 0, \"INVALID_BALANCE_ON_COOLDOWN\");\n        stakersCooldowns[msg.sender] = block.timestamp;\n    }\n\n    /**\n     * @dev Test helper function to allow changing the cooldown\n     **/\n    function setCooldown(address account, uint256 _cooldown) external {\n        stakersCooldowns[account] = _cooldown;\n    }\n}\n"
    },
    "contracts/mocks/MockStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockStrategy {\n    address[] public assets;\n\n    address public withdrawAllAsset;\n    address public withdrawAllRecipient;\n\n    constructor() {}\n\n    function deposit(address asset, uint256 amount) external {}\n\n    function depositAll() external {}\n\n    function withdraw(\n        address recipient,\n        address asset,\n        uint256 amount\n    ) external {\n        IERC20(asset).transfer(recipient, amount);\n    }\n\n    function withdrawAll() external {\n        IERC20(withdrawAllAsset).transfer(\n            withdrawAllRecipient,\n            IERC20(withdrawAllAsset).balanceOf(address(this))\n        );\n    }\n\n    function checkBalance(address asset)\n        external\n        view\n        returns (uint256 balance)\n    {\n        balance = IERC20(asset).balanceOf(address(this));\n    }\n\n    function supportsAsset(address) external view returns (bool) {\n        return true;\n    }\n\n    function collectRewardTokens() external {}\n\n    function getRewardTokenAddresses()\n        external\n        view\n        returns (address[] memory)\n    {\n        return new address[](0);\n    }\n\n    function setWithdrawAll(address asset, address recipient) external {\n        withdrawAllAsset = asset;\n        withdrawAllRecipient = recipient;\n    }\n}\n"
    },
    "contracts/mocks/MockSwapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IMintableERC20 } from \"./MintableERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockSwapper {\n    uint256 public nextOutAmount;\n\n    function swap(\n        // solhint-disable-next-line no-unused-vars\n        address _fromAsset,\n        address _toAsset,\n        // solhint-disable-next-line no-unused-vars\n        uint256 _fromAssetAmount,\n        uint256 _minToAssetAmount,\n        // solhint-disable-next-line no-unused-vars\n        bytes calldata _data\n    ) external returns (uint256 toAssetAmount) {\n        toAssetAmount = (nextOutAmount > 0) ? nextOutAmount : _minToAssetAmount;\n        nextOutAmount = 0;\n        IMintableERC20(_toAsset).mint(toAssetAmount);\n        IERC20(_toAsset).transfer(msg.sender, toAssetAmount);\n    }\n\n    function setNextOutAmount(uint256 _nextOutAmount) public {\n        nextOutAmount = _nextOutAmount;\n    }\n}\n"
    },
    "contracts/mocks/MockTUSD.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockTUSD is MintableERC20 {\n    constructor() ERC20(\"TrueUSD\", \"TUSD\") {}\n\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n}\n"
    },
    "contracts/mocks/MockUniswapPair.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IUniswapV2Pair } from \"../interfaces/uniswap/IUniswapV2Pair.sol\";\n\ncontract MockUniswapPair is IUniswapV2Pair {\n    address tok0;\n    address tok1;\n    uint112 reserve0;\n    uint112 reserve1;\n    uint256 blockTimestampLast;\n\n    bool public hasSynced = false;\n\n    constructor(\n        address _token0,\n        address _token1,\n        uint112 _reserve0,\n        uint112 _reserve1\n    ) {\n        tok0 = _token0;\n        tok1 = _token1;\n        reserve0 = _reserve0;\n        reserve1 = _reserve1;\n        blockTimestampLast = block.timestamp;\n    }\n\n    function token0() external view override returns (address) {\n        return tok0;\n    }\n\n    function token1() external view override returns (address) {\n        return tok1;\n    }\n\n    function getReserves()\n        external\n        view\n        override\n        returns (\n            uint112,\n            uint112,\n            uint32\n        )\n    {\n        return (reserve0, reserve1, uint32(blockTimestampLast));\n    }\n\n    function setReserves(uint112 _reserve0, uint112 _reserve1) public {\n        reserve0 = _reserve0;\n        reserve1 = _reserve1;\n        blockTimestampLast = block.timestamp;\n    }\n\n    // CAUTION This will not work if you setReserves multiple times over\n    // multiple different blocks because then it wouldn't be a continuous\n    // reserve factor over that blockTimestamp, this assumes an even reserve\n    // ratio all the way through\n    function price0CumulativeLast() external view override returns (uint256) {\n        return\n            uint256(FixedPoint.fraction(reserve1, reserve0)._x) *\n            blockTimestampLast;\n    }\n\n    function price1CumulativeLast() external view override returns (uint256) {\n        return\n            uint256(FixedPoint.fraction(reserve0, reserve1)._x) *\n            blockTimestampLast;\n    }\n\n    function sync() external override {\n        hasSynced = true;\n    }\n\n    function checkHasSynced() external view {\n        require(hasSynced, \"Not synced\");\n    }\n}\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // returns a uq112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).div(denominator)\n    function fraction(uint112 numerator, uint112 denominator)\n        internal\n        pure\n        returns (uq112x112 memory)\n    {\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) << 112) / denominator);\n    }\n}\n"
    },
    "contracts/mocks/MockUniswapRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { MintableERC20 } from \"./MintableERC20.sol\";\nimport { IUniswapV2Router } from \"../interfaces/uniswap/IUniswapV2Router02.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\ncontract MockUniswapRouter is IUniswapV2Router {\n    using StableMath for uint256;\n\n    mapping(address => address) public pairMaps;\n    uint256 public slippage = 1 ether;\n\n    function initialize(\n        address[] calldata _0tokens,\n        address[] calldata _1tokens\n    ) public {\n        require(\n            _0tokens.length == _1tokens.length,\n            \"Mock token pairs should be of the same length\"\n        );\n        for (uint256 i = 0; i < _0tokens.length; i++) {\n            pairMaps[_0tokens[i]] = _1tokens[i];\n        }\n    }\n\n    function setSlippage(uint256 _slippage) external {\n        slippage = _slippage;\n    }\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        // solhint-disable-next-line no-unused-vars\n        uint256\n    ) external override returns (uint256[] memory amountsOut) {\n        address tok0 = path[0];\n        address tok1 = path[path.length - 1];\n\n        uint256 amountOut = (amountOutMin * slippage) / 1 ether;\n        require(amountOut >= amountOutMin, \"Slippage error\");\n\n        IERC20(tok0).transferFrom(msg.sender, address(this), amountIn);\n        MintableERC20(tok1).mintTo(to, amountOut);\n\n        amountsOut = new uint256[](path.length);\n        amountsOut[path.length - 1] = amountOut;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    function exactInput(ExactInputParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut)\n    {\n        (address tok0, address tok1) = _getFirstAndLastToken(params.path);\n\n        amountOut = (params.amountOutMinimum * slippage) / 1 ether;\n\n        IERC20(tok0).transferFrom(msg.sender, address(this), params.amountIn);\n        MintableERC20(tok1).mintTo(params.recipient, amountOut);\n\n        require(\n            amountOut >= params.amountOutMinimum,\n            \"UniswapMock: amountOut less than amountOutMinimum\"\n        );\n        return amountOut;\n    }\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        override\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        // this is needed to make this contract whole else it'd be just virtual\n    }\n\n    function WETH() external pure override returns (address) {\n        return address(0);\n    }\n\n    // Universal router mock\n    function execute(\n        bytes calldata,\n        bytes[] calldata inputs,\n        uint256\n    ) external payable {\n        uint256 inLen = inputs.length;\n        for (uint256 i = 0; i < inLen; ++i) {\n            (\n                address recipient,\n                ,\n                uint256 amountOutMinimum,\n                bytes memory path,\n\n            ) = abi.decode(inputs[i], (address, uint256, uint256, bytes, bool));\n\n            (address token0, address token1) = _getFirstAndLastToken(path);\n\n            amountOutMinimum = amountOutMinimum.scaleBy(\n                Helpers.getDecimals(token0),\n                Helpers.getDecimals(token1)\n            );\n\n            MintableERC20(token1).mintTo(recipient, amountOutMinimum);\n        }\n    }\n\n    function _getFirstAndLastToken(bytes memory path)\n        internal\n        view\n        returns (address token0, address token1)\n    {\n        bytes memory tok0Bytes = new bytes(20);\n        for (uint256 j = 0; j < 20; ++j) {\n            tok0Bytes[j] = path[j];\n        }\n        token0 = address(bytes20(tok0Bytes));\n\n        if (pairMaps[token0] != address(0)) {\n            token0 = pairMaps[token0];\n        }\n\n        bytes memory tok1Bytes = new bytes(20);\n        uint256 tok1Offset = path.length - 20;\n        for (uint256 j = 0; j < 20; ++j) {\n            tok1Bytes[j] = path[j + tok1Offset];\n        }\n        token1 = address(bytes20(tok1Bytes));\n\n        if (pairMaps[token1] != address(0)) {\n            token1 = pairMaps[token1];\n        }\n    }\n}\n"
    },
    "contracts/mocks/MockUSDC.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockUSDC is MintableERC20 {\n    constructor() ERC20(\"USDC Coin\", \"USDC\") {}\n\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n}\n"
    },
    "contracts/mocks/MockUSDS.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockUSDS is MintableERC20 {\n    constructor() ERC20(\"USDS\", \"USDS\") {}\n}\n"
    },
    "contracts/mocks/MockUSDT.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockUSDT is MintableERC20 {\n    constructor() ERC20(\"USDT Coin\", \"USDT\") {}\n\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n}\n"
    },
    "contracts/mocks/MockVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { VaultCore } from \"../vault/VaultCore.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { VaultInitializer } from \"../vault/VaultInitializer.sol\";\nimport \"../utils/Helpers.sol\";\n\ncontract MockVault is VaultCore {\n    using StableMath for uint256;\n\n    uint256 storedTotalValue;\n\n    function setTotalValue(uint256 _value) public {\n        storedTotalValue = _value;\n    }\n\n    function totalValue() external view override returns (uint256) {\n        return storedTotalValue;\n    }\n\n    function _totalValue() internal view override returns (uint256) {\n        return storedTotalValue;\n    }\n\n    function _checkBalance(address _asset)\n        internal\n        view\n        override\n        returns (uint256 balance)\n    {\n        // Avoids rounding errors by returning the total value\n        // in a single currency\n        if (allAssets[0] == _asset) {\n            uint256 decimals = Helpers.getDecimals(_asset);\n            return storedTotalValue.scaleBy(decimals, 18);\n        } else {\n            return 0;\n        }\n    }\n\n    function setMaxSupplyDiff(uint256 _maxSupplyDiff) external onlyGovernor {\n        maxSupplyDiff = _maxSupplyDiff;\n    }\n}\n"
    },
    "contracts/mocks/MockVaultCoreInstantRebase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { VaultCore } from \"../vault/VaultCore.sol\";\n\ncontract MockVaultCoreInstantRebase is VaultCore {\n    function _nextYield(uint256 supply, uint256 vaultValue)\n        internal\n        view\n        override\n        returns (uint256 yield, uint256 targetRate)\n    {\n        if (vaultValue <= supply) {\n            return (0, 0);\n        }\n        yield = vaultValue - supply;\n        return (yield, 0);\n    }\n}\n"
    },
    "contracts/mocks/MockWETH.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\n// Just importing to \"unbreak\" coverage tests\nimport { IERC721Receiver } from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\ncontract MockWETH is MintableERC20 {\n    constructor() ERC20(\"WETH\", \"WETH\") {}\n\n    function deposit() external payable {\n        _mint(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) external {\n        _burn(msg.sender, wad);\n        payable(msg.sender).transfer(wad);\n    }\n}\n"
    },
    "contracts/mocks/MockWS.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockWS is MintableERC20 {\n    constructor() ERC20(\"Wrapped Sonic\", \"wS\") {}\n\n    function deposit() external payable {\n        _mint(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) external {\n        _burn(msg.sender, wad);\n        payable(msg.sender).transfer(wad);\n    }\n}\n"
    },
    "contracts/mocks/TestUpgradedOUSD.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../token/OUSD.sol\";\n\n// used to alter internal state of OUSD contract\ncontract TestUpgradedOUSD is OUSD {\n    constructor() OUSD() {}\n\n    function overwriteCreditBalances(address _account, uint256 _creditBalance)\n        public\n    {\n        creditBalances[_account] = _creditBalance;\n    }\n\n    function overwriteAlternativeCPT(address _account, uint256 _acpt) public {\n        alternativeCreditsPerToken[_account] = _acpt;\n    }\n\n    function overwriteRebaseState(address _account, RebaseOptions _rebaseOption)\n        public\n    {\n        rebaseState[_account] = _rebaseOption;\n    }\n}\n"
    },
    "contracts/oracle/AbstractOracleRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// @notice Abstract functionality that is shared between various Oracle Routers\nabstract contract AbstractOracleRouter is IOracle {\n    using StableMath for uint256;\n    using SafeCast for int256;\n\n    uint256 internal constant MIN_DRIFT = 0.7e18;\n    uint256 internal constant MAX_DRIFT = 1.3e18;\n    address internal constant FIXED_PRICE =\n        0x0000000000000000000000000000000000000001;\n    // Maximum allowed staleness buffer above normal Oracle maximum staleness\n    uint256 internal constant STALENESS_BUFFER = 1 days;\n    mapping(address => uint8) internal decimalsCache;\n\n    /**\n     * @dev The price feed contract to use for a particular asset along with\n     *      maximum data staleness\n     * @param asset address of the asset\n     * @return feedAddress address of the price feed for the asset\n     * @return maxStaleness maximum acceptable data staleness duration\n     */\n    function feedMetadata(address asset)\n        internal\n        view\n        virtual\n        returns (address feedAddress, uint256 maxStaleness);\n\n    /**\n     * @notice Returns the total price in 18 digit unit for a given asset.\n     * @param asset address of the asset\n     * @return uint256 unit price for 1 asset unit, in 18 decimal fixed\n     */\n    function price(address asset)\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        (address _feed, uint256 maxStaleness) = feedMetadata(asset);\n        require(_feed != address(0), \"Asset not available\");\n        require(_feed != FIXED_PRICE, \"Fixed price feeds not supported\");\n\n        // slither-disable-next-line unused-return\n        (, int256 _iprice, , uint256 updatedAt, ) = AggregatorV3Interface(_feed)\n            .latestRoundData();\n\n        require(\n            updatedAt + maxStaleness >= block.timestamp,\n            \"Oracle price too old\"\n        );\n\n        uint8 decimals = getDecimals(_feed);\n\n        uint256 _price = _iprice.toUint256().scaleBy(18, decimals);\n        if (shouldBePegged(asset)) {\n            require(_price <= MAX_DRIFT, \"Oracle: Price exceeds max\");\n            require(_price >= MIN_DRIFT, \"Oracle: Price under min\");\n        }\n        return _price;\n    }\n\n    function getDecimals(address _feed) internal view virtual returns (uint8) {\n        uint8 decimals = decimalsCache[_feed];\n        require(decimals > 0, \"Oracle: Decimals not cached\");\n        return decimals;\n    }\n\n    /**\n     * @notice Before an asset/feed price is fetches for the first time the\n     *         decimals need to be cached. This is a gas optimization\n     * @param asset address of the asset\n     * @return uint8 corresponding asset decimals\n     */\n    function cacheDecimals(address asset) external returns (uint8) {\n        (address _feed, ) = feedMetadata(asset);\n        require(_feed != address(0), \"Asset not available\");\n        require(_feed != FIXED_PRICE, \"Fixed price feeds not supported\");\n\n        uint8 decimals = AggregatorV3Interface(_feed).decimals();\n        decimalsCache[_feed] = decimals;\n        return decimals;\n    }\n\n    function shouldBePegged(address _asset) internal view returns (bool) {\n        string memory symbol = Helpers.getSymbol(_asset);\n        bytes32 symbolHash = keccak256(abi.encodePacked(symbol));\n        return\n            symbolHash == keccak256(abi.encodePacked(\"DAI\")) ||\n            symbolHash == keccak256(abi.encodePacked(\"USDC\")) ||\n            symbolHash == keccak256(abi.encodePacked(\"USDT\"));\n    }\n}\n"
    },
    "contracts/oracle/OETHBaseOracleRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { AbstractOracleRouter } from \"./AbstractOracleRouter.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\n\n// @notice Oracle Router (for OETH on Base) that denominates all prices in ETH\ncontract OETHBaseOracleRouter is AbstractOracleRouter {\n    using StableMath for uint256;\n    using SafeCast for int256;\n\n    address constant WETH = 0x4200000000000000000000000000000000000006;\n    address constant WOETH = 0xD8724322f44E5c58D7A815F542036fb17DbbF839;\n    address constant WOETH_CHAINLINK_FEED =\n        0xe96EB1EDa83d18cbac224233319FA5071464e1b9;\n\n    constructor() {}\n\n    /**\n     * @notice Returns the total price in 18 digit units for a given asset.\n     *         This implementation does not (!) do range checks as the\n     *         parent OracleRouter does.\n     * @param asset address of the asset\n     * @return uint256 unit price for 1 asset unit, in 18 decimal fixed\n     */\n    function price(address asset)\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        (address _feed, uint256 maxStaleness) = feedMetadata(asset);\n        if (_feed == FIXED_PRICE) {\n            return 1e18;\n        }\n        require(_feed != address(0), \"Asset not available\");\n\n        // slither-disable-next-line unused-return\n        (, int256 _iprice, , uint256 updatedAt, ) = AggregatorV3Interface(_feed)\n            .latestRoundData();\n\n        require(\n            updatedAt + maxStaleness >= block.timestamp,\n            \"Oracle price too old\"\n        );\n\n        uint8 decimals = getDecimals(_feed);\n        uint256 _price = _iprice.toUint256().scaleBy(18, decimals);\n        return _price;\n    }\n\n    /**\n     * @dev The price feed contract to use for a particular asset along with\n     *      maximum data staleness\n     * @param asset address of the asset\n     * @return feedAddress address of the price feed for the asset\n     * @return maxStaleness maximum acceptable data staleness duration\n     */\n    function feedMetadata(address asset)\n        internal\n        view\n        virtual\n        override\n        returns (address feedAddress, uint256 maxStaleness)\n    {\n        if (asset == WETH) {\n            // FIXED_PRICE: WETH/ETH\n            feedAddress = FIXED_PRICE;\n            maxStaleness = 0;\n        } else if (asset == WOETH) {\n            // Chainlink: https://data.chain.link/feeds/base/base/woeth-oeth-exchange-rate\n            // Bridged wOETH/OETH\n            feedAddress = WOETH_CHAINLINK_FEED;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else {\n            revert(\"Asset not available\");\n        }\n    }\n}\n"
    },
    "contracts/oracle/OETHFixedOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { OETHOracleRouter } from \"./OETHOracleRouter.sol\";\n\n// @notice Oracle Router that returns 1e18 for all prices\n// used solely for deployment to testnets\ncontract OETHFixedOracle is OETHOracleRouter {\n    constructor() OETHOracleRouter() {}\n\n    /**\n     * @dev The price feed contract to use for a particular asset along with\n     *      maximum data staleness\n     * @param asset address of the asset\n     * @return feedAddress address of the price feed for the asset\n     * @return maxStaleness maximum acceptable data staleness duration\n     */\n    // solhint-disable-next-line no-unused-vars\n    function feedMetadata(address asset)\n        internal\n        view\n        virtual\n        override\n        returns (address feedAddress, uint256 maxStaleness)\n    {\n        // fixes price for all of the assets\n        feedAddress = FIXED_PRICE;\n        maxStaleness = 0;\n    }\n}\n"
    },
    "contracts/oracle/OETHOracleRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\nimport { AbstractOracleRouter } from \"./AbstractOracleRouter.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\n// @notice Oracle Router that denominates all prices in ETH\ncontract OETHOracleRouter is AbstractOracleRouter {\n    using StableMath for uint256;\n\n    constructor() {}\n\n    /**\n     * @notice Returns the total price in 18 digit units for a given asset.\n     *         This implementation does not (!) do range checks as the\n     *         parent OracleRouter does.\n     * @param asset address of the asset\n     * @return uint256 unit price for 1 asset unit, in 18 decimal fixed\n     */\n    function price(address asset)\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        (address _feed, uint256 maxStaleness) = feedMetadata(asset);\n        if (_feed == FIXED_PRICE) {\n            return 1e18;\n        }\n        require(_feed != address(0), \"Asset not available\");\n\n        // slither-disable-next-line unused-return\n        (, int256 _iprice, , uint256 updatedAt, ) = AggregatorV3Interface(_feed)\n            .latestRoundData();\n\n        require(\n            updatedAt + maxStaleness >= block.timestamp,\n            \"Oracle price too old\"\n        );\n\n        uint8 decimals = getDecimals(_feed);\n        uint256 _price = uint256(_iprice).scaleBy(18, decimals);\n        return _price;\n    }\n\n    /**\n     * @dev The price feed contract to use for a particular asset along with\n     *      maximum data staleness\n     * @param asset address of the asset\n     * @return feedAddress address of the price feed for the asset\n     * @return maxStaleness maximum acceptable data staleness duration\n     */\n    function feedMetadata(address asset)\n        internal\n        view\n        virtual\n        override\n        returns (address feedAddress, uint256 maxStaleness)\n    {\n        if (asset == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) {\n            // FIXED_PRICE: WETH/ETH\n            feedAddress = FIXED_PRICE;\n            maxStaleness = 0;\n        } else if (asset == 0x5E8422345238F34275888049021821E8E08CAa1f) {\n            // frxETH/ETH\n            feedAddress = 0xC58F3385FBc1C8AD2c0C9a061D7c13b141D7A5Df;\n            maxStaleness = 18 hours + STALENESS_BUFFER;\n        } else if (asset == 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84) {\n            // https://data.chain.link/ethereum/mainnet/crypto-eth/steth-eth\n            // Chainlink: stETH/ETH\n            feedAddress = 0x86392dC19c0b719886221c78AB11eb8Cf5c52812;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else if (asset == 0xae78736Cd615f374D3085123A210448E74Fc6393) {\n            // https://data.chain.link/ethereum/mainnet/crypto-eth/reth-eth\n            // Chainlink: rETH/ETH\n            feedAddress = 0x536218f9E9Eb48863970252233c8F271f554C2d0;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else if (asset == 0xD533a949740bb3306d119CC777fa900bA034cd52) {\n            // https://data.chain.link/ethereum/mainnet/crypto-eth/crv-eth\n            // Chainlink: CRV/ETH\n            feedAddress = 0x8a12Be339B0cD1829b91Adc01977caa5E9ac121e;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else if (asset == 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B) {\n            // https://data.chain.link/ethereum/mainnet/crypto-eth/cvx-eth\n            // Chainlink: CVX/ETH\n            feedAddress = 0xC9CbF687f43176B302F03f5e58470b77D07c61c6;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else if (asset == 0xBe9895146f7AF43049ca1c1AE358B0541Ea49704) {\n            // https://data.chain.link/ethereum/mainnet/crypto-eth/cbeth-eth\n            // Chainlink: cbETH/ETH\n            feedAddress = 0xF017fcB346A1885194689bA23Eff2fE6fA5C483b;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else if (asset == 0xba100000625a3754423978a60c9317c58a424e3D) {\n            // https://data.chain.link/ethereum/mainnet/crypto-eth/bal-eth\n            // Chainlink: BAL/ETH\n            feedAddress = 0xC1438AA3823A6Ba0C159CfA8D98dF5A994bA120b;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else {\n            revert(\"Asset not available\");\n        }\n    }\n}\n"
    },
    "contracts/oracle/OETHPlumeOracleRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { AbstractOracleRouter } from \"./AbstractOracleRouter.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\n\n// @notice Oracle Router (for OETH on Plume) that denominates all prices in ETH\ncontract OETHPlumeOracleRouter is AbstractOracleRouter {\n    using StableMath for uint256;\n    using SafeCast for int256;\n\n    address constant WETH = 0xca59cA09E5602fAe8B629DeE83FfA819741f14be;\n    address constant WOETH = 0xD8724322f44E5c58D7A815F542036fb17DbbF839;\n    // Ref: https://docs.eo.app/docs/eprice/feed-addresses/plume\n    address constant WOETH_ORACLE_FEED =\n        0x4915600Ed7d85De62011433eEf0BD5399f677e9b;\n\n    constructor() {}\n\n    /**\n     * @notice Returns the total price in 18 digit units for a given asset.\n     *         This implementation does not (!) do range checks as the\n     *         parent OracleRouter does.\n     * @param asset address of the asset\n     * @return uint256 unit price for 1 asset unit, in 18 decimal fixed\n     */\n    function price(address asset)\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        (address _feed, uint256 maxStaleness) = feedMetadata(asset);\n        if (_feed == FIXED_PRICE) {\n            return 1e18;\n        }\n        require(_feed != address(0), \"Asset not available\");\n\n        // slither-disable-next-line unused-return\n        (, int256 _iprice, , uint256 updatedAt, ) = AggregatorV3Interface(_feed)\n            .latestRoundData();\n\n        require(\n            updatedAt + maxStaleness >= block.timestamp,\n            \"Oracle price too old\"\n        );\n\n        uint8 decimals = getDecimals(_feed);\n        uint256 _price = _iprice.toUint256().scaleBy(18, decimals);\n        return _price;\n    }\n\n    /**\n     * @dev The price feed contract to use for a particular asset along with\n     *      maximum data staleness\n     * @param asset address of the asset\n     * @return feedAddress address of the price feed for the asset\n     * @return maxStaleness maximum acceptable data staleness duration\n     */\n    function feedMetadata(address asset)\n        internal\n        view\n        virtual\n        override\n        returns (address feedAddress, uint256 maxStaleness)\n    {\n        if (asset == WETH) {\n            // FIXED_PRICE: WETH/ETH\n            feedAddress = FIXED_PRICE;\n            maxStaleness = 0;\n        } else if (asset == WOETH) {\n            // Chainlink: https://data.chain.link/feeds/base/base/woeth-oeth-exchange-rate\n            // Bridged wOETH/OETH\n            feedAddress = WOETH_ORACLE_FEED;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else {\n            revert(\"Asset not available\");\n        }\n    }\n}\n"
    },
    "contracts/oracle/OracleRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\nimport { AbstractOracleRouter } from \"./AbstractOracleRouter.sol\";\n\n// @notice Oracle Router that denominates all prices in USD\ncontract OracleRouter is AbstractOracleRouter {\n    /**\n     * @dev The price feed contract to use for a particular asset along with\n     *      maximum data staleness\n     * @param asset address of the asset\n     * @return feedAddress address of the price feed for the asset\n     * @return maxStaleness maximum acceptable data staleness duration\n     */\n    function feedMetadata(address asset)\n        internal\n        pure\n        virtual\n        override\n        returns (address feedAddress, uint256 maxStaleness)\n    {\n        /* + STALENESS_BUFFER is added in case Oracle for some reason doesn't\n         * update on heartbeat and we add a generous buffer amount.\n         */\n        if (asset == 0x6B175474E89094C44Da98b954EedeAC495271d0F) {\n            // https://data.chain.link/ethereum/mainnet/stablecoins/dai-usd\n            // Chainlink: DAI/USD\n            feedAddress = 0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9;\n            maxStaleness = 1 hours + STALENESS_BUFFER;\n        } else if (asset == 0xdC035D45d973E3EC169d2276DDab16f1e407384F) {\n            // https://data.chain.link/feeds/ethereum/mainnet/usds-usd\n            // Chainlink: USDS/USD\n            feedAddress = 0xfF30586cD0F29eD462364C7e81375FC0C71219b1;\n            maxStaleness = 1 hours + STALENESS_BUFFER;\n        } else if (asset == 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48) {\n            // https://data.chain.link/ethereum/mainnet/stablecoins/usdc-usd\n            // Chainlink: USDC/USD\n            feedAddress = 0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else if (asset == 0xdAC17F958D2ee523a2206206994597C13D831ec7) {\n            // https://data.chain.link/ethereum/mainnet/stablecoins/usdt-usd\n            // Chainlink: USDT/USD\n            feedAddress = 0x3E7d1eAB13ad0104d2750B8863b489D65364e32D;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else if (asset == 0xc00e94Cb662C3520282E6f5717214004A7f26888) {\n            // https://data.chain.link/ethereum/mainnet/crypto-usd/comp-usd\n            // Chainlink: COMP/USD\n            feedAddress = 0xdbd020CAeF83eFd542f4De03e3cF0C28A4428bd5;\n            maxStaleness = 1 hours + STALENESS_BUFFER;\n        } else if (asset == 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9) {\n            // https://data.chain.link/ethereum/mainnet/crypto-usd/aave-usd\n            // Chainlink: AAVE/USD\n            feedAddress = 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9;\n            maxStaleness = 1 hours + STALENESS_BUFFER;\n        } else if (asset == 0xD533a949740bb3306d119CC777fa900bA034cd52) {\n            // https://data.chain.link/ethereum/mainnet/crypto-usd/crv-usd\n            // Chainlink: CRV/USD\n            feedAddress = 0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else if (asset == 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B) {\n            // Chainlink: CVX/USD\n            feedAddress = 0xd962fC30A72A84cE50161031391756Bf2876Af5D;\n            maxStaleness = 1 days + STALENESS_BUFFER;\n        } else {\n            revert(\"Asset not available\");\n        }\n    }\n}\n"
    },
    "contracts/oracle/OSonicOracleRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { OETHFixedOracle } from \"./OETHFixedOracle.sol\";\n\n// @notice Oracle Router that returns 1e18 for all prices\n// used solely for deployment to testnets\ncontract OSonicOracleRouter is OETHFixedOracle {\n    constructor() OETHFixedOracle() {}\n}\n"
    },
    "contracts/poolBooster/AbstractPoolBoosterFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Governable } from \"../governance/Governable.sol\";\nimport { IPoolBooster } from \"../interfaces/poolBooster/IPoolBooster.sol\";\nimport { IPoolBoostCentralRegistry } from \"../interfaces/poolBooster/IPoolBoostCentralRegistry.sol\";\n\n/**\n * @title Abstract Pool booster factory\n * @author Origin Protocol Inc\n */\ncontract AbstractPoolBoosterFactory is Governable {\n    struct PoolBoosterEntry {\n        address boosterAddress;\n        address ammPoolAddress;\n        IPoolBoostCentralRegistry.PoolBoosterType boosterType;\n    }\n\n    // @notice address of Origin Sonic\n    address public immutable oSonic;\n    // @notice Central registry contract\n    IPoolBoostCentralRegistry public immutable centralRegistry;\n\n    // @notice list of all the pool boosters created by this factory\n    PoolBoosterEntry[] public poolBoosters;\n    // @notice mapping of AMM pool to pool booster\n    mapping(address => PoolBoosterEntry) public poolBoosterFromPool;\n\n    // @param address _oSonic address of the OSonic token\n    // @param address _governor address governor\n    // @param address _centralRegistry address of the central registry\n    constructor(\n        address _oSonic,\n        address _governor,\n        address _centralRegistry\n    ) {\n        require(_oSonic != address(0), \"Invalid oSonic address\");\n        require(_governor != address(0), \"Invalid governor address\");\n        require(\n            _centralRegistry != address(0),\n            \"Invalid central registry address\"\n        );\n\n        oSonic = _oSonic;\n        centralRegistry = IPoolBoostCentralRegistry(_centralRegistry);\n        _setGovernor(_governor);\n    }\n\n    /**\n     * @notice Goes over all the pool boosters created by this factory and\n     *         calls bribe() on them.\n     * @param _exclusionList A list of pool booster addresses to skip when\n     *        calling this function.\n     */\n    function bribeAll(address[] memory _exclusionList) external {\n        uint256 lengthI = poolBoosters.length;\n        for (uint256 i = 0; i < lengthI; i++) {\n            address poolBoosterAddress = poolBoosters[i].boosterAddress;\n            bool skipBribeCall = false;\n            uint256 lengthJ = _exclusionList.length;\n            for (uint256 j = 0; j < lengthJ; j++) {\n                // pool booster in exclusion list\n                if (_exclusionList[j] == poolBoosterAddress) {\n                    skipBribeCall = true;\n                    break;\n                }\n            }\n\n            if (!skipBribeCall) {\n                IPoolBooster(poolBoosterAddress).bribe();\n            }\n        }\n    }\n\n    /**\n     * @notice Removes the pool booster from the internal list of pool boosters.\n     * @dev This action does not destroy the pool booster contract nor does it\n     *      stop the yield delegation to it.\n     * @param _poolBoosterAddress address of the pool booster\n     */\n    function removePoolBooster(address _poolBoosterAddress)\n        external\n        onlyGovernor\n    {\n        uint256 boostersLen = poolBoosters.length;\n        for (uint256 i = 0; i < boostersLen; ++i) {\n            if (poolBoosters[i].boosterAddress == _poolBoosterAddress) {\n                // erase mapping\n                delete poolBoosterFromPool[poolBoosters[i].ammPoolAddress];\n\n                // overwrite current pool booster with the last entry in the list\n                poolBoosters[i] = poolBoosters[boostersLen - 1];\n                // drop the last entry\n                poolBoosters.pop();\n\n                centralRegistry.emitPoolBoosterRemoved(_poolBoosterAddress);\n                break;\n            }\n        }\n    }\n\n    function _storePoolBoosterEntry(\n        address _poolBoosterAddress,\n        address _ammPoolAddress,\n        IPoolBoostCentralRegistry.PoolBoosterType _boosterType\n    ) internal {\n        PoolBoosterEntry memory entry = PoolBoosterEntry(\n            _poolBoosterAddress,\n            _ammPoolAddress,\n            _boosterType\n        );\n\n        poolBoosters.push(entry);\n        poolBoosterFromPool[_ammPoolAddress] = entry;\n\n        // emit the events of the pool booster created\n        centralRegistry.emitPoolBoosterCreated(\n            _poolBoosterAddress,\n            _ammPoolAddress,\n            _boosterType\n        );\n    }\n\n    function _deployContract(bytes memory _bytecode, uint256 _salt)\n        internal\n        returns (address _address)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _address := create2(\n                0,\n                add(_bytecode, 0x20),\n                mload(_bytecode),\n                _salt\n            )\n        }\n\n        require(\n            _address.code.length > 0 && _address != address(0),\n            \"Failed creating a pool booster\"\n        );\n    }\n\n    // pre-compute the address of the deployed contract that will be\n    // created when create2 is called\n    function _computeAddress(bytes memory _bytecode, uint256 _salt)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                _salt,\n                keccak256(_bytecode)\n            )\n        );\n\n        // cast last 20 bytes of hash to address\n        return address(uint160(uint256(hash)));\n    }\n\n    function poolBoosterLength() external view returns (uint256) {\n        return poolBoosters.length;\n    }\n}\n"
    },
    "contracts/poolBooster/PoolBoostCentralRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Governable } from \"../governance/Governable.sol\";\nimport { IPoolBoostCentralRegistry } from \"../interfaces/poolBooster/IPoolBoostCentralRegistry.sol\";\n\n/**\n * @title Contract that holds all governance approved pool booster Factory\n *        implementation deployments\n * @author Origin Protocol Inc\n */\ncontract PoolBoostCentralRegistry is Governable, IPoolBoostCentralRegistry {\n    event FactoryApproved(address factoryAddress);\n    event FactoryRemoved(address factoryAddress);\n\n    // @notice List of approved factories\n    address[] public factories;\n\n    modifier onlyApprovedFactories() {\n        require(isApprovedFactory(msg.sender), \"Not an approved factory\");\n        _;\n    }\n\n    constructor() {\n        // set the governor of the implementation contract to zero address\n        _setGovernor(address(0));\n    }\n\n    /**\n     * @notice Adds a factory address to the approved factory addresses\n     * @param _factoryAddress address of the factory\n     */\n    function approveFactory(address _factoryAddress) external onlyGovernor {\n        require(_factoryAddress != address(0), \"Invalid address\");\n        require(\n            !isApprovedFactory(_factoryAddress),\n            \"Factory already approved\"\n        );\n\n        factories.push(_factoryAddress);\n        emit FactoryApproved(_factoryAddress);\n    }\n\n    /**\n     * @notice Removes the factory from approved factory addresses\n     * @param _factoryAddress address of the factory\n     */\n    function removeFactory(address _factoryAddress) external onlyGovernor {\n        require(_factoryAddress != address(0), \"Invalid address\");\n\n        uint256 length = factories.length;\n        bool factoryRemoved = false;\n        for (uint256 i = 0; i < length; i++) {\n            if (factories[i] != _factoryAddress) {\n                continue;\n            }\n\n            factories[i] = factories[length - 1];\n            factories.pop();\n            emit FactoryRemoved(_factoryAddress);\n            factoryRemoved = true;\n            break;\n        }\n        require(factoryRemoved, \"Not an approved factory\");\n\n        emit FactoryRemoved(_factoryAddress);\n    }\n\n    /**\n     * @notice Emits a pool booster created event\n     * @dev    This has been created as a convenience method for the monitoring to have\n     *         an index of all of the created pool boosters by only listening to the\n     *         events of this contract.\n     * @param _poolBoosterAddress address of the pool booster created\n     * @param _ammPoolAddress address of the AMM pool forwarding yield to the pool booster\n     * @param _boosterType PoolBoosterType the type of the pool booster\n     */\n    function emitPoolBoosterCreated(\n        address _poolBoosterAddress,\n        address _ammPoolAddress,\n        PoolBoosterType _boosterType\n    ) external onlyApprovedFactories {\n        emit PoolBoosterCreated(\n            _poolBoosterAddress,\n            _ammPoolAddress,\n            _boosterType,\n            msg.sender // address of the factory\n        );\n    }\n\n    /**\n     * @notice Emits a pool booster removed event\n     * @dev    This has been created as a convenience method for the monitoring to have\n     *         an index of all of the removed pool boosters by only listening to the\n     *         events of this contract.\n     * @param _poolBoosterAddress address of the pool booster to be removed\n     */\n    function emitPoolBoosterRemoved(address _poolBoosterAddress)\n        external\n        onlyApprovedFactories\n    {\n        emit PoolBoosterRemoved(_poolBoosterAddress);\n    }\n\n    /**\n     * @notice Returns true if the factory is approved\n     * @param _factoryAddress address of the factory\n     */\n    function isApprovedFactory(address _factoryAddress)\n        public\n        view\n        returns (bool)\n    {\n        uint256 length = factories.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (factories[i] == _factoryAddress) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice Returns all supported factories\n     */\n    function getAllFactories() external view returns (address[] memory) {\n        return factories;\n    }\n}\n"
    },
    "contracts/poolBooster/PoolBoosterFactoryMerkl.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { PoolBoosterMerkl } from \"./PoolBoosterMerkl.sol\";\nimport { AbstractPoolBoosterFactory, IPoolBoostCentralRegistry } from \"./AbstractPoolBoosterFactory.sol\";\n\n/**\n * @title Pool booster factory for creating Merkl pool boosters.\n * @author Origin Protocol Inc\n */\ncontract PoolBoosterFactoryMerkl is AbstractPoolBoosterFactory {\n    uint256 public constant version = 1;\n\n    /// @notice address of the Merkl distributor\n    address public merklDistributor;\n\n    /// @notice event emitted when the Merkl distributor is updated\n    event MerklDistributorUpdated(address newDistributor);\n\n    /**\n     * @param _oSonic address of the OSonic token\n     * @param _governor address governor\n     * @param _centralRegistry address of the central registry\n     * @param _merklDistributor address of the Merkl distributor\n     */\n    constructor(\n        address _oSonic,\n        address _governor,\n        address _centralRegistry,\n        address _merklDistributor\n    ) AbstractPoolBoosterFactory(_oSonic, _governor, _centralRegistry) {\n        _setMerklDistributor(_merklDistributor);\n    }\n\n    /**\n     * @dev Create a Pool Booster for Merkl.\n     * @param _campaignType The type of campaign to create. This is used to determine the type of\n     *        bribe contract to create. The type is defined in the MerklDistributor contract.\n     * @param _ammPoolAddress address of the AMM pool where the yield originates from\n     * @param _campaignDuration The duration of the campaign in seconds\n     * @param campaignData The data to be used for the campaign. This is used to determine the type of\n     *        bribe contract to create. The type is defined in the MerklDistributor contract.\n     *        This should be fetched from the Merkl UI.\n     * @param _salt A unique number that affects the address of the pool booster created. Note: this number\n     *        should match the one from `computePoolBoosterAddress` in order for the final deployed address\n     *        and pre-computed address to match\n     */\n    function createPoolBoosterMerkl(\n        uint32 _campaignType,\n        address _ammPoolAddress,\n        uint32 _campaignDuration,\n        bytes calldata campaignData,\n        uint256 _salt\n    ) external onlyGovernor {\n        require(\n            _ammPoolAddress != address(0),\n            \"Invalid ammPoolAddress address\"\n        );\n        require(_salt > 0, \"Invalid salt\");\n        require(_campaignDuration > 1 hours, \"Invalid campaign duration\");\n        require(campaignData.length > 0, \"Invalid campaign data\");\n\n        address poolBoosterAddress = _deployContract(\n            abi.encodePacked(\n                type(PoolBoosterMerkl).creationCode,\n                abi.encode(\n                    oSonic,\n                    merklDistributor,\n                    _campaignDuration,\n                    _campaignType,\n                    governor(),\n                    campaignData\n                )\n            ),\n            _salt\n        );\n\n        _storePoolBoosterEntry(\n            poolBoosterAddress,\n            _ammPoolAddress,\n            IPoolBoostCentralRegistry.PoolBoosterType.MerklBooster\n        );\n    }\n\n    /**\n     * @dev Create a Pool Booster for Merkl.\n     * @param _campaignType The type of campaign to create. This is used to determine the type of\n     *        bribe contract to create. The type is defined in the MerklDistributor contract.\n     * @param _ammPoolAddress address of the AMM pool where the yield originates from\n     * @param _salt A unique number that affects the address of the pool booster created. Note: this number\n     *        should match the one from `createPoolBoosterMerkl` in order for the final deployed address\n     *        and pre-computed address to match\n     */\n    function computePoolBoosterAddress(\n        uint32 _campaignType,\n        address _ammPoolAddress,\n        uint32 _campaignDuration,\n        bytes calldata campaignData,\n        uint256 _salt\n    ) external view returns (address) {\n        require(\n            _ammPoolAddress != address(0),\n            \"Invalid ammPoolAddress address\"\n        );\n        require(_salt > 0, \"Invalid salt\");\n        require(_campaignDuration > 1 hours, \"Invalid campaign duration\");\n        require(campaignData.length > 0, \"Invalid campaign data\");\n\n        return\n            _computeAddress(\n                abi.encodePacked(\n                    type(PoolBoosterMerkl).creationCode,\n                    abi.encode(\n                        oSonic,\n                        merklDistributor,\n                        _campaignDuration,\n                        _campaignType,\n                        governor(),\n                        campaignData\n                    )\n                ),\n                _salt\n            );\n    }\n\n    /**\n     * @dev Set the address of the Merkl distributor\n     * @param _merklDistributor The address of the Merkl distributor\n     */\n    function setMerklDistributor(address _merklDistributor)\n        external\n        onlyGovernor\n    {\n        _setMerklDistributor(_merklDistributor);\n    }\n\n    function _setMerklDistributor(address _merklDistributor) internal {\n        require(\n            _merklDistributor != address(0),\n            \"Invalid merklDistributor address\"\n        );\n        merklDistributor = _merklDistributor;\n        emit MerklDistributorUpdated(_merklDistributor);\n    }\n}\n"
    },
    "contracts/poolBooster/PoolBoosterFactoryMetropolis.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { PoolBoosterMetropolis } from \"./PoolBoosterMetropolis.sol\";\nimport { AbstractPoolBoosterFactory, IPoolBoostCentralRegistry } from \"./AbstractPoolBoosterFactory.sol\";\n\n/**\n * @title Pool booster factory for creating Metropolis pool boosters.\n * @author Origin Protocol Inc\n */\ncontract PoolBoosterFactoryMetropolis is AbstractPoolBoosterFactory {\n    uint256 public constant version = 1;\n    address public immutable rewardFactory;\n    address public immutable voter;\n\n    // @param address _oSonic address of the OSonic token\n    // @param address _governor address governor\n    // @param address _centralRegistry address of the central registry\n    // @param address _rewardFactory address of the Metropolis reward factory\n    // @param address _voter address of the Metropolis voter\n    constructor(\n        address _oSonic,\n        address _governor,\n        address _centralRegistry,\n        address _rewardFactory,\n        address _voter\n    ) AbstractPoolBoosterFactory(_oSonic, _governor, _centralRegistry) {\n        rewardFactory = _rewardFactory;\n        voter = _voter;\n    }\n\n    /**\n     * @dev Create a Pool Booster for Metropolis pool.\n     * @param _ammPoolAddress address of the AMM pool where the yield originates from\n     * @param _salt A unique number that affects the address of the pool booster created. Note: this number\n     *        should match the one from `computePoolBoosterAddress` in order for the final deployed address\n     *        and pre-computed address to match\n     */\n    function createPoolBoosterMetropolis(address _ammPoolAddress, uint256 _salt)\n        external\n        onlyGovernor\n    {\n        require(\n            _ammPoolAddress != address(0),\n            \"Invalid ammPoolAddress address\"\n        );\n        require(_salt > 0, \"Invalid salt\");\n\n        address poolBoosterAddress = _deployContract(\n            abi.encodePacked(\n                type(PoolBoosterMetropolis).creationCode,\n                abi.encode(oSonic, rewardFactory, _ammPoolAddress, voter)\n            ),\n            _salt\n        );\n\n        _storePoolBoosterEntry(\n            poolBoosterAddress,\n            _ammPoolAddress,\n            IPoolBoostCentralRegistry.PoolBoosterType.MetropolisBooster\n        );\n    }\n\n    /**\n     * @dev Create a Pool Booster for Metropolis pool.\n     * @param _ammPoolAddress address of the AMM pool where the yield originates from\n     * @param _salt A unique number that affects the address of the pool booster created. Note: this number\n     *        should match the one from `createPoolBoosterMetropolis` in order for the final deployed address\n     *        and pre-computed address to match\n     */\n    function computePoolBoosterAddress(address _ammPoolAddress, uint256 _salt)\n        external\n        view\n        returns (address)\n    {\n        require(\n            _ammPoolAddress != address(0),\n            \"Invalid ammPoolAddress address\"\n        );\n        require(_salt > 0, \"Invalid salt\");\n\n        return\n            _computeAddress(\n                abi.encodePacked(\n                    type(PoolBoosterMetropolis).creationCode,\n                    abi.encode(oSonic, rewardFactory, _ammPoolAddress, voter)\n                ),\n                _salt\n            );\n    }\n}\n"
    },
    "contracts/poolBooster/PoolBoosterFactorySwapxDouble.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { PoolBoosterSwapxDouble } from \"./PoolBoosterSwapxDouble.sol\";\nimport { AbstractPoolBoosterFactory, IPoolBoostCentralRegistry } from \"./AbstractPoolBoosterFactory.sol\";\n\n/**\n * @title Pool booster factory for creating Swapx Ichi pool boosters where both of the\n *        gauges need incentivizing.\n * @author Origin Protocol Inc\n */\ncontract PoolBoosterFactorySwapxDouble is AbstractPoolBoosterFactory {\n    uint256 public constant version = 1;\n\n    // @param address _oSonic address of the OSonic token\n    // @param address _governor address governor\n    // @param address _centralRegistry address of the central registry\n    constructor(\n        address _oSonic,\n        address _governor,\n        address _centralRegistry\n    ) AbstractPoolBoosterFactory(_oSonic, _governor, _centralRegistry) {}\n\n    /**\n     * @dev Create a Pool Booster for SwapX Ichi vault based pool where 2 Bribe contracts need to be\n     *      bribed\n     * @param _bribeAddressOS address of the Bribes.sol(Bribe) contract for the OS token side\n     * @param _bribeAddressOther address of the Bribes.sol(Bribe) contract for the other token in the pool\n     * @param _ammPoolAddress address of the AMM pool where the yield originates from\n     * @param _split 1e18 denominated split between OS and Other bribe. E.g. 0.4e17 means 40% to OS\n     *        bribe contract and 60% to other bribe contract\n     * @param _salt A unique number that affects the address of the pool booster created. Note: this number\n     *        should match the one from `computePoolBoosterAddress` in order for the final deployed address\n     *        and pre-computed address to match\n     */\n    function createPoolBoosterSwapxDouble(\n        address _bribeAddressOS,\n        address _bribeAddressOther,\n        address _ammPoolAddress,\n        uint256 _split,\n        uint256 _salt\n    ) external onlyGovernor {\n        require(\n            _ammPoolAddress != address(0),\n            \"Invalid ammPoolAddress address\"\n        );\n        require(_salt > 0, \"Invalid salt\");\n\n        address poolBoosterAddress = _deployContract(\n            abi.encodePacked(\n                type(PoolBoosterSwapxDouble).creationCode,\n                abi.encode(_bribeAddressOS, _bribeAddressOther, oSonic, _split)\n            ),\n            _salt\n        );\n\n        _storePoolBoosterEntry(\n            poolBoosterAddress,\n            _ammPoolAddress,\n            IPoolBoostCentralRegistry.PoolBoosterType.SwapXDoubleBooster\n        );\n    }\n\n    /**\n     * @dev Compute the address of the pool booster to be deployed.\n     * @param _bribeAddressOS address of the Bribes.sol(Bribe) contract for the OS token side\n     * @param _bribeAddressOther address of the Bribes.sol(Bribe) contract for the other token in the pool\n     * @param _ammPoolAddress address of the AMM pool where the yield originates from\n     * @param _split 1e18 denominated split between OS and Other bribe. E.g. 0.4e17 means 40% to OS\n     *        bribe contract and 60% to other bribe contract\n     * @param _salt A unique number that affects the address of the pool booster created. Note: this number\n     *        should match the one from `createPoolBoosterSwapxDouble` in order for the final deployed address\n     *        and pre-computed address to match\n     */\n    function computePoolBoosterAddress(\n        address _bribeAddressOS,\n        address _bribeAddressOther,\n        address _ammPoolAddress,\n        uint256 _split,\n        uint256 _salt\n    ) external view returns (address) {\n        require(\n            _ammPoolAddress != address(0),\n            \"Invalid ammPoolAddress address\"\n        );\n        require(_salt > 0, \"Invalid salt\");\n\n        return\n            _computeAddress(\n                abi.encodePacked(\n                    type(PoolBoosterSwapxDouble).creationCode,\n                    abi.encode(\n                        _bribeAddressOS,\n                        _bribeAddressOther,\n                        oSonic,\n                        _split\n                    )\n                ),\n                _salt\n            );\n    }\n}\n"
    },
    "contracts/poolBooster/PoolBoosterFactorySwapxSingle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { PoolBoosterSwapxSingle } from \"./PoolBoosterSwapxSingle.sol\";\nimport { AbstractPoolBoosterFactory, IPoolBoostCentralRegistry } from \"./AbstractPoolBoosterFactory.sol\";\n\n/**\n * @title Pool booster factory for creating Swapx Single pool boosters - where a single\n *        gauge is created for a pool. this is appropriate for Classic Stable & Classic\n *        Volatile SwapX pools.\n * @author Origin Protocol Inc\n */\ncontract PoolBoosterFactorySwapxSingle is AbstractPoolBoosterFactory {\n    uint256 public constant version = 1;\n\n    // @param address _oSonic address of the OSonic token\n    // @param address _governor address governor\n    // @param address _centralRegistry address of the central registry\n    constructor(\n        address _oSonic,\n        address _governor,\n        address _centralRegistry\n    ) AbstractPoolBoosterFactory(_oSonic, _governor, _centralRegistry) {}\n\n    /**\n     * @dev Create a Pool Booster for SwapX classic volatile or classic stable pools where\n     *      a single Bribe contract is incentivized.\n     * @param _bribeAddress address of the Bribes.sol contract\n     * @param _ammPoolAddress address of the AMM pool where the yield originates from\n     * @param _salt A unique number that affects the address of the pool booster created. Note: this number\n     *        should match the one from `computePoolBoosterAddress` in order for the final deployed address\n     *        and pre-computed address to match\n     */\n    function createPoolBoosterSwapxSingle(\n        address _bribeAddress,\n        address _ammPoolAddress,\n        uint256 _salt\n    ) external onlyGovernor {\n        require(\n            _ammPoolAddress != address(0),\n            \"Invalid ammPoolAddress address\"\n        );\n        require(_salt > 0, \"Invalid salt\");\n\n        address poolBoosterAddress = _deployContract(\n            abi.encodePacked(\n                type(PoolBoosterSwapxSingle).creationCode,\n                abi.encode(_bribeAddress, oSonic)\n            ),\n            _salt\n        );\n\n        _storePoolBoosterEntry(\n            poolBoosterAddress,\n            _ammPoolAddress,\n            IPoolBoostCentralRegistry.PoolBoosterType.SwapXSingleBooster\n        );\n    }\n\n    /**\n     * @dev Create a Pool Booster for SwapX classic volatile or classic stable pools where\n     *      a single Bribe contract is incentivized.\n     * @param _bribeAddress address of the Bribes.sol contract\n     * @param _ammPoolAddress address of the AMM pool where the yield originates from\n     * @param _salt A unique number that affects the address of the pool booster created. Note: this number\n     *        should match the one from `createPoolBoosterSwapxSingle` in order for the final deployed address\n     *        and pre-computed address to match\n     */\n    function computePoolBoosterAddress(\n        address _bribeAddress,\n        address _ammPoolAddress,\n        uint256 _salt\n    ) external view returns (address) {\n        require(\n            _ammPoolAddress != address(0),\n            \"Invalid ammPoolAddress address\"\n        );\n        require(_salt > 0, \"Invalid salt\");\n\n        return\n            _computeAddress(\n                abi.encodePacked(\n                    type(PoolBoosterSwapxSingle).creationCode,\n                    abi.encode(_bribeAddress, oSonic)\n                ),\n                _salt\n            );\n    }\n}\n"
    },
    "contracts/poolBooster/PoolBoosterMerkl.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IPoolBooster } from \"../interfaces/poolBooster/IPoolBooster.sol\";\nimport { IMerklDistributor } from \"../interfaces/poolBooster/IMerklDistributor.sol\";\n\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature)\n        external\n        view\n        returns (bytes4 magicValue);\n}\n\n/**\n * @title Pool booster for Merkl distributor\n * @author Origin Protocol Inc\n */\ncontract PoolBoosterMerkl is IPoolBooster, IERC1271 {\n    /// @notice address of merkl distributor\n    IMerklDistributor public immutable merklDistributor;\n    /// @notice address of the OS token\n    IERC20 public immutable rewardToken;\n    /// @notice if balance under this amount the bribe action is skipped\n    uint256 public constant MIN_BRIBE_AMOUNT = 1e10;\n    /// @notice Campaign duration in seconds\n    uint32 public immutable duration; // -> should be immutable\n    /// @notice Campaign type\n    uint32 public immutable campaignType;\n    /// @notice Owner of the campaign\n    address public immutable creator;\n    /// @notice Campaign data\n    bytes public campaignData;\n\n    constructor(\n        address _rewardToken,\n        address _merklDistributor,\n        uint32 _duration,\n        uint32 _campaignType,\n        address _creator,\n        bytes memory _campaignData\n    ) {\n        require(_rewardToken != address(0), \"Invalid rewardToken address\");\n        require(\n            _merklDistributor != address(0),\n            \"Invalid merklDistributor address\"\n        );\n        require(_campaignData.length > 0, \"Invalid campaignData\");\n        require(_duration > 1 hours, \"Invalid duration\");\n\n        campaignType = _campaignType;\n        duration = _duration;\n        creator = _creator;\n\n        merklDistributor = IMerklDistributor(_merklDistributor);\n        rewardToken = IERC20(_rewardToken);\n        campaignData = _campaignData;\n    }\n\n    /// @notice Create a campaign on the Merkl distributor\n    function bribe() external override {\n        // Ensure token is approved for the Merkl distributor\n        uint256 minAmount = merklDistributor.rewardTokenMinAmounts(\n            address(rewardToken)\n        );\n        require(minAmount > 0, \"Min reward amount must be > 0\");\n\n        // if balance too small or below threshold, do no bribes\n        uint256 balance = rewardToken.balanceOf(address(this));\n        if (\n            balance < MIN_BRIBE_AMOUNT ||\n            (balance * 1 hours < minAmount * duration)\n        ) {\n            return;\n        }\n\n        // Approve the bribe contract to spend the reward token\n        rewardToken.approve(address(merklDistributor), balance);\n\n        // Notify the bribe contract of the reward amount\n        merklDistributor.signAndCreateCampaign(\n            IMerklDistributor.CampaignParameters({\n                campaignId: bytes32(0),\n                creator: creator,\n                rewardToken: address(rewardToken),\n                amount: balance,\n                campaignType: campaignType,\n                startTimestamp: getNextPeriodStartTime(),\n                duration: duration,\n                campaignData: campaignData\n            }),\n            bytes(\"\")\n        );\n        emit BribeExecuted(balance);\n    }\n\n    /// @notice Used to sign a campaign on the Merkl distributor\n    function isValidSignature(bytes32, bytes memory)\n        external\n        view\n        override\n        returns (bytes4 magicValue)\n    {\n        require(msg.sender == address(merklDistributor), \"Invalid sender\");\n        // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")) == 0x1626ba7e\n        return bytes4(0x1626ba7e);\n    }\n\n    /// @notice Returns the timestamp for the start of the next period based on the configured duration\n    function getNextPeriodStartTime() public view returns (uint32) {\n        // Calculate the timestamp for the next period boundary\n        return uint32((block.timestamp / duration + 1) * duration);\n    }\n}\n"
    },
    "contracts/poolBooster/PoolBoosterMetropolis.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IPoolBooster } from \"../interfaces/poolBooster/IPoolBooster.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Pool booster for Metropolis pools\n * @author Origin Protocol Inc\n */\ncontract PoolBoosterMetropolis is IPoolBooster {\n    // @notice address of the OS token\n    IERC20 public immutable osToken;\n    // @notice address of the pool\n    address public immutable pool;\n    // @notice if balance under this amount the bribe action is skipped\n    uint256 public constant MIN_BRIBE_AMOUNT = 1e10;\n\n    IRewarderFactory public immutable rewardFactory;\n\n    IVoter public immutable voter;\n\n    constructor(\n        address _osToken,\n        address _rewardFactory,\n        address _pool,\n        address _voter\n    ) {\n        require(_pool != address(0), \"Invalid pool address\");\n        pool = _pool;\n        // Abstract factory already validates this is not a zero address\n        osToken = IERC20(_osToken);\n\n        rewardFactory = IRewarderFactory(_rewardFactory);\n\n        voter = IVoter(_voter);\n    }\n\n    function bribe() external override {\n        uint256 balance = osToken.balanceOf(address(this));\n        // balance too small, do no bribes\n        (, uint256 minBribeAmount) = rewardFactory.getWhitelistedTokenInfo(\n            address(osToken)\n        );\n        if (balance < MIN_BRIBE_AMOUNT || balance < minBribeAmount) {\n            return;\n        }\n\n        uint256 id = voter.getCurrentVotingPeriod() + 1;\n\n        // Deploy a rewarder\n        IRewarder rewarder = IRewarder(\n            rewardFactory.createBribeRewarder(address(osToken), pool)\n        );\n\n        // Approve the rewarder to spend the balance\n        osToken.approve(address(rewarder), balance);\n\n        // Fund and bribe the rewarder\n        rewarder.fundAndBribe(id, id, balance);\n\n        emit BribeExecuted(balance);\n    }\n}\n\ninterface IRewarderFactory {\n    function createBribeRewarder(address token, address pool)\n        external\n        returns (address rewarder);\n\n    function getWhitelistedTokenInfo(address token)\n        external\n        view\n        returns (bool isWhitelisted, uint256 minBribeAmount);\n}\n\ninterface IRewarder {\n    function fundAndBribe(\n        uint256 startId,\n        uint256 lastId,\n        uint256 amountPerPeriod\n    ) external payable;\n}\n\ninterface IVoter {\n    function getCurrentVotingPeriod() external view returns (uint256);\n}\n"
    },
    "contracts/poolBooster/PoolBoosterSwapxDouble.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IBribe } from \"../interfaces/poolBooster/ISwapXAlgebraBribe.sol\";\nimport { IPoolBooster } from \"../interfaces/poolBooster/IPoolBooster.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\n/**\n * @title Pool booster for SwapX concentrated liquidity where 2 gauges are created for\n *        every pool. Ichi vaults currently have such setup.\n * @author Origin Protocol Inc\n */\ncontract PoolBoosterSwapxDouble is IPoolBooster {\n    using StableMath for uint256;\n\n    // @notice address of the Bribes.sol(Bribe) contract for the OS token side\n    IBribe public immutable bribeContractOS;\n    // @notice address of the  Bribes.sol(Bribe) contract for the other token in the pool\n    IBribe public immutable bribeContractOther;\n    // @notice address of the OS token\n    IERC20 public immutable osToken;\n    // @notice 1e18 denominated split between OS and Other bribe. E.g. 0.4e17 means 40% to OS\n    //         bribe contract and 60% to other bribe contract\n    uint256 public immutable split;\n\n    // @notice if balance under this amount the bribe action is skipped\n    uint256 public constant MIN_BRIBE_AMOUNT = 1e10;\n\n    constructor(\n        address _bribeContractOS,\n        address _bribeContractOther,\n        address _osToken,\n        uint256 _split\n    ) {\n        require(\n            _bribeContractOS != address(0),\n            \"Invalid bribeContractOS address\"\n        );\n        require(\n            _bribeContractOther != address(0),\n            \"Invalid bribeContractOther address\"\n        );\n        // expect it to be between 1% & 99%\n        require(_split > 1e16 && _split < 99e16, \"Unexpected split amount\");\n\n        bribeContractOS = IBribe(_bribeContractOS);\n        bribeContractOther = IBribe(_bribeContractOther);\n        // Abstract factory already validates this is not a zero address\n        osToken = IERC20(_osToken);\n        split = _split;\n    }\n\n    function bribe() external override {\n        uint256 balance = osToken.balanceOf(address(this));\n        // balance too small, do no bribes\n        if (balance < MIN_BRIBE_AMOUNT) {\n            return;\n        }\n\n        uint256 osBribeAmount = balance.mulTruncate(split);\n        uint256 otherBribeAmount = balance - osBribeAmount;\n\n        osToken.approve(address(bribeContractOS), osBribeAmount);\n        osToken.approve(address(bribeContractOther), otherBribeAmount);\n\n        bribeContractOS.notifyRewardAmount(address(osToken), osBribeAmount);\n        bribeContractOther.notifyRewardAmount(\n            address(osToken),\n            otherBribeAmount\n        );\n\n        emit BribeExecuted(balance);\n    }\n}\n"
    },
    "contracts/poolBooster/PoolBoosterSwapxSingle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IBribe } from \"../interfaces/poolBooster/ISwapXAlgebraBribe.sol\";\nimport { IPoolBooster } from \"../interfaces/poolBooster/IPoolBooster.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Pool booster for SwapX for Classic Stable Pools and Classic Volatile Pools\n * @author Origin Protocol Inc\n */\ncontract PoolBoosterSwapxSingle is IPoolBooster {\n    // @notice address of the Bribes.sol(Bribe) contract\n    IBribe public immutable bribeContract;\n    // @notice address of the OS token\n    IERC20 public immutable osToken;\n    // @notice if balance under this amount the bribe action is skipped\n    uint256 public constant MIN_BRIBE_AMOUNT = 1e10;\n\n    constructor(address _bribeContract, address _osToken) {\n        require(_bribeContract != address(0), \"Invalid bribeContract address\");\n        bribeContract = IBribe(_bribeContract);\n        // Abstract factory already validates this is not a zero address\n        osToken = IERC20(_osToken);\n    }\n\n    function bribe() external override {\n        uint256 balance = osToken.balanceOf(address(this));\n        // balance too small, do no bribes\n        if (balance < MIN_BRIBE_AMOUNT) {\n            return;\n        }\n\n        osToken.approve(address(bribeContract), balance);\n\n        bribeContract.notifyRewardAmount(address(osToken), balance);\n        emit BribeExecuted(balance);\n    }\n}\n"
    },
    "contracts/proxies/BaseProxies.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { InitializeGovernedUpgradeabilityProxy } from \"./InitializeGovernedUpgradeabilityProxy.sol\";\n\n/**\n * @notice BridgedBaseWOETHProxy delegates calls to BridgedWOETH implementation\n */\ncontract BridgedBaseWOETHProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHBaseVaultProxy delegates calls to OETHBaseVault implementation\n */\ncontract OETHBaseVaultProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHBaseProxy delegates calls to OETH implementation\n */\ncontract OETHBaseProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice WOETHBaseProxy delegates calls to WOETH implementation\n */\ncontract WOETHBaseProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHBaseDripperProxy delegates calls to a FixedRateDripper implementation\n */\ncontract OETHBaseDripperProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice AerodromeAMOStrategyProxy delegates calls to AerodromeAMOStrategy implementation\n */\ncontract AerodromeAMOStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice BridgedWOETHStrategyProxy delegates calls to BridgedWOETHStrategy implementation\n */\ncontract BridgedWOETHStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHBaseHarvesterProxy delegates calls to a SuperOETHHarvester implementation\n */\ncontract OETHBaseHarvesterProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHBaseCurveAMOProxy delegates calls to a OETHBaseCurveAMO implementation\n */\ncontract OETHBaseCurveAMOProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n"
    },
    "contracts/proxies/InitializeGovernedUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { Governable } from \"../governance/Governable.sol\";\n\n/**\n * @title BaseGovernedUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with our governor system.\n * It is based on an older version of OpenZeppelins BaseUpgradeabilityProxy\n * with Solidity ^0.8.0.\n * @author Origin Protocol Inc\n */\ncontract InitializeGovernedUpgradeabilityProxy is Governable {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     * @param implementation Address of the new implementation.\n     */\n    event Upgraded(address indexed implementation);\n\n    constructor() {\n        _setGovernor(msg.sender);\n    }\n\n    /**\n     * @dev Contract initializer with Governor enforcement\n     * @param _logic Address of the initial implementation.\n     * @param _initGovernor Address of the initial Governor.\n     * @param _data Data to send as msg.data to the implementation to initialize\n     * the proxied contract.\n     * It should include the signature and the parameters of the function to be\n     * called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     * This parameter is optional, if no data is given the initialization call\n     * to proxied contract will be skipped.\n     */\n    function initialize(\n        address _logic,\n        address _initGovernor,\n        bytes calldata _data\n    ) public payable onlyGovernor {\n        require(_implementation() == address(0));\n        require(_logic != address(0), \"Implementation not set\");\n        assert(\n            IMPLEMENTATION_SLOT ==\n                bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1)\n        );\n        _setImplementation(_logic);\n        if (_data.length > 0) {\n            (bool success, ) = _logic.delegatecall(_data);\n            require(success);\n        }\n        _changeGovernor(_initGovernor);\n    }\n\n    /**\n     * @return The address of the proxy admin/it's also the governor.\n     */\n    function admin() external view returns (address) {\n        return _governor();\n    }\n\n    /**\n     * @return The address of the implementation.\n     */\n    function implementation() external view returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @dev Upgrade the backing implementation of the proxy.\n     * Only the admin can call this function.\n     * @param _newImplementation Address of the new implementation.\n     */\n    function upgradeTo(address _newImplementation) external onlyGovernor {\n        _upgradeTo(_newImplementation);\n    }\n\n    /**\n     * @dev Upgrade the backing implementation of the proxy and call a function\n     * on the new implementation.\n     * This is useful to initialize the proxied contract.\n     * @param newImplementation Address of the new implementation.\n     * @param data Data to send as msg.data in the low level call.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\n        external\n        payable\n        onlyGovernor\n    {\n        _upgradeTo(newImplementation);\n        (bool success, ) = newImplementation.delegatecall(data);\n        require(success);\n    }\n\n    /**\n     * @dev Fallback function.\n     * Implemented entirely in `_fallback`.\n     */\n    fallback() external payable {\n        _fallback();\n    }\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * This is a low level function that doesn't return to its internal call site.\n     * It will return to the external caller whatever the implementation returns.\n     * @param _impl Address to delegate.\n     */\n    function _delegate(address _impl) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev Function that is run as the first thing in the fallback function.\n     * Can be redefined in derived contracts to add functionality.\n     * Redefinitions must call super._willFallback().\n     */\n    function _willFallback() internal {}\n\n    /**\n     * @dev fallback implementation.\n     * Extracted to enable manual triggering.\n     */\n    function _fallback() internal {\n        _willFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation.\n     * @return impl Address of the current implementation\n     */\n    function _implementation() internal view returns (address impl) {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Upgrades the proxy to a new implementation.\n     * @param newImplementation Address of the new implementation.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation address of the proxy.\n     * @param newImplementation Address of the new implementation.\n     */\n    function _setImplementation(address newImplementation) internal {\n        require(\n            Address.isContract(newImplementation),\n            \"Cannot set a proxy implementation to a non-contract address\"\n        );\n\n        bytes32 slot = IMPLEMENTATION_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n}\n"
    },
    "contracts/proxies/PlumeProxies.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { InitializeGovernedUpgradeabilityProxy } from \"./InitializeGovernedUpgradeabilityProxy.sol\";\n\n/**\n * @notice OETHPlumeVaultProxy delegates calls to OETHPlumeVault implementation\n */\ncontract OETHPlumeVaultProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHPlumeProxy delegates calls to OETH implementation\n */\ncontract OETHPlumeProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice WOETHPlumeProxy delegates calls to WOETH implementation\n */\ncontract WOETHPlumeProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice RoosterAMOStrategyProxy delegates calls to a RoosterAMOStrategy implementation\n */\ncontract RoosterAMOStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n"
    },
    "contracts/proxies/Proxies.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { InitializeGovernedUpgradeabilityProxy } from \"./InitializeGovernedUpgradeabilityProxy.sol\";\n\n/**\n * @notice OUSDProxy delegates calls to an OUSD implementation\n */\ncontract OUSDProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice WrappedOUSDProxy delegates calls to a WrappedOUSD implementation\n */\ncontract WrappedOUSDProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice VaultProxy delegates calls to a Vault implementation\n */\ncontract VaultProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice CompoundStrategyProxy delegates calls to a CompoundStrategy implementation\n */\ncontract CompoundStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice AaveStrategyProxy delegates calls to a AaveStrategy implementation\n */\ncontract AaveStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice ConvexStrategyProxy delegates calls to a ConvexStrategy implementation\n */\ncontract ConvexStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice HarvesterProxy delegates calls to a Harvester implementation\n */\ncontract HarvesterProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice DripperProxy delegates calls to a Dripper implementation\n */\ncontract DripperProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice MorphoCompoundStrategyProxy delegates calls to a MorphoCompoundStrategy implementation\n */\ncontract MorphoCompoundStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice ConvexOUSDMetaStrategyProxy delegates calls to a ConvexOUSDMetaStrategy implementation\n */\ncontract ConvexOUSDMetaStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice MorphoAaveStrategyProxy delegates calls to a MorphoCompoundStrategy implementation\n */\ncontract MorphoAaveStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHProxy delegates calls to nowhere for now\n */\ncontract OETHProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice WOETHProxy delegates calls to nowhere for now\n */\ncontract WOETHProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHVaultProxy delegates calls to a Vault implementation\n */\ncontract OETHVaultProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHDripperProxy delegates calls to a OETHDripper implementation\n */\ncontract OETHDripperProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHHarvesterProxy delegates calls to a Harvester implementation\n */\ncontract OETHHarvesterProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice CurveEthStrategyProxy delegates calls to a CurveEthStrategy implementation\n */\ncontract ConvexEthMetaStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice BuybackProxy delegates calls to Buyback implementation\n */\ncontract BuybackProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHMorphoAaveStrategyProxy delegates calls to a MorphoAaveStrategy implementation\n */\ncontract OETHMorphoAaveStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHBalancerMetaPoolrEthStrategyProxy delegates calls to a BalancerMetaPoolStrategy implementation\n */\ncontract OETHBalancerMetaPoolrEthStrategyProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice OETHBalancerMetaPoolwstEthStrategyProxy delegates calls to a BalancerMetaPoolStrategy implementation\n */\ncontract OETHBalancerMetaPoolwstEthStrategyProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice MakerDsrStrategyProxy delegates calls to a Generalized4626Strategy implementation\n */\ncontract MakerDsrStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHBuybackProxy delegates calls to Buyback implementation\n */\ncontract OETHBuybackProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice BridgedWOETHProxy delegates calls to BridgedWOETH implementation\n */\ncontract BridgedWOETHProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice NativeStakingSSVStrategyProxy delegates calls to NativeStakingSSVStrategy implementation\n */\ncontract NativeStakingSSVStrategyProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice NativeStakingFeeAccumulatorProxy delegates calls to FeeAccumulator implementation\n */\ncontract NativeStakingFeeAccumulatorProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice NativeStakingSSVStrategy2Proxy delegates calls to NativeStakingSSVStrategy implementation\n */\ncontract NativeStakingSSVStrategy2Proxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice NativeStakingFeeAccumulator2Proxy delegates calls to FeeAccumulator implementation\n */\ncontract NativeStakingFeeAccumulator2Proxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice NativeStakingSSVStrategy3Proxy delegates calls to NativeStakingSSVStrategy implementation\n */\ncontract NativeStakingSSVStrategy3Proxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice NativeStakingFeeAccumulator3Proxy delegates calls to FeeAccumulator implementation\n */\ncontract NativeStakingFeeAccumulator3Proxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice MetaMorphoStrategyProxy delegates calls to a Generalized4626Strategy implementation\n */\ncontract MetaMorphoStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice ARMBuybackProxy delegates calls to Buyback implementation\n */\ncontract ARMBuybackProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice MorphoGauntletPrimeUSDCStrategyProxy delegates calls to a Generalized4626Strategy implementation\n */\ncontract MorphoGauntletPrimeUSDCStrategyProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice MorphoGauntletPrimeUSDTStrategyProxy delegates calls to a Generalized4626USDTStrategy implementation\n */\ncontract MorphoGauntletPrimeUSDTStrategyProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice CurvePoolBoosterProxy delegates calls to a CurvePoolBooster implementation\n */\ncontract CurvePoolBoosterProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHFixedRateDripperProxy delegates calls to a OETHFixedRateDripper implementation\n */\ncontract OETHFixedRateDripperProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHSimpleHarvesterProxy delegates calls to a OETHSimpleHarvester implementation\n */\ncontract OETHSimpleHarvesterProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice PoolBoostCentralRegistryProxy delegates calls to the PoolBoostCentralRegistry implementation\n */\ncontract PoolBoostCentralRegistryProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice MakerSSRStrategyProxy delegates calls to a Generalized4626Strategy implementation\n */\ncontract MakerSSRStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OUSDCurveAMOProxy delegates calls to a CurveAMOStrategy implementation\n */\ncontract OUSDCurveAMOProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHCurveAMOProxy delegates calls to a CurveAMOStrategy implementation\n */\ncontract OETHCurveAMOProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice CompoundingStakingSSVStrategyProxy delegates calls to a CompoundingStakingSSVStrategy implementation\n */\ncontract CompoundingStakingSSVStrategyProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n"
    },
    "contracts/proxies/SonicProxies.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { InitializeGovernedUpgradeabilityProxy } from \"./InitializeGovernedUpgradeabilityProxy.sol\";\n\n/**\n * @notice OSonicVaultProxy delegates calls to OSonicVault implementation\n */\ncontract OSonicVaultProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OSonicProxy delegates calls to OSonic implementation\n */\ncontract OSonicProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice WOSonicProxy delegates calls to WOSonic implementation\n */\ncontract WOSonicProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OSonicDripperProxy delegates calls to a FixedRateDripper implementation\n */\ncontract OSonicDripperProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice SonicStakingStrategyProxy delegates calls to SonicStakingStrategy implementation\n */\ncontract SonicStakingStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OSonicHarvesterProxy delegates calls to a OSonicHarvester implementation\n */\ncontract OSonicHarvesterProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice SonicSwapXAMOStrategyProxy delegates calls to a SonicSwapXAMOStrategy implementation\n */\ncontract SonicSwapXAMOStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n"
    },
    "contracts/strategies/AaveStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD Aave Strategy\n * @notice Investment strategy for investing stablecoins via Aave\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./IAave.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\n\nimport { IAaveStakedToken } from \"./IAaveStakeToken.sol\";\nimport { IAaveIncentivesController } from \"./IAaveIncentivesController.sol\";\n\ncontract AaveStrategy is InitializableAbstractStrategy {\n    using SafeERC20 for IERC20;\n\n    uint16 constant referralCode = 92;\n\n    IAaveIncentivesController public incentivesController;\n    IAaveStakedToken public stkAave;\n\n    /**\n     * @param _stratConfig The platform and OToken vault addresses\n     */\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as AAVE needs several extra\n     * addresses for the rewards program.\n     * @param _rewardTokenAddresses Address of the AAVE token\n     * @param _assets Addresses of supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     * @param _incentivesAddress Address of the AAVE incentives controller\n     * @param _stkAaveAddress Address of the stkAave contract\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // AAVE\n        address[] calldata _assets,\n        address[] calldata _pTokens,\n        address _incentivesAddress,\n        address _stkAaveAddress\n    ) external onlyGovernor initializer {\n        incentivesController = IAaveIncentivesController(_incentivesAddress);\n        stkAave = IAaveStakedToken(_stkAaveAddress);\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n    }\n\n    /**\n     * @dev Deposit asset into Aave\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @dev Deposit asset into Aave\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_amount > 0, \"Must deposit something\");\n        // Following line also doubles as a check that we are depositing\n        // an asset that we support.\n        emit Deposit(_asset, _getATokenFor(_asset), _amount);\n        _getLendingPool().deposit(_asset, _amount, address(this), referralCode);\n    }\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into Aave\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            uint256 balance = IERC20(assetsMapped[i]).balanceOf(address(this));\n            if (balance > 0) {\n                _deposit(assetsMapped[i], balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw asset from Aave\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        emit Withdrawal(_asset, _getATokenFor(_asset), _amount);\n        uint256 actual = _getLendingPool().withdraw(\n            _asset,\n            _amount,\n            address(this)\n        );\n        require(actual == _amount, \"Did not withdraw enough\");\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            // Redeem entire balance of aToken\n            IERC20 asset = IERC20(assetsMapped[i]);\n            address aToken = _getATokenFor(assetsMapped[i]);\n            uint256 balance = IERC20(aToken).balanceOf(address(this));\n            if (balance > 0) {\n                uint256 actual = _getLendingPool().withdraw(\n                    address(asset),\n                    balance,\n                    address(this)\n                );\n                require(actual == balance, \"Did not withdraw enough\");\n\n                uint256 assetBalance = asset.balanceOf(address(this));\n                // Transfer entire balance to Vault\n                asset.safeTransfer(vaultAddress, assetBalance);\n\n                emit Withdrawal(address(asset), aToken, assetBalance);\n            }\n        }\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        // Balance is always with token aToken decimals\n        address aToken = _getATokenFor(_asset);\n        balance = IERC20(aToken).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @dev Approve the spending of all assets by their corresponding aToken,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        address lendingPool = address(_getLendingPool());\n        // approve the pool to spend the Asset\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            address asset = assetsMapped[i];\n            // Safe approval\n            IERC20(asset).safeApprove(lendingPool, 0);\n            IERC20(asset).safeApprove(lendingPool, type(uint256).max);\n        }\n    }\n\n    /**\n     * @dev Internal method to respond to the addition of new asset / aTokens\n            We need to give the AAVE lending pool approval to transfer the\n            asset.\n     * @param _asset Address of the asset to approve\n     * @param _aToken Address of the aToken\n     */\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address _aToken)\n        internal\n        override\n    {\n        address lendingPool = address(_getLendingPool());\n        IERC20(_asset).safeApprove(lendingPool, 0);\n        IERC20(_asset).safeApprove(lendingPool, type(uint256).max);\n    }\n\n    /**\n     * @dev Get the aToken wrapped in the IERC20 interface for this asset.\n     *      Fails if the pToken doesn't exist in our mappings.\n     * @param _asset Address of the asset\n     * @return Corresponding aToken to this asset\n     */\n    function _getATokenFor(address _asset) internal view returns (address) {\n        address aToken = assetToPToken[_asset];\n        require(aToken != address(0), \"aToken does not exist\");\n        return aToken;\n    }\n\n    /**\n     * @dev Get the current address of the Aave lending pool, which is the gateway to\n     *      depositing.\n     * @return Current lending pool implementation\n     */\n    function _getLendingPool() internal view returns (IAaveLendingPool) {\n        address lendingPool = ILendingPoolAddressesProvider(platformAddress)\n            .getLendingPool();\n        require(lendingPool != address(0), \"Lending pool does not exist\");\n        return IAaveLendingPool(lendingPool);\n    }\n\n    /**\n     * @dev Collect stkAave, convert it to AAVE send to Vault.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        if (address(stkAave) == address(0)) {\n            return;\n        }\n\n        // Check staked AAVE cooldown timer\n        uint256 cooldown = stkAave.stakersCooldowns(address(this));\n        uint256 windowStart = cooldown + stkAave.COOLDOWN_SECONDS();\n        uint256 windowEnd = windowStart + stkAave.UNSTAKE_WINDOW();\n\n        // If inside the unlock window, then we can redeem stkAave\n        // for AAVE and send it to the vault.\n        if (block.timestamp > windowStart && block.timestamp <= windowEnd) {\n            // Redeem to AAVE\n            uint256 stkAaveBalance = stkAave.balanceOf(address(this));\n            stkAave.redeem(address(this), stkAaveBalance);\n\n            // Transfer AAVE to harvesterAddress\n            uint256 aaveBalance = IERC20(rewardTokenAddresses[0]).balanceOf(\n                address(this)\n            );\n            if (aaveBalance > 0) {\n                IERC20(rewardTokenAddresses[0]).safeTransfer(\n                    harvesterAddress,\n                    aaveBalance\n                );\n            }\n        }\n\n        // Collect available rewards and restart the cooldown timer, if either of\n        // those should be run.\n        if (block.timestamp > windowStart || cooldown == 0) {\n            uint256 assetsLen = assetsMapped.length;\n            // aToken addresses for incentives controller\n            address[] memory aTokens = new address[](assetsLen);\n            for (uint256 i = 0; i < assetsLen; ++i) {\n                aTokens[i] = _getATokenFor(assetsMapped[i]);\n            }\n\n            // 1. If we have rewards availabile, collect them\n            uint256 pendingRewards = incentivesController.getRewardsBalance(\n                aTokens,\n                address(this)\n            );\n            if (pendingRewards > 0) {\n                // Because getting more stkAAVE from the incentives controller\n                // with claimRewards() may push the stkAAVE cooldown time\n                // forward, it is called after stakedAAVE has been turned into\n                // AAVE.\n                uint256 collected = incentivesController.claimRewards(\n                    aTokens,\n                    pendingRewards,\n                    address(this)\n                );\n                require(collected == pendingRewards, \"AAVE reward difference\");\n            }\n\n            // 2. Start cooldown counting down.\n            if (stkAave.balanceOf(address(this)) > 0) {\n                // Protected with if since cooldown call would revert\n                // if no stkAave balance.\n                stkAave.cooldown();\n            }\n        }\n    }\n}\n"
    },
    "contracts/strategies/AbstractCompoundStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Base Compound Abstract Strategy\n * @author Origin Protocol Inc\n */\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ICERC20 } from \"./ICompound.sol\";\nimport { IComptroller } from \"../interfaces/IComptroller.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\n\nabstract contract AbstractCompoundStrategy is InitializableAbstractStrategy {\n    using SafeERC20 for IERC20;\n\n    int256[50] private __reserved;\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @dev Get the cToken wrapped in the ICERC20 interface for this asset.\n     *      Fails if the pToken doesn't exist in our mappings.\n     * @param _asset Address of the asset\n     * @return Corresponding cToken to this asset\n     */\n    function _getCTokenFor(address _asset) internal view returns (ICERC20) {\n        address cToken = assetToPToken[_asset];\n        require(cToken != address(0), \"cToken does not exist\");\n        return ICERC20(cToken);\n    }\n\n    /**\n     * @dev Converts an underlying amount into cToken amount\n     *      cTokenAmt = (underlying * 1e18) / exchangeRate\n     * @param _cToken     cToken for which to change\n     * @param _underlying Amount of underlying to convert\n     * @return amount     Equivalent amount of cTokens\n     */\n    function _convertUnderlyingToCToken(ICERC20 _cToken, uint256 _underlying)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // e.g. 1e18*1e18 / 205316390724364402565641705 = 50e8\n        // e.g. 1e8*1e18 / 205316390724364402565641705 = 0.45 or 0\n        amount = (_underlying * 1e18) / _cToken.exchangeRateStored();\n    }\n}\n"
    },
    "contracts/strategies/AbstractConvexMetaStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Curve Convex Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IRewardStaking } from \"./IRewardStaking.sol\";\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { ICurveMetaPool } from \"./ICurveMetaPool.sol\";\nimport { IERC20, AbstractCurveStrategy, InitializableAbstractStrategy } from \"./AbstractCurveStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\n\nabstract contract AbstractConvexMetaStrategy is AbstractCurveStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    event MaxWithdrawalSlippageUpdated(\n        uint256 _prevMaxSlippagePercentage,\n        uint256 _newMaxSlippagePercentage\n    );\n\n    // used to circumvent the stack too deep issue\n    struct InitConfig {\n        address cvxDepositorAddress; //Address of the Convex depositor(AKA booster) for this pool\n        address metapoolAddress; //Address of the Curve MetaPool\n        address metapoolMainToken; //Address of Main metapool token\n        address cvxRewardStakerAddress; //Address of the CVX rewards staker\n        address metapoolLPToken; //Address of metapool LP token\n        uint256 cvxDepositorPTokenId; //Pid of the pool referred to by Depositor and staker\n    }\n\n    address internal cvxDepositorAddress;\n    address internal cvxRewardStakerAddress;\n    uint256 internal cvxDepositorPTokenId;\n    ICurveMetaPool internal metapool;\n    IERC20 internal metapoolMainToken;\n    IERC20 internal metapoolLPToken;\n    // Ordered list of metapool assets\n    address[] internal metapoolAssets;\n    // Max withdrawal slippage denominated in 1e18 (1e18 == 100%)\n    uint256 public maxWithdrawalSlippage;\n    uint128 internal crvCoinIndex;\n    uint128 internal mainCoinIndex;\n\n    int256[41] private ___reserved;\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Curve strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Address of CRV & CVX\n     * @param _assets Addresses of supported assets. MUST be passed in the same\n     *                order as returned by coins on the pool contract, i.e.\n     *                DAI, USDC, USDT\n     * @param _pTokens Platform Token corresponding addresses\n     * @param initConfig Various addresses and info for initialization state\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // CRV + CVX\n        address[] calldata _assets,\n        address[] calldata _pTokens,\n        InitConfig calldata initConfig\n    ) external onlyGovernor initializer {\n        require(_assets.length == 3, \"Must have exactly three assets\");\n        // Should be set prior to abstract initialize call otherwise\n        // abstractSetPToken calls will fail\n        cvxDepositorAddress = initConfig.cvxDepositorAddress;\n        pTokenAddress = _pTokens[0];\n        metapool = ICurveMetaPool(initConfig.metapoolAddress);\n        metapoolMainToken = IERC20(initConfig.metapoolMainToken);\n        cvxRewardStakerAddress = initConfig.cvxRewardStakerAddress;\n        metapoolLPToken = IERC20(initConfig.metapoolLPToken);\n        cvxDepositorPTokenId = initConfig.cvxDepositorPTokenId;\n        maxWithdrawalSlippage = 1e16;\n\n        metapoolAssets = [metapool.coins(0), metapool.coins(1)];\n        crvCoinIndex = _getMetapoolCoinIndex(pTokenAddress);\n        mainCoinIndex = _getMetapoolCoinIndex(initConfig.metapoolMainToken);\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n        _approveBase();\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        virtual\n        override\n        returns (uint256 balance)\n    {\n        require(assetToPToken[_asset] != address(0), \"Unsupported asset\");\n        balance = 0;\n\n        // LP tokens in this contract. This should generally be nothing as we\n        // should always stake the full balance in the Gauge, but include for\n        // safety\n        uint256 contractPTokens = IERC20(pTokenAddress).balanceOf(\n            address(this)\n        );\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        if (contractPTokens > 0) {\n            uint256 virtual_price = curvePool.get_virtual_price();\n            uint256 value = contractPTokens.mulTruncate(virtual_price);\n            balance += value;\n        }\n\n        /* We intentionally omit the metapoolLp tokens held by the metastrategyContract\n         * since the contract should never (except in the middle of deposit/withdrawal\n         * transaction) hold any amount of those tokens in normal operation. There\n         * could be tokens sent to it by a 3rd party and we decide to actively ignore\n         * those.\n         */\n        uint256 metapoolGaugePTokens = IRewardStaking(cvxRewardStakerAddress)\n            .balanceOf(address(this));\n\n        if (metapoolGaugePTokens > 0) {\n            uint256 value = metapoolGaugePTokens.mulTruncate(\n                metapool.get_virtual_price()\n            );\n            balance += value;\n        }\n\n        uint256 assetDecimals = Helpers.getDecimals(_asset);\n        balance = balance.scaleBy(assetDecimals, 18) / THREEPOOL_ASSET_COUNT;\n    }\n\n    /**\n     * @dev This function is completely analogous to _calcCurveTokenAmount[AbstractCurveStrategy]\n     * and just utilizes different Curve (meta)pool API\n     */\n    function _calcCurveMetaTokenAmount(uint128 _coinIndex, uint256 _amount)\n        internal\n        returns (uint256 requiredMetapoolLP)\n    {\n        uint256[2] memory _amounts = [uint256(0), uint256(0)];\n        _amounts[uint256(_coinIndex)] = _amount;\n\n        // LP required when removing required asset ignoring fees\n        uint256 lpRequiredNoFees = metapool.calc_token_amount(_amounts, false);\n        /* LP required if fees would apply to entirety of removed amount\n         *\n         * fee is 1e10 denominated number: https://curve.readthedocs.io/exchange-pools.html#StableSwap.fee\n         */\n        uint256 lpRequiredFullFees = lpRequiredNoFees.mulTruncateScale(\n            1e10 + metapool.fee(),\n            1e10\n        );\n\n        /* asset received when withdrawing full fee applicable LP accounting for\n         * slippage and fees\n         */\n        uint256 assetReceivedForFullLPFees = metapool.calc_withdraw_one_coin(\n            lpRequiredFullFees,\n            int128(_coinIndex)\n        );\n\n        // exact amount of LP required\n        requiredMetapoolLP =\n            (lpRequiredFullFees * _amount) /\n            assetReceivedForFullLPFees;\n    }\n\n    function _approveBase() internal override {\n        IERC20 pToken = IERC20(pTokenAddress);\n        // 3Pool for LP token (required for removing liquidity)\n        pToken.safeApprove(platformAddress, 0);\n        pToken.safeApprove(platformAddress, type(uint256).max);\n        // Gauge for LP token\n        metapoolLPToken.safeApprove(cvxDepositorAddress, 0);\n        metapoolLPToken.safeApprove(cvxDepositorAddress, type(uint256).max);\n        // Metapool for LP token\n        pToken.safeApprove(address(metapool), 0);\n        pToken.safeApprove(address(metapool), type(uint256).max);\n        // Metapool for Metapool main token\n        metapoolMainToken.safeApprove(address(metapool), 0);\n        metapoolMainToken.safeApprove(address(metapool), type(uint256).max);\n    }\n\n    /**\n     * @dev Get the index of the coin\n     */\n    function _getMetapoolCoinIndex(address _asset)\n        internal\n        view\n        returns (uint128)\n    {\n        for (uint128 i = 0; i < 2; i++) {\n            if (metapoolAssets[i] == _asset) return i;\n        }\n        revert(\"Invalid Metapool asset\");\n    }\n\n    /**\n     * @dev Sets max withdrawal slippage that is considered when removing\n     * liquidity from Metapools.\n     * @param _maxWithdrawalSlippage Max withdrawal slippage denominated in\n     *        wad (number with 18 decimals): 1e18 == 100%, 1e16 == 1%\n     *\n     * IMPORTANT Minimum maxWithdrawalSlippage should actually be 0.1% (1e15)\n     * for production usage. Contract allows as low value as 0% for confirming\n     * correct behavior in test suite.\n     */\n    function setMaxWithdrawalSlippage(uint256 _maxWithdrawalSlippage)\n        external\n        onlyVaultOrGovernorOrStrategist\n    {\n        require(\n            _maxWithdrawalSlippage <= 1e18,\n            \"Max withdrawal slippage needs to be between 0% - 100%\"\n        );\n        emit MaxWithdrawalSlippageUpdated(\n            maxWithdrawalSlippage,\n            _maxWithdrawalSlippage\n        );\n        maxWithdrawalSlippage = _maxWithdrawalSlippage;\n    }\n\n    /**\n     * @dev Collect accumulated CRV and CVX and send to Harvester.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Collect CRV and CVX\n        IRewardStaking(cvxRewardStakerAddress).getReward();\n        _collectRewardTokens();\n    }\n\n    /**\n     * @dev Returns the largest of two numbers int256 version\n     */\n    function _max(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n}\n"
    },
    "contracts/strategies/AbstractCurveStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Curve 3Pool Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\n\nabstract contract AbstractCurveStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant MAX_SLIPPAGE = 1e16; // 1%, same as the Curve UI\n    // number of assets in Curve 3Pool (USDC, DAI, USDT)\n    uint256 internal constant THREEPOOL_ASSET_COUNT = 3;\n    address internal pTokenAddress;\n\n    int256[49] private __reserved;\n\n    /**\n     * @dev Deposit asset into the Curve 3Pool\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        require(_amount > 0, \"Must deposit something\");\n        emit Deposit(_asset, pTokenAddress, _amount);\n\n        // 3Pool requires passing deposit amounts for all 3 assets, set to 0 for\n        // all\n        uint256[3] memory _amounts;\n        uint256 poolCoinIndex = _getCoinIndex(_asset);\n        // Set the amount on the asset we want to deposit\n        _amounts[poolCoinIndex] = _amount;\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        uint256 assetDecimals = Helpers.getDecimals(_asset);\n        uint256 depositValue = _amount.scaleBy(18, assetDecimals).divPrecisely(\n            curvePool.get_virtual_price()\n        );\n        uint256 minMintAmount = depositValue.mulTruncate(\n            uint256(1e18) - MAX_SLIPPAGE\n        );\n        // Do the deposit to 3pool\n        curvePool.add_liquidity(_amounts, minMintAmount);\n        _lpDepositAll();\n    }\n\n    function _lpDepositAll() internal virtual;\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into the Curve 3pool\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256[3] memory _amounts = [uint256(0), uint256(0), uint256(0)];\n        uint256 depositValue = 0;\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        uint256 curveVirtualPrice = curvePool.get_virtual_price();\n\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; i++) {\n            address assetAddress = assetsMapped[i];\n            uint256 balance = IERC20(assetAddress).balanceOf(address(this));\n            if (balance > 0) {\n                uint256 poolCoinIndex = _getCoinIndex(assetAddress);\n                // Set the amount on the asset we want to deposit\n                _amounts[poolCoinIndex] = balance;\n                uint256 assetDecimals = Helpers.getDecimals(assetAddress);\n                // Get value of deposit in Curve LP token to later determine\n                // the minMintAmount argument for add_liquidity\n                depositValue =\n                    depositValue +\n                    balance.scaleBy(18, assetDecimals).divPrecisely(\n                        curveVirtualPrice\n                    );\n                emit Deposit(assetAddress, pTokenAddress, balance);\n            }\n        }\n\n        uint256 minMintAmount = depositValue.mulTruncate(\n            uint256(1e18) - MAX_SLIPPAGE\n        );\n        // Do the deposit to 3pool\n        curvePool.add_liquidity(_amounts, minMintAmount);\n\n        /* In case of Curve Strategy all assets are mapped to the same pToken (3CrvLP). Let\n         * descendants further handle the pToken. By either deploying it to the metapool and\n         * resulting tokens in Gauge. Or deploying pTokens directly to the Gauge.\n         */\n        _lpDepositAll();\n    }\n\n    function _lpWithdraw(uint256 numCrvTokens) internal virtual;\n\n    function _lpWithdrawAll() internal virtual;\n\n    /**\n     * @dev Withdraw asset from Curve 3Pool\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_amount > 0, \"Invalid amount\");\n\n        emit Withdrawal(_asset, pTokenAddress, _amount);\n\n        uint256 contractCrv3Tokens = IERC20(pTokenAddress).balanceOf(\n            address(this)\n        );\n\n        uint256 coinIndex = _getCoinIndex(_asset);\n        ICurvePool curvePool = ICurvePool(platformAddress);\n\n        uint256 requiredCrv3Tokens = _calcCurveTokenAmount(coinIndex, _amount);\n\n        // We have enough LP tokens, make sure they are all on this contract\n        if (contractCrv3Tokens < requiredCrv3Tokens) {\n            _lpWithdraw(requiredCrv3Tokens - contractCrv3Tokens);\n        }\n\n        uint256[3] memory _amounts = [uint256(0), uint256(0), uint256(0)];\n        _amounts[coinIndex] = _amount;\n\n        curvePool.remove_liquidity_imbalance(_amounts, requiredCrv3Tokens);\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Calculate amount of LP required when withdrawing specific amount of one\n     * of the underlying assets accounting for fees and slippage.\n     *\n     * Curve pools unfortunately do not contain a calculation function for\n     * amount of LP required when withdrawing a specific amount of one of the\n     * underlying tokens and also accounting for fees (Curve's calc_token_amount\n     * does account for slippage but not fees).\n     *\n     * Steps taken to calculate the metric:\n     *  - get amount of LP required if fees wouldn't apply\n     *  - increase the LP amount as if fees would apply to the entirety of the underlying\n     *    asset withdrawal. (when withdrawing only one coin fees apply only to amounts\n     *    of other assets pool would return in case of balanced removal - since those need\n     *    to be swapped for the single underlying asset being withdrawn)\n     *  - get amount of underlying asset withdrawn (this Curve function does consider slippage\n     *    and fees) when using the increased LP amount. As LP amount is slightly over-increased\n     *    so is amount of underlying assets returned.\n     *  - since we know exactly how much asset we require take the rate of LP required for asset\n     *    withdrawn to get the exact amount of LP.\n     */\n    function _calcCurveTokenAmount(uint256 _coinIndex, uint256 _amount)\n        internal\n        returns (uint256 required3Crv)\n    {\n        ICurvePool curvePool = ICurvePool(platformAddress);\n\n        uint256[3] memory _amounts = [uint256(0), uint256(0), uint256(0)];\n        _amounts[_coinIndex] = _amount;\n\n        // LP required when removing required asset ignoring fees\n        uint256 lpRequiredNoFees = curvePool.calc_token_amount(_amounts, false);\n        /* LP required if fees would apply to entirety of removed amount\n         *\n         * fee is 1e10 denominated number: https://curve.readthedocs.io/exchange-pools.html#StableSwap.fee\n         */\n        uint256 lpRequiredFullFees = lpRequiredNoFees.mulTruncateScale(\n            1e10 + curvePool.fee(),\n            1e10\n        );\n\n        /* asset received when withdrawing full fee applicable LP accounting for\n         * slippage and fees\n         */\n        uint256 assetReceivedForFullLPFees = curvePool.calc_withdraw_one_coin(\n            lpRequiredFullFees,\n            int128(uint128(_coinIndex))\n        );\n\n        // exact amount of LP required\n        required3Crv =\n            (lpRequiredFullFees * _amount) /\n            assetReceivedForFullLPFees;\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        _lpWithdrawAll();\n        // Withdraws are proportional to assets held by 3Pool\n        uint256[3] memory minWithdrawAmounts = [\n            uint256(0),\n            uint256(0),\n            uint256(0)\n        ];\n\n        // Remove liquidity\n        ICurvePool threePool = ICurvePool(platformAddress);\n        threePool.remove_liquidity(\n            IERC20(pTokenAddress).balanceOf(address(this)),\n            minWithdrawAmounts\n        );\n        // Transfer assets out of Vault\n        // Note that Curve will provide all 3 of the assets in 3pool even if\n        // we have not set PToken addresses for all of them in this strategy\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            IERC20 asset = IERC20(threePool.coins(i));\n            asset.safeTransfer(vaultAddress, asset.balanceOf(address(this)));\n        }\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        virtual\n        override\n        returns (uint256 balance)\n    {\n        require(assetToPToken[_asset] != address(0), \"Unsupported asset\");\n        // LP tokens in this contract. This should generally be nothing as we\n        // should always stake the full balance in the Gauge, but include for\n        // safety\n        uint256 totalPTokens = IERC20(pTokenAddress).balanceOf(address(this));\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        if (totalPTokens > 0) {\n            uint256 virtual_price = curvePool.get_virtual_price();\n            uint256 value = (totalPTokens * virtual_price) / 1e18;\n            uint256 assetDecimals = Helpers.getDecimals(_asset);\n            balance = value.scaleBy(assetDecimals, 18) / THREEPOOL_ASSET_COUNT;\n        }\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @dev Approve the spending of all assets by their corresponding pool tokens,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        _approveBase();\n        // This strategy is a special case since it only supports one asset\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            _approveAsset(assetsMapped[i]);\n        }\n    }\n\n    /**\n     * @dev Call the necessary approvals for the Curve pool and gauge\n     * @param _asset Address of the asset\n     */\n    function _abstractSetPToken(address _asset, address) internal override {\n        _approveAsset(_asset);\n    }\n\n    function _approveAsset(address _asset) internal {\n        IERC20 asset = IERC20(_asset);\n        // 3Pool for asset (required for adding liquidity)\n        asset.safeApprove(platformAddress, 0);\n        asset.safeApprove(platformAddress, type(uint256).max);\n    }\n\n    function _approveBase() internal virtual;\n\n    /**\n     * @dev Get the index of the coin\n     */\n    function _getCoinIndex(address _asset) internal view returns (uint256) {\n        for (uint256 i = 0; i < 3; i++) {\n            if (assetsMapped[i] == _asset) return i;\n        }\n        revert(\"Invalid 3pool asset\");\n    }\n}\n"
    },
    "contracts/strategies/aerodrome/AerodromeAMOStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Aerodrome AMO strategy\n * @author Origin Protocol Inc\n */\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { IERC20, InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\n\nimport { ISugarHelper } from \"../../interfaces/aerodrome/ISugarHelper.sol\";\nimport { INonfungiblePositionManager } from \"../../interfaces/aerodrome/INonfungiblePositionManager.sol\";\nimport { ISwapRouter } from \"../../interfaces/aerodrome/ISwapRouter.sol\";\nimport { ICLPool } from \"../../interfaces/aerodrome/ICLPool.sol\";\nimport { ICLGauge } from \"../../interfaces/aerodrome/ICLGauge.sol\";\nimport { IVault } from \"../../interfaces/IVault.sol\";\n\ncontract AerodromeAMOStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    /************************************************\n            Important (!) setup configuration\n    *************************************************/\n\n    /**\n     * In order to be able to remove a reasonable amount of complexity from the contract one of the\n     * preconditions for this contract to function correctly is to have an outside account mint a small\n     * amount of liquidity in the tick space where the contract will deploy's its liquidity and then send\n     * that NFT LP position to a dead address (transfer to zero address not allowed.) See example of such\n     * NFT LP token:\n     * https://basescan.org/token/0x827922686190790b37229fd06084350e74485b72?a=413296#inventory\n     */\n\n    /***************************************\n            Storage slot members\n    ****************************************/\n\n    /// @notice tokenId of the liquidity position\n    uint256 public tokenId;\n    /// @dev Minimum amount of tokens the strategy would be able to withdraw from the pool.\n    ///      minimum amount of tokens are withdrawn at a 1:1 price\n    uint256 public underlyingAssets;\n    /// @notice Marks the start of the interval that defines the allowed range of WETH share in\n    /// the pre-configured pool's liquidity ticker\n    uint256 public allowedWethShareStart;\n    /// @notice Marks the end of the interval that defines the allowed range of WETH share in\n    /// the pre-configured pool's liquidity ticker\n    uint256 public allowedWethShareEnd;\n    /// @dev reserved for inheritance\n    int256[46] private __reserved;\n\n    /***************************************\n          Constants, structs and events\n    ****************************************/\n\n    /// @notice The address of the Wrapped ETH (WETH) token contract\n    address public immutable WETH;\n    /// @notice The address of the OETHb token contract\n    address public immutable OETHb;\n    /// @notice lower tick set to -1 representing the price of 1.0001 of WETH for 1 OETHb.\n    int24 public immutable lowerTick;\n    /// @notice lower tick set to 0 representing the price of 1.0000 of WETH for 1 OETHb.\n    int24 public immutable upperTick;\n    /// @notice tick spacing of the pool (set to 1)\n    int24 public immutable tickSpacing;\n    /// @notice the swapRouter for performing swaps\n    ISwapRouter public immutable swapRouter;\n    /// @notice the underlying AMO Slipstream pool\n    ICLPool public immutable clPool;\n    /// @notice the gauge for the corresponding Slipstream pool (clPool)\n    /// @dev can become an immutable once the gauge is created on the base main-net\n    ICLGauge public immutable clGauge;\n    /// @notice the Position manager contract that is used to manage the pool's position\n    INonfungiblePositionManager public immutable positionManager;\n    /// @notice helper contract for liquidity and ticker math\n    ISugarHelper public immutable helper;\n    /// @notice sqrtRatioX96TickLower\n    /// @dev tick lower has value -1 and represents the lowest price of WETH priced in OETHb. Meaning the pool\n    /// offers less than 1 OETHb for 1 WETH. In other terms to get 1 OETHB the swap needs to offer 1.0001 WETH\n    /// this is where purchasing OETHb with WETH within the liquidity position is most expensive\n    uint160 public immutable sqrtRatioX96TickLower;\n    /// @notice sqrtRatioX96TickHigher\n    /// @dev tick higher has value 0 and represents 1:1 price parity of WETH to OETHb\n    uint160 public immutable sqrtRatioX96TickHigher;\n    /// @dev tick closest to 1:1 price parity\n    ///      Correctly assessing which tick is closer to 1:1 price parity is important since it affects\n    ///      the way we calculate the underlying assets in check Balance. The underlying aerodrome pool\n    ///      orders the tokens depending on the values of their addresses. If OETH token is token0 in the pool\n    ///      then sqrtRatioX96TickClosestToParity=sqrtRatioX96TickLower. If it is token1 in the pool then\n    ///      sqrtRatioX96TickClosestToParity=sqrtRatioX96TickHigher\n    uint160 public immutable sqrtRatioX96TickClosestToParity;\n\n    /// @dev a threshold under which the contract no longer allows for the protocol to rebalance. Guarding\n    ///      against a strategist / guardian being taken over and with multiple transactions draining the\n    ///      protocol funds.\n    uint256 public constant SOLVENCY_THRESHOLD = 0.998 ether;\n\n    error NotEnoughWethForSwap(uint256 wethBalance, uint256 requiredWeth); // 0x989e5ca8\n    error NotEnoughWethLiquidity(uint256 wethBalance, uint256 requiredWeth); // 0xa6737d87\n    error PoolRebalanceOutOfBounds(\n        uint256 currentPoolWethShare,\n        uint256 allowedWethShareStart,\n        uint256 allowedWethShareEnd\n    ); // 0x3681e8e0\n    error OutsideExpectedTickRange(int24 currentTick); // 0x5a2eba75\n\n    event PoolRebalanced(uint256 currentPoolWethShare);\n\n    event PoolWethShareIntervalUpdated(\n        uint256 allowedWethShareStart,\n        uint256 allowedWethShareEnd\n    );\n\n    event LiquidityRemoved(\n        uint256 withdrawLiquidityShare,\n        uint256 removedWETHAmount,\n        uint256 removedOETHbAmount,\n        uint256 wethAmountCollected,\n        uint256 oethbAmountCollected,\n        uint256 underlyingAssets\n    );\n\n    event LiquidityAdded(\n        uint256 wethAmountDesired,\n        uint256 oethbAmountDesired,\n        uint256 wethAmountSupplied,\n        uint256 oethbAmountSupplied,\n        uint256 tokenId,\n        uint256 underlyingAssets\n    );\n\n    event UnderlyingAssetsUpdated(uint256 underlyingAssets);\n\n    /**\n     * @dev Un-stakes the token from the gauge for the execution duration of\n     * the function and after that re-stakes it back in.\n     *\n     * It is important that the token is unstaked and owned by the strategy contract\n     * during any liquidity altering operations and that it is re-staked back into the\n     * gauge after liquidity changes. If the token fails to re-stake back to the\n     * gauge it is not earning incentives.\n     */\n    // all functions using this modifier are used by functions with reentrancy check\n    // slither-disable-start reentrancy-no-eth\n    modifier gaugeUnstakeAndRestake() {\n        // because of solidity short-circuit _isLpTokenStakedInGauge doesn't get called\n        // when tokenId == 0\n        if (tokenId != 0 && _isLpTokenStakedInGauge()) {\n            clGauge.withdraw(tokenId);\n        }\n        _;\n        // because of solidity short-circuit _isLpTokenStakedInGauge doesn't get called\n        // when tokenId == 0\n        if (tokenId != 0 && !_isLpTokenStakedInGauge()) {\n            /**\n             * It can happen that a withdrawal (or a full withdrawal) transactions would\n             * remove all of the liquidity from the token with a NFT token still existing.\n             * In that case the token can not be staked into the gauge, as some liquidity\n             * needs to be added to it first.\n             */\n            if (_getLiquidity() > 0) {\n                // if token liquidity changes the positionManager requires re-approval.\n                // to any contract pre-approved to handle the token.\n                positionManager.approve(address(clGauge), tokenId);\n                clGauge.deposit(tokenId);\n            }\n        }\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice the constructor\n    /// @dev This contract is intended to be used as a proxy. To prevent the\n    ///      potential confusion of having a functional implementation contract\n    ///      the constructor has the `initializer` modifier. This way the\n    ///      `initialize` function can not be called on the implementation contract.\n    ///      For the same reason the implementation contract also has the governor\n    ///      set to a zero address.\n    /// @param _stratConfig the basic strategy configuration\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\n    /// @param _oethbAddress Address of the Erc20 OETHb Token contract\n    /// @param _swapRouter Address of the Aerodrome Universal Swap Router\n    /// @param _nonfungiblePositionManager Address of position manager to add/remove\n    ///         the liquidity\n    /// @param _clPool Address of the Aerodrome concentrated liquidity pool\n    /// @param _clGauge Address of the Aerodrome slipstream pool gauge\n    /// @param _sugarHelper Address of the Aerodrome Sugar helper contract\n    /// @param _lowerBoundingTick Smaller bounding tick of our liquidity position\n    /// @param _upperBoundingTick Larger bounding tick of our liquidity position\n    /// @param _tickClosestToParity Tick that is closer to 1:1 price parity\n    constructor(\n        BaseStrategyConfig memory _stratConfig,\n        address _wethAddress,\n        address _oethbAddress,\n        address _swapRouter,\n        address _nonfungiblePositionManager,\n        address _clPool,\n        address _clGauge,\n        address _sugarHelper,\n        int24 _lowerBoundingTick,\n        int24 _upperBoundingTick,\n        int24 _tickClosestToParity\n    ) initializer InitializableAbstractStrategy(_stratConfig) {\n        require(\n            _lowerBoundingTick == _tickClosestToParity ||\n                _upperBoundingTick == _tickClosestToParity,\n            \"Misconfigured tickClosestToParity\"\n        );\n        require(\n            ICLPool(_clPool).token0() == _wethAddress,\n            \"Only WETH supported as token0\"\n        );\n        require(\n            ICLPool(_clPool).token1() == _oethbAddress,\n            \"Only OETHb supported as token1\"\n        );\n        int24 _tickSpacing = ICLPool(_clPool).tickSpacing();\n        // when we generalize AMO we might support other tick spacings\n        require(_tickSpacing == 1, \"Unsupported tickSpacing\");\n\n        WETH = _wethAddress;\n        OETHb = _oethbAddress;\n        swapRouter = ISwapRouter(_swapRouter);\n        positionManager = INonfungiblePositionManager(\n            _nonfungiblePositionManager\n        );\n        clPool = ICLPool(_clPool);\n        clGauge = ICLGauge(_clGauge);\n        helper = ISugarHelper(_sugarHelper);\n        sqrtRatioX96TickLower = ISugarHelper(_sugarHelper).getSqrtRatioAtTick(\n            _lowerBoundingTick\n        );\n        sqrtRatioX96TickHigher = ISugarHelper(_sugarHelper).getSqrtRatioAtTick(\n            _upperBoundingTick\n        );\n        sqrtRatioX96TickClosestToParity = ISugarHelper(_sugarHelper)\n            .getSqrtRatioAtTick(_tickClosestToParity);\n\n        lowerTick = _lowerBoundingTick;\n        upperTick = _upperBoundingTick;\n        tickSpacing = _tickSpacing;\n\n        // prevent implementation contract to be governed\n        _setGovernor(address(0));\n    }\n\n    /**\n     * @notice initialize function, to set up initial internal state\n     * @param _rewardTokenAddresses Address of reward token for platform\n     */\n    function initialize(address[] memory _rewardTokenAddresses)\n        external\n        onlyGovernor\n        initializer\n    {\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            new address[](0),\n            new address[](0)\n        );\n    }\n\n    /***************************************\n                  Configuration \n    ****************************************/\n\n    /**\n     * @notice Set allowed pool weth share interval. After the rebalance happens\n     * the share of WETH token in the ticker needs to be withing the specifications\n     * of the interval.\n     *\n     * @param _allowedWethShareStart Start of WETH share interval expressed as 18 decimal amount\n     * @param _allowedWethShareEnd End of WETH share interval expressed as 18 decimal amount\n     */\n    function setAllowedPoolWethShareInterval(\n        uint256 _allowedWethShareStart,\n        uint256 _allowedWethShareEnd\n    ) external onlyGovernor {\n        require(\n            _allowedWethShareStart < _allowedWethShareEnd,\n            \"Invalid interval\"\n        );\n        // can not go below 1% weth share\n        require(_allowedWethShareStart > 0.01 ether, \"Invalid interval start\");\n        // can not go above 95% weth share\n        require(_allowedWethShareEnd < 0.95 ether, \"Invalid interval end\");\n\n        allowedWethShareStart = _allowedWethShareStart;\n        allowedWethShareEnd = _allowedWethShareEnd;\n        emit PoolWethShareIntervalUpdated(\n            allowedWethShareStart,\n            allowedWethShareEnd\n        );\n    }\n\n    /***************************************\n                Periphery utils\n    ****************************************/\n\n    function _isLpTokenStakedInGauge() internal view returns (bool) {\n        require(tokenId != 0, \"Missing NFT LP token\");\n\n        address owner = positionManager.ownerOf(tokenId);\n        require(\n            owner == address(clGauge) || owner == address(this),\n            \"Unexpected token owner\"\n        );\n        return owner == address(clGauge);\n    }\n\n    /***************************************\n               Strategy overrides \n    ****************************************/\n\n    /**\n     * @notice Deposit an amount of assets into the strategy contract. Calling deposit doesn't\n     *         automatically deposit funds into the underlying Aerodrome pool\n     * @param _asset   Address for the asset\n     * @param _amount  Units of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @notice Deposit WETH to the strategy contract. This function does not add liquidity to the\n     *         underlying Aerodrome pool.\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        if (_wethBalance > 1e12) {\n            _deposit(WETH, _wethBalance);\n        }\n    }\n\n    /**\n     * @dev Deposit WETH to the contract. This function doesn't deposit the liquidity to the\n     *      pool, that is done via the rebalance call.\n     * @param _asset Address of the asset to deposit\n     * @param _amount Amount of assets to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_asset == WETH, \"Unsupported asset\");\n        require(_amount > 0, \"Must deposit something\");\n        emit Deposit(_asset, address(0), _amount);\n\n        // if the pool price is not within the expected interval leave the WETH on the contract\n        // as to not break the mints\n        (bool _isExpectedRange, ) = _checkForExpectedPoolPrice(false);\n        if (_isExpectedRange) {\n            // deposit funds into the underlying pool\n            _rebalance(0, false, 0);\n        }\n    }\n\n    /**\n     * @notice Rebalance the pool to the desired token split and Deposit any WETH on the contract to the\n     * underlying aerodrome pool. Print the required amount of corresponding OETHb. After the rebalancing is\n     * done burn any potentially remaining OETHb tokens still on the strategy contract.\n     *\n     * This function has a slightly different behaviour depending on the status of the underlying Aerodrome\n     * slipstream pool. The function consists of the following 3 steps:\n     * 1. withdrawPartialLiquidity -> so that moving the activeTrading price via  a swap is cheaper\n     * 2. swapToDesiredPosition   -> move active trading price in the pool to be able to deposit WETH & OETHb\n     *                               tokens with the desired pre-configured shares\n     * 3. addLiquidity            -> add liquidity into the pool respecting share split configuration\n     *\n     * Scenario 1: When there is no liquidity in the pool from the strategy but there is from other LPs then\n     *             only step 1 is skipped. (It is important to note that liquidity needs to exist in the configured\n     *             strategy tick ranges in order for the swap to be possible) Step 3 mints new liquidity position\n     *             instead of adding to an existing one.\n     * Scenario 2: When there is strategy's liquidity in the pool all 3 steps are taken\n     *\n     *\n     * Exact _amountToSwap, _swapWeth & _minTokenReceived parameters shall be determined by simulating the\n     * transaction off-chain. The strategy checks that after the swap the share of the tokens is in the\n     * expected ranges.\n     *\n     * @param _amountToSwap The amount of the token to swap\n     * @param _swapWeth Swap using WETH when true, use OETHb when false\n     * @param _minTokenReceived Slippage check -> minimum amount of token expected in return\n     */\n    function rebalance(\n        uint256 _amountToSwap,\n        bool _swapWeth,\n        uint256 _minTokenReceived\n    ) external nonReentrant onlyGovernorOrStrategist {\n        _rebalance(_amountToSwap, _swapWeth, _minTokenReceived);\n    }\n\n    function _rebalance(\n        uint256 _amountToSwap,\n        bool _swapWeth,\n        uint256 _minTokenReceived\n    ) internal {\n        /**\n         * Would be nice to check if there is any total liquidity in the pool before performing this swap\n         * but there is no easy way to do that in UniswapV3:\n         * - clPool.liquidity() -> only liquidity in the active tick\n         * - asset[1&2].balanceOf(address(clPool)) -> will include uncollected tokens of LP providers\n         *   after their liquidity position has been decreased\n         */\n\n        /**\n         * When rebalance is called for the first time there is no strategy\n         * liquidity in the pool yet. The liquidity removal is thus skipped.\n         * Also execute this function when WETH is required for the swap.\n         */\n        if (tokenId != 0 && _swapWeth && _amountToSwap > 0) {\n            _ensureWETHBalance(_amountToSwap);\n        }\n\n        // in some cases we will just want to add liquidity and not issue a swap to move the\n        // active trading position within the pool\n        if (_amountToSwap > 0) {\n            _swapToDesiredPosition(_amountToSwap, _swapWeth, _minTokenReceived);\n        }\n        // calling check liquidity early so we don't get unexpected errors when adding liquidity\n        // in the later stages of this function\n        _checkForExpectedPoolPrice(true);\n\n        _addLiquidity();\n\n        // this call shouldn't be necessary, since adding liquidity shouldn't affect the active\n        // trading price. It is a defensive programming measure.\n        (, uint256 _wethSharePct) = _checkForExpectedPoolPrice(true);\n\n        // revert if protocol insolvent\n        _solvencyAssert();\n\n        emit PoolRebalanced(_wethSharePct);\n    }\n\n    /**\n     * Checks that the protocol is solvent, protecting from a rogue Strategist / Guardian that can\n     * keep rebalancing the pool in both directions making the protocol lose a tiny amount of\n     * funds each time.\n     *\n     * Protocol must be at least SOLVENCY_THRESHOLD (99,8 %) backed in order for the rebalances to\n     * function.\n     */\n    function _solvencyAssert() internal view {\n        uint256 _totalVaultValue = IVault(vaultAddress).totalValue();\n        uint256 _totalOethbSupply = IERC20(OETHb).totalSupply();\n\n        if (\n            _totalVaultValue.divPrecisely(_totalOethbSupply) <\n            SOLVENCY_THRESHOLD\n        ) {\n            revert(\"Protocol insolvent\");\n        }\n    }\n\n    /**\n     * @dev Decrease partial or all liquidity from the pool.\n     * @param _liquidityToDecrease The amount of liquidity to remove expressed in 18 decimal point\n     */\n    function _removeLiquidity(uint256 _liquidityToDecrease)\n        internal\n        gaugeUnstakeAndRestake\n    {\n        require(_liquidityToDecrease > 0, \"Must remove some liquidity\");\n\n        uint128 _liquidity = _getLiquidity();\n        // need to convert to uint256 since intermittent result is to big for uint128 to handle\n        uint128 _liquidityToRemove = uint256(_liquidity)\n            .mulTruncate(_liquidityToDecrease)\n            .toUint128();\n\n        /**\n         * There is no liquidity to remove -> exit function early. This can happen after a\n         * withdraw/withdrawAll removes all of the liquidity while retaining the NFT token.\n         */\n        if (_liquidity == 0 || _liquidityToRemove == 0) {\n            return;\n        }\n\n        (uint256 _amountWeth, uint256 _amountOethb) = positionManager\n            .decreaseLiquidity(\n                // Both expected amounts can be 0 since we don't really care if any swaps\n                // happen just before the liquidity removal.\n                INonfungiblePositionManager.DecreaseLiquidityParams({\n                    tokenId: tokenId,\n                    liquidity: _liquidityToRemove,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    deadline: block.timestamp\n                })\n            );\n\n        (\n            uint256 _amountWethCollected,\n            uint256 _amountOethbCollected\n        ) = positionManager.collect(\n                INonfungiblePositionManager.CollectParams({\n                    tokenId: tokenId,\n                    recipient: address(this),\n                    amount0Max: type(uint128).max, // defaults to all tokens owed\n                    amount1Max: type(uint128).max // defaults to all tokens owed\n                })\n            );\n\n        _updateUnderlyingAssets();\n\n        emit LiquidityRemoved(\n            _liquidityToDecrease,\n            _amountWeth, //removedWethAmount\n            _amountOethb, //removedOethbAmount\n            _amountWethCollected,\n            _amountOethbCollected,\n            underlyingAssets\n        );\n\n        _burnOethbOnTheContract();\n    }\n\n    /**\n     * @dev Perform a swap so that after the swap the ticker has the desired WETH to OETHb token share.\n     */\n    function _swapToDesiredPosition(\n        uint256 _amountToSwap,\n        bool _swapWeth,\n        uint256 _minTokenReceived\n    ) internal {\n        IERC20 _tokenToSwap = IERC20(_swapWeth ? WETH : OETHb);\n        uint256 _balance = _tokenToSwap.balanceOf(address(this));\n\n        if (_balance < _amountToSwap) {\n            // This should never trigger since _ensureWETHBalance will already\n            // throw an error if there is not enough WETH\n            if (_swapWeth) {\n                revert NotEnoughWethForSwap(_balance, _amountToSwap);\n            }\n            // if swapping OETHb\n            uint256 mintForSwap = _amountToSwap - _balance;\n            IVault(vaultAddress).mintForStrategy(mintForSwap);\n        }\n\n        // approve the specific amount of WETH required\n        if (_swapWeth) {\n            IERC20(WETH).approve(address(swapRouter), _amountToSwap);\n        }\n\n        // Swap it\n        swapRouter.exactInputSingle(\n            // sqrtPriceLimitX96 is just a rough sanity check that we are within 0 -> 1 tick\n            // a more fine check is performed in _checkForExpectedPoolPrice\n            // Note: this needs further work if we want to generalize this approach\n            ISwapRouter.ExactInputSingleParams({\n                tokenIn: address(_tokenToSwap),\n                tokenOut: _swapWeth ? OETHb : WETH,\n                tickSpacing: tickSpacing, // set to 1\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountIn: _amountToSwap,\n                amountOutMinimum: _minTokenReceived, // slippage check\n                sqrtPriceLimitX96: _swapWeth\n                    ? sqrtRatioX96TickLower\n                    : sqrtRatioX96TickHigher\n            })\n        );\n\n        /**\n         * In the interest of each function in _rebalance to leave the contract state as\n         * clean as possible the OETHb tokens here are burned. This decreases the\n         * dependence where `_swapToDesiredPosition` function relies on later functions\n         * (`addLiquidity`) to burn the OETHb. Reducing the risk of error introduction.\n         */\n        _burnOethbOnTheContract();\n    }\n\n    /**\n     * @dev Add liquidity into the pool in the pre-configured WETH to OETHb share ratios\n     * defined by the allowedPoolWethShareStart|End interval. This function will respect\n     * liquidity ratios when there is no liquidity yet in the pool. If liquidity is already\n     * present then it relies on the `_swapToDesiredPosition` function in a step before\n     * to already move the trading price to desired position (with some tolerance).\n     */\n    // rebalance already has re-entrency checks\n    // slither-disable-start reentrancy-no-eth\n    function _addLiquidity() internal gaugeUnstakeAndRestake {\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        uint256 _oethbBalance = IERC20(OETHb).balanceOf(address(this));\n        // don't deposit small liquidity amounts\n        if (_wethBalance <= 1e12) {\n            return;\n        }\n\n        uint160 _currentPrice = getPoolX96Price();\n        /**\n         * Sanity check active trading price is positioned within our desired tick.\n         *\n         * We revert when price is equal to the lower tick even though that is still\n         * a valid amount in regards to ticker position by Sugar.estimateAmount call.\n         * Current price equaling tick bound at the 1:1 price parity results in\n         * uint overfow when calculating the OETHb balance to deposit.\n         */\n        if (\n            _currentPrice <= sqrtRatioX96TickLower ||\n            _currentPrice >= sqrtRatioX96TickHigher\n        ) {\n            revert OutsideExpectedTickRange(getCurrentTradingTick());\n        }\n\n        /**\n         * If estimateAmount1 call fails it could be due to _currentPrice being really\n         * close to a tick and amount1 is a larger number than the sugar helper is able\n         * to compute.\n         *\n         * If token addresses were reversed estimateAmount0 would be required here\n         */\n        uint256 _oethbRequired = helper.estimateAmount1(\n            _wethBalance,\n            address(0), // no need to pass pool address when current price is specified\n            _currentPrice,\n            lowerTick,\n            upperTick\n        );\n\n        if (_oethbRequired > _oethbBalance) {\n            IVault(vaultAddress).mintForStrategy(\n                _oethbRequired - _oethbBalance\n            );\n        }\n\n        // approve the specific amount of WETH required\n        IERC20(WETH).approve(address(positionManager), _wethBalance);\n\n        uint256 _wethAmountSupplied;\n        uint256 _oethbAmountSupplied;\n        if (tokenId == 0) {\n            (\n                tokenId,\n                ,\n                _wethAmountSupplied,\n                _oethbAmountSupplied\n            ) = positionManager.mint(\n                /** amount0Min & amount1Min are left at 0 because slippage protection is ensured by the\n                 * _checkForExpectedPoolPrice\n                 *›\n                 * Also sqrtPriceX96 is 0 because the pool is already created\n                 * non zero amount attempts to create a new instance of the pool\n                 */\n                INonfungiblePositionManager.MintParams({\n                    token0: WETH,\n                    token1: OETHb,\n                    tickSpacing: tickSpacing,\n                    tickLower: lowerTick,\n                    tickUpper: upperTick,\n                    amount0Desired: _wethBalance,\n                    amount1Desired: _oethbRequired,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    recipient: address(this),\n                    deadline: block.timestamp,\n                    sqrtPriceX96: 0\n                })\n            );\n        } else {\n            (, _wethAmountSupplied, _oethbAmountSupplied) = positionManager\n                .increaseLiquidity(\n                    /** amount0Min & amount1Min are left at 0 because slippage protection is ensured by the\n                     * _checkForExpectedPoolPrice\n                     */\n                    INonfungiblePositionManager.IncreaseLiquidityParams({\n                        tokenId: tokenId,\n                        amount0Desired: _wethBalance,\n                        amount1Desired: _oethbRequired,\n                        amount0Min: 0,\n                        amount1Min: 0,\n                        deadline: block.timestamp\n                    })\n                );\n        }\n\n        _updateUnderlyingAssets();\n        emit LiquidityAdded(\n            _wethBalance, // wethAmountDesired\n            _oethbRequired, // oethbAmountDesired\n            _wethAmountSupplied, // wethAmountSupplied\n            _oethbAmountSupplied, // oethbAmountSupplied\n            tokenId, // tokenId\n            underlyingAssets\n        );\n\n        // burn remaining OETHb\n        _burnOethbOnTheContract();\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /**\n     * @dev Check that the Aerodrome pool price is within the expected\n     *      parameters.\n     *      This function works whether the strategy contract has liquidity\n     *      position in the pool or not. The function returns _wethSharePct\n     *      as a gas optimization measure.\n     * @param throwException  when set to true the function throws an exception\n     *        when pool's price is not within expected range.\n     * @return _isExpectedRange  Bool expressing price is within expected range\n     * @return _wethSharePct  Share of WETH owned by this strategy contract in the\n     *         configured ticker.\n     */\n    function _checkForExpectedPoolPrice(bool throwException)\n        internal\n        view\n        returns (bool _isExpectedRange, uint256 _wethSharePct)\n    {\n        require(\n            allowedWethShareStart != 0 && allowedWethShareEnd != 0,\n            \"Weth share interval not set\"\n        );\n\n        uint160 _currentPrice = getPoolX96Price();\n\n        /**\n         * First check we are in expected tick range\n         *\n         * We revert even though price being equal to the lower tick would still\n         * count being within lower tick for the purpose of Sugar.estimateAmount calls\n         */\n        if (\n            _currentPrice <= sqrtRatioX96TickLower ||\n            _currentPrice >= sqrtRatioX96TickHigher\n        ) {\n            if (throwException) {\n                revert OutsideExpectedTickRange(getCurrentTradingTick());\n            }\n            return (false, 0);\n        }\n\n        // 18 decimal number expressed WETH tick share\n        _wethSharePct = _getWethShare(_currentPrice);\n\n        if (\n            _wethSharePct < allowedWethShareStart ||\n            _wethSharePct > allowedWethShareEnd\n        ) {\n            if (throwException) {\n                revert PoolRebalanceOutOfBounds(\n                    _wethSharePct,\n                    allowedWethShareStart,\n                    allowedWethShareEnd\n                );\n            }\n            return (false, _wethSharePct);\n        }\n\n        return (true, _wethSharePct);\n    }\n\n    /**\n     * Burns any OETHb tokens remaining on the strategy contract\n     */\n    function _burnOethbOnTheContract() internal {\n        uint256 _oethbBalance = IERC20(OETHb).balanceOf(address(this));\n        if (_oethbBalance > 1e12) {\n            IVault(vaultAddress).burnForStrategy(_oethbBalance);\n        }\n    }\n\n    /// @dev This function assumes there are no uncollected tokens in the clPool owned by the strategy contract.\n    ///      For that reason any liquidity withdrawals must also collect the tokens.\n    function _updateUnderlyingAssets() internal {\n        if (tokenId == 0) {\n            underlyingAssets = 0;\n            emit UnderlyingAssetsUpdated(underlyingAssets);\n            return;\n        }\n\n        uint128 _liquidity = _getLiquidity();\n\n        /**\n         * Our net value represent the smallest amount of tokens we are able to extract from the position\n         * given our liquidity.\n         *\n         * The least amount of tokens extraditable from the position is where the active trading price is\n         * at the ticker 0 meaning the pool is offering 1:1 trades between WETH & OETHb. At that moment the pool\n         * consists completely of OETHb and no WETH.\n         *\n         * The more swaps from WETH -> OETHb happen on the pool the more the price starts to move towards the -1\n         * ticker making OETHb (priced in WETH) more expensive.\n         *\n         * An additional note: when liquidity is 0 then the helper returns 0 for both token amounts. And the\n         * function set underlying assets to 0.\n         */\n        (uint256 _wethAmount, uint256 _oethbAmount) = helper\n            .getAmountsForLiquidity(\n                sqrtRatioX96TickClosestToParity, // sqrtRatioX96\n                sqrtRatioX96TickLower, // sqrtRatioAX96\n                sqrtRatioX96TickHigher, // sqrtRatioBX96\n                _liquidity\n            );\n\n        require(_wethAmount == 0, \"Non zero wethAmount\");\n        underlyingAssets = _oethbAmount;\n        emit UnderlyingAssetsUpdated(underlyingAssets);\n    }\n\n    /**\n     * @dev This function removes the appropriate amount of liquidity to assure that the required\n     * amount of WETH is available on the contract\n     *\n     * @param _amount  WETH balance required on the contract\n     */\n    function _ensureWETHBalance(uint256 _amount) internal {\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        if (_wethBalance >= _amount) {\n            return;\n        }\n\n        require(tokenId != 0, \"No liquidity available\");\n        uint256 _additionalWethRequired = _amount - _wethBalance;\n        (uint256 _wethInThePool, ) = getPositionPrincipal();\n\n        if (_wethInThePool < _additionalWethRequired) {\n            revert NotEnoughWethLiquidity(\n                _wethInThePool,\n                _additionalWethRequired\n            );\n        }\n\n        uint256 shareOfWethToRemove = Math.min(\n            _additionalWethRequired.divPrecisely(_wethInThePool) + 1,\n            1e18\n        );\n        _removeLiquidity(shareOfWethToRemove);\n    }\n\n    /**\n     * @notice Withdraw an `amount` of assets from the platform and\n     *         send to the `_recipient`.\n     * @param _recipient  Address to which the asset should be sent\n     * @param _asset      WETH address\n     * @param _amount     Amount of WETH to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_asset == WETH, \"Unsupported asset\");\n        require(_recipient == vaultAddress, \"Only withdraw to vault allowed\");\n\n        _ensureWETHBalance(_amount);\n\n        _withdraw(_recipient, _amount);\n    }\n\n    /**\n     * @notice Withdraw WETH and sends it to the Vault.\n     */\n    function withdrawAll() external override onlyVault nonReentrant {\n        if (tokenId != 0) {\n            _removeLiquidity(1e18);\n        }\n\n        uint256 _balance = IERC20(WETH).balanceOf(address(this));\n        if (_balance > 0) {\n            _withdraw(vaultAddress, _balance);\n        }\n    }\n\n    function _withdraw(address _recipient, uint256 _amount) internal {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient == vaultAddress, \"Only withdraw to vault allowed\");\n\n        IERC20(WETH).safeTransfer(_recipient, _amount);\n        emit Withdrawal(WETH, address(0), _amount);\n    }\n\n    /**\n     * @dev Collect the AERO token from the gauge\n     */\n    function _collectRewardTokens() internal override {\n        if (tokenId != 0 && _isLpTokenStakedInGauge()) {\n            clGauge.getReward(tokenId);\n        }\n        super._collectRewardTokens();\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == WETH;\n    }\n\n    /**\n     * @dev Approve the spending of all assets\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        // to add liquidity to the clPool\n        IERC20(OETHb).approve(address(positionManager), type(uint256).max);\n        // to be able to rebalance using the swapRouter\n        IERC20(OETHb).approve(address(swapRouter), type(uint256).max);\n\n        /* the behaviour of this strategy has slightly changed and WETH could be\n         * present on the contract between the transactions. For that reason we are\n         * un-approving WETH to the swapRouter & positionManager and only approving\n         * the required amount before a transaction\n         */\n        IERC20(WETH).approve(address(swapRouter), 0);\n        IERC20(WETH).approve(address(positionManager), 0);\n    }\n\n    /***************************************\n            Balances and Fees\n    ****************************************/\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(_asset == WETH, \"Only WETH supported\");\n\n        // we could in theory deposit to the strategy and forget to call rebalance in the same\n        // governance transaction batch. In that case the WETH that is on the strategy contract\n        // also needs to be accounted for.\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        // just paranoia check, in case there is OETHb in the strategy that for some reason hasn't\n        // been burned yet.\n        uint256 _oethbBalance = IERC20(OETHb).balanceOf(address(this));\n        return underlyingAssets + _wethBalance + _oethbBalance;\n    }\n\n    /**\n     * @dev Returns the balance of both tokens in a given position (excluding fees)\n     * @return _amountWeth Amount of WETH in position\n     * @return _amountOethb Amount of OETHb in position\n     */\n    function getPositionPrincipal()\n        public\n        view\n        returns (uint256 _amountWeth, uint256 _amountOethb)\n    {\n        if (tokenId == 0) {\n            return (0, 0);\n        }\n\n        uint160 _sqrtRatioX96 = getPoolX96Price();\n        (_amountWeth, _amountOethb) = helper.principal(\n            positionManager,\n            tokenId,\n            _sqrtRatioX96\n        );\n    }\n\n    /**\n     * @notice Returns the current pool price in X96 format\n     * @return _sqrtRatioX96 Pool price\n     */\n    function getPoolX96Price() public view returns (uint160 _sqrtRatioX96) {\n        (_sqrtRatioX96, , , , , ) = clPool.slot0();\n    }\n\n    /**\n     * @notice Returns the current active trading tick of the underlying pool\n     * @return _currentTick Current pool trading tick\n     */\n    function getCurrentTradingTick() public view returns (int24 _currentTick) {\n        (, _currentTick, , , , ) = clPool.slot0();\n    }\n\n    /**\n     * @notice Returns the percentage of WETH liquidity in the configured ticker\n     *         owned by this strategy contract.\n     * @return uint256 1e18 denominated percentage expressing the share\n     */\n    function getWETHShare() external view returns (uint256) {\n        uint160 _currentPrice = getPoolX96Price();\n        return _getWethShare(_currentPrice);\n    }\n\n    /**\n     * @notice Returns the amount of liquidity in the contract's LP position\n     * @return _liquidity Amount of liquidity in the position\n     */\n    function _getLiquidity() internal view returns (uint128 _liquidity) {\n        if (tokenId == 0) {\n            revert(\"No LP position\");\n        }\n\n        (, , , , , , , _liquidity, , , , ) = positionManager.positions(tokenId);\n    }\n\n    function _getWethShare(uint160 _currentPrice)\n        internal\n        view\n        returns (uint256)\n    {\n        /**\n         * If estimateAmount1 call fails it could be due to _currentPrice being really\n         * close to a tick and amount1 too big to compute.\n         *\n         * If token addresses were reversed estimateAmount0 would be required here\n         */\n        uint256 _normalizedWethAmount = 1 ether;\n        uint256 _correspondingOethAmount = helper.estimateAmount1(\n            _normalizedWethAmount,\n            address(0), // no need to pass pool address when current price is specified\n            _currentPrice,\n            lowerTick,\n            upperTick\n        );\n\n        // 18 decimal number expressed weth tick share\n        return\n            _normalizedWethAmount.divPrecisely(\n                _normalizedWethAmount + _correspondingOethAmount\n            );\n    }\n\n    /***************************************\n            Hidden functions\n    ****************************************/\n    /// @inheritdoc InitializableAbstractStrategy\n    function setPTokenAddress(address, address) external override {\n        // The pool tokens can never change.\n        revert(\"Unsupported method\");\n    }\n\n    /// @inheritdoc InitializableAbstractStrategy\n    function removePToken(uint256) external override {\n        // The pool tokens can never change.\n        revert(\"Unsupported method\");\n    }\n\n    /**\n     * @dev Not supported\n     */\n    function _abstractSetPToken(address, address) internal override {\n        // the deployer shall call safeApproveAllTokens() to set necessary approvals\n        revert(\"Unsupported method\");\n    }\n\n    /***************************************\n            ERC721 management\n    ****************************************/\n\n    /// @notice Callback function for whenever a NFT is transferred to this contract\n    //  solhint-disable-next-line max-line-length\n    /// Ref: https://docs.openzeppelin.com/contracts/3.x/api/token/erc721#IERC721Receiver-onERC721Received-address-address-uint256-bytes-\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/strategies/balancer/AbstractAuraStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OETH Base Balancer Abstract Strategy\n * @author Origin Protocol Inc\n */\n\nimport { AbstractBalancerStrategy } from \"./AbstractBalancerStrategy.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { IERC4626 } from \"../../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\nimport { IRewardStaking } from \"../IRewardStaking.sol\";\n\nabstract contract AbstractAuraStrategy is AbstractBalancerStrategy {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    /// @notice Address of the Aura rewards pool\n    address public immutable auraRewardPoolAddress;\n\n    // renamed from __reserved to not shadow AbstractBalancerStrategy.__reserved,\n    int256[50] private __reserved_baseAuraStrategy;\n\n    constructor(address _auraRewardPoolAddress) {\n        auraRewardPoolAddress = _auraRewardPoolAddress;\n    }\n\n    /**\n     * @dev Deposit all Balancer Pool Tokens (BPT) in this strategy contract\n     * to the Aura rewards pool.\n     */\n    function _lpDepositAll() internal virtual override {\n        uint256 bptBalance = IERC20(platformAddress).balanceOf(address(this));\n        uint256 auraLp = IERC4626(auraRewardPoolAddress).deposit(\n            bptBalance,\n            address(this)\n        );\n        require(bptBalance == auraLp, \"Aura LP != BPT\");\n    }\n\n    /**\n     * @dev Withdraw `numBPTTokens` Balancer Pool Tokens (BPT) from\n     * the Aura rewards pool to this strategy contract.\n     * @param numBPTTokens Number of Balancer Pool Tokens (BPT) to withdraw\n     */\n    function _lpWithdraw(uint256 numBPTTokens) internal virtual override {\n        IRewardStaking(auraRewardPoolAddress).withdrawAndUnwrap(\n            numBPTTokens,\n            true // also claim reward tokens\n        );\n    }\n\n    /**\n     * @dev Withdraw all Balancer Pool Tokens (BPT) from\n     * the Aura rewards pool to this strategy contract.\n     */\n    function _lpWithdrawAll() internal virtual override {\n        // Get all the strategy's BPTs in Aura\n        // maxRedeem is implemented as balanceOf(address) in Aura\n        uint256 bptBalance = IERC4626(auraRewardPoolAddress).maxRedeem(\n            address(this)\n        );\n\n        IRewardStaking(auraRewardPoolAddress).withdrawAndUnwrap(\n            bptBalance,\n            true // also claim reward tokens\n        );\n    }\n\n    /**\n     * @notice Collects BAL and AURA tokens from the rewards pool.\n     */\n    function collectRewardTokens()\n        external\n        virtual\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        /* Similar to Convex, calling this function collects both of the\n         * accrued BAL and AURA tokens.\n         */\n        IRewardStaking(auraRewardPoolAddress).getReward();\n        _collectRewardTokens();\n    }\n\n    /// @notice Balancer Pool Tokens (BPT) in the Balancer pool and the Aura rewards pool.\n    function _getBalancerPoolTokens()\n        internal\n        view\n        override\n        returns (uint256 balancerPoolTokens)\n    {\n        balancerPoolTokens =\n            IERC20(platformAddress).balanceOf(address(this)) +\n            // maxRedeem is implemented as balanceOf(address) in Aura\n            IERC4626(auraRewardPoolAddress).maxRedeem(address(this));\n    }\n\n    function _approveBase() internal virtual override {\n        super._approveBase();\n\n        IERC20 pToken = IERC20(platformAddress);\n        pToken.safeApprove(auraRewardPoolAddress, type(uint256).max);\n    }\n}\n"
    },
    "contracts/strategies/balancer/AbstractBalancerStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OETH Balancer Abstract Strategy\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { IBalancerVault } from \"../../interfaces/balancer/IBalancerVault.sol\";\nimport { IRateProvider } from \"../../interfaces/balancer/IRateProvider.sol\";\nimport { VaultReentrancyLib } from \"./VaultReentrancyLib.sol\";\nimport { IOracle } from \"../../interfaces/IOracle.sol\";\nimport { IWstETH } from \"../../interfaces/IWstETH.sol\";\nimport { IERC4626 } from \"../../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\n\nabstract contract AbstractBalancerStrategy is InitializableAbstractStrategy {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    address public immutable rETH;\n    address public immutable stETH;\n    address public immutable wstETH;\n    address public immutable frxETH;\n    address public immutable sfrxETH;\n\n    /// @notice Address of the Balancer vault\n    IBalancerVault public immutable balancerVault;\n    /// @notice Balancer pool identifier\n    bytes32 public immutable balancerPoolId;\n\n    // Max withdrawal deviation denominated in 1e18 (1e18 == 100%)\n    uint256 public maxWithdrawalDeviation;\n    // Max deposit deviation denominated in 1e18 (1e18 == 100%)\n    uint256 public maxDepositDeviation;\n\n    int256[48] private __reserved;\n\n    struct BaseBalancerConfig {\n        address rEthAddress; // Address of the rETH token\n        address stEthAddress; // Address of the stETH token\n        address wstEthAddress; // Address of the wstETH token\n        address frxEthAddress; // Address of the frxEth token\n        address sfrxEthAddress; // Address of the sfrxEth token\n        address balancerVaultAddress; // Address of the Balancer vault\n        bytes32 balancerPoolId; // Balancer pool identifier\n    }\n\n    event MaxWithdrawalDeviationUpdated(\n        uint256 _prevMaxDeviationPercentage,\n        uint256 _newMaxDeviationPercentage\n    );\n    event MaxDepositDeviationUpdated(\n        uint256 _prevMaxDeviationPercentage,\n        uint256 _newMaxDeviationPercentage\n    );\n\n    /**\n     * @dev Ensure we are not in a Vault context when this function is called, by attempting a no-op internal\n     * balance operation. If we are already in a Vault transaction (e.g., a swap, join, or exit), the Vault's\n     * reentrancy protection will cause this function to revert.\n     *\n     * Use this modifier with any function that can cause a state change in a pool and is either public itself,\n     * or called by a public function *outside* a Vault operation (e.g., join, exit, or swap).\n     *\n     * This is to protect against Balancer's read-only re-entrancy vulnerability:\n     * https://www.notion.so/originprotocol/Balancer-read-only-reentrancy-c686e72c82414ef18fa34312bb02e11b\n     */\n    modifier whenNotInBalancerVaultContext() {\n        VaultReentrancyLib.ensureNotInVaultContext(balancerVault);\n        _;\n    }\n\n    constructor(BaseBalancerConfig memory _balancerConfig) {\n        rETH = _balancerConfig.rEthAddress;\n        stETH = _balancerConfig.stEthAddress;\n        wstETH = _balancerConfig.wstEthAddress;\n        frxETH = _balancerConfig.frxEthAddress;\n        sfrxETH = _balancerConfig.sfrxEthAddress;\n\n        balancerVault = IBalancerVault(_balancerConfig.balancerVaultAddress);\n        balancerPoolId = _balancerConfig.balancerPoolId;\n    }\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Balancer's strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Address of BAL & AURA\n     * @param _assets Addresses of supported assets. MUST be passed in the same\n     *                order as returned by coins on the pool contract, i.e.\n     *                WETH, stETH\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // BAL & AURA\n        address[] calldata _assets,\n        address[] calldata _pTokens\n    ) external onlyGovernor initializer {\n        maxWithdrawalDeviation = 1e16;\n        maxDepositDeviation = 1e16;\n\n        emit MaxWithdrawalDeviationUpdated(0, maxWithdrawalDeviation);\n        emit MaxDepositDeviationUpdated(0, maxDepositDeviation);\n\n        IERC20[] memory poolAssets = _getPoolAssets();\n        require(\n            poolAssets.length == _assets.length,\n            \"Pool assets length mismatch\"\n        );\n        for (uint256 i = 0; i < _assets.length; ++i) {\n            address asset = _fromPoolAsset(address(poolAssets[i]));\n            require(_assets[i] == asset, \"Pool assets mismatch\");\n        }\n\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n        _approveBase();\n    }\n\n    /**\n     * @notice Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @notice Get strategy's share of an assets in the Balancer pool.\n     * This is not denominated in OUSD/ETH value of the assets in the Balancer pool.\n     * @param _asset  Address of the Vault collateral asset\n     * @return amount  the amount of vault collateral assets\n     *\n     * IMPORTANT if this function is overridden it needs to have a whenNotInBalancerVaultContext\n     * modifier on it or it is susceptible to read-only re-entrancy attack\n     *\n     * @dev it is important that this function is not affected by reporting inflated\n     * values of assets in case of any pool manipulation. Such a manipulation could easily\n     * exploit the protocol by:\n     *  - minting OETH\n     *  - tilting Balancer pool to report higher balances of assets\n     *  - rebasing() -> all that extra token balances get distributed to OETH holders\n     *  - tilting pool back\n     *  - redeeming OETH\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        virtual\n        override\n        whenNotInBalancerVaultContext\n        returns (uint256 amount)\n    {\n        require(assetToPToken[_asset] != address(0), \"Unsupported asset\");\n\n        uint256 bptBalance = _getBalancerPoolTokens();\n\n        /* To calculate the worth of queried asset:\n         *  - assume that all tokens normalized to their ETH value have an equal split balance\n         *    in the pool when it is balanced\n         *  - multiply the BPT amount with the bpt rate to get the ETH denominated amount\n         *    of strategy's holdings\n         *  - divide that by the number of tokens we support in the pool to get ETH denominated\n         *    amount that is applicable to each supported token in the pool.\n         *\n         *    It would be possible to support only 1 asset in the pool (and be exposed to all\n         *    the assets while holding BPT tokens) and deposit/withdraw/checkBalance using only\n         *    that asset. TBD: changes to other functions still required if we ever decide to\n         *    go with such configuration.\n         */\n        amount = (bptBalance.mulTruncate(\n            IRateProvider(platformAddress).getRate()\n        ) / assetsMapped.length);\n\n        /* If the pool asset is equal to (strategy )_asset it means that a rate\n         * provider for that asset exists and that asset is not necessarily\n         * pegged to a unit (ETH).\n         *\n         * Because this function returns the balance of the asset and is not denominated in\n         * ETH units we need to convert the ETH denominated amount to asset amount.\n         */\n        if (_toPoolAsset(_asset) == _asset) {\n            amount = amount.divPrecisely(_getRateProviderRate(_asset));\n        }\n    }\n\n    /**\n     * @notice Returns the value of all assets managed by this strategy.\n     * Uses the Balancer pool's rate (virtual price) to convert the strategy's\n     * Balancer Pool Tokens (BPT) to ETH value.\n     * @return value The ETH value\n     *\n     * IMPORTANT if this function is overridden it needs to have a whenNotInBalancerVaultContext\n     * modifier on it or it is susceptible to read-only re-entrancy attack\n     */\n    function checkBalance()\n        external\n        view\n        virtual\n        whenNotInBalancerVaultContext\n        returns (uint256 value)\n    {\n        uint256 bptBalance = _getBalancerPoolTokens();\n\n        // Convert BPT to ETH value\n        value = bptBalance.mulTruncate(\n            IRateProvider(platformAddress).getRate()\n        );\n    }\n\n    /// @notice Balancer Pool Tokens (BPT) in the Balancer pool.\n    function _getBalancerPoolTokens()\n        internal\n        view\n        virtual\n        returns (uint256 balancerPoolTokens)\n    {\n        balancerPoolTokens = IERC20(platformAddress).balanceOf(address(this));\n    }\n\n    /* solhint-disable max-line-length */\n    /**\n     * @notice BPT price is calculated by taking the rate from the rateProvider of the asset in\n     * question. If one does not exist it defaults to 1e18. To get the final BPT expected that\n     * is multiplied by the underlying asset amount divided by BPT token rate. BPT token rate is\n     * similar to Curve's virtual_price and expresses how much has the price of BPT appreciated\n     * (e.g. due to swap fees) in relation to the underlying assets\n     *\n     * Using the above approach makes the strategy vulnerable to a possible MEV attack using\n     * flash loan to manipulate the pool before a deposit/withdrawal since the function ignores\n     * market values of the assets being priced in BPT.\n     *\n     * At the time of writing there is no safe on-chain approach to pricing BPT in a way that it\n     * would make it invulnerable to MEV pool manipulation. See recent Balancer exploit:\n     * https://www.notion.so/originprotocol/Balancer-OETH-strategy-9becdea132704e588782a919d7d471eb?pvs=4#1cf07de12fc64f1888072321e0644348\n     *\n     * To mitigate MEV possibilities during deposits and withdraws, the VaultValueChecker will use checkBalance before and after the move\n     * to ensure the expected changes took place.\n     *\n     * @param _asset Address of the Balancer pool asset\n     * @param _amount Amount of the Balancer pool asset\n     * @return bptExpected of BPT expected in exchange for the asset\n     *\n     * @dev\n     * bptAssetPrice = 1e18 (asset peg) * pool_asset_rate\n     *\n     * bptExpected = bptAssetPrice * asset_amount / BPT_token_rate\n     *\n     * bptExpected = 1e18 (asset peg) * pool_asset_rate * asset_amount / BPT_token_rate\n     * bptExpected = asset_amount * pool_asset_rate / BPT_token_rate\n     *\n     * further information available here:\n     * https://www.notion.so/originprotocol/Balancer-OETH-strategy-9becdea132704e588782a919d7d471eb?pvs=4#ce01495ae70346d8971f5dced809fb83\n     */\n    /* solhint-enable max-line-length */\n    function _getBPTExpected(address _asset, uint256 _amount)\n        internal\n        view\n        virtual\n        returns (uint256 bptExpected)\n    {\n        uint256 bptRate = IRateProvider(platformAddress).getRate();\n        uint256 poolAssetRate = _getRateProviderRate(_asset);\n        bptExpected = _amount.mulTruncate(poolAssetRate).divPrecisely(bptRate);\n    }\n\n    function _getBPTExpected(\n        address[] memory _assets,\n        uint256[] memory _amounts\n    ) internal view virtual returns (uint256 bptExpected) {\n        require(_assets.length == _amounts.length, \"Assets & amounts mismatch\");\n\n        for (uint256 i = 0; i < _assets.length; ++i) {\n            uint256 poolAssetRate = _getRateProviderRate(_assets[i]);\n            // convert asset amount to ETH amount\n            bptExpected += _amounts[i].mulTruncate(poolAssetRate);\n        }\n\n        uint256 bptRate = IRateProvider(platformAddress).getRate();\n        // Convert ETH amount to BPT amount\n        bptExpected = bptExpected.divPrecisely(bptRate);\n    }\n\n    function _lpDepositAll() internal virtual;\n\n    function _lpWithdraw(uint256 numBPTTokens) internal virtual;\n\n    function _lpWithdrawAll() internal virtual;\n\n    /**\n     * @notice Balancer returns assets and rateProviders for corresponding assets ordered\n     * by numerical order.\n     */\n    function _getPoolAssets() internal view returns (IERC20[] memory assets) {\n        // slither-disable-next-line unused-return\n        (assets, , ) = balancerVault.getPoolTokens(balancerPoolId);\n    }\n\n    /**\n     * @dev If an asset is rebasing the Balancer pools have a wrapped versions of assets\n     * that the strategy supports. This function converts the pool(wrapped) asset\n     * and corresponding amount to strategy asset.\n     */\n    function _toPoolAsset(address asset, uint256 amount)\n        internal\n        view\n        returns (address poolAsset, uint256 poolAmount)\n    {\n        if (asset == stETH) {\n            poolAsset = wstETH;\n            if (amount > 0) {\n                poolAmount = IWstETH(wstETH).getWstETHByStETH(amount);\n            }\n        } else if (asset == frxETH) {\n            poolAsset = sfrxETH;\n            if (amount > 0) {\n                poolAmount = IERC4626(sfrxETH).convertToShares(amount);\n            }\n        } else {\n            poolAsset = asset;\n            poolAmount = amount;\n        }\n    }\n\n    /**\n     * @dev Converts a Vault collateral asset to a Balancer pool asset.\n     * stETH becomes wstETH, frxETH becomes sfrxETH and everything else stays the same.\n     * @param asset Address of the Vault collateral asset.\n     * @return Address of the Balancer pool asset.\n     */\n    function _toPoolAsset(address asset) internal view returns (address) {\n        if (asset == stETH) {\n            return wstETH;\n        } else if (asset == frxETH) {\n            return sfrxETH;\n        }\n        return asset;\n    }\n\n    /**\n     * @dev Converts rebasing asset to its wrapped counterpart.\n     */\n    function _wrapPoolAsset(address asset, uint256 amount)\n        internal\n        returns (address wrappedAsset, uint256 wrappedAmount)\n    {\n        if (asset == stETH) {\n            wrappedAsset = wstETH;\n            if (amount > 0) {\n                wrappedAmount = IWstETH(wstETH).wrap(amount);\n            }\n        } else if (asset == frxETH) {\n            wrappedAsset = sfrxETH;\n            if (amount > 0) {\n                wrappedAmount = IERC4626(sfrxETH).deposit(\n                    amount,\n                    address(this)\n                );\n            }\n        } else {\n            wrappedAsset = asset;\n            wrappedAmount = amount;\n        }\n    }\n\n    /**\n     * @dev Converts wrapped asset to its rebasing counterpart.\n     */\n    function _unwrapPoolAsset(address asset, uint256 amount)\n        internal\n        returns (uint256 unwrappedAmount)\n    {\n        if (asset == stETH) {\n            unwrappedAmount = IWstETH(wstETH).unwrap(amount);\n        } else if (asset == frxETH) {\n            unwrappedAmount = IERC4626(sfrxETH).withdraw(\n                amount,\n                address(this),\n                address(this)\n            );\n        } else {\n            unwrappedAmount = amount;\n        }\n    }\n\n    /**\n     * @dev If an asset is rebasing the Balancer pools have a wrapped versions of assets\n     * that the strategy supports. This function converts the rebasing strategy asset\n     * and corresponding amount to wrapped(pool) asset.\n     */\n    function _fromPoolAsset(address poolAsset, uint256 poolAmount)\n        internal\n        view\n        returns (address asset, uint256 amount)\n    {\n        if (poolAsset == wstETH) {\n            asset = stETH;\n            if (poolAmount > 0) {\n                amount = IWstETH(wstETH).getStETHByWstETH(poolAmount);\n            }\n        } else if (poolAsset == sfrxETH) {\n            asset = frxETH;\n            if (poolAmount > 0) {\n                amount = IERC4626(sfrxETH).convertToAssets(poolAmount);\n            }\n        } else {\n            asset = poolAsset;\n            amount = poolAmount;\n        }\n    }\n\n    function _fromPoolAsset(address poolAsset)\n        internal\n        view\n        returns (address asset)\n    {\n        if (poolAsset == wstETH) {\n            asset = stETH;\n        } else if (poolAsset == sfrxETH) {\n            asset = frxETH;\n        } else {\n            asset = poolAsset;\n        }\n    }\n\n    /**\n     * @notice Sets max withdrawal deviation that is considered when removing\n     * liquidity from Balancer pools.\n     * @param _maxWithdrawalDeviation Max withdrawal deviation denominated in\n     *        wad (number with 18 decimals): 1e18 == 100%, 1e16 == 1%\n     *\n     * IMPORTANT Minimum maxWithdrawalDeviation will be 1% (1e16) for production\n     * usage. Vault value checker in combination with checkBalance will\n     * catch any unexpected manipulation.\n     */\n    function setMaxWithdrawalDeviation(uint256 _maxWithdrawalDeviation)\n        external\n        onlyVaultOrGovernorOrStrategist\n    {\n        require(\n            _maxWithdrawalDeviation <= 1e18,\n            \"Withdrawal dev. out of bounds\"\n        );\n        emit MaxWithdrawalDeviationUpdated(\n            maxWithdrawalDeviation,\n            _maxWithdrawalDeviation\n        );\n        maxWithdrawalDeviation = _maxWithdrawalDeviation;\n    }\n\n    /**\n     * @notice Sets max deposit deviation that is considered when adding\n     * liquidity to Balancer pools.\n     * @param _maxDepositDeviation Max deposit deviation denominated in\n     *        wad (number with 18 decimals): 1e18 == 100%, 1e16 == 1%\n     *\n     * IMPORTANT Minimum maxDepositDeviation will default to 1% (1e16)\n     * for production usage. Vault value checker in combination with\n     * checkBalance will catch any unexpected manipulation.\n     */\n    function setMaxDepositDeviation(uint256 _maxDepositDeviation)\n        external\n        onlyVaultOrGovernorOrStrategist\n    {\n        require(_maxDepositDeviation <= 1e18, \"Deposit dev. out of bounds\");\n        emit MaxDepositDeviationUpdated(\n            maxDepositDeviation,\n            _maxDepositDeviation\n        );\n        maxDepositDeviation = _maxDepositDeviation;\n    }\n\n    function _approveBase() internal virtual {\n        IERC20 pToken = IERC20(platformAddress);\n        // Balancer vault for BPT token (required for removing liquidity)\n        pToken.safeApprove(address(balancerVault), type(uint256).max);\n    }\n\n    function _getRateProviderRate(address _asset)\n        internal\n        view\n        virtual\n        returns (uint256);\n}\n"
    },
    "contracts/strategies/balancer/BalancerMetaPoolStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OETH Balancer MetaStablePool Strategy\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { AbstractAuraStrategy, AbstractBalancerStrategy } from \"./AbstractAuraStrategy.sol\";\nimport { IBalancerVault } from \"../../interfaces/balancer/IBalancerVault.sol\";\nimport { IRateProvider } from \"../../interfaces/balancer/IRateProvider.sol\";\nimport { IMetaStablePool } from \"../../interfaces/balancer/IMetaStablePool.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\n\ncontract BalancerMetaPoolStrategy is AbstractAuraStrategy {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    constructor(\n        BaseStrategyConfig memory _stratConfig,\n        BaseBalancerConfig memory _balancerConfig,\n        address _auraRewardPoolAddress\n    )\n        InitializableAbstractStrategy(_stratConfig)\n        AbstractBalancerStrategy(_balancerConfig)\n        AbstractAuraStrategy(_auraRewardPoolAddress)\n    {}\n\n    /**\n     * @notice There are no plans to configure BalancerMetaPool as a default\n     * asset strategy. For that reason there is no need to support this\n     * functionality.\n     */\n    function deposit(address, uint256)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        revert(\"Not supported\");\n    }\n\n    /**\n     * @notice There are no plans to configure BalancerMetaPool as a default\n     * asset strategy. For that reason there is no need to support this\n     * functionality.\n     */\n    function deposit(address[] calldata, uint256[] calldata)\n        external\n        onlyVault\n        nonReentrant\n    {\n        revert(\"Not supported\");\n    }\n\n    /**\n     * @notice Deposits all supported assets in this strategy contract to the Balancer pool.\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 assetsLength = assetsMapped.length;\n        address[] memory strategyAssets = new address[](assetsLength);\n        uint256[] memory strategyAmounts = new uint256[](assetsLength);\n\n        // For each vault collateral asset\n        for (uint256 i = 0; i < assetsLength; ++i) {\n            strategyAssets[i] = assetsMapped[i];\n            // Get the asset balance in this strategy contract\n            strategyAmounts[i] = IERC20(strategyAssets[i]).balanceOf(\n                address(this)\n            );\n        }\n        _deposit(strategyAssets, strategyAmounts);\n    }\n\n    /*\n     * _deposit doesn't require a read-only re-entrancy protection since during the deposit\n     * the function enters the Balancer Vault Context. If this function were called as part of\n     * the attacking contract (while intercepting execution flow upon receiving ETH) the read-only\n     * protection of the Balancer Vault would be triggered. Since the attacking contract would\n     * already be in the Balancer Vault context and wouldn't be able to enter it again.\n     */\n    function _deposit(\n        address[] memory _strategyAssets,\n        uint256[] memory _strategyAmounts\n    ) internal {\n        require(\n            _strategyAssets.length == _strategyAmounts.length,\n            \"Array length missmatch\"\n        );\n\n        (IERC20[] memory tokens, , ) = balancerVault.getPoolTokens(\n            balancerPoolId\n        );\n\n        uint256[] memory strategyAssetAmountsToPoolAssetAmounts = new uint256[](\n            _strategyAssets.length\n        );\n        address[] memory strategyAssetsToPoolAssets = new address[](\n            _strategyAssets.length\n        );\n\n        for (uint256 i = 0; i < _strategyAssets.length; ++i) {\n            address strategyAsset = _strategyAssets[i];\n            uint256 strategyAmount = _strategyAmounts[i];\n\n            require(\n                assetToPToken[strategyAsset] != address(0),\n                \"Unsupported asset\"\n            );\n            strategyAssetsToPoolAssets[i] = _toPoolAsset(strategyAsset);\n\n            if (strategyAmount > 0) {\n                emit Deposit(strategyAsset, platformAddress, strategyAmount);\n\n                // wrap rebasing assets like stETH and frxETH to wstETH and sfrxETH\n                (, strategyAssetAmountsToPoolAssetAmounts[i]) = _wrapPoolAsset(\n                    strategyAsset,\n                    strategyAmount\n                );\n            }\n        }\n\n        uint256[] memory amountsIn = new uint256[](tokens.length);\n        address[] memory poolAssets = new address[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            // Convert IERC20 type to address\n            poolAssets[i] = address(tokens[i]);\n\n            // For each of the mapped assets\n            for (uint256 j = 0; j < strategyAssetsToPoolAssets.length; ++j) {\n                // If the pool asset is the same as the mapped asset\n                if (poolAssets[i] == strategyAssetsToPoolAssets[j]) {\n                    amountsIn[i] = strategyAssetAmountsToPoolAssetAmounts[j];\n                }\n            }\n        }\n\n        uint256 minBPT = _getBPTExpected(\n            strategyAssetsToPoolAssets,\n            strategyAssetAmountsToPoolAssetAmounts\n        );\n        uint256 minBPTwDeviation = minBPT.mulTruncate(\n            1e18 - maxDepositDeviation\n        );\n\n        /* EXACT_TOKENS_IN_FOR_BPT_OUT:\n         * User sends precise quantities of tokens, and receives an\n         * estimated but unknown (computed at run time) quantity of BPT.\n         *\n         * ['uint256', 'uint256[]', 'uint256']\n         * [EXACT_TOKENS_IN_FOR_BPT_OUT, amountsIn, minimumBPT]\n         */\n        bytes memory userData = abi.encode(\n            IBalancerVault.WeightedPoolJoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n            amountsIn,\n            minBPTwDeviation\n        );\n\n        IBalancerVault.JoinPoolRequest memory request = IBalancerVault\n            .JoinPoolRequest(poolAssets, amountsIn, userData, false);\n\n        // Add the pool assets in this strategy to the balancer pool\n        balancerVault.joinPool(\n            balancerPoolId,\n            address(this),\n            address(this),\n            request\n        );\n\n        // Deposit the Balancer Pool Tokens (BPT) into Aura\n        _lpDepositAll();\n    }\n\n    /**\n     * @notice Withdraw a Vault collateral asset from the Balancer pool.\n     * @param _recipient Address to receive the Vault collateral assets. Typically is the Vault.\n     * @param _strategyAsset Address of the Vault collateral asset\n     * @param _strategyAmount The amount of Vault collateral assets to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _strategyAsset,\n        uint256 _strategyAmount\n    ) external override onlyVault nonReentrant {\n        address[] memory strategyAssets = new address[](1);\n        uint256[] memory strategyAmounts = new uint256[](1);\n        strategyAssets[0] = _strategyAsset;\n        strategyAmounts[0] = _strategyAmount;\n\n        _withdraw(_recipient, strategyAssets, strategyAmounts);\n    }\n\n    /**\n     * @notice Withdraw multiple Vault collateral asset from the Balancer pool.\n     * @param _recipient Address to receive the Vault collateral assets. Typically is the Vault.\n     * @param _strategyAssets Addresses of the Vault collateral assets\n     * @param _strategyAmounts The amounts of Vault collateral assets to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address[] calldata _strategyAssets,\n        uint256[] calldata _strategyAmounts\n    ) external onlyVault nonReentrant {\n        _withdraw(_recipient, _strategyAssets, _strategyAmounts);\n    }\n\n    /**\n     * @dev Withdraw multiple Vault collateral asset from the Balancer pool.\n     * @param _recipient Address to receive the Vault collateral assets. Typically is the Vault.\n     * @param _strategyAssets Addresses of the Vault collateral assets\n     * @param _strategyAmounts The amounts of Vault collateral assets to withdraw\n     *\n     * _withdrawal doesn't require a read-only re-entrancy protection since during the withdrawal\n     * the function enters the Balancer Vault Context. If this function were called as part of\n     * the attacking contract (while intercepting execution flow upon receiving ETH) the read-only\n     * protection of the Balancer Vault would be triggered. Since the attacking contract would\n     * already be in the Balancer Vault context and wouldn't be able to enter it again.\n     */\n    function _withdraw(\n        address _recipient,\n        address[] memory _strategyAssets,\n        uint256[] memory _strategyAmounts\n    ) internal {\n        require(\n            _strategyAssets.length == _strategyAmounts.length,\n            \"Invalid input arrays\"\n        );\n\n        for (uint256 i = 0; i < _strategyAssets.length; ++i) {\n            require(\n                assetToPToken[_strategyAssets[i]] != address(0),\n                \"Unsupported asset\"\n            );\n        }\n\n        // STEP 1 - Calculate the Balancer pool assets and amounts from the vault collateral assets\n\n        // Get all the supported balancer pool assets\n        (IERC20[] memory tokens, , ) = balancerVault.getPoolTokens(\n            balancerPoolId\n        );\n        // Calculate the balancer pool assets and amounts to withdraw\n        uint256[] memory poolAssetsAmountsOut = new uint256[](tokens.length);\n        address[] memory poolAssets = new address[](tokens.length);\n        // Is the wrapped asset amount indexed by the assets array, not the order of the Balancer pool tokens\n        // eg wstETH and sfrxETH amounts, not the stETH and frxETH amounts\n        uint256[] memory strategyAssetsToPoolAssetsAmounts = new uint256[](\n            _strategyAssets.length\n        );\n\n        // For each of the Balancer pool assets\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            poolAssets[i] = address(tokens[i]);\n\n            // Convert the Balancer pool asset back to a vault collateral asset\n            address strategyAsset = _fromPoolAsset(poolAssets[i]);\n\n            // for each of the vault assets\n            for (uint256 j = 0; j < _strategyAssets.length; ++j) {\n                // If the vault asset equals the vault asset mapped from the Balancer pool asset\n                if (_strategyAssets[j] == strategyAsset) {\n                    (, poolAssetsAmountsOut[i]) = _toPoolAsset(\n                        strategyAsset,\n                        _strategyAmounts[j]\n                    );\n                    strategyAssetsToPoolAssetsAmounts[j] = poolAssetsAmountsOut[\n                        i\n                    ];\n\n                    /* Because of the potential Balancer rounding error mentioned below\n                     * the contract might receive 1-2 WEI smaller amount than required\n                     * in the withdraw user data encoding. If slightly lesser token amount\n                     * is received the strategy can not unwrap the pool asset as it is\n                     * smaller than expected.\n                     *\n                     * For that reason we `overshoot` the required tokens expected to\n                     * circumvent the error\n                     */\n                    if (poolAssetsAmountsOut[i] > 0) {\n                        poolAssetsAmountsOut[i] += 2;\n                    }\n                }\n            }\n        }\n\n        // STEP 2 - Calculate the max about of Balancer Pool Tokens (BPT) to withdraw\n\n        // Estimate the required amount of Balancer Pool Tokens (BPT) for the assets\n        uint256 maxBPTtoWithdraw = _getBPTExpected(\n            poolAssets,\n            /* all non 0 values are overshot by 2 WEI and with the expected mainnet\n             * ~1% withdrawal deviation, the 2 WEI aren't important\n             */\n            poolAssetsAmountsOut\n        );\n        // Increase BPTs by the max allowed deviation\n        // Any excess BPTs will be left in this strategy contract\n        maxBPTtoWithdraw = maxBPTtoWithdraw.mulTruncate(\n            1e18 + maxWithdrawalDeviation\n        );\n\n        // STEP 3  - Withdraw the Balancer Pool Tokens (BPT) from Aura to this strategy contract\n\n        // Withdraw BPT from Aura allowing for BPTs left in this strategy contract from previous withdrawals\n        _lpWithdraw(\n            maxBPTtoWithdraw - IERC20(platformAddress).balanceOf(address(this))\n        );\n\n        // STEP 4 - Withdraw the balancer pool assets from the pool\n\n        /* Custom asset exit: BPT_IN_FOR_EXACT_TOKENS_OUT:\n         * User sends an estimated but unknown (computed at run time) quantity of BPT,\n         * and receives precise quantities of specified tokens.\n         *\n         * ['uint256', 'uint256[]', 'uint256']\n         * [BPT_IN_FOR_EXACT_TOKENS_OUT, amountsOut, maxBPTAmountIn]\n         */\n        bytes memory userData = abi.encode(\n            IBalancerVault.WeightedPoolExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT,\n            poolAssetsAmountsOut,\n            maxBPTtoWithdraw\n        );\n\n        IBalancerVault.ExitPoolRequest memory request = IBalancerVault\n            .ExitPoolRequest(\n                poolAssets,\n                /* We specify the exact amount of a tokens we are expecting in the encoded\n                 * userData, for that reason we don't need to specify the amountsOut here.\n                 *\n                 * Also Balancer has a rounding issue that can make a transaction fail:\n                 * https://github.com/balancer/balancer-v2-monorepo/issues/2541\n                 * which is an extra reason why this field is empty.\n                 */\n                new uint256[](tokens.length),\n                userData,\n                false\n            );\n\n        balancerVault.exitPool(\n            balancerPoolId,\n            address(this),\n            /* Payable keyword is required because of the IBalancerVault interface even though\n             * this strategy shall never be receiving native ETH\n             */\n            payable(address(this)),\n            request\n        );\n\n        // STEP 5 - Re-deposit any left over BPT tokens back into Aura\n        /* When concluding how much of BPT we need to withdraw from Aura we overshoot by\n         * roughly around 1% (initial mainnet setting of maxWithdrawalDeviation). After exiting\n         * the pool strategy could have left over BPT tokens that are not earning boosted yield.\n         * We re-deploy those back in.\n         */\n        _lpDepositAll();\n\n        // STEP 6 - Unswap balancer pool assets to vault collateral assets and send to the vault.\n\n        // For each of the specified assets\n        for (uint256 i = 0; i < _strategyAssets.length; ++i) {\n            // Unwrap assets like wstETH and sfrxETH to rebasing assets stETH and frxETH\n            if (strategyAssetsToPoolAssetsAmounts[i] > 0) {\n                _unwrapPoolAsset(\n                    _strategyAssets[i],\n                    strategyAssetsToPoolAssetsAmounts[i]\n                );\n            }\n\n            // Transfer the vault collateral assets to the recipient, which is typically the vault\n            if (_strategyAmounts[i] > 0) {\n                IERC20(_strategyAssets[i]).safeTransfer(\n                    _recipient,\n                    _strategyAmounts[i]\n                );\n\n                emit Withdrawal(\n                    _strategyAssets[i],\n                    platformAddress,\n                    _strategyAmounts[i]\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraws all supported Vault collateral assets from the Balancer pool\n     * and send to the OToken's Vault.\n     *\n     * Is only executable by the OToken's Vault or the Governor.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        // STEP 1 - Withdraw all Balancer Pool Tokens (BPT) from Aura to this strategy contract\n\n        _lpWithdrawAll();\n        // Get the BPTs withdrawn from Aura plus any that were already in this strategy contract\n        uint256 BPTtoWithdraw = IERC20(platformAddress).balanceOf(\n            address(this)\n        );\n        // Get the balancer pool assets and their total balances\n        (IERC20[] memory tokens, , ) = balancerVault.getPoolTokens(\n            balancerPoolId\n        );\n        uint256[] memory minAmountsOut = new uint256[](tokens.length);\n        address[] memory poolAssets = new address[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            poolAssets[i] = address(tokens[i]);\n        }\n\n        // STEP 2 - Withdraw the Balancer pool assets from the pool\n        /* Proportional exit: EXACT_BPT_IN_FOR_TOKENS_OUT:\n         * User sends a precise quantity of BPT, and receives an estimated but unknown\n         * (computed at run time) quantity of a single token\n         *\n         * ['uint256', 'uint256']\n         * [EXACT_BPT_IN_FOR_TOKENS_OUT, bptAmountIn]\n         *\n         * It is ok to pass an empty minAmountsOut since tilting the pool in any direction\n         * when doing a proportional exit can only be beneficial to the strategy. Since\n         * it will receive more of the underlying tokens for the BPT traded in.\n         */\n        bytes memory userData = abi.encode(\n            IBalancerVault.WeightedPoolExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT,\n            BPTtoWithdraw\n        );\n\n        IBalancerVault.ExitPoolRequest memory request = IBalancerVault\n            .ExitPoolRequest(poolAssets, minAmountsOut, userData, false);\n\n        balancerVault.exitPool(\n            balancerPoolId,\n            address(this),\n            /* Payable keyword is required because of the IBalancerVault interface even though\n             * this strategy shall never be receiving native ETH\n             */\n            payable(address(this)),\n            request\n        );\n\n        // STEP 3 - Convert the balancer pool assets to the vault collateral assets and send to the vault\n        // For each of the Balancer pool assets\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            address poolAsset = address(tokens[i]);\n            // Convert the balancer pool asset to the strategy asset\n            address strategyAsset = _fromPoolAsset(poolAsset);\n            // Get the balancer pool assets withdraw from the pool plus any that were already in this strategy contract\n            uint256 poolAssetAmount = IERC20(poolAsset).balanceOf(\n                address(this)\n            );\n\n            // Unwrap assets like wstETH and sfrxETH to rebasing assets stETH and frxETH\n            uint256 unwrappedAmount = 0;\n            if (poolAssetAmount > 0) {\n                unwrappedAmount = _unwrapPoolAsset(\n                    strategyAsset,\n                    poolAssetAmount\n                );\n            }\n\n            // Transfer the vault collateral assets to the vault\n            if (unwrappedAmount > 0) {\n                IERC20(strategyAsset).safeTransfer(\n                    vaultAddress,\n                    unwrappedAmount\n                );\n                emit Withdrawal(\n                    strategyAsset,\n                    platformAddress,\n                    unwrappedAmount\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Approves the Balancer Vault to transfer poolAsset counterparts\n     * of all of the supported assets from this strategy. E.g. stETH is a supported\n     * strategy and Balancer Vault gets unlimited approval to transfer wstETH.\n     *\n     * If Balancer pool uses a wrapped version of a supported asset then also approve\n     * unlimited usage of an asset to the contract responsible for wrapping.\n     *\n     * Approve unlimited spending by Balancer Vault and Aura reward pool of the\n     * pool BPT tokens.\n     *\n     * Is only executable by the Governor.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            _abstractSetPToken(assetsMapped[i], platformAddress);\n        }\n        _approveBase();\n    }\n\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address) internal override {\n        address poolAsset = _toPoolAsset(_asset);\n        if (_asset == stETH) {\n            // slither-disable-next-line unused-return\n            IERC20(stETH).approve(wstETH, type(uint256).max);\n        } else if (_asset == frxETH) {\n            // slither-disable-next-line unused-return\n            IERC20(frxETH).approve(sfrxETH, type(uint256).max);\n        }\n        _approveAsset(poolAsset);\n    }\n\n    /**\n     * @dev Approves the Balancer Vault to transfer an asset from\n     * this strategy. The assets could be a Vault collateral asset\n     * like WETH or rETH; or a Balancer pool asset that wraps the vault asset\n     * like wstETH or sfrxETH.\n     */\n    function _approveAsset(address _asset) internal {\n        IERC20 asset = IERC20(_asset);\n        // slither-disable-next-line unused-return\n        asset.approve(address(balancerVault), type(uint256).max);\n    }\n\n    /**\n     * @notice Returns the rate supplied by the Balancer configured rate\n     * provider. Rate is used to normalize the token to common underlying\n     * pool denominator. (ETH for ETH Liquid staking derivatives)\n     *\n     * @param _asset Address of the Balancer pool asset\n     * @return rate of the corresponding asset\n     */\n    function _getRateProviderRate(address _asset)\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        IMetaStablePool pool = IMetaStablePool(platformAddress);\n        IRateProvider[] memory providers = pool.getRateProviders();\n        (IERC20[] memory tokens, , ) = balancerVault.getPoolTokens(\n            balancerPoolId\n        );\n\n        uint256 providersLength = providers.length;\n        for (uint256 i = 0; i < providersLength; ++i) {\n            // _assets and corresponding rate providers are all in the same order\n            if (address(tokens[i]) == _asset) {\n                // rate provider doesn't exist, defaults to 1e18\n                if (address(providers[i]) == address(0)) {\n                    return 1e18;\n                }\n                return providers[i].getRate();\n            }\n        }\n\n        // should never happen\n        assert(false);\n    }\n}\n"
    },
    "contracts/strategies/balancer/VaultReentrancyLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../../utils/BalancerErrors.sol\";\nimport { IBalancerVault } from \"../../interfaces/balancer/IBalancerVault.sol\";\n\nlibrary VaultReentrancyLib {\n    /**\n     * @dev Ensure we are not in a Vault context when this function is called, by attempting a no-op internal\n     * balance operation. If we are already in a Vault transaction (e.g., a swap, join, or exit), the Vault's\n     * reentrancy protection will cause this function to revert.\n     *\n     * The exact function call doesn't really matter: we're just trying to trigger the Vault reentrancy check\n     * (and not hurt anything in case it works). An empty operation array with no specific operation at all works\n     * for that purpose, and is also the least expensive in terms of gas and bytecode size.\n     *\n     * Call this at the top of any function that can cause a state change in a pool and is either public itself,\n     * or called by a public function *outside* a Vault operation (e.g., join, exit, or swap).\n     *\n     * If this is *not* called in functions that are vulnerable to the read-only reentrancy issue described\n     * here (https://forum.balancer.fi/t/reentrancy-vulnerability-scope-expanded/4345), those functions are unsafe,\n     * and subject to manipulation that may result in loss of funds.\n     */\n    function ensureNotInVaultContext(IBalancerVault vault) internal view {\n        // Perform the following operation to trigger the Vault's reentrancy guard:\n        //\n        // IBalancerVault.UserBalanceOp[] memory noop = new IBalancerVault.UserBalanceOp[](0);\n        // _vault.manageUserBalance(noop);\n        //\n        // However, use a static call so that it can be a view function (even though the function is non-view).\n        // This allows the library to be used more widely, as some functions that need to be protected might be\n        // view.\n        //\n        // This staticcall always reverts, but we need to make sure it doesn't fail due to a re-entrancy attack.\n        // Staticcalls consume all gas forwarded to them on a revert caused by storage modification.\n        // By default, almost the entire available gas is forwarded to the staticcall,\n        // causing the entire call to revert with an 'out of gas' error.\n        //\n        // We set the gas limit to 10k for the staticcall to\n        // avoid wasting gas when it reverts due to storage modification.\n        // `manageUserBalance` is a non-reentrant function in the Vault, so calling it invokes `_enterNonReentrant`\n        // in the `ReentrancyGuard` contract, reproduced here:\n        //\n        //    function _enterNonReentrant() private {\n        //        // If the Vault is actually being reentered, it will revert in the first line, at the `_require` that\n        //        // checks the reentrancy flag, with \"BAL#400\" (corresponding to Errors.REENTRANCY) in the revertData.\n        //        // The full revertData will be: `abi.encodeWithSignature(\"Error(string)\", \"BAL#400\")`.\n        //        _require(_status != _ENTERED, Errors.REENTRANCY);\n        //\n        //        // If the Vault is not being reentered, the check above will pass: but it will *still* revert,\n        //        // because the next line attempts to modify storage during a staticcall. However, this type of\n        //        // failure results in empty revertData.\n        //        _status = _ENTERED;\n        //    }\n        //\n        // So based on this analysis, there are only two possible revertData values: empty, or abi.encoded BAL#400.\n        //\n        // It is of course much more bytecode and gas efficient to check for zero-length revertData than to compare it\n        // to the encoded REENTRANCY revertData.\n        //\n        // While it should be impossible for the call to fail in any other way (especially since it reverts before\n        // `manageUserBalance` even gets called), any other error would generate non-zero revertData, so checking for\n        // empty data guards against this case too.\n\n        (, bytes memory revertData) = address(vault).staticcall{ gas: 10_000 }(\n            abi.encodeWithSelector(vault.manageUserBalance.selector, 0)\n        );\n\n        _require(revertData.length == 0, Errors.REENTRANCY);\n    }\n}\n"
    },
    "contracts/strategies/BaseCurveAMOStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Curve Automated Market Maker (AMO) Strategy\n * @notice AMO strategy for the Curve OETH/WETH pool\n * @author Origin Protocol Inc\n */\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { ICurveStableSwapNG } from \"../interfaces/ICurveStableSwapNG.sol\";\nimport { ICurveXChainLiquidityGauge } from \"../interfaces/ICurveXChainLiquidityGauge.sol\";\nimport { IChildLiquidityGaugeFactory } from \"../interfaces/IChildLiquidityGaugeFactory.sol\";\n\ncontract BaseCurveAMOStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n    using SafeCast for uint256;\n\n    /**\n     * @dev a threshold under which the contract no longer allows for the protocol to manually rebalance.\n     *      Guarding against a strategist / guardian being taken over and with multiple transactions\n     *      draining the protocol funds.\n     */\n    uint256 public constant SOLVENCY_THRESHOLD = 0.998 ether;\n\n    // New immutable variables that must be set in the constructor\n    /**\n     * @notice Address of the Wrapped ETH (WETH) contract.\n     */\n    IWETH9 public immutable weth;\n\n    /**\n     * @notice Address of the OETH token contract.\n     */\n    IERC20 public immutable oeth;\n\n    /**\n     * @notice Address of the LP (Liquidity Provider) token contract.\n     */\n    IERC20 public immutable lpToken;\n\n    /**\n     * @notice Address of the Curve StableSwap NG pool contract.\n     */\n    ICurveStableSwapNG public immutable curvePool;\n\n    /**\n     * @notice Address of the Curve X-Chain Liquidity Gauge contract.\n     */\n    ICurveXChainLiquidityGauge public immutable gauge;\n\n    /**\n     * @notice Address of the Child Liquidity Gauge Factory contract.\n     */\n    IChildLiquidityGaugeFactory public immutable gaugeFactory;\n\n    // Ordered list of pool assets\n    uint128 public immutable oethCoinIndex;\n    uint128 public immutable wethCoinIndex;\n\n    /**\n     * @notice Maximum slippage allowed for adding/removing liquidity from the Curve pool.\n     */\n    uint256 public maxSlippage;\n\n    event MaxSlippageUpdated(uint256 newMaxSlippage);\n\n    /**\n     * @dev Verifies that the caller is the Strategist.\n     */\n    modifier onlyStrategist() {\n        require(\n            msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Strategist\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Checks the Curve pool's balances have improved and the balances\n     * have not tipped to the other side.\n     * This modifier is only applied to functions that do a single sided add or remove.\n     * The standard deposit function adds to both sides of the pool in a way that\n     * the pool's balance is not worsened.\n     * Withdrawals are proportional so doesn't change the pools asset balance.\n     */\n    modifier improvePoolBalance() {\n        // Get the asset and OToken balances in the Curve pool\n        uint256[] memory balancesBefore = curvePool.get_balances();\n        // diff = ETH balance - OETH balance\n        int256 diffBefore = balancesBefore[wethCoinIndex].toInt256() -\n            balancesBefore[oethCoinIndex].toInt256();\n\n        _;\n\n        // Get the asset and OToken balances in the Curve pool\n        uint256[] memory balancesAfter = curvePool.get_balances();\n        // diff = ETH balance - OETH balance\n        int256 diffAfter = balancesAfter[wethCoinIndex].toInt256() -\n            balancesAfter[oethCoinIndex].toInt256();\n\n        if (diffBefore == 0) {\n            require(diffAfter == 0, \"Position balance is worsened\");\n        } else if (diffBefore < 0) {\n            // If the pool was originally imbalanced in favor of OETH, then\n            // we want to check that the pool is now more balanced\n            require(diffAfter <= 0, \"OTokens overshot peg\");\n            require(diffBefore < diffAfter, \"OTokens balance worse\");\n        } else if (diffBefore > 0) {\n            // If the pool was originally imbalanced in favor of ETH, then\n            // we want to check that the pool is now more balanced\n            require(diffAfter >= 0, \"Assets overshot peg\");\n            require(diffAfter < diffBefore, \"Assets balance worse\");\n        }\n    }\n\n    constructor(\n        BaseStrategyConfig memory _baseConfig,\n        address _oeth,\n        address _weth,\n        address _gauge,\n        address _gaugeFactory,\n        uint128 _oethCoinIndex,\n        uint128 _wethCoinIndex\n    ) InitializableAbstractStrategy(_baseConfig) {\n        oethCoinIndex = _oethCoinIndex;\n        wethCoinIndex = _wethCoinIndex;\n\n        lpToken = IERC20(_baseConfig.platformAddress);\n        curvePool = ICurveStableSwapNG(_baseConfig.platformAddress);\n\n        oeth = IERC20(_oeth);\n        weth = IWETH9(_weth);\n        gauge = ICurveXChainLiquidityGauge(_gauge);\n        gaugeFactory = IChildLiquidityGaugeFactory(_gaugeFactory);\n\n        _setGovernor(address(0));\n    }\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Curve strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Address of CRV\n     * @param _maxSlippage Maximum slippage allowed for adding/removing liquidity from the Curve pool.\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // CRV\n        uint256 _maxSlippage\n    ) external onlyGovernor initializer {\n        address[] memory pTokens = new address[](1);\n        pTokens[0] = address(curvePool);\n\n        address[] memory _assets = new address[](1);\n        _assets[0] = address(weth);\n\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            pTokens\n        );\n\n        _approveBase();\n        _setMaxSlippage(_maxSlippage);\n    }\n\n    /***************************************\n                    Deposit\n    ****************************************/\n\n    /**\n     * @notice Deposit WETH into the Curve pool\n     * @param _weth Address of Wrapped ETH (WETH) contract.\n     * @param _amount Amount of WETH to deposit.\n     */\n    function deposit(address _weth, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_weth, _amount);\n    }\n\n    function _deposit(address _weth, uint256 _wethAmount) internal {\n        require(_wethAmount > 0, \"Must deposit something\");\n        require(_weth == address(weth), \"Can only deposit WETH\");\n\n        emit Deposit(_weth, address(lpToken), _wethAmount);\n\n        // Get the asset and OToken balances in the Curve pool\n        uint256[] memory balances = curvePool.get_balances();\n        // safe to cast since min value is at least 0\n        uint256 oethToAdd = uint256(\n            _max(\n                0,\n                balances[wethCoinIndex].toInt256() +\n                    _wethAmount.toInt256() -\n                    balances[oethCoinIndex].toInt256()\n            )\n        );\n\n        /* Add so much OETH so that the pool ends up being balanced. And at minimum\n         * add as much OETH as WETH and at maximum twice as much OETH.\n         */\n        oethToAdd = Math.max(oethToAdd, _wethAmount);\n        oethToAdd = Math.min(oethToAdd, _wethAmount * 2);\n\n        /* Mint OETH with a strategy that attempts to contribute to stability of OETH/WETH pool. Try\n         * to mint so much OETH that after deployment of liquidity pool ends up being balanced.\n         *\n         * To manage unpredictability minimal OETH minted will always be at least equal or greater\n         * to WETH amount deployed. And never larger than twice the WETH amount deployed even if\n         * it would have a further beneficial effect on pool stability.\n         */\n        IVault(vaultAddress).mintForStrategy(oethToAdd);\n\n        emit Deposit(address(oeth), address(lpToken), oethToAdd);\n\n        uint256[] memory _amounts = new uint256[](2);\n        _amounts[wethCoinIndex] = _wethAmount;\n        _amounts[oethCoinIndex] = oethToAdd;\n\n        uint256 valueInLpTokens = (_wethAmount + oethToAdd).divPrecisely(\n            curvePool.get_virtual_price()\n        );\n        uint256 minMintAmount = valueInLpTokens.mulTruncate(\n            uint256(1e18) - maxSlippage\n        );\n\n        // Do the deposit to the Curve pool\n        uint256 lpDeposited = curvePool.add_liquidity(_amounts, minMintAmount);\n        require(lpDeposited >= minMintAmount, \"Min LP amount error\");\n\n        // Deposit the Curve pool's LP tokens into the Curve gauge\n        gauge.deposit(lpDeposited);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n    }\n\n    /**\n     * @notice Deposit the strategy's entire balance of WETH into the Curve pool\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 balance = weth.balanceOf(address(this));\n        if (balance > 0) {\n            _deposit(address(weth), balance);\n        }\n    }\n\n    /***************************************\n                    Withdraw\n    ****************************************/\n\n    /**\n     * @notice Withdraw ETH and OETH from the Curve pool, burn the OETH,\n     * convert the ETH to WETH and transfer to the recipient.\n     * @param _recipient Address to receive withdrawn asset which is normally the Vault.\n     * @param _weth Address of the Wrapped ETH (WETH) contract.\n     * @param _amount Amount of WETH to withdraw.\n     */\n    function withdraw(\n        address _recipient,\n        address _weth,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_weth == address(weth), \"Can only withdraw WETH\");\n\n        emit Withdrawal(_weth, address(lpToken), _amount);\n\n        uint256 requiredLpTokens = calcTokenToBurn(_amount);\n\n        _lpWithdraw(requiredLpTokens);\n\n        /* math in requiredLpTokens should correctly calculate the amount of LP to remove\n         * in that the strategy receives enough WETH on balanced removal\n         */\n        uint256[] memory _minWithdrawalAmounts = new uint256[](2);\n        _minWithdrawalAmounts[wethCoinIndex] = _amount;\n        // slither-disable-next-line unused-return\n        curvePool.remove_liquidity(requiredLpTokens, _minWithdrawalAmounts);\n\n        // Burn all the removed OETH and any that was left in the strategy\n        uint256 oethToBurn = oeth.balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(oethToBurn);\n\n        emit Withdrawal(address(oeth), address(lpToken), oethToBurn);\n\n        // Transfer WETH to the recipient\n        require(\n            weth.transfer(_recipient, _amount),\n            \"Transfer of WETH not successful\"\n        );\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n    }\n\n    function calcTokenToBurn(uint256 _wethAmount)\n        internal\n        view\n        returns (uint256 lpToBurn)\n    {\n        /* The rate between coins in the pool determines the rate at which pool returns\n         * tokens when doing balanced removal (remove_liquidity call). And by knowing how much WETH\n         * we want we can determine how much of OETH we receive by removing liquidity.\n         *\n         * Because we are doing balanced removal we should be making profit when removing liquidity in a\n         * pool tilted to either side.\n         *\n         * Important: A downside is that the Strategist / Governor needs to be\n         * cognisant of not removing too much liquidity. And while the proposal to remove liquidity\n         * is being voted on the pool tilt might change so much that the proposal that has been valid while\n         * created is no longer valid.\n         */\n\n        uint256 poolWETHBalance = curvePool.balances(wethCoinIndex);\n        /* K is multiplied by 1e36 which is used for higher precision calculation of required\n         * pool LP tokens. Without it the end value can have rounding errors up to precision of\n         * 10 digits. This way we move the decimal point by 36 places when doing the calculation\n         * and again by 36 places when we are done with it.\n         */\n        uint256 k = (1e36 * lpToken.totalSupply()) / poolWETHBalance;\n        // prettier-ignore\n        // slither-disable-next-line divide-before-multiply\n        uint256 diff = (_wethAmount + 1) * k;\n        lpToBurn = diff / 1e36;\n    }\n\n    /**\n     * @notice Remove all ETH and OETH from the Curve pool, burn the OETH,\n     * convert the ETH to WETH and transfer to the Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        uint256 gaugeTokens = gauge.balanceOf(address(this));\n        // Can not withdraw zero LP tokens from the gauge\n        if (gaugeTokens == 0) return;\n        _lpWithdraw(gaugeTokens);\n\n        // Withdraws are proportional to assets held by 3Pool\n        uint256[] memory minWithdrawAmounts = new uint256[](2);\n\n        // Remove liquidity\n        // slither-disable-next-line unused-return\n        curvePool.remove_liquidity(\n            lpToken.balanceOf(address(this)),\n            minWithdrawAmounts\n        );\n\n        // Burn all OETH\n        uint256 oethToBurn = oeth.balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(oethToBurn);\n\n        // Get the strategy contract's WETH balance.\n        // This includes all that was removed from the Curve pool and\n        // any ether that was sitting in the strategy contract before the removal.\n        uint256 ethBalance = weth.balanceOf(address(this));\n        require(\n            weth.transfer(vaultAddress, ethBalance),\n            \"Transfer of WETH not successful\"\n        );\n\n        emit Withdrawal(address(weth), address(lpToken), ethBalance);\n        emit Withdrawal(address(oeth), address(lpToken), oethToBurn);\n    }\n\n    /***************************************\n            Curve pool Rebalancing\n    ****************************************/\n\n    /**\n     * @notice Mint OTokens and one-sided add to the Curve pool.\n     * This is used when the Curve pool does not have enough OTokens and too many ETH.\n     * The OToken/Asset, eg OETH/ETH, price with increase.\n     * The amount of assets in the vault is unchanged.\n     * The total supply of OTokens is increased.\n     * The asset value of the strategy and vault is increased.\n     * @param _oTokens The amount of OTokens to be minted and added to the pool.\n     */\n    function mintAndAddOTokens(uint256 _oTokens)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n    {\n        IVault(vaultAddress).mintForStrategy(_oTokens);\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[oethCoinIndex] = _oTokens;\n\n        // Convert OETH to Curve pool LP tokens\n        uint256 valueInLpTokens = (_oTokens).divPrecisely(\n            curvePool.get_virtual_price()\n        );\n        // Apply slippage to LP tokens\n        uint256 minMintAmount = valueInLpTokens.mulTruncate(\n            uint256(1e18) - maxSlippage\n        );\n\n        // Add the minted OTokens to the Curve pool\n        uint256 lpDeposited = curvePool.add_liquidity(amounts, minMintAmount);\n        require(lpDeposited >= minMintAmount, \"Min LP amount error\");\n\n        // Deposit the Curve pool LP tokens to the Curve gauge\n        gauge.deposit(lpDeposited);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n\n        emit Deposit(address(oeth), address(lpToken), _oTokens);\n    }\n\n    /**\n     * @notice One-sided remove of OTokens from the Curve pool which are then burned.\n     * This is used when the Curve pool has too many OTokens and not enough ETH.\n     * The amount of assets in the vault is unchanged.\n     * The total supply of OTokens is reduced.\n     * The asset value of the strategy and vault is reduced.\n     * @param _lpTokens The amount of Curve pool LP tokens to be burned for OTokens.\n     */\n    function removeAndBurnOTokens(uint256 _lpTokens)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n    {\n        // Withdraw Curve pool LP tokens from Convex and remove OTokens from the Curve pool\n        uint256 oethToBurn = _withdrawAndRemoveFromPool(\n            _lpTokens,\n            oethCoinIndex\n        );\n\n        // The vault burns the OTokens from this strategy\n        IVault(vaultAddress).burnForStrategy(oethToBurn);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n\n        emit Withdrawal(address(oeth), address(lpToken), oethToBurn);\n    }\n\n    /**\n     * @notice One-sided remove of ETH from the Curve pool, convert to WETH\n     * and transfer to the vault.\n     * This is used when the Curve pool does not have enough OTokens and too many ETH.\n     * The OToken/Asset, eg OETH/ETH, price with decrease.\n     * The amount of assets in the vault increases.\n     * The total supply of OTokens does not change.\n     * The asset value of the strategy reduces.\n     * The asset value of the vault should be close to the same.\n     * @param _lpTokens The amount of Curve pool LP tokens to be burned for ETH.\n     * @dev Curve pool LP tokens is used rather than WETH assets as Curve does not\n     * have a way to accurately calculate the amount of LP tokens for a required\n     * amount of ETH. Curve's `calc_token_amount` functioun does not include fees.\n     * A 3rd party libary can be used that takes into account the fees, but this\n     * is a gas intensive process. It's easier for the trusted strategist to\n     * caclulate the amount of Curve pool LP tokens required off-chain.\n     */\n    function removeOnlyAssets(uint256 _lpTokens)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n    {\n        // Withdraw Curve pool LP tokens from Curve gauge and remove ETH from the Curve pool\n        uint256 ethAmount = _withdrawAndRemoveFromPool(\n            _lpTokens,\n            wethCoinIndex\n        );\n\n        // Transfer WETH to the vault\n        require(\n            weth.transfer(vaultAddress, ethAmount),\n            \"Transfer of WETH not successful\"\n        );\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n\n        emit Withdrawal(address(weth), address(lpToken), ethAmount);\n    }\n\n    /**\n     * @dev Remove Curve pool LP tokens from the Convex pool and\n     * do a one-sided remove of ETH or OETH from the Curve pool.\n     * @param _lpTokens The amount of Curve pool LP tokens to be removed from the Convex pool.\n     * @param coinIndex The index of the coin to be removed from the Curve pool. 0 = ETH, 1 = OETH.\n     * @return coinsRemoved The amount of ETH or OETH removed from the Curve pool.\n     */\n    function _withdrawAndRemoveFromPool(uint256 _lpTokens, uint128 coinIndex)\n        internal\n        returns (uint256 coinsRemoved)\n    {\n        // Withdraw Curve pool LP tokens from Curve gauge\n        _lpWithdraw(_lpTokens);\n\n        // Convert Curve pool LP tokens to ETH value\n        uint256 valueInEth = _lpTokens.mulTruncate(\n            curvePool.get_virtual_price()\n        );\n        // Apply slippage to ETH value\n        uint256 minAmount = valueInEth.mulTruncate(uint256(1e18) - maxSlippage);\n\n        // Remove just the ETH from the Curve pool\n        coinsRemoved = curvePool.remove_liquidity_one_coin(\n            _lpTokens,\n            int128(coinIndex),\n            minAmount,\n            address(this)\n        );\n    }\n\n    /**\n     * Checks that the protocol is solvent, protecting from a rogue Strategist / Guardian that can\n     * keep rebalancing the pool in both directions making the protocol lose a tiny amount of\n     * funds each time.\n     *\n     * Protocol must be at least SOLVENCY_THRESHOLD (99,8 %) backed in order for the rebalances to\n     * function.\n     */\n    function _solvencyAssert() internal view {\n        uint256 _totalVaultValue = IVault(vaultAddress).totalValue();\n        uint256 _totalOethbSupply = oeth.totalSupply();\n\n        if (\n            _totalVaultValue.divPrecisely(_totalOethbSupply) <\n            SOLVENCY_THRESHOLD\n        ) {\n            revert(\"Protocol insolvent\");\n        }\n    }\n\n    /***************************************\n                Assets and Rewards\n    ****************************************/\n\n    /**\n     * @notice Collect accumulated CRV (and other) rewards and send to the Harvester.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // CRV rewards flow.\n        //---\n        // CRV inflation:\n        // Gauge receive CRV rewards from inflation.\n        // Each checkpoint on the gauge send this CRV inflation to gauge factory.\n        // This strategy should call mint on the gauge factory to collect the CRV rewards.\n        // ---\n        // Extra rewards:\n        // Calling claim_rewards on the gauge will only claim extra rewards (outside of CRV).\n        // ---\n\n        // Mint CRV on Child Liquidity gauge factory\n        gaugeFactory.mint(address(gauge));\n        // Collect extra gauge rewards (outside of CRV)\n        gauge.claim_rewards();\n\n        _collectRewardTokens();\n    }\n\n    function _lpWithdraw(uint256 _lpAmount) internal {\n        // withdraw lp tokens from the gauge without claiming rewards\n        gauge.withdraw(_lpAmount);\n    }\n\n    /**\n     * @notice Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == address(weth), \"Unsupported asset\");\n\n        // WETH balance needed here for the balance check that happens from vault during depositing.\n        balance = weth.balanceOf(address(this));\n        uint256 lpTokens = gauge.balanceOf(address(this));\n        if (lpTokens > 0) {\n            balance += (lpTokens * curvePool.get_virtual_price()) / 1e18;\n        }\n    }\n\n    /**\n     * @notice Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == address(weth);\n    }\n\n    /***************************************\n                    Approvals\n    ****************************************/\n\n    /**\n     * @notice Sets the maximum slippage allowed for any swap/liquidity operation\n     * @param _maxSlippage Maximum slippage allowed, 1e18 = 100%.\n     */\n    function setMaxSlippage(uint256 _maxSlippage) external onlyGovernor {\n        _setMaxSlippage(_maxSlippage);\n    }\n\n    function _setMaxSlippage(uint256 _maxSlippage) internal {\n        require(_maxSlippage <= 5e16, \"Slippage must be less than 100%\");\n        maxSlippage = _maxSlippage;\n        emit MaxSlippageUpdated(_maxSlippage);\n    }\n\n    /**\n     * @notice Approve the spending of all assets by their corresponding pool tokens,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        _approveBase();\n    }\n\n    /**\n     * @dev Since we are unwrapping WETH before depositing it to Curve\n     *      there is no need to set an approval for WETH on the Curve\n     *      pool\n     * @param _asset Address of the asset\n     * @param _pToken Address of the Curve LP token\n     */\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        override\n    {}\n\n    function _approveBase() internal {\n        // Approve Curve pool for OETH (required for adding liquidity)\n        // slither-disable-next-line unused-return\n        oeth.approve(platformAddress, type(uint256).max);\n\n        // Approve Curve pool for WETH (required for adding liquidity)\n        // slither-disable-next-line unused-return\n        weth.approve(platformAddress, type(uint256).max);\n\n        // Approve Curve gauge contract to transfer Curve pool LP tokens\n        // This is needed for deposits if Curve pool LP tokens into the Curve gauge.\n        // slither-disable-next-line unused-return\n        lpToken.approve(address(gauge), type(uint256).max);\n    }\n\n    /**\n     * @dev Returns the largest of two numbers int256 version\n     */\n    function _max(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n}\n"
    },
    "contracts/strategies/BridgedWOETHStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20, SafeERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { AggregatorV3Interface } from \"../interfaces/chainlink/AggregatorV3Interface.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\n\ncontract BridgedWOETHStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n    using StableMath for uint128;\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n\n    event MaxPriceDiffBpsUpdated(uint128 oldValue, uint128 newValue);\n    event WOETHPriceUpdated(uint128 oldValue, uint128 newValue);\n\n    IWETH9 public immutable weth;\n    IERC20 public immutable bridgedWOETH;\n    IERC20 public immutable oethb;\n\n    uint256 public constant MAX_PRICE_STALENESS = 2 days;\n\n    uint128 public lastOraclePrice;\n    uint128 public maxPriceDiffBps;\n\n    constructor(\n        BaseStrategyConfig memory _stratConfig,\n        address _weth,\n        address _bridgedWOETH,\n        address _oethb\n    ) InitializableAbstractStrategy(_stratConfig) {\n        weth = IWETH9(_weth);\n        bridgedWOETH = IERC20(_bridgedWOETH);\n        oethb = IERC20(_oethb);\n    }\n\n    function initialize(uint128 _maxPriceDiffBps)\n        external\n        onlyGovernor\n        initializer\n    {\n        InitializableAbstractStrategy._initialize(\n            new address[](0), // No reward tokens\n            new address[](0), // No assets\n            new address[](0) // No pTokens\n        );\n\n        _setMaxPriceDiffBps(_maxPriceDiffBps);\n    }\n\n    /**\n     * @dev Sets the max price diff bps for the wOETH value appreciation\n     * @param _maxPriceDiffBps Bps value, 10k == 100%\n     */\n    function setMaxPriceDiffBps(uint128 _maxPriceDiffBps)\n        external\n        onlyGovernor\n    {\n        _setMaxPriceDiffBps(_maxPriceDiffBps);\n    }\n\n    /**\n     * @dev Sets the max price diff bps for the wOETH value appreciation\n     * @param _maxPriceDiffBps Bps value, 10k == 100%\n     */\n    function _setMaxPriceDiffBps(uint128 _maxPriceDiffBps) internal {\n        require(\n            _maxPriceDiffBps > 0 && _maxPriceDiffBps <= 10000,\n            \"Invalid bps value\"\n        );\n\n        emit MaxPriceDiffBpsUpdated(maxPriceDiffBps, _maxPriceDiffBps);\n\n        maxPriceDiffBps = _maxPriceDiffBps;\n    }\n\n    /**\n     * @dev Wrapper for _updateWOETHOraclePrice with nonReentrant flag\n     * @return The latest price of wOETH from Oracle\n     */\n    function updateWOETHOraclePrice() external nonReentrant returns (uint256) {\n        return _updateWOETHOraclePrice();\n    }\n\n    /**\n     * @dev Finds the value of bridged wOETH from the Oracle.\n     *      Ensures that it's within the bounds and reasonable.\n     *      And stores it.\n     *\n     *      NOTE: Intentionally not caching `Vault.priceProvider` here,\n     *      since doing so would mean that we also have to update this\n     *      strategy every time there's a change in oracle router.\n     *      Besides on L2, the gas is considerably cheaper than mainnet.\n     *\n     * @return Latest price from oracle\n     */\n    function _updateWOETHOraclePrice() internal returns (uint256) {\n        // WETH price per unit of bridged wOETH\n        uint256 oraclePrice = IOracle(IVault(vaultAddress).priceProvider())\n            .price(address(bridgedWOETH));\n\n        // 1 wOETH > 1 WETH, always\n        require(oraclePrice > 1 ether, \"Invalid wOETH value\");\n\n        uint128 oraclePrice128 = oraclePrice.toUint128();\n\n        // Do some checks\n        if (lastOraclePrice > 0) {\n            // Make sure the value only goes up\n            require(oraclePrice128 >= lastOraclePrice, \"Negative wOETH yield\");\n\n            // lastOraclePrice * (1 + maxPriceDiffBps)\n            uint256 maxPrice = (lastOraclePrice * (1e4 + maxPriceDiffBps)) /\n                1e4;\n\n            // And that it's within the bounds.\n            require(oraclePrice128 <= maxPrice, \"Price diff beyond threshold\");\n        }\n\n        emit WOETHPriceUpdated(lastOraclePrice, oraclePrice128);\n\n        // Store the price\n        lastOraclePrice = oraclePrice128;\n\n        return oraclePrice;\n    }\n\n    /**\n     * @dev Computes & returns the value of given wOETH in WETH\n     * @param woethAmount Amount of wOETH\n     * @return Value of wOETH in WETH (using the last stored oracle price)\n     */\n    function getBridgedWOETHValue(uint256 woethAmount)\n        public\n        view\n        returns (uint256)\n    {\n        return (woethAmount * lastOraclePrice) / 1 ether;\n    }\n\n    /**\n     * @dev Takes in bridged wOETH and mints & returns\n     *      equivalent amount of OETHb.\n     * @param woethAmount Amount of bridged wOETH to transfer in\n     */\n    function depositBridgedWOETH(uint256 woethAmount)\n        external\n        onlyGovernorOrStrategist\n        nonReentrant\n    {\n        // Update wOETH price\n        uint256 oraclePrice = _updateWOETHOraclePrice();\n\n        // Figure out how much they are worth\n        uint256 oethToMint = (woethAmount * oraclePrice) / 1 ether;\n\n        require(oethToMint > 0, \"Invalid deposit amount\");\n\n        // There's no pToken, however, it just uses WOETH address in the event\n        emit Deposit(address(weth), address(bridgedWOETH), oethToMint);\n\n        // Mint OETHb tokens and transfer it to the caller\n        IVault(vaultAddress).mintForStrategy(oethToMint);\n\n        // Transfer out minted OETHb\n        // slither-disable-next-line unchecked-transfer unused-return\n        oethb.transfer(msg.sender, oethToMint);\n\n        // Transfer in all bridged wOETH tokens\n        // slither-disable-next-line unchecked-transfer unused-return\n        bridgedWOETH.transferFrom(msg.sender, address(this), woethAmount);\n    }\n\n    /**\n     * @dev Takes in OETHb and burns it and returns\n     *      equivalent amount of bridged wOETH.\n     * @param oethToBurn Amount of OETHb to burn\n     */\n    function withdrawBridgedWOETH(uint256 oethToBurn)\n        external\n        onlyGovernorOrStrategist\n        nonReentrant\n    {\n        // Update wOETH price\n        uint256 oraclePrice = _updateWOETHOraclePrice();\n\n        // Figure out how much they are worth\n        uint256 woethAmount = (oethToBurn * 1 ether) / oraclePrice;\n\n        require(woethAmount > 0, \"Invalid withdraw amount\");\n\n        // There's no pToken, however, it just uses WOETH address in the event\n        emit Withdrawal(address(weth), address(bridgedWOETH), oethToBurn);\n\n        // Transfer WOETH back\n        // slither-disable-next-line unchecked-transfer unused-return\n        bridgedWOETH.transfer(msg.sender, woethAmount);\n\n        // Transfer in OETHb\n        // slither-disable-next-line unchecked-transfer unused-return\n        oethb.transferFrom(msg.sender, address(this), oethToBurn);\n\n        // Burn OETHb\n        IVault(vaultAddress).burnForStrategy(oethToBurn);\n    }\n\n    /**\n     * @notice Returns the amount of backing WETH the strategy holds\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == address(weth), \"Unsupported asset\");\n\n        // Figure out how much wOETH is worth at the time.\n        // Always uses the last stored oracle price.\n        // Call updateWOETHOraclePrice manually to pull in latest yields.\n\n        // NOTE: If the contract has been deployed but the call to\n        // `updateWOETHOraclePrice()` has never been made, then this\n        // will return zero. It should be fine because the strategy\n        // should update the price whenever a deposit/withdraw happens.\n\n        // If `updateWOETHOraclePrice()` hasn't been called in a while,\n        // the strategy will underreport its holdings but never overreport it.\n\n        balance =\n            (bridgedWOETH.balanceOf(address(this)) * lastOraclePrice) /\n            1 ether;\n    }\n\n    /**\n     * @notice Check if an asset is supported.\n     * @param _asset    Address of the asset\n     * @return bool     Whether asset is supported\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        // Strategist deposits bridged wOETH but the contract only\n        // reports the balance in WETH. As far as Vault is concerned,\n        // it isn't aware of bridged wOETH token\n        return _asset == address(weth);\n    }\n\n    /***************************************\n               Overridden methods\n    ****************************************/\n    /**\n     * @inheritdoc InitializableAbstractStrategy\n     */\n    function transferToken(address _asset, uint256 _amount)\n        public\n        override\n        onlyGovernor\n    {\n        require(\n            _asset != address(bridgedWOETH) && _asset != address(weth),\n            \"Cannot transfer supported asset\"\n        );\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /**\n     * @notice deposit() function not used for this strategy\n     */\n    function deposit(address, uint256)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        // Use depositBridgedWOETH() instead\n        require(false, \"Deposit disabled\");\n    }\n\n    /**\n     * @notice depositAll() function not used for this strategy\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        // Use depositBridgedWOETH() instead\n        require(false, \"Deposit disabled\");\n    }\n\n    /**\n     * @notice withdraw() function not used for this strategy\n     */\n    function withdraw(\n        // solhint-disable-next-line no-unused-vars\n        address _recipient,\n        // solhint-disable-next-line no-unused-vars\n        address _asset,\n        // solhint-disable-next-line no-unused-vars\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(false, \"Withdrawal disabled\");\n    }\n\n    /**\n     * @notice withdrawAll() function not used for this strategy\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        // Withdrawal disabled\n    }\n\n    function _abstractSetPToken(address, address) internal override {\n        revert(\"No pTokens are used\");\n    }\n\n    function safeApproveAllTokens() external override {}\n\n    /**\n     * @inheritdoc InitializableAbstractStrategy\n     */\n    function removePToken(uint256) external override {\n        revert(\"No pTokens are used\");\n    }\n\n    /**\n     * @inheritdoc InitializableAbstractStrategy\n     */\n    function collectRewardTokens() external override {}\n}\n"
    },
    "contracts/strategies/CompoundStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Compound Strategy\n * @notice Investment strategy for Compound like lending platforms. eg Compound and Flux\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ICERC20 } from \"./ICompound.sol\";\nimport { AbstractCompoundStrategy, InitializableAbstractStrategy } from \"./AbstractCompoundStrategy.sol\";\nimport { IComptroller } from \"../interfaces/IComptroller.sol\";\nimport { IERC20 } from \"../utils/InitializableAbstractStrategy.sol\";\n\ncontract CompoundStrategy is AbstractCompoundStrategy {\n    using SafeERC20 for IERC20;\n    event SkippedWithdrawal(address asset, uint256 amount);\n\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /**\n     * @notice initialize function, to set up initial internal state\n     * @param _rewardTokenAddresses Address of reward token for platform\n     * @param _assets Addresses of initial supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function initialize(\n        address[] memory _rewardTokenAddresses,\n        address[] memory _assets,\n        address[] memory _pTokens\n    ) external onlyGovernor initializer {\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n    }\n\n    /**\n     * @notice Collect accumulated COMP and send to Harvester.\n     */\n    function collectRewardTokens()\n        external\n        virtual\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Claim COMP from Comptroller\n        ICERC20 cToken = _getCTokenFor(assetsMapped[0]);\n        IComptroller comptroller = IComptroller(cToken.comptroller());\n        // Only collect from active cTokens, saves gas\n        address[] memory ctokensToCollect = new address[](assetsMapped.length);\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            ctokensToCollect[i] = address(_getCTokenFor(assetsMapped[i]));\n        }\n        // Claim only for this strategy\n        address[] memory claimers = new address[](1);\n        claimers[0] = address(this);\n        // Claim COMP from Comptroller. Only collect for supply, saves gas\n        comptroller.claimComp(claimers, ctokensToCollect, false, true);\n        // Transfer COMP to Harvester\n        IERC20 rewardToken = IERC20(rewardTokenAddresses[0]);\n        uint256 balance = rewardToken.balanceOf(address(this));\n        emit RewardTokenCollected(\n            harvesterAddress,\n            rewardTokenAddresses[0],\n            balance\n        );\n        rewardToken.safeTransfer(harvesterAddress, balance);\n    }\n\n    /**\n     * @notice Deposit asset into the underlying platform\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of assets to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @dev Deposit an asset into the underlying platform\n     * @param _asset Address of the asset to deposit\n     * @param _amount Amount of assets to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_amount > 0, \"Must deposit something\");\n        ICERC20 cToken = _getCTokenFor(_asset);\n        emit Deposit(_asset, address(cToken), _amount);\n        require(cToken.mint(_amount) == 0, \"cToken mint failed\");\n    }\n\n    /**\n     * @notice Deposit the entire balance of any supported asset in the strategy into the underlying platform\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            IERC20 asset = IERC20(assetsMapped[i]);\n            uint256 assetBalance = asset.balanceOf(address(this));\n            if (assetBalance > 0) {\n                _deposit(address(asset), assetBalance);\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraw an asset from the underlying platform\n     * @param _recipient Address to receive withdrawn assets\n     * @param _asset Address of the asset to withdraw\n     * @param _amount Amount of assets to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        ICERC20 cToken = _getCTokenFor(_asset);\n        // If redeeming 0 cTokens, just skip, else COMP will revert\n        uint256 cTokensToRedeem = _convertUnderlyingToCToken(cToken, _amount);\n        if (cTokensToRedeem == 0) {\n            emit SkippedWithdrawal(_asset, _amount);\n            return;\n        }\n\n        emit Withdrawal(_asset, address(cToken), _amount);\n        require(cToken.redeemUnderlying(_amount) == 0, \"Redeem failed\");\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Internal method to respond to the addition of new asset / cTokens\n     *      We need to approve the cToken and give it permission to spend the asset\n     * @param _asset Address of the asset to approve. eg DAI\n     * @param _pToken The pToken for the approval. eg cDAI or fDAI\n     */\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        override\n    {\n        // Safe approval\n        IERC20(_asset).safeApprove(_pToken, 0);\n        IERC20(_asset).safeApprove(_pToken, type(uint256).max);\n    }\n\n    /**\n     * @notice Remove all supported assets from the underlying platform and send them to Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            IERC20 asset = IERC20(assetsMapped[i]);\n            // Redeem entire balance of cToken\n            ICERC20 cToken = _getCTokenFor(address(asset));\n            uint256 cTokenBalance = cToken.balanceOf(address(this));\n            if (cTokenBalance > 0) {\n                require(cToken.redeem(cTokenBalance) == 0, \"Redeem failed\");\n                uint256 assetBalance = asset.balanceOf(address(this));\n                // Transfer entire balance to Vault\n                asset.safeTransfer(vaultAddress, assetBalance);\n\n                emit Withdrawal(address(asset), address(cToken), assetBalance);\n            }\n        }\n    }\n\n    /**\n     * @notice Get the total asset value held in the underlying platform\n     *      This includes any interest that was generated since depositing.\n     *      The exchange rate between the cToken and asset gradually increases,\n     *      causing the cToken to be worth more corresponding asset.\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        // Balance is always with token cToken decimals\n        ICERC20 cToken = _getCTokenFor(_asset);\n        balance = _checkBalance(cToken);\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     *      underlying = (cTokenAmt * exchangeRate) / 1e18\n     * @param _cToken     cToken for which to check balance\n     * @return balance    Total value of the asset in the platform\n     */\n    function _checkBalance(ICERC20 _cToken)\n        internal\n        view\n        returns (uint256 balance)\n    {\n        // e.g. 50e8*205316390724364402565641705 / 1e18 = 1.0265..e18\n        balance =\n            (_cToken.balanceOf(address(this)) * _cToken.exchangeRateStored()) /\n            1e18;\n    }\n\n    /**\n     * @notice Approve the spending of all assets by their corresponding cToken,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens() external override {\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            IERC20 asset = IERC20(assetsMapped[i]);\n            address cToken = assetToPToken[address(asset)];\n            // Safe approval\n            asset.safeApprove(cToken, 0);\n            asset.safeApprove(cToken, type(uint256).max);\n        }\n    }\n}\n"
    },
    "contracts/strategies/ConvexEthMetaStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Convex Automated Market Maker (AMO) Strategy\n * @notice AMO strategy for the Curve OETH/ETH pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { ICurveETHPoolV1 } from \"./ICurveETHPoolV1.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { IConvexDeposits } from \"./IConvexDeposits.sol\";\nimport { IRewardStaking } from \"./IRewardStaking.sol\";\n\ncontract ConvexEthMetaStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant MAX_SLIPPAGE = 1e16; // 1%, same as the Curve UI\n    address public constant ETH_ADDRESS =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    // The following slots have been deprecated with immutable variables\n    // slither-disable-next-line constable-states\n    address private _deprecated_cvxDepositorAddress;\n    // slither-disable-next-line constable-states\n    address private _deprecated_cvxRewardStaker;\n    // slither-disable-next-line constable-states\n    uint256 private _deprecated_cvxDepositorPTokenId;\n    // slither-disable-next-line constable-states\n    address private _deprecated_curvePool;\n    // slither-disable-next-line constable-states\n    address private _deprecated_lpToken;\n    // slither-disable-next-line constable-states\n    address private _deprecated_oeth;\n    // slither-disable-next-line constable-states\n    address private _deprecated_weth;\n\n    // Ordered list of pool assets\n    // slither-disable-next-line constable-states\n    uint128 private _deprecated_oethCoinIndex;\n    // slither-disable-next-line constable-states\n    uint128 private _deprecated_ethCoinIndex;\n\n    // New immutable variables that must be set in the constructor\n    address public immutable cvxDepositorAddress;\n    IRewardStaking public immutable cvxRewardStaker;\n    uint256 public immutable cvxDepositorPTokenId;\n    ICurveETHPoolV1 public immutable curvePool;\n    IERC20 public immutable lpToken;\n    IERC20 public immutable oeth;\n    IWETH9 public immutable weth;\n\n    // Ordered list of pool assets\n    uint128 public constant oethCoinIndex = 1;\n    uint128 public constant ethCoinIndex = 0;\n\n    /**\n     * @dev Verifies that the caller is the Strategist.\n     */\n    modifier onlyStrategist() {\n        require(\n            msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Strategist\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Checks the Curve pool's balances have improved and the balances\n     * have not tipped to the other side.\n     * This modifier only works on functions that do a single sided add or remove.\n     * The standard deposit function adds to both sides of the pool in a way that\n     * the pool's balance is not worsened.\n     * Withdrawals are proportional so doesn't change the pools asset balance.\n     */\n    modifier improvePoolBalance() {\n        // Get the asset and OToken balances in the Curve pool\n        uint256[2] memory balancesBefore = curvePool.get_balances();\n        // diff = ETH balance - OETH balance\n        int256 diffBefore = int256(balancesBefore[ethCoinIndex]) -\n            int256(balancesBefore[oethCoinIndex]);\n\n        _;\n\n        // Get the asset and OToken balances in the Curve pool\n        uint256[2] memory balancesAfter = curvePool.get_balances();\n        // diff = ETH balance - OETH balance\n        int256 diffAfter = int256(balancesAfter[ethCoinIndex]) -\n            int256(balancesAfter[oethCoinIndex]);\n\n        if (diffBefore <= 0) {\n            // If the pool was originally imbalanced in favor of OETH, then\n            // we want to check that the pool is now more balanced\n            require(diffAfter <= 0, \"OTokens overshot peg\");\n            require(diffBefore < diffAfter, \"OTokens balance worse\");\n        }\n        if (diffBefore >= 0) {\n            // If the pool was originally imbalanced in favor of ETH, then\n            // we want to check that the pool is now more balanced\n            require(diffAfter >= 0, \"Assets overshot peg\");\n            require(diffAfter < diffBefore, \"Assets balance worse\");\n        }\n    }\n\n    // Used to circumvent the stack too deep issue\n    struct ConvexEthMetaConfig {\n        address cvxDepositorAddress; //Address of the Convex depositor(AKA booster) for this pool\n        address cvxRewardStakerAddress; //Address of the CVX rewards staker\n        uint256 cvxDepositorPTokenId; //Pid of the pool referred to by Depositor and staker\n        address oethAddress; //Address of OETH token\n        address wethAddress; //Address of WETH\n    }\n\n    constructor(\n        BaseStrategyConfig memory _baseConfig,\n        ConvexEthMetaConfig memory _convexConfig\n    ) InitializableAbstractStrategy(_baseConfig) {\n        lpToken = IERC20(_baseConfig.platformAddress);\n        curvePool = ICurveETHPoolV1(_baseConfig.platformAddress);\n\n        cvxDepositorAddress = _convexConfig.cvxDepositorAddress;\n        cvxRewardStaker = IRewardStaking(_convexConfig.cvxRewardStakerAddress);\n        cvxDepositorPTokenId = _convexConfig.cvxDepositorPTokenId;\n        oeth = IERC20(_convexConfig.oethAddress);\n        weth = IWETH9(_convexConfig.wethAddress);\n    }\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Curve strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Address of CRV & CVX\n     * @param _assets Addresses of supported assets. eg WETH\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // CRV + CVX\n        address[] calldata _assets // WETH\n    ) external onlyGovernor initializer {\n        require(_assets.length == 1, \"Must have exactly one asset\");\n        require(_assets[0] == address(weth), \"Asset not WETH\");\n\n        address[] memory pTokens = new address[](1);\n        pTokens[0] = address(curvePool);\n\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            pTokens\n        );\n\n        _approveBase();\n    }\n\n    /***************************************\n                    Deposit\n    ****************************************/\n\n    /**\n     * @notice Deposit WETH into the Curve pool\n     * @param _weth Address of Wrapped ETH (WETH) contract.\n     * @param _amount Amount of WETH to deposit.\n     */\n    function deposit(address _weth, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_weth, _amount);\n    }\n\n    function _deposit(address _weth, uint256 _wethAmount) internal {\n        require(_wethAmount > 0, \"Must deposit something\");\n        require(_weth == address(weth), \"Can only deposit WETH\");\n        weth.withdraw(_wethAmount);\n\n        emit Deposit(_weth, address(lpToken), _wethAmount);\n\n        // Get the asset and OToken balances in the Curve pool\n        uint256[2] memory balances = curvePool.get_balances();\n        // safe to cast since min value is at least 0\n        uint256 oethToAdd = uint256(\n            _max(\n                0,\n                int256(balances[ethCoinIndex]) +\n                    int256(_wethAmount) -\n                    int256(balances[oethCoinIndex])\n            )\n        );\n\n        /* Add so much OETH so that the pool ends up being balanced. And at minimum\n         * add as much OETH as WETH and at maximum twice as much OETH.\n         */\n        oethToAdd = Math.max(oethToAdd, _wethAmount);\n        oethToAdd = Math.min(oethToAdd, _wethAmount * 2);\n\n        /* Mint OETH with a strategy that attempts to contribute to stability of OETH/WETH pool. Try\n         * to mint so much OETH that after deployment of liquidity pool ends up being balanced.\n         *\n         * To manage unpredictability minimal OETH minted will always be at least equal or greater\n         * to WETH amount deployed. And never larger than twice the WETH amount deployed even if\n         * it would have a further beneficial effect on pool stability.\n         */\n        IVault(vaultAddress).mintForStrategy(oethToAdd);\n\n        emit Deposit(address(oeth), address(lpToken), oethToAdd);\n\n        uint256[2] memory _amounts;\n        _amounts[ethCoinIndex] = _wethAmount;\n        _amounts[oethCoinIndex] = oethToAdd;\n\n        uint256 valueInLpTokens = (_wethAmount + oethToAdd).divPrecisely(\n            curvePool.get_virtual_price()\n        );\n        uint256 minMintAmount = valueInLpTokens.mulTruncate(\n            uint256(1e18) - MAX_SLIPPAGE\n        );\n\n        // Do the deposit to the Curve pool\n        // slither-disable-next-line arbitrary-send\n        uint256 lpDeposited = curvePool.add_liquidity{ value: _wethAmount }(\n            _amounts,\n            minMintAmount\n        );\n\n        // Deposit the Curve pool's LP tokens into the Convex rewards pool\n        require(\n            IConvexDeposits(cvxDepositorAddress).deposit(\n                cvxDepositorPTokenId,\n                lpDeposited,\n                true // Deposit with staking\n            ),\n            \"Depositing LP to Convex not successful\"\n        );\n    }\n\n    /**\n     * @notice Deposit the strategy's entire balance of WETH into the Curve pool\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 balance = weth.balanceOf(address(this));\n        if (balance > 0) {\n            _deposit(address(weth), balance);\n        }\n    }\n\n    /***************************************\n                    Withdraw\n    ****************************************/\n\n    /**\n     * @notice Withdraw ETH and OETH from the Curve pool, burn the OETH,\n     * convert the ETH to WETH and transfer to the recipient.\n     * @param _recipient Address to receive withdrawn asset which is normally the Vault.\n     * @param _weth Address of the Wrapped ETH (WETH) contract.\n     * @param _amount Amount of WETH to withdraw.\n     */\n    function withdraw(\n        address _recipient,\n        address _weth,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_amount > 0, \"Invalid amount\");\n        require(_weth == address(weth), \"Can only withdraw WETH\");\n\n        emit Withdrawal(_weth, address(lpToken), _amount);\n\n        uint256 requiredLpTokens = calcTokenToBurn(_amount);\n\n        _lpWithdraw(requiredLpTokens);\n\n        /* math in requiredLpTokens should correctly calculate the amount of LP to remove\n         * in that the strategy receives enough WETH on balanced removal\n         */\n        uint256[2] memory _minWithdrawalAmounts = [uint256(0), uint256(0)];\n        _minWithdrawalAmounts[ethCoinIndex] = _amount;\n        // slither-disable-next-line unused-return\n        curvePool.remove_liquidity(requiredLpTokens, _minWithdrawalAmounts);\n\n        // Burn all the removed OETH and any that was left in the strategy\n        uint256 oethToBurn = oeth.balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(oethToBurn);\n\n        emit Withdrawal(address(oeth), address(lpToken), oethToBurn);\n\n        // Transfer WETH to the recipient\n        weth.deposit{ value: _amount }();\n        require(\n            weth.transfer(_recipient, _amount),\n            \"Transfer of WETH not successful\"\n        );\n    }\n\n    function calcTokenToBurn(uint256 _wethAmount)\n        internal\n        view\n        returns (uint256 lpToBurn)\n    {\n        /* The rate between coins in the pool determines the rate at which pool returns\n         * tokens when doing balanced removal (remove_liquidity call). And by knowing how much WETH\n         * we want we can determine how much of OETH we receive by removing liquidity.\n         *\n         * Because we are doing balanced removal we should be making profit when removing liquidity in a\n         * pool tilted to either side.\n         *\n         * Important: A downside is that the Strategist / Governor needs to be\n         * cognisant of not removing too much liquidity. And while the proposal to remove liquidity\n         * is being voted on the pool tilt might change so much that the proposal that has been valid while\n         * created is no longer valid.\n         */\n\n        uint256 poolWETHBalance = curvePool.balances(ethCoinIndex);\n        /* K is multiplied by 1e36 which is used for higher precision calculation of required\n         * pool LP tokens. Without it the end value can have rounding errors up to precision of\n         * 10 digits. This way we move the decimal point by 36 places when doing the calculation\n         * and again by 36 places when we are done with it.\n         */\n        uint256 k = (1e36 * lpToken.totalSupply()) / poolWETHBalance;\n        // prettier-ignore\n        // slither-disable-next-line divide-before-multiply\n        uint256 diff = (_wethAmount + 1) * k;\n        lpToBurn = diff / 1e36;\n    }\n\n    /**\n     * @notice Remove all ETH and OETH from the Curve pool, burn the OETH,\n     * convert the ETH to WETH and transfer to the Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        uint256 gaugeTokens = cvxRewardStaker.balanceOf(address(this));\n        _lpWithdraw(gaugeTokens);\n\n        // Withdraws are proportional to assets held by 3Pool\n        uint256[2] memory minWithdrawAmounts = [uint256(0), uint256(0)];\n\n        // Remove liquidity\n        // slither-disable-next-line unused-return\n        curvePool.remove_liquidity(\n            lpToken.balanceOf(address(this)),\n            minWithdrawAmounts\n        );\n\n        // Burn all OETH\n        uint256 oethToBurn = oeth.balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(oethToBurn);\n\n        // Get the strategy contract's ether balance.\n        // This includes all that was removed from the Curve pool and\n        // any ether that was sitting in the strategy contract before the removal.\n        uint256 ethBalance = address(this).balance;\n        // Convert all the strategy contract's ether to WETH and transfer to the vault.\n        weth.deposit{ value: ethBalance }();\n        require(\n            weth.transfer(vaultAddress, ethBalance),\n            \"Transfer of WETH not successful\"\n        );\n\n        emit Withdrawal(address(weth), address(lpToken), ethBalance);\n        emit Withdrawal(address(oeth), address(lpToken), oethToBurn);\n    }\n\n    /***************************************\n            Curve pool Rebalancing\n    ****************************************/\n\n    /**\n     * @notice Mint OTokens and one-sided add to the Curve pool.\n     * This is used when the Curve pool does not have enough OTokens and too many ETH.\n     * The OToken/Asset, eg OETH/ETH, price with increase.\n     * The amount of assets in the vault is unchanged.\n     * The total supply of OTokens is increased.\n     * The asset value of the strategy and vault is increased.\n     * @param _oTokens The amount of OTokens to be minted and added to the pool.\n     */\n    function mintAndAddOTokens(uint256 _oTokens)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n    {\n        IVault(vaultAddress).mintForStrategy(_oTokens);\n\n        uint256[2] memory amounts = [uint256(0), uint256(0)];\n        amounts[oethCoinIndex] = _oTokens;\n\n        // Convert OETH to Curve pool LP tokens\n        uint256 valueInLpTokens = (_oTokens).divPrecisely(\n            curvePool.get_virtual_price()\n        );\n        // Apply slippage to LP tokens\n        uint256 minMintAmount = valueInLpTokens.mulTruncate(\n            uint256(1e18) - MAX_SLIPPAGE\n        );\n\n        // Add the minted OTokens to the Curve pool\n        uint256 lpDeposited = curvePool.add_liquidity(amounts, minMintAmount);\n\n        // Deposit the Curve pool LP tokens to the Convex rewards pool\n        require(\n            IConvexDeposits(cvxDepositorAddress).deposit(\n                cvxDepositorPTokenId,\n                lpDeposited,\n                true // Deposit with staking\n            ),\n            \"Failed to Deposit LP to Convex\"\n        );\n\n        emit Deposit(address(oeth), address(lpToken), _oTokens);\n    }\n\n    /**\n     * @notice One-sided remove of OTokens from the Curve pool which are then burned.\n     * This is used when the Curve pool has too many OTokens and not enough ETH.\n     * The amount of assets in the vault is unchanged.\n     * The total supply of OTokens is reduced.\n     * The asset value of the strategy and vault is reduced.\n     * @param _lpTokens The amount of Curve pool LP tokens to be burned for OTokens.\n     */\n    function removeAndBurnOTokens(uint256 _lpTokens)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n    {\n        // Withdraw Curve pool LP tokens from Convex and remove OTokens from the Curve pool\n        uint256 oethToBurn = _withdrawAndRemoveFromPool(\n            _lpTokens,\n            oethCoinIndex\n        );\n\n        // The vault burns the OTokens from this strategy\n        IVault(vaultAddress).burnForStrategy(oethToBurn);\n\n        emit Withdrawal(address(oeth), address(lpToken), oethToBurn);\n    }\n\n    /**\n     * @notice One-sided remove of ETH from the Curve pool, convert to WETH\n     * and transfer to the vault.\n     * This is used when the Curve pool does not have enough OTokens and too many ETH.\n     * The OToken/Asset, eg OETH/ETH, price with decrease.\n     * The amount of assets in the vault increases.\n     * The total supply of OTokens does not change.\n     * The asset value of the strategy reduces.\n     * The asset value of the vault should be close to the same.\n     * @param _lpTokens The amount of Curve pool LP tokens to be burned for ETH.\n     * @dev Curve pool LP tokens is used rather than WETH assets as Curve does not\n     * have a way to accurately calculate the amount of LP tokens for a required\n     * amount of ETH. Curve's `calc_token_amount` functioun does not include fees.\n     * A 3rd party libary can be used that takes into account the fees, but this\n     * is a gas intensive process. It's easier for the trusted strategist to\n     * caclulate the amount of Curve pool LP tokens required off-chain.\n     */\n    function removeOnlyAssets(uint256 _lpTokens)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n    {\n        // Withdraw Curve pool LP tokens from Convex and remove ETH from the Curve pool\n        uint256 ethAmount = _withdrawAndRemoveFromPool(_lpTokens, ethCoinIndex);\n\n        // Convert ETH to WETH and transfer to the vault\n        weth.deposit{ value: ethAmount }();\n        require(\n            weth.transfer(vaultAddress, ethAmount),\n            \"Transfer of WETH not successful\"\n        );\n\n        emit Withdrawal(address(weth), address(lpToken), ethAmount);\n    }\n\n    /**\n     * @dev Remove Curve pool LP tokens from the Convex pool and\n     * do a one-sided remove of ETH or OETH from the Curve pool.\n     * @param _lpTokens The amount of Curve pool LP tokens to be removed from the Convex pool.\n     * @param coinIndex The index of the coin to be removed from the Curve pool. 0 = ETH, 1 = OETH.\n     * @return coinsRemoved The amount of ETH or OETH removed from the Curve pool.\n     */\n    function _withdrawAndRemoveFromPool(uint256 _lpTokens, uint128 coinIndex)\n        internal\n        returns (uint256 coinsRemoved)\n    {\n        // Withdraw Curve pool LP tokens from Convex pool\n        _lpWithdraw(_lpTokens);\n\n        // Convert Curve pool LP tokens to ETH value\n        uint256 valueInEth = _lpTokens.mulTruncate(\n            curvePool.get_virtual_price()\n        );\n        // Apply slippage to ETH value\n        uint256 minAmount = valueInEth.mulTruncate(\n            uint256(1e18) - MAX_SLIPPAGE\n        );\n\n        // Remove just the ETH from the Curve pool\n        coinsRemoved = curvePool.remove_liquidity_one_coin(\n            _lpTokens,\n            int128(coinIndex),\n            minAmount,\n            address(this)\n        );\n    }\n\n    /***************************************\n                Assets and Rewards\n    ****************************************/\n\n    /**\n     * @notice Collect accumulated CRV and CVX rewards and send to the Harvester.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Collect CRV and CVX\n        cvxRewardStaker.getReward();\n        _collectRewardTokens();\n    }\n\n    function _lpWithdraw(uint256 _wethAmount) internal {\n        // withdraw and unwrap with claim takes back the lpTokens\n        // and also collects the rewards for deposit\n        cvxRewardStaker.withdrawAndUnwrap(_wethAmount, true);\n    }\n\n    /**\n     * @notice Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == address(weth), \"Unsupported asset\");\n\n        // Eth balance needed here for the balance check that happens from vault during depositing.\n        balance = address(this).balance;\n        uint256 lpTokens = cvxRewardStaker.balanceOf(address(this));\n        if (lpTokens > 0) {\n            balance += (lpTokens * curvePool.get_virtual_price()) / 1e18;\n        }\n    }\n\n    /**\n     * @notice Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == address(weth);\n    }\n\n    /***************************************\n                    Approvals\n    ****************************************/\n\n    /**\n     * @notice Approve the spending of all assets by their corresponding pool tokens,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        _approveBase();\n    }\n\n    /**\n     * @notice Accept unwrapped WETH\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Since we are unwrapping WETH before depositing it to Curve\n     *      there is no need to set an approval for WETH on the Curve\n     *      pool\n     * @param _asset Address of the asset\n     * @param _pToken Address of the Curve LP token\n     */\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        override\n    {}\n\n    function _approveBase() internal {\n        // Approve Curve pool for OETH (required for adding liquidity)\n        // No approval is needed for ETH\n        // slither-disable-next-line unused-return\n        oeth.approve(platformAddress, type(uint256).max);\n\n        // Approve Convex deposit contract to transfer Curve pool LP tokens\n        // This is needed for deposits if Curve pool LP tokens into the Convex rewards pool\n        // slither-disable-next-line unused-return\n        lpToken.approve(cvxDepositorAddress, type(uint256).max);\n    }\n\n    /**\n     * @dev Returns the largest of two numbers int256 version\n     */\n    function _max(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n}\n"
    },
    "contracts/strategies/ConvexGeneralizedMetaStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Curve Convex Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport { IRewardStaking } from \"./IRewardStaking.sol\";\nimport { IConvexDeposits } from \"./IConvexDeposits.sol\";\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"./AbstractCurveStrategy.sol\";\nimport { AbstractConvexMetaStrategy } from \"./AbstractConvexMetaStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\ncontract ConvexGeneralizedMetaStrategy is AbstractConvexMetaStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /* Take 3pool LP and deposit it to metapool. Take the LP from metapool\n     * and deposit them to Convex.\n     */\n    function _lpDepositAll() internal override {\n        IERC20 threePoolLp = IERC20(pTokenAddress);\n        ICurvePool curvePool = ICurvePool(platformAddress);\n\n        uint256 threePoolLpBalance = threePoolLp.balanceOf(address(this));\n        uint256 curve3PoolVirtualPrice = curvePool.get_virtual_price();\n        uint256 threePoolLpDollarValue = threePoolLpBalance.mulTruncate(\n            curve3PoolVirtualPrice\n        );\n\n        uint256[2] memory _amounts = [0, threePoolLpBalance];\n\n        uint256 metapoolVirtualPrice = metapool.get_virtual_price();\n        /**\n         * First convert all the deposited tokens to dollar values,\n         * then divide by virtual price to convert to metapool LP tokens\n         * and apply the max slippage\n         */\n        uint256 minReceived = threePoolLpDollarValue\n            .divPrecisely(metapoolVirtualPrice)\n            .mulTruncate(uint256(1e18) - MAX_SLIPPAGE);\n\n        uint256 metapoolLp = metapool.add_liquidity(_amounts, minReceived);\n\n        bool success = IConvexDeposits(cvxDepositorAddress).deposit(\n            cvxDepositorPTokenId,\n            metapoolLp,\n            true // Deposit with staking\n        );\n\n        require(success, \"Failed to deposit to Convex\");\n    }\n\n    /**\n     * Withdraw the specified amount of tokens from the gauge. And use all the resulting tokens\n     * to remove liquidity from metapool\n     * @param num3CrvTokens Number of Convex 3pool LP tokens to withdraw from metapool\n     */\n    function _lpWithdraw(uint256 num3CrvTokens) internal override {\n        uint256 gaugeTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n\n        uint256 requiredMetapoolLpTokens = _calcCurveMetaTokenAmount(\n            crvCoinIndex,\n            num3CrvTokens\n        );\n\n        require(\n            requiredMetapoolLpTokens <= gaugeTokens,\n            string(\n                bytes.concat(\n                    bytes(\"Attempting to withdraw \"),\n                    bytes(Strings.toString(requiredMetapoolLpTokens)),\n                    bytes(\", metapoolLP but only \"),\n                    bytes(Strings.toString(gaugeTokens)),\n                    bytes(\" available.\")\n                )\n            )\n        );\n\n        // withdraw and unwrap with claim takes back the lpTokens and also collects the rewards for deposit\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            requiredMetapoolLpTokens,\n            true\n        );\n\n        if (requiredMetapoolLpTokens > 0) {\n            // slither-disable-next-line unused-return\n            metapool.remove_liquidity_one_coin(\n                requiredMetapoolLpTokens,\n                int128(crvCoinIndex),\n                num3CrvTokens\n            );\n        }\n    }\n\n    function _lpWithdrawAll() internal override {\n        uint256 gaugeTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            gaugeTokens,\n            true\n        );\n\n        if (gaugeTokens > 0) {\n            uint256 burnDollarAmount = gaugeTokens.mulTruncate(\n                metapool.get_virtual_price()\n            );\n            uint256 curve3PoolExpected = burnDollarAmount.divPrecisely(\n                ICurvePool(platformAddress).get_virtual_price()\n            );\n\n            // Always withdraw all of the available metapool LP tokens (similar to how we always deposit all)\n            // slither-disable-next-line unused-return\n            metapool.remove_liquidity_one_coin(\n                gaugeTokens,\n                int128(crvCoinIndex),\n                curve3PoolExpected -\n                    curve3PoolExpected.mulTruncate(maxWithdrawalSlippage)\n            );\n        }\n    }\n}\n"
    },
    "contracts/strategies/ConvexOUSDMetaStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Curve Convex Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { IRewardStaking } from \"./IRewardStaking.sol\";\nimport { IConvexDeposits } from \"./IConvexDeposits.sol\";\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"./AbstractCurveStrategy.sol\";\nimport { AbstractConvexMetaStrategy } from \"./AbstractConvexMetaStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract ConvexOUSDMetaStrategy is AbstractConvexMetaStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /* Take 3pool LP and mint the corresponding amount of ousd. Deposit and stake that to\n     * ousd Curve Metapool. Take the LP from metapool and deposit them to Convex.\n     */\n    function _lpDepositAll() internal override {\n        ICurvePool curvePool = ICurvePool(platformAddress);\n\n        uint256 threePoolLpBalance = IERC20(pTokenAddress).balanceOf(\n            address(this)\n        );\n        uint256 curve3PoolVirtualPrice = curvePool.get_virtual_price();\n        uint256 threePoolLpDollarValue = threePoolLpBalance.mulTruncate(\n            curve3PoolVirtualPrice\n        );\n\n        // safe to cast since min value is at least 0\n        uint256 ousdToAdd = uint256(\n            _max(\n                0,\n                int256(\n                    metapool.balances(crvCoinIndex).mulTruncate(\n                        curve3PoolVirtualPrice\n                    )\n                ) -\n                    int256(metapool.balances(mainCoinIndex)) +\n                    int256(threePoolLpDollarValue)\n            )\n        );\n\n        /* Add so much OUSD so that the pool ends up being balanced. And at minimum\n         * add twice as much OUSD as 3poolLP and at maximum at twice as\n         * much OUSD.\n         */\n        ousdToAdd = Math.max(ousdToAdd, threePoolLpDollarValue);\n        ousdToAdd = Math.min(ousdToAdd, threePoolLpDollarValue * 2);\n\n        /* Mint OUSD with a strategy that attempts to contribute to stability of OUSD metapool. Try\n         * to mint so much OUSD that after deployment of liquidity pool ends up being balanced.\n         *\n         * To manage unpredictability minimal OUSD minted will always be at least equal or greater\n         * to stablecoin(DAI, USDC, USDT) amount of 3CRVLP deployed. And never larger than twice the\n         * stablecoin amount of 3CRVLP deployed even if it would have a further beneficial effect\n         * on pool stability.\n         */\n        if (ousdToAdd > 0) {\n            IVault(vaultAddress).mintForStrategy(ousdToAdd);\n        }\n\n        uint256[2] memory _amounts = [ousdToAdd, threePoolLpBalance];\n\n        uint256 metapoolVirtualPrice = metapool.get_virtual_price();\n        /**\n         * First convert all the deposited tokens to dollar values,\n         * then divide by virtual price to convert to metapool LP tokens\n         * and apply the max slippage\n         */\n        uint256 minReceived = (ousdToAdd + threePoolLpDollarValue)\n            .divPrecisely(metapoolVirtualPrice)\n            .mulTruncate(uint256(1e18) - MAX_SLIPPAGE);\n\n        uint256 metapoolLp = metapool.add_liquidity(_amounts, minReceived);\n\n        bool success = IConvexDeposits(cvxDepositorAddress).deposit(\n            cvxDepositorPTokenId,\n            metapoolLp,\n            true // Deposit with staking\n        );\n\n        require(success, \"Failed to deposit to Convex\");\n    }\n\n    /**\n     * Withdraw the specified amount of tokens from the gauge. And use all the resulting tokens\n     * to remove liquidity from metapool\n     * @param num3CrvTokens Number of 3CRV tokens to withdraw from metapool\n     */\n    function _lpWithdraw(uint256 num3CrvTokens) internal override {\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        /* The rate between coins in the metapool determines the rate at which metapool returns\n         * tokens when doing balanced removal (remove_liquidity call). And by knowing how much 3crvLp\n         * we want we can determine how much of OUSD we receive by removing liquidity.\n         *\n         * Because we are doing balanced removal we should be making profit when removing liquidity in a\n         * pool tilted to either side.\n         *\n         * Important: A downside is that the Strategist / Governor needs to be\n         * cognisant of not removing too much liquidity. And while the proposal to remove liquidity\n         * is being voted on the pool tilt might change so much that the proposal that has been valid while\n         * created is no longer valid.\n         */\n\n        uint256 crvPoolBalance = metapool.balances(crvCoinIndex);\n        /* K is multiplied by 1e36 which is used for higher precision calculation of required\n         * metapool LP tokens. Without it the end value can have rounding errors up to precision of\n         * 10 digits. This way we move the decimal point by 36 places when doing the calculation\n         * and again by 36 places when we are done with it.\n         */\n        uint256 k = (1e36 * metapoolLPToken.totalSupply()) / crvPoolBalance;\n        // simplifying below to: `uint256 diff = (num3CrvTokens - 1) * k` causes loss of precision\n        // prettier-ignore\n        // slither-disable-next-line divide-before-multiply\n        uint256 diff = crvPoolBalance * k -\n            (crvPoolBalance - num3CrvTokens - 1) * k;\n        uint256 lpToBurn = diff / 1e36;\n\n        uint256 gaugeTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n\n        require(\n            lpToBurn <= gaugeTokens,\n            string(\n                bytes.concat(\n                    bytes(\"Attempting to withdraw \"),\n                    bytes(Strings.toString(lpToBurn)),\n                    bytes(\", metapoolLP but only \"),\n                    bytes(Strings.toString(gaugeTokens)),\n                    bytes(\" available.\")\n                )\n            )\n        );\n\n        // withdraw and unwrap with claim takes back the lpTokens and also collects the rewards for deposit\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            lpToBurn,\n            true\n        );\n\n        // calculate the min amount of OUSD expected for the specified amount of LP tokens\n        uint256 minOUSDAmount = lpToBurn.mulTruncate(\n            metapool.get_virtual_price()\n        ) -\n            num3CrvTokens.mulTruncate(curvePool.get_virtual_price()) -\n            1;\n\n        // withdraw the liquidity from metapool\n        uint256[2] memory _removedAmounts = metapool.remove_liquidity(\n            lpToBurn,\n            [minOUSDAmount, num3CrvTokens]\n        );\n\n        IVault(vaultAddress).burnForStrategy(_removedAmounts[mainCoinIndex]);\n    }\n\n    function _lpWithdrawAll() internal override {\n        IERC20 metapoolErc20 = IERC20(address(metapool));\n        uint256 gaugeTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            gaugeTokens,\n            true\n        );\n\n        uint256[2] memory _minAmounts = [uint256(0), uint256(0)];\n        uint256[2] memory _removedAmounts = metapool.remove_liquidity(\n            metapoolErc20.balanceOf(address(this)),\n            _minAmounts\n        );\n\n        IVault(vaultAddress).burnForStrategy(_removedAmounts[mainCoinIndex]);\n    }\n}\n"
    },
    "contracts/strategies/ConvexStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Curve Convex Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { IRewardStaking } from \"./IRewardStaking.sol\";\nimport { IConvexDeposits } from \"./IConvexDeposits.sol\";\nimport { IERC20, AbstractCurveStrategy, InitializableAbstractStrategy } from \"./AbstractCurveStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\n\n/*\n * IMPORTANT(!) If ConvexStrategy needs to be re-deployed, it requires new\n * proxy contract with fresh storage slots. Changes in `AbstractCurveStrategy`\n * storage slots would break existing implementation.\n *\n * Remove this notice if ConvexStrategy is re-deployed\n */\ncontract ConvexStrategy is AbstractCurveStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address internal cvxDepositorAddress;\n    address internal cvxRewardStakerAddress;\n    // slither-disable-next-line constable-states\n    address private _deprecated_cvxRewardTokenAddress;\n    uint256 internal cvxDepositorPTokenId;\n\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Curve strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Address of CRV & CVX\n     * @param _assets Addresses of supported assets. MUST be passed in the same\n     *                order as returned by coins on the pool contract, i.e.\n     *                DAI, USDC, USDT\n     * @param _pTokens Platform Token corresponding addresses\n     * @param _cvxDepositorAddress Address of the Convex depositor(AKA booster) for this pool\n     * @param _cvxRewardStakerAddress Address of the CVX rewards staker\n     * @param _cvxDepositorPTokenId Pid of the pool referred to by Depositor and staker\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // CRV + CVX\n        address[] calldata _assets,\n        address[] calldata _pTokens,\n        address _cvxDepositorAddress,\n        address _cvxRewardStakerAddress,\n        uint256 _cvxDepositorPTokenId\n    ) external onlyGovernor initializer {\n        require(_assets.length == 3, \"Must have exactly three assets\");\n        // Should be set prior to abstract initialize call otherwise\n        // abstractSetPToken calls will fail\n        cvxDepositorAddress = _cvxDepositorAddress;\n        cvxRewardStakerAddress = _cvxRewardStakerAddress;\n        cvxDepositorPTokenId = _cvxDepositorPTokenId;\n        pTokenAddress = _pTokens[0];\n\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n        _approveBase();\n    }\n\n    function _lpDepositAll() internal override {\n        IERC20 pToken = IERC20(pTokenAddress);\n        // Deposit with staking\n        bool success = IConvexDeposits(cvxDepositorAddress).deposit(\n            cvxDepositorPTokenId,\n            pToken.balanceOf(address(this)),\n            true\n        );\n        require(success, \"Failed to deposit to Convex\");\n    }\n\n    function _lpWithdraw(uint256 numCrvTokens) internal override {\n        uint256 gaugePTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n\n        // Not enough in this contract or in the Gauge, can't proceed\n        require(numCrvTokens > gaugePTokens, \"Insufficient 3CRV balance\");\n\n        // withdraw and unwrap with claim takes back the lpTokens and also collects the rewards to this\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            numCrvTokens,\n            true\n        );\n    }\n\n    function _lpWithdrawAll() internal override {\n        // withdraw and unwrap with claim takes back the lpTokens and also collects the rewards to this\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            IRewardStaking(cvxRewardStakerAddress).balanceOf(address(this)),\n            true\n        );\n    }\n\n    function _approveBase() internal override {\n        IERC20 pToken = IERC20(pTokenAddress);\n        // 3Pool for LP token (required for removing liquidity)\n        pToken.safeApprove(platformAddress, 0);\n        pToken.safeApprove(platformAddress, type(uint256).max);\n        // Gauge for LP token\n        pToken.safeApprove(cvxDepositorAddress, 0);\n        pToken.safeApprove(cvxDepositorAddress, type(uint256).max);\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(assetToPToken[_asset] != address(0), \"Unsupported asset\");\n        // LP tokens in this contract. This should generally be nothing as we\n        // should always stake the full balance in the Gauge, but include for\n        // safety\n        uint256 contractPTokens = IERC20(pTokenAddress).balanceOf(\n            address(this)\n        );\n        uint256 gaugePTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n        uint256 totalPTokens = contractPTokens + gaugePTokens;\n\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        if (totalPTokens > 0) {\n            uint256 virtual_price = curvePool.get_virtual_price();\n            uint256 value = (totalPTokens * virtual_price) / 1e18;\n            uint256 assetDecimals = Helpers.getDecimals(_asset);\n            balance = value.scaleBy(assetDecimals, 18) / 3;\n        }\n    }\n\n    /**\n     * @dev Collect accumulated CRV and CVX and send to Vault.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Collect CRV and CVX\n        IRewardStaking(cvxRewardStakerAddress).getReward();\n        _collectRewardTokens();\n    }\n}\n"
    },
    "contracts/strategies/CurveAMOStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Curve Automated Market Maker (AMO) Strategy\n * @notice AMO strategy for a Curve pool using an OToken.\n * @author Origin Protocol Inc\n */\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { ICurveStableSwapNG } from \"../interfaces/ICurveStableSwapNG.sol\";\nimport { ICurveLiquidityGaugeV6 } from \"../interfaces/ICurveLiquidityGaugeV6.sol\";\nimport { IBasicToken } from \"../interfaces/IBasicToken.sol\";\nimport { ICurveMinter } from \"../interfaces/ICurveMinter.sol\";\n\ncontract CurveAMOStrategy is InitializableAbstractStrategy {\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    /**\n     * @dev a threshold under which the contract no longer allows for the protocol to manually rebalance.\n     *      Guarding against a strategist / guardian being taken over and with multiple transactions\n     *      draining the protocol funds.\n     */\n    uint256 public constant SOLVENCY_THRESHOLD = 0.998 ether;\n\n    // New immutable variables that must be set in the constructor\n    /**\n     * @notice Address of the hard asset (weth, usdt, usdc).\n     */\n    IERC20 public immutable hardAsset;\n\n    /**\n     * @notice Address of the OTOKEN token contract.\n     */\n    IERC20 public immutable oToken;\n\n    /**\n     * @notice Address of the LP (Liquidity Provider) token contract.\n     */\n    IERC20 public immutable lpToken;\n\n    /**\n     * @notice Address of the Curve StableSwap NG pool contract.\n     */\n    ICurveStableSwapNG public immutable curvePool;\n\n    /**\n     * @notice Address of the Curve X-Chain Liquidity Gauge contract.\n     */\n    ICurveLiquidityGaugeV6 public immutable gauge;\n\n    /**\n     * @notice Address of the Curve Minter contract.\n     */\n    ICurveMinter public immutable minter;\n\n    /**\n     * @notice Index of the OTOKEN and hardAsset in the Curve pool.\n     */\n    uint128 public immutable otokenCoinIndex;\n    uint128 public immutable hardAssetCoinIndex;\n\n    /**\n     * @notice Decimals of the OTOKEN and hardAsset.\n     */\n    uint8 public immutable decimalsOToken;\n    uint8 public immutable decimalsHardAsset;\n\n    /**\n     * @notice Maximum slippage allowed for adding/removing liquidity from the Curve pool.\n     */\n    uint256 public maxSlippage;\n\n    event MaxSlippageUpdated(uint256 newMaxSlippage);\n\n    /**\n     * @dev Verifies that the caller is the Strategist.\n     */\n    modifier onlyStrategist() {\n        require(\n            msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Strategist\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Checks the Curve pool's balances have improved and the balances\n     * have not tipped to the other side.\n     * This modifier is only applied to functions that do a single sided add or remove.\n     * The standard deposit function adds to both sides of the pool in a way that\n     * the pool's balance is not worsened.\n     * Withdrawals are proportional so doesn't change the pools asset balance.\n     */\n    modifier improvePoolBalance() {\n        // Get the hard asset and OToken balances in the Curve pool\n        uint256[] memory balancesBefore = curvePool.get_balances();\n        // diff = hardAsset balance - OTOKEN balance\n        int256 diffBefore = (\n            balancesBefore[hardAssetCoinIndex].scaleBy(\n                decimalsOToken,\n                decimalsHardAsset\n            )\n        ).toInt256() - balancesBefore[otokenCoinIndex].toInt256();\n\n        _;\n\n        // Get the hard asset and OToken balances in the Curve pool\n        uint256[] memory balancesAfter = curvePool.get_balances();\n        // diff = hardAsset balance - OTOKEN balance\n        int256 diffAfter = (\n            balancesAfter[hardAssetCoinIndex].scaleBy(\n                decimalsOToken,\n                decimalsHardAsset\n            )\n        ).toInt256() - balancesAfter[otokenCoinIndex].toInt256();\n\n        if (diffBefore == 0) {\n            require(diffAfter == 0, \"Position balance is worsened\");\n        } else if (diffBefore < 0) {\n            // If the pool was originally imbalanced in favor of OTOKEN, then\n            // we want to check that the pool is now more balanced\n            require(diffAfter <= 0, \"OTokens overshot peg\");\n            require(diffBefore < diffAfter, \"OTokens balance worse\");\n        } else if (diffBefore > 0) {\n            // If the pool was originally imbalanced in favor of hardAsset, then\n            // we want to check that the pool is now more balanced\n            require(diffAfter >= 0, \"Assets overshot peg\");\n            require(diffAfter < diffBefore, \"Assets balance worse\");\n        }\n    }\n\n    constructor(\n        BaseStrategyConfig memory _baseConfig,\n        address _otoken,\n        address _hardAsset,\n        address _gauge,\n        address _minter\n    ) InitializableAbstractStrategy(_baseConfig) {\n        lpToken = IERC20(_baseConfig.platformAddress);\n        curvePool = ICurveStableSwapNG(_baseConfig.platformAddress);\n        minter = ICurveMinter(_minter);\n\n        oToken = IERC20(_otoken);\n        hardAsset = IERC20(_hardAsset);\n        gauge = ICurveLiquidityGaugeV6(_gauge);\n        decimalsHardAsset = IBasicToken(_hardAsset).decimals();\n        decimalsOToken = IBasicToken(_otoken).decimals();\n\n        (hardAssetCoinIndex, otokenCoinIndex) = curvePool.coins(0) == _hardAsset\n            ? (0, 1)\n            : (1, 0);\n        require(\n            curvePool.coins(otokenCoinIndex) == _otoken &&\n                curvePool.coins(hardAssetCoinIndex) == _hardAsset,\n            \"Invalid coin indexes\"\n        );\n        require(gauge.lp_token() == address(curvePool), \"Invalid pool\");\n    }\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Curve strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Address of CRV\n     * @param _maxSlippage Maximum slippage allowed for adding/removing liquidity from the Curve pool.\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // CRV\n        uint256 _maxSlippage\n    ) external onlyGovernor initializer {\n        address[] memory pTokens = new address[](1);\n        pTokens[0] = address(curvePool);\n\n        address[] memory _assets = new address[](1);\n        _assets[0] = address(hardAsset);\n\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            pTokens\n        );\n\n        _approveBase();\n        _setMaxSlippage(_maxSlippage);\n    }\n\n    /***************************************\n                    Deposit\n    ****************************************/\n\n    /**\n     * @notice Deposit hard asset into the Curve pool\n     * @param _hardAsset Address of hard asset contract.\n     * @param _amount Amount of hard asset to deposit.\n     */\n    function deposit(address _hardAsset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_hardAsset, _amount);\n    }\n\n    function _deposit(address _hardAsset, uint256 _hardAssetAmount) internal {\n        require(_hardAssetAmount > 0, \"Must deposit something\");\n        require(_hardAsset == address(hardAsset), \"Unsupported asset\");\n\n        emit Deposit(_hardAsset, address(lpToken), _hardAssetAmount);\n        uint256 scaledHardAssetAmount = _hardAssetAmount.scaleBy(\n            decimalsOToken,\n            decimalsHardAsset\n        );\n\n        // Get the asset and OToken balances in the Curve pool\n        uint256[] memory balances = curvePool.get_balances();\n        // safe to cast since min value is at least 0\n        uint256 otokenToAdd = uint256(\n            _max(\n                0,\n                (\n                    balances[hardAssetCoinIndex].scaleBy(\n                        decimalsOToken,\n                        decimalsHardAsset\n                    )\n                ).toInt256() +\n                    scaledHardAssetAmount.toInt256() -\n                    balances[otokenCoinIndex].toInt256()\n            )\n        );\n\n        /* Add so much OTOKEN so that the pool ends up being balanced. And at minimum\n         * add as much OTOKEN as hard asset and at maximum twice as much OTOKEN.\n         */\n        otokenToAdd = Math.max(otokenToAdd, scaledHardAssetAmount);\n        otokenToAdd = Math.min(otokenToAdd, scaledHardAssetAmount * 2);\n\n        /* Mint OTOKEN with a strategy that attempts to contribute to stability of OTOKEN/hardAsset pool. Try\n         * to mint so much OTOKEN that after deployment of liquidity pool ends up being balanced.\n         *\n         * To manage unpredictability minimal OTOKEN minted will always be at least equal or greater\n         * to hardAsset amount deployed. And never larger than twice the hardAsset amount deployed even if\n         * it would have a further beneficial effect on pool stability.\n         */\n        IVault(vaultAddress).mintForStrategy(otokenToAdd);\n\n        emit Deposit(address(oToken), address(lpToken), otokenToAdd);\n\n        uint256[] memory _amounts = new uint256[](2);\n        _amounts[hardAssetCoinIndex] = _hardAssetAmount;\n        _amounts[otokenCoinIndex] = otokenToAdd;\n\n        uint256 valueInLpTokens = (scaledHardAssetAmount + otokenToAdd)\n            .divPrecisely(curvePool.get_virtual_price());\n        uint256 minMintAmount = valueInLpTokens.mulTruncate(\n            uint256(1e18) - maxSlippage\n        );\n\n        // Do the deposit to the Curve pool\n        uint256 lpDeposited = curvePool.add_liquidity(_amounts, minMintAmount);\n        require(lpDeposited >= minMintAmount, \"Min LP amount error\");\n\n        // Deposit the Curve pool's LP tokens into the Curve gauge\n        gauge.deposit(lpDeposited);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n    }\n\n    /**\n     * @notice Deposit the strategy's entire balance of hardAsset into the Curve pool\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 balance = hardAsset.balanceOf(address(this));\n        if (balance > 0) {\n            _deposit(address(hardAsset), balance);\n        }\n    }\n\n    /***************************************\n                    Withdraw\n    ****************************************/\n\n    /**\n     * @notice Withdraw hardAsset and OTOKEN from the Curve pool, burn the OTOKEN,\n     * transfer hardAsset to the recipient.\n     * @param _recipient Address to receive withdrawn asset which is normally the Vault.\n     * @param _hardAsset Address of the hardAsset contract.\n     * @param _amount Amount of hardAsset to withdraw.\n     */\n    function withdraw(\n        address _recipient,\n        address _hardAsset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_amount > 0, \"Must withdraw something\");\n        require(\n            _hardAsset == address(hardAsset),\n            \"Can only withdraw hard asset\"\n        );\n\n        emit Withdrawal(_hardAsset, address(lpToken), _amount);\n\n        uint256 requiredLpTokens = calcTokenToBurn(\n            _amount.scaleBy(decimalsOToken, decimalsHardAsset)\n        );\n\n        _lpWithdraw(requiredLpTokens);\n\n        /* math in requiredLpTokens should correctly calculate the amount of LP to remove\n         * in that the strategy receives enough hardAsset on balanced removal\n         */\n        uint256[] memory _minWithdrawalAmounts = new uint256[](2);\n        _minWithdrawalAmounts[hardAssetCoinIndex] = _amount;\n        // slither-disable-next-line unused-return\n        curvePool.remove_liquidity(requiredLpTokens, _minWithdrawalAmounts);\n\n        // Burn all the removed OTOKEN and any that was left in the strategy\n        uint256 otokenToBurn = oToken.balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(otokenToBurn);\n\n        emit Withdrawal(address(oToken), address(lpToken), otokenToBurn);\n\n        // Transfer hardAsset to the recipient\n        hardAsset.safeTransfer(_recipient, _amount);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n    }\n\n    function calcTokenToBurn(uint256 _hardAssetAmount)\n        internal\n        view\n        returns (uint256 lpToBurn)\n    {\n        /* The rate between coins in the pool determines the rate at which pool returns\n         * tokens when doing balanced removal (remove_liquidity call). And by knowing how much hardAsset\n         * we want we can determine how much of OTOKEN we receive by removing liquidity.\n         *\n         * Because we are doing balanced removal we should be making profit when removing liquidity in a\n         * pool tilted to either side.\n         *\n         * Important: A downside is that the Strategist / Governor needs to be\n         * cognisant of not removing too much liquidity. And while the proposal to remove liquidity\n         * is being voted on the pool tilt might change so much that the proposal that has been valid while\n         * created is no longer valid.\n         */\n\n        uint256 poolHardAssetBalance = curvePool\n            .balances(hardAssetCoinIndex)\n            .scaleBy(decimalsOToken, decimalsHardAsset);\n        /* K is multiplied by 1e36 which is used for higher precision calculation of required\n         * pool LP tokens. Without it the end value can have rounding errors up to precision of\n         * 10 digits. This way we move the decimal point by 36 places when doing the calculation\n         * and again by 36 places when we are done with it.\n         */\n        uint256 k = (1e36 * lpToken.totalSupply()) / poolHardAssetBalance;\n        // prettier-ignore\n        // slither-disable-next-line divide-before-multiply\n        uint256 diff = (_hardAssetAmount + 1) * k;\n        lpToBurn = diff / 1e36;\n    }\n\n    /**\n     * @notice Remove all hardAsset and OTOKEN from the Curve pool, burn the OTOKEN,\n     * transfer hardAsset to the Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        uint256 gaugeTokens = gauge.balanceOf(address(this));\n        _lpWithdraw(gaugeTokens);\n\n        // Withdraws are proportional to assets held by 3Pool\n        uint256[] memory minWithdrawAmounts = new uint256[](2);\n\n        // Check balance of LP tokens in the strategy, if 0 return\n        uint256 lpBalance = lpToken.balanceOf(address(this));\n\n        // Remove liquidity\n        // slither-disable-next-line unused-return\n        if (lpBalance > 0) {\n            curvePool.remove_liquidity(lpBalance, minWithdrawAmounts);\n        }\n\n        // Burn all OTOKEN\n        uint256 otokenToBurn = oToken.balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(otokenToBurn);\n\n        // Get the strategy contract's hardAsset balance.\n        // This includes all that was removed from the Curve pool and\n        // any hardAsset that was sitting in the strategy contract before the removal.\n        uint256 hardAssetBalance = hardAsset.balanceOf(address(this));\n        hardAsset.safeTransfer(vaultAddress, hardAssetBalance);\n\n        if (hardAssetBalance > 0)\n            emit Withdrawal(\n                address(hardAsset),\n                address(lpToken),\n                hardAssetBalance\n            );\n        if (otokenToBurn > 0)\n            emit Withdrawal(address(oToken), address(lpToken), otokenToBurn);\n    }\n\n    /***************************************\n            Curve pool Rebalancing\n    ****************************************/\n\n    /**\n     * @notice Mint OTokens and one-sided add to the Curve pool.\n     * This is used when the Curve pool does not have enough OTokens and too many hardAsset.\n     * The OToken/Asset, eg OTOKEN/hardAsset, price with increase.\n     * The amount of assets in the vault is unchanged.\n     * The total supply of OTokens is increased.\n     * The asset value of the strategy and vault is increased.\n     * @param _oTokens The amount of OTokens to be minted and added to the pool.\n     */\n    function mintAndAddOTokens(uint256 _oTokens)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n    {\n        IVault(vaultAddress).mintForStrategy(_oTokens);\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[otokenCoinIndex] = _oTokens;\n\n        // Convert OTOKEN to Curve pool LP tokens\n        uint256 valueInLpTokens = (_oTokens).divPrecisely(\n            curvePool.get_virtual_price()\n        );\n        // Apply slippage to LP tokens\n        uint256 minMintAmount = valueInLpTokens.mulTruncate(\n            uint256(1e18) - maxSlippage\n        );\n\n        // Add the minted OTokens to the Curve pool\n        uint256 lpDeposited = curvePool.add_liquidity(amounts, minMintAmount);\n        require(lpDeposited >= minMintAmount, \"Min LP amount error\");\n\n        // Deposit the Curve pool LP tokens to the Curve gauge\n        gauge.deposit(lpDeposited);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n\n        emit Deposit(address(oToken), address(lpToken), _oTokens);\n    }\n\n    /**\n     * @notice One-sided remove of OTokens from the Curve pool which are then burned.\n     * This is used when the Curve pool has too many OTokens and not enough hardAsset.\n     * The amount of assets in the vault is unchanged.\n     * The total supply of OTokens is reduced.\n     * The asset value of the strategy and vault is reduced.\n     * @param _lpTokens The amount of Curve pool LP tokens to be burned for OTokens.\n     */\n    function removeAndBurnOTokens(uint256 _lpTokens)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n    {\n        // Withdraw Curve pool LP tokens from gauge and remove OTokens from the Curve pool\n        uint256 otokenToBurn = _withdrawAndRemoveFromPool(\n            _lpTokens,\n            otokenCoinIndex\n        );\n\n        // The vault burns the OTokens from this strategy\n        IVault(vaultAddress).burnForStrategy(otokenToBurn);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n\n        emit Withdrawal(address(oToken), address(lpToken), otokenToBurn);\n    }\n\n    /**\n     * @notice One-sided remove of hardAsset from the Curve pool and transfer to the vault.\n     * This is used when the Curve pool does not have enough OTokens and too many hardAsset.\n     * The OToken/Asset, eg OTOKEN/hardAsset, price with decrease.\n     * The amount of assets in the vault increases.\n     * The total supply of OTokens does not change.\n     * The asset value of the strategy reduces.\n     * The asset value of the vault should be close to the same.\n     * @param _lpTokens The amount of Curve pool LP tokens to be burned for hardAsset.\n     * @dev Curve pool LP tokens is used rather than hardAsset assets as Curve does not\n     * have a way to accurately calculate the amount of LP tokens for a required\n     * amount of hardAsset. Curve's `calc_token_amount` function does not include fees.\n     * A 3rd party library can be used that takes into account the fees, but this\n     * is a gas intensive process. It's easier for the trusted strategist to\n     * calculate the amount of Curve pool LP tokens required off-chain.\n     */\n    function removeOnlyAssets(uint256 _lpTokens)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n    {\n        // Withdraw Curve pool LP tokens from Curve gauge and remove hardAsset from the Curve pool\n        uint256 hardAssetAmount = _withdrawAndRemoveFromPool(\n            _lpTokens,\n            hardAssetCoinIndex\n        );\n\n        // Transfer hardAsset to the vault\n        hardAsset.safeTransfer(vaultAddress, hardAssetAmount);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n\n        emit Withdrawal(address(hardAsset), address(lpToken), hardAssetAmount);\n    }\n\n    /**\n     * @dev Remove Curve pool LP tokens from the gauge and\n     * do a one-sided remove of hardAsset or OTOKEN from the Curve pool.\n     * @param _lpTokens The amount of Curve pool LP tokens to be removed from the gauge\n     * @param coinIndex The index of the coin to be removed from the Curve pool. 0 = hardAsset, 1 = OTOKEN.\n     * @return coinsRemoved The amount of hardAsset or OTOKEN removed from the Curve pool.\n     */\n    function _withdrawAndRemoveFromPool(uint256 _lpTokens, uint128 coinIndex)\n        internal\n        returns (uint256 coinsRemoved)\n    {\n        // Withdraw Curve pool LP tokens from Curve gauge\n        _lpWithdraw(_lpTokens);\n\n        // Convert Curve pool LP tokens to hardAsset value\n        uint256 valueInEth = _lpTokens.mulTruncate(\n            curvePool.get_virtual_price()\n        );\n\n        if (coinIndex == hardAssetCoinIndex) {\n            valueInEth = valueInEth.scaleBy(decimalsHardAsset, decimalsOToken);\n        }\n\n        // Apply slippage to hardAsset value\n        uint256 minAmount = valueInEth.mulTruncate(uint256(1e18) - maxSlippage);\n\n        // Remove just the hardAsset from the Curve pool\n        coinsRemoved = curvePool.remove_liquidity_one_coin(\n            _lpTokens,\n            int128(coinIndex),\n            minAmount,\n            address(this)\n        );\n    }\n\n    /**\n     * Checks that the protocol is solvent, protecting from a rogue Strategist / Guardian that can\n     * keep rebalancing the pool in both directions making the protocol lose a tiny amount of\n     * funds each time.\n     *\n     * Protocol must be at least SOLVENCY_THRESHOLD (99,8 %) backed in order for the rebalances to\n     * function.\n     */\n    function _solvencyAssert() internal view {\n        uint256 _totalVaultValue = IVault(vaultAddress).totalValue();\n        uint256 _totalOtokenSupply = oToken.totalSupply();\n\n        if (\n            _totalVaultValue.divPrecisely(_totalOtokenSupply) <\n            SOLVENCY_THRESHOLD\n        ) {\n            revert(\"Protocol insolvent\");\n        }\n    }\n\n    /***************************************\n                Assets and Rewards\n    ****************************************/\n\n    /**\n     * @notice Collect accumulated CRV (and other) rewards and send to the Harvester.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Collect CRV rewards from inflation\n        minter.mint(address(gauge));\n\n        // Collect extra gauge rewards (outside of CRV)\n        gauge.claim_rewards();\n\n        _collectRewardTokens();\n    }\n\n    function _lpWithdraw(uint256 _lpAmount) internal {\n        require(\n            gauge.balanceOf(address(this)) >= _lpAmount,\n            \"Insufficient LP tokens\"\n        );\n        // withdraw lp tokens from the gauge without claiming rewards\n        gauge.withdraw(_lpAmount);\n    }\n\n    /**\n     * @notice Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == address(hardAsset), \"Unsupported asset\");\n\n        // hardAsset balance needed here for the balance check that happens from vault during depositing.\n        balance = hardAsset.balanceOf(address(this));\n        uint256 lpTokens = gauge.balanceOf(address(this));\n        if (lpTokens > 0) {\n            balance += ((lpTokens * curvePool.get_virtual_price()) / 1e18)\n                .scaleBy(decimalsHardAsset, decimalsOToken);\n        }\n    }\n\n    /**\n     * @notice Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == address(hardAsset);\n    }\n\n    /***************************************\n                    Approvals\n    ****************************************/\n\n    /**\n     * @notice Sets the maximum slippage allowed for any swap/liquidity operation\n     * @param _maxSlippage Maximum slippage allowed, 1e18 = 100%.\n     */\n    function setMaxSlippage(uint256 _maxSlippage) external onlyGovernor {\n        _setMaxSlippage(_maxSlippage);\n    }\n\n    function _setMaxSlippage(uint256 _maxSlippage) internal {\n        require(_maxSlippage <= 5e16, \"Slippage must be less than 100%\");\n        maxSlippage = _maxSlippage;\n        emit MaxSlippageUpdated(_maxSlippage);\n    }\n\n    /**\n     * @notice Approve the spending of all assets by their corresponding pool tokens,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        _approveBase();\n    }\n\n    /**\n     * @dev Since we are unwrapping WETH before depositing it to Curve\n     *      there is no need to set an approval for WETH on the Curve\n     *      pool\n     * @param _asset Address of the asset\n     * @param _pToken Address of the Curve LP token\n     */\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        override\n    {}\n\n    function _approveBase() internal {\n        // Approve Curve pool for OTOKEN (required for adding liquidity)\n        // slither-disable-next-line unused-return\n        oToken.approve(platformAddress, type(uint256).max);\n\n        // Approve Curve pool for hardAsset (required for adding liquidity)\n        // slither-disable-next-line unused-return\n        hardAsset.safeApprove(platformAddress, type(uint256).max);\n\n        // Approve Curve gauge contract to transfer Curve pool LP tokens\n        // This is needed for deposits if Curve pool LP tokens into the Curve gauge.\n        // slither-disable-next-line unused-return\n        lpToken.approve(address(gauge), type(uint256).max);\n    }\n\n    /**\n     * @dev Returns the largest of two numbers int256 version\n     */\n    function _max(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n}\n"
    },
    "contracts/strategies/CurvePoolBooster.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { Strategizable } from \"../governance/Strategizable.sol\";\nimport { ICampaignRemoteManager } from \"../interfaces/ICampaignRemoteManager.sol\";\n\n/// @title CurvePoolBooster\n/// @author Origin Protocol\n/// @notice Contract to manage interactions with VotemarketV2 for a dedicated Curve pool/gauge.\ncontract CurvePoolBooster is Initializable, Strategizable {\n    using SafeERC20 for IERC20;\n\n    ////////////////////////////////////////////////////\n    /// --- CONSTANTS && IMMUTABLES\n    ////////////////////////////////////////////////////\n    /// @notice Base fee for the contract, 100%\n    uint16 public constant FEE_BASE = 10_000;\n\n    /// @notice Address of the gauge to manage\n    address public immutable gauge;\n\n    /// @notice Address of the reward token\n    address public immutable rewardToken;\n\n    /// @notice Chain id of the target chain\n    uint256 public immutable targetChainId;\n\n    ////////////////////////////////////////////////////\n    /// --- STORAGE\n    ////////////////////////////////////////////////////\n    /// @notice Fee in FEE_BASE unit payed when managing campaign.\n    uint16 public fee;\n\n    /// @notice Address of the fee collector\n    address public feeCollector;\n\n    /// @notice Address of the campaignRemoteManager linked to VotemarketV2\n    address public campaignRemoteManager;\n\n    /// @notice Address of votemarket in L2\n    address public votemarket;\n\n    /// @notice Id of the campaign created\n    uint256 public campaignId;\n\n    ////////////////////////////////////////////////////\n    /// --- EVENTS\n    ////////////////////////////////////////////////////\n    event FeeUpdated(uint16 newFee);\n    event FeeCollected(address feeCollector, uint256 feeAmount);\n    event FeeCollectorUpdated(address newFeeCollector);\n    event VotemarketUpdated(address newVotemarket);\n    event CampaignRemoteManagerUpdated(address newCampaignRemoteManager);\n    event CampaignCreated(\n        address gauge,\n        address rewardToken,\n        uint256 maxRewardPerVote,\n        uint256 totalRewardAmount\n    );\n    event CampaignIdUpdated(uint256 newId);\n    event CampaignClosed(uint256 campaignId);\n    event TotalRewardAmountUpdated(uint256 extraTotalRewardAmount);\n    event NumberOfPeriodsUpdated(uint8 extraNumberOfPeriods);\n    event RewardPerVoteUpdated(uint256 newMaxRewardPerVote);\n    event TokensRescued(address token, uint256 amount, address receiver);\n\n    ////////////////////////////////////////////////////\n    /// --- CONSTRUCTOR && INITIALIZATION\n    ////////////////////////////////////////////////////\n    constructor(\n        uint256 _targetChainId,\n        address _rewardToken,\n        address _gauge\n    ) {\n        targetChainId = _targetChainId;\n        rewardToken = _rewardToken;\n        gauge = _gauge;\n\n        // Prevent implementation contract to be governed\n        _setGovernor(address(0));\n    }\n\n    /// @notice initialize function, to set up initial internal state\n    /// @param _strategist Address of the strategist\n    /// @param _fee Fee in FEE_BASE unit payed when managing campaign\n    /// @param _feeCollector Address of the fee collector\n    function initialize(\n        address _strategist,\n        uint16 _fee,\n        address _feeCollector,\n        address _campaignRemoteManager,\n        address _votemarket\n    ) external onlyGovernor initializer {\n        _setStrategistAddr(_strategist);\n        _setFee(_fee);\n        _setFeeCollector(_feeCollector);\n        _setCampaignRemoteManager(_campaignRemoteManager);\n        _setVotemarket(_votemarket);\n    }\n\n    ////////////////////////////////////////////////////\n    /// --- MUTATIVE FUNCTIONS\n    ////////////////////////////////////////////////////\n    /// @notice Create a new campaign on VotemarketV2\n    /// @dev This will use all token available in this contract\n    /// @param numberOfPeriods Duration of the campaign in weeks\n    /// @param maxRewardPerVote Maximum reward per vote to distribute, to avoid overspending\n    /// @param blacklist  List of addresses to exclude from the campaign\n    /// @param bridgeFee Fee to pay for the bridge\n    /// @param additionalGasLimit Additional gas limit for the bridge\n    function createCampaign(\n        uint8 numberOfPeriods,\n        uint256 maxRewardPerVote,\n        address[] calldata blacklist,\n        uint256 bridgeFee,\n        uint256 additionalGasLimit\n    ) external nonReentrant onlyGovernorOrStrategist {\n        require(campaignId == 0, \"Campaign already created\");\n        require(numberOfPeriods > 1, \"Invalid number of periods\");\n        require(maxRewardPerVote > 0, \"Invalid reward per vote\");\n\n        // Handle fee (if any)\n        uint256 balanceSubFee = _handleFee();\n\n        // Approve the balanceSubFee to the campaign manager\n        IERC20(rewardToken).safeApprove(campaignRemoteManager, 0);\n        IERC20(rewardToken).safeApprove(campaignRemoteManager, balanceSubFee);\n\n        // Create a new campaign\n        ICampaignRemoteManager(campaignRemoteManager).createCampaign{\n            value: bridgeFee\n        }(\n            ICampaignRemoteManager.CampaignCreationParams({\n                chainId: targetChainId,\n                gauge: gauge,\n                manager: address(this),\n                rewardToken: rewardToken,\n                numberOfPeriods: numberOfPeriods,\n                maxRewardPerVote: maxRewardPerVote,\n                totalRewardAmount: balanceSubFee,\n                addresses: blacklist,\n                hook: address(0),\n                isWhitelist: false\n            }),\n            targetChainId,\n            additionalGasLimit,\n            votemarket\n        );\n\n        emit CampaignCreated(\n            gauge,\n            rewardToken,\n            maxRewardPerVote,\n            balanceSubFee\n        );\n    }\n\n    /// @notice Manage the total reward amount of the campaign\n    /// @dev This function should be called after the campaign is created\n    /// @dev This will use all the token available in this contract\n    /// @param bridgeFee Fee to pay for the bridge\n    /// @param additionalGasLimit Additional gas limit for the bridge\n    function manageTotalRewardAmount(\n        uint256 bridgeFee,\n        uint256 additionalGasLimit\n    ) external nonReentrant onlyGovernorOrStrategist {\n        require(campaignId != 0, \"Campaign not created\");\n\n        // Handle fee (if any)\n        uint256 balanceSubFee = _handleFee();\n\n        // Approve the total reward amount to the campaign manager\n        IERC20(rewardToken).safeApprove(campaignRemoteManager, 0);\n        IERC20(rewardToken).safeApprove(campaignRemoteManager, balanceSubFee);\n\n        // Manage the campaign\n        // https://github.com/stake-dao/votemarket-v2/blob/main/packages/votemarket/src/Votemarket.sol#L668\n        ICampaignRemoteManager(campaignRemoteManager).manageCampaign{\n            value: bridgeFee\n        }(\n            ICampaignRemoteManager.CampaignManagementParams({\n                campaignId: campaignId,\n                rewardToken: rewardToken,\n                numberOfPeriods: 0,\n                totalRewardAmount: balanceSubFee,\n                maxRewardPerVote: 0\n            }),\n            targetChainId,\n            additionalGasLimit,\n            votemarket\n        );\n\n        emit TotalRewardAmountUpdated(balanceSubFee);\n    }\n\n    /// @notice Manage the number of periods of the campaign\n    /// @dev This function should be called after the campaign is created\n    /// @param extraNumberOfPeriods Number of additional periods (cannot be 0)\n    ///         that will be added to already existing amount of periods.\n    /// @param bridgeFee Fee to pay for the bridge\n    /// @param additionalGasLimit Additional gas limit for the bridge\n    function manageNumberOfPeriods(\n        uint8 extraNumberOfPeriods,\n        uint256 bridgeFee,\n        uint256 additionalGasLimit\n    ) external nonReentrant onlyGovernorOrStrategist {\n        require(campaignId != 0, \"Campaign not created\");\n        require(extraNumberOfPeriods > 0, \"Invalid number of periods\");\n\n        // Manage the campaign\n        ICampaignRemoteManager(campaignRemoteManager).manageCampaign{\n            value: bridgeFee\n        }(\n            ICampaignRemoteManager.CampaignManagementParams({\n                campaignId: campaignId,\n                rewardToken: rewardToken,\n                numberOfPeriods: extraNumberOfPeriods,\n                totalRewardAmount: 0,\n                maxRewardPerVote: 0\n            }),\n            targetChainId,\n            additionalGasLimit,\n            votemarket\n        );\n\n        emit NumberOfPeriodsUpdated(extraNumberOfPeriods);\n    }\n\n    /// @notice Manage the reward per vote of the campaign\n    /// @dev This function should be called after the campaign is created\n    /// @param newMaxRewardPerVote New maximum reward per vote\n    /// @param bridgeFee Fee to pay for the bridge\n    /// @param additionalGasLimit Additional gas limit for the bridge\n    function manageRewardPerVote(\n        uint256 newMaxRewardPerVote,\n        uint256 bridgeFee,\n        uint256 additionalGasLimit\n    ) external nonReentrant onlyGovernorOrStrategist {\n        require(campaignId != 0, \"Campaign not created\");\n        require(newMaxRewardPerVote > 0, \"Invalid reward per vote\");\n\n        // Manage the campaign\n        ICampaignRemoteManager(campaignRemoteManager).manageCampaign{\n            value: bridgeFee\n        }(\n            ICampaignRemoteManager.CampaignManagementParams({\n                campaignId: campaignId,\n                rewardToken: rewardToken,\n                numberOfPeriods: 0,\n                totalRewardAmount: 0,\n                maxRewardPerVote: newMaxRewardPerVote\n            }),\n            targetChainId,\n            additionalGasLimit,\n            votemarket\n        );\n\n        emit RewardPerVoteUpdated(newMaxRewardPerVote);\n    }\n\n    /// @notice Close the campaign.\n    /// @dev This function only work on the L2 chain. Not on mainnet.\n    /// @dev The _campaignId parameter is not related to the campaignId of this contract, allowing greater flexibility.\n    /// @param _campaignId Id of the campaign to close\n    function closeCampaign(\n        uint256 _campaignId,\n        uint256 bridgeFee,\n        uint256 additionalGasLimit\n    ) external nonReentrant onlyGovernorOrStrategist {\n        ICampaignRemoteManager(campaignRemoteManager).closeCampaign{\n            value: bridgeFee\n        }(\n            ICampaignRemoteManager.CampaignClosingParams({\n                campaignId: campaignId\n            }),\n            targetChainId,\n            additionalGasLimit,\n            votemarket\n        );\n        emit CampaignClosed(_campaignId);\n    }\n\n    /// @notice calculate the fee amount and transfer it to the feeCollector\n    /// @return Balance after fee\n    function _handleFee() internal returns (uint256) {\n        // Cache current rewardToken balance\n        uint256 balance = IERC20(rewardToken).balanceOf(address(this));\n        require(balance > 0, \"No reward to manage\");\n\n        uint256 feeAmount = (balance * fee) / FEE_BASE;\n\n        // If there is a fee, transfer it to the feeCollector\n        if (feeAmount > 0) {\n            // Transfer the fee to the feeCollector\n            IERC20(rewardToken).safeTransfer(feeCollector, feeAmount);\n            emit FeeCollected(feeCollector, feeAmount);\n\n            return IERC20(rewardToken).balanceOf(address(this));\n        }\n\n        // Return remaining balance\n        return balance;\n    }\n\n    ////////////////////////////////////////////////////\n    /// --- GOVERNANCE && OPERATION\n    ////////////////////////////////////////////////////\n    /// @notice Set the campaign id\n    /// @dev Only callable by the governor or strategist\n    /// @param _campaignId New campaign id\n    function setCampaignId(uint256 _campaignId)\n        external\n        onlyGovernorOrStrategist\n    {\n        campaignId = _campaignId;\n        emit CampaignIdUpdated(_campaignId);\n    }\n\n    /// @notice Rescue ETH from the contract\n    /// @dev Only callable by the governor or strategist\n    /// @param receiver Address to receive the ETH\n    function rescueETH(address receiver)\n        external\n        nonReentrant\n        onlyGovernorOrStrategist\n    {\n        require(receiver != address(0), \"Invalid receiver\");\n        uint256 balance = address(this).balance;\n        (bool success, ) = receiver.call{ value: balance }(\"\");\n        require(success, \"Transfer failed\");\n        emit TokensRescued(address(0), balance, receiver);\n    }\n\n    /// @notice Rescue ERC20 tokens from the contract\n    /// @dev Only callable by the governor or strategist\n    /// @param token Address of the token to rescue\n    function rescueToken(address token, address receiver)\n        external\n        nonReentrant\n        onlyGovernor\n    {\n        require(receiver != address(0), \"Invalid receiver\");\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n        emit TokensRescued(token, balance, receiver);\n    }\n\n    /// @notice Set the fee\n    /// @dev Only callable by the governor\n    /// @param _fee New fee\n    function setFee(uint16 _fee) external onlyGovernor {\n        _setFee(_fee);\n    }\n\n    /// @notice Internal logic to set the fee\n    function _setFee(uint16 _fee) internal {\n        require(_fee <= FEE_BASE / 2, \"Fee too high\");\n        fee = _fee;\n        emit FeeUpdated(_fee);\n    }\n\n    /// @notice Set the fee collector\n    /// @dev Only callable by the governor\n    /// @param _feeCollector New fee collector\n    function setFeeCollector(address _feeCollector) external onlyGovernor {\n        _setFeeCollector(_feeCollector);\n    }\n\n    /// @notice Internal logic to set the fee collector\n    function _setFeeCollector(address _feeCollector) internal {\n        require(_feeCollector != address(0), \"Invalid fee collector\");\n        feeCollector = _feeCollector;\n        emit FeeCollectorUpdated(_feeCollector);\n    }\n\n    /// @notice Set the campaignRemoteManager\n    /// @param _campaignRemoteManager New campaignRemoteManager address\n    function setCampaignRemoteManager(address _campaignRemoteManager)\n        external\n        onlyGovernor\n    {\n        _setCampaignRemoteManager(_campaignRemoteManager);\n    }\n\n    /// @notice Internal logic to set the campaignRemoteManager\n    /// @param _campaignRemoteManager New campaignRemoteManager address\n    function _setCampaignRemoteManager(address _campaignRemoteManager)\n        internal\n    {\n        require(\n            _campaignRemoteManager != address(0),\n            \"Invalid campaignRemoteManager\"\n        );\n        campaignRemoteManager = _campaignRemoteManager;\n        emit CampaignRemoteManagerUpdated(_campaignRemoteManager);\n    }\n\n    /// @notice Set the votemarket address\n    /// @param _votemarket New votemarket address\n    function setVotemarket(address _votemarket) external onlyGovernor {\n        _setVotemarket(_votemarket);\n    }\n\n    /// @notice Internal logic to set the votemarket address\n    function _setVotemarket(address _votemarket) internal onlyGovernor {\n        require(_votemarket != address(0), \"Invalid votemarket\");\n        votemarket = _votemarket;\n        emit VotemarketUpdated(_votemarket);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/strategies/Generalized4626Strategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Generalized 4626 Strategy\n * @notice Investment strategy for ERC-4626 Tokenized Vaults\n * @author Origin Protocol Inc\n */\nimport { IERC4626 } from \"../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\n\ncontract Generalized4626Strategy is InitializableAbstractStrategy {\n    /// @dev Replaced with an immutable variable\n    // slither-disable-next-line constable-states\n    address private _deprecate_shareToken;\n    /// @dev Replaced with an immutable variable\n    // slither-disable-next-line constable-states\n    address private _deprecate_assetToken;\n\n    IERC20 public immutable shareToken;\n    IERC20 public immutable assetToken;\n\n    // For future use\n    uint256[50] private __gap;\n\n    /**\n     * @param _baseConfig Base strategy config with platformAddress (ERC-4626 Vault contract), eg sfrxETH or sDAI,\n     * and vaultAddress (OToken Vault contract), eg VaultProxy or OETHVaultProxy\n     * @param _assetToken Address of the ERC-4626 asset token. eg frxETH or DAI\n     */\n    constructor(BaseStrategyConfig memory _baseConfig, address _assetToken)\n        InitializableAbstractStrategy(_baseConfig)\n    {\n        shareToken = IERC20(_baseConfig.platformAddress);\n        assetToken = IERC20(_assetToken);\n    }\n\n    function initialize() external virtual onlyGovernor initializer {\n        address[] memory rewardTokens = new address[](0);\n        address[] memory assets = new address[](1);\n        address[] memory pTokens = new address[](1);\n\n        assets[0] = address(assetToken);\n        pTokens[0] = address(platformAddress);\n\n        InitializableAbstractStrategy._initialize(\n            rewardTokens,\n            assets,\n            pTokens\n        );\n    }\n\n    /**\n     * @dev Deposit assets by converting them to shares\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @dev Deposit assets by converting them to shares\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal virtual {\n        require(_amount > 0, \"Must deposit something\");\n        require(_asset == address(assetToken), \"Unexpected asset address\");\n\n        // slither-disable-next-line unused-return\n        IERC4626(platformAddress).deposit(_amount, address(this));\n        emit Deposit(_asset, address(shareToken), _amount);\n    }\n\n    /**\n     * @dev Deposit the entire balance of assetToken to gain shareToken\n     */\n    function depositAll() external virtual override onlyVault nonReentrant {\n        uint256 balance = assetToken.balanceOf(address(this));\n        if (balance > 0) {\n            _deposit(address(assetToken), balance);\n        }\n    }\n\n    /**\n     * @dev Withdraw asset by burning shares\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external virtual override onlyVault nonReentrant {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n        require(_asset == address(assetToken), \"Unexpected asset address\");\n\n        // slither-disable-next-line unused-return\n        IERC4626(platformAddress).withdraw(_amount, _recipient, address(this));\n        emit Withdrawal(_asset, address(shareToken), _amount);\n    }\n\n    /**\n     * @dev Internal method to respond to the addition of new asset / share tokens\n     */\n    function _abstractSetPToken(address, address) internal virtual override {\n        _approveBase();\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll()\n        external\n        virtual\n        override\n        onlyVaultOrGovernor\n        nonReentrant\n    {\n        uint256 shareBalance = shareToken.balanceOf(address(this));\n        uint256 assetAmount = 0;\n        if (shareBalance > 0) {\n            assetAmount = IERC4626(platformAddress).redeem(\n                shareBalance,\n                vaultAddress,\n                address(this)\n            );\n            emit Withdrawal(\n                address(assetToken),\n                address(shareToken),\n                assetAmount\n            );\n        }\n    }\n\n    /**\n     * @notice Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        virtual\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == address(assetToken), \"Unexpected asset address\");\n        /* We are intentionally not counting the amount of assetToken parked on the\n         * contract toward the checkBalance. The deposit and withdraw functions\n         * should not result in assetToken being unused and owned by this strategy\n         * contract.\n         */\n        IERC4626 platform = IERC4626(platformAddress);\n        return platform.previewRedeem(platform.balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Governor approves the ERC-4626 Tokenized Vault to spend the asset.\n     */\n    function safeApproveAllTokens() external override onlyGovernor {\n        _approveBase();\n    }\n\n    function _approveBase() internal virtual {\n        // Approval the asset to be transferred to the ERC-4626 Tokenized Vault.\n        // Used by the ERC-4626 deposit() and mint() functions\n        // slither-disable-next-line unused-return\n        assetToken.approve(platformAddress, type(uint256).max);\n    }\n\n    /**\n     * @dev Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _asset == address(assetToken);\n    }\n\n    /**\n     * @notice is not supported for this strategy as the asset and\n     * ERC-4626 Tokenized Vault are set at deploy time.\n     * @dev If the ERC-4626 Tokenized Vault needed to be changed, a new\n     * contract would need to be deployed and the proxy updated.\n     */\n    function setPTokenAddress(address, address) external override onlyGovernor {\n        revert(\"unsupported function\");\n    }\n\n    /**\n     * @notice is not supported for this strategy as the asset and\n     * ERC-4626 Tokenized Vault are set at deploy time.\n     * @dev If the ERC-4626 Tokenized Vault needed to be changed, a new\n     * contract would need to be deployed and the proxy updated.\n     */\n    function removePToken(uint256) external override onlyGovernor {\n        revert(\"unsupported function\");\n    }\n}\n"
    },
    "contracts/strategies/Generalized4626USDTStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IUSDT {\n    // Tether's approve does not return a bool like standard IERC20 contracts\n    // slither-disable-next-line erc20-interface\n    function approve(address _spender, uint256 _value) external;\n}\n\n/**\n * @title Generalized 4626 Strategy when asset is Tether USD (USDT)\n * @notice Investment strategy for ERC-4626 Tokenized Vaults for the USDT asset.\n * @author Origin Protocol Inc\n */\nimport { Generalized4626Strategy } from \"./Generalized4626Strategy.sol\";\n\ncontract Generalized4626USDTStrategy is Generalized4626Strategy {\n    /**\n     * @param _baseConfig Base strategy config with platformAddress (ERC-4626 Vault contract), eg sfrxETH or sDAI,\n     * and vaultAddress (OToken Vault contract), eg VaultProxy or OETHVaultProxy\n     * @param _assetToken Address of the ERC-4626 asset token. eg frxETH or DAI\n     */\n    constructor(BaseStrategyConfig memory _baseConfig, address _assetToken)\n        Generalized4626Strategy(_baseConfig, _assetToken)\n    {}\n\n    /// @dev Override for Tether as USDT does not return a bool on approve.\n    /// Using assetToken.approve will fail as it expects a bool return value\n    function _approveBase() internal virtual override {\n        // Approval the asset to be transferred to the ERC-4626 Tokenized Vault.\n        // Used by the ERC-4626 deposit() and mint() functions\n        // slither-disable-next-line unused-return\n        IUSDT(address(assetToken)).approve(platformAddress, type(uint256).max);\n    }\n}\n"
    },
    "contracts/strategies/IAave.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface for Aaves Lending Pool\n * Documentation: https://developers.aave.com/#lendingpool\n */\ninterface IAaveLendingPool {\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n}\n\n/**\n * @dev Interface for Aaves Lending Pool\n * Documentation: https://developers.aave.com/#lendingpooladdressesprovider\n */\ninterface ILendingPoolAddressesProvider {\n    /**\n     * @notice Get the current address for Aave LendingPool\n     * @dev Lending pool is the core contract on which to call deposit\n     */\n    function getLendingPool() external view returns (address);\n}\n"
    },
    "contracts/strategies/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IAaveIncentivesController {\n    event RewardsAccrued(address indexed user, uint256 amount);\n\n    event RewardsClaimed(\n        address indexed user,\n        address indexed to,\n        uint256 amount\n    );\n\n    event RewardsClaimed(\n        address indexed user,\n        address indexed to,\n        address indexed claimer,\n        uint256 amount\n    );\n\n    event ClaimerSet(address indexed user, address indexed claimer);\n\n    /*\n     * @dev Returns the configuration of the distribution for a certain asset\n     * @param asset The address of the reference asset of the distribution\n     * @return The asset index, the emission per second and the last updated timestamp\n     **/\n    function getAssetData(address asset)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    /**\n     * @dev Whitelists an address to claim the rewards on behalf of another address\n     * @param user The address of the user\n     * @param claimer The address of the claimer\n     */\n    function setClaimer(address user, address claimer) external;\n\n    /**\n     * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\n     * @param user The address of the user\n     * @return The claimer address\n     */\n    function getClaimer(address user) external view returns (address);\n\n    /**\n     * @dev Configure assets for a certain rewards emission\n     * @param assets The assets to incentivize\n     * @param emissionsPerSecond The emission for each asset\n     */\n    function configureAssets(\n        address[] calldata assets,\n        uint256[] calldata emissionsPerSecond\n    ) external;\n\n    /**\n     * @dev Called by the corresponding asset on any update that affects the rewards distribution\n     * @param asset The address of the user\n     * @param userBalance The balance of the user of the asset in the lending pool\n     * @param totalSupply The total supply of the asset in the lending pool\n     **/\n    function handleAction(\n        address asset,\n        uint256 userBalance,\n        uint256 totalSupply\n    ) external;\n\n    /**\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n     * @param user The address of the user\n     * @return The rewards\n     **/\n    function getRewardsBalance(address[] calldata assets, address user)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Claims reward for an user, on all the assets of the lending pool,\n     * accumulating the pending rewards\n     * @param amount Amount of rewards to claim\n     * @param to Address that will be receiving the rewards\n     * @return Rewards claimed\n     **/\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Claims reward for an user on behalf, on all the assets of the\n     * lending pool, accumulating the pending rewards. The caller must\n     * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n     * @param amount Amount of rewards to claim\n     * @param user Address to check and claim rewards\n     * @param to Address that will be receiving the rewards\n     * @return Rewards claimed\n     **/\n    function claimRewardsOnBehalf(\n        address[] calldata assets,\n        uint256 amount,\n        address user,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev returns the unclaimed rewards of the user\n     * @param user the address of the user\n     * @return the unclaimed user rewards\n     */\n    function getUserUnclaimedRewards(address user)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev returns the unclaimed rewards of the user\n     * @param user the address of the user\n     * @param asset The asset to incentivize\n     * @return the user index for the asset\n     */\n    function getUserAssetData(address user, address asset)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev for backward compatibility with previous implementation of the Incentives controller\n     */\n    function REWARD_TOKEN() external view returns (address);\n\n    /**\n     * @dev for backward compatibility with previous implementation of the Incentives controller\n     */\n    function PRECISION() external view returns (uint8);\n\n    /**\n     * @dev Gets the distribution end timestamp of the emissions\n     */\n    function DISTRIBUTION_END() external view returns (uint256);\n}\n"
    },
    "contracts/strategies/IAaveStakeToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IAaveStakedToken {\n    function COOLDOWN_SECONDS() external returns (uint256);\n\n    function UNSTAKE_WINDOW() external returns (uint256);\n\n    function balanceOf(address addr) external returns (uint256);\n\n    function redeem(address to, uint256 amount) external;\n\n    function stakersCooldowns(address addr) external returns (uint256);\n\n    function cooldown() external;\n}\n"
    },
    "contracts/strategies/ICompound.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @dev Compound C Token interface\n * Documentation: https://compound.finance/developers/ctokens\n */\ninterface ICERC20 {\n    /**\n     * @notice The mint function transfers an asset into the protocol, which begins accumulating\n     * interest based on the current Supply Rate for the asset. The user receives a quantity of\n     * cTokens equal to the underlying tokens supplied, divided by the current Exchange Rate.\n     * @param mintAmount The amount of the asset to be supplied, in units of the underlying asset.\n     * @return 0 on success, otherwise an Error codes\n     */\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise an error code.\n     */\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    /**\n     * @notice The redeem underlying function converts cTokens into a specified quantity of the underlying\n     * asset, and returns them to the user. The amount of cTokens redeemed is equal to the quantity of\n     * underlying tokens received, divided by the current Exchange Rate. The amount redeemed must be less\n     * than the user's Account Liquidity and the market's available liquidity.\n     * @param redeemAmount The amount of underlying to be redeemed.\n     * @return 0 on success, otherwise an error code.\n     */\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    /**\n     * @notice The user's underlying balance, representing their assets in the protocol, is equal to\n     * the user's cToken balance multiplied by the Exchange Rate.\n     * @param owner The account to get the underlying balance of.\n     * @return The amount of underlying currently owned by the account.\n     */\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() external view returns (uint256);\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @notice Get the supply rate per block for supplying the token to Compound.\n     */\n    function supplyRatePerBlock() external view returns (uint256);\n\n    /**\n     * @notice Address of the Compound Comptroller.\n     */\n    function comptroller() external view returns (address);\n}\n"
    },
    "contracts/strategies/IConvexDeposits.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IConvexDeposits {\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool _stake\n    ) external returns (bool);\n\n    function deposit(\n        uint256 _amount,\n        bool _lock,\n        address _stakeAddress\n    ) external;\n}\n"
    },
    "contracts/strategies/ICRVMinter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface ICRVMinter {\n    function mint(address gaugeAddress) external;\n}\n"
    },
    "contracts/strategies/ICurveETHPoolV1.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface ICurveETHPoolV1 {\n    event AddLiquidity(\n        address indexed provider,\n        uint256[2] token_amounts,\n        uint256[2] fees,\n        uint256 invariant,\n        uint256 token_supply\n    );\n    event ApplyNewFee(uint256 fee);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event CommitNewFee(uint256 new_fee);\n    event RampA(\n        uint256 old_A,\n        uint256 new_A,\n        uint256 initial_time,\n        uint256 future_time\n    );\n    event RemoveLiquidity(\n        address indexed provider,\n        uint256[2] token_amounts,\n        uint256[2] fees,\n        uint256 token_supply\n    );\n    event RemoveLiquidityImbalance(\n        address indexed provider,\n        uint256[2] token_amounts,\n        uint256[2] fees,\n        uint256 invariant,\n        uint256 token_supply\n    );\n    event RemoveLiquidityOne(\n        address indexed provider,\n        uint256 token_amount,\n        uint256 coin_amount,\n        uint256 token_supply\n    );\n    event StopRampA(uint256 A, uint256 t);\n    event TokenExchange(\n        address indexed buyer,\n        int128 sold_id,\n        uint256 tokens_sold,\n        int128 bought_id,\n        uint256 tokens_bought\n    );\n    event Transfer(\n        address indexed sender,\n        address indexed receiver,\n        uint256 value\n    );\n\n    function A() external view returns (uint256);\n\n    function A_precise() external view returns (uint256);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function add_liquidity(uint256[2] memory _amounts, uint256 _min_mint_amount)\n        external\n        payable\n        returns (uint256);\n\n    function add_liquidity(\n        uint256[2] memory _amounts,\n        uint256 _min_mint_amount,\n        address _receiver\n    ) external payable returns (uint256);\n\n    function admin_action_deadline() external view returns (uint256);\n\n    function admin_balances(uint256 i) external view returns (uint256);\n\n    function admin_fee() external view returns (uint256);\n\n    function allowance(address arg0, address arg1)\n        external\n        view\n        returns (uint256);\n\n    function apply_new_fee() external;\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function balanceOf(address arg0) external view returns (uint256);\n\n    function balances(uint256 arg0) external view returns (uint256);\n\n    function calc_token_amount(uint256[2] memory _amounts, bool _is_deposit)\n        external\n        view\n        returns (uint256);\n\n    function calc_withdraw_one_coin(uint256 _burn_amount, int128 i)\n        external\n        view\n        returns (uint256);\n\n    function coins(uint256 arg0) external view returns (address);\n\n    function commit_new_fee(uint256 _new_fee) external;\n\n    function decimals() external view returns (uint256);\n\n    function ema_price() external view returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy\n    ) external payable returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy,\n        address _receiver\n    ) external payable returns (uint256);\n\n    function fee() external view returns (uint256);\n\n    function future_A() external view returns (uint256);\n\n    function future_A_time() external view returns (uint256);\n\n    function future_fee() external view returns (uint256);\n\n    function get_balances() external view returns (uint256[2] memory);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function get_p() external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function initial_A() external view returns (uint256);\n\n    function initial_A_time() external view returns (uint256);\n\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address[4] memory _coins,\n        uint256[4] memory _rate_multipliers,\n        uint256 _A,\n        uint256 _fee\n    ) external;\n\n    function last_price() external view returns (uint256);\n\n    function ma_exp_time() external view returns (uint256);\n\n    function ma_last_time() external view returns (uint256);\n\n    function name() external view returns (string memory);\n\n    function nonces(address arg0) external view returns (uint256);\n\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (bool);\n\n    function price_oracle() external view returns (uint256);\n\n    function ramp_A(uint256 _future_A, uint256 _future_time) external;\n\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[2] memory _min_amounts\n    ) external returns (uint256[2] memory);\n\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[2] memory _min_amounts,\n        address _receiver\n    ) external returns (uint256[2] memory);\n\n    function remove_liquidity_imbalance(\n        uint256[2] memory _amounts,\n        uint256 _max_burn_amount\n    ) external returns (uint256);\n\n    function remove_liquidity_imbalance(\n        uint256[2] memory _amounts,\n        uint256 _max_burn_amount,\n        address _receiver\n    ) external returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_received\n    ) external returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_received,\n        address _receiver\n    ) external returns (uint256);\n\n    function set_ma_exp_time(uint256 _ma_exp_time) external;\n\n    function stop_ramp_A() external;\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function version() external view returns (string memory);\n\n    function withdraw_admin_fees() external;\n}\n"
    },
    "contracts/strategies/ICurveGauge.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface ICurveGauge {\n    function balanceOf(address account) external view returns (uint256);\n\n    function deposit(uint256 value, address account) external;\n\n    function withdraw(uint256 value) external;\n}\n"
    },
    "contracts/strategies/ICurveMetaPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.4;\n\ninterface ICurveMetaPool {\n    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount)\n        external\n        returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function remove_liquidity(uint256 _amount, uint256[2] calldata min_amounts)\n        external\n        returns (uint256[2] calldata);\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 min_amount\n    ) external returns (uint256);\n\n    function remove_liquidity_imbalance(\n        uint256[2] calldata amounts,\n        uint256 max_burn_amount\n    ) external returns (uint256);\n\n    function calc_withdraw_one_coin(uint256 _token_amount, int128 i)\n        external\n        view\n        returns (uint256);\n\n    function balances(uint256 i) external view returns (uint256);\n\n    function calc_token_amount(uint256[2] calldata amounts, bool deposit)\n        external\n        view\n        returns (uint256);\n\n    function base_pool() external view returns (address);\n\n    function fee() external view returns (uint256);\n\n    function coins(uint256 i) external view returns (address);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/strategies/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface ICurvePool {\n    function get_virtual_price() external view returns (uint256);\n\n    function add_liquidity(uint256[3] calldata _amounts, uint256 _min) external;\n\n    function balances(uint256) external view returns (uint256);\n\n    function calc_token_amount(uint256[3] calldata _amounts, bool _deposit)\n        external\n        returns (uint256);\n\n    function fee() external view returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _amount,\n        int128 _index,\n        uint256 _minAmount\n    ) external;\n\n    function remove_liquidity(\n        uint256 _amount,\n        uint256[3] calldata _minWithdrawAmounts\n    ) external;\n\n    function calc_withdraw_one_coin(uint256 _amount, int128 _index)\n        external\n        view\n        returns (uint256);\n\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n\n    function coins(uint256 _index) external view returns (address);\n\n    function remove_liquidity_imbalance(\n        uint256[3] calldata _amounts,\n        uint256 maxBurnAmount\n    ) external;\n}\n"
    },
    "contracts/strategies/IRewardStaking.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IRewardStaking {\n    function stakeFor(address, uint256) external;\n\n    function stake(uint256) external;\n\n    function withdraw(uint256 amount, bool claim) external;\n\n    function withdrawAndUnwrap(uint256 amount, bool claim) external;\n\n    function earned(address account) external view returns (uint256);\n\n    function getReward() external;\n\n    function getReward(address _account, bool _claimExtras) external;\n\n    function extraRewardsLength() external returns (uint256);\n\n    function extraRewards(uint256 _pid) external returns (address);\n\n    function rewardToken() external returns (address);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "contracts/strategies/MorphoAaveStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD Morpho Aave Strategy\n * @notice Investment strategy for investing stablecoins via Morpho (Aave)\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { IMorpho } from \"../interfaces/morpho/IMorpho.sol\";\nimport { ILens } from \"../interfaces/morpho/ILens.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\ncontract MorphoAaveStrategy is InitializableAbstractStrategy {\n    address public constant MORPHO = 0x777777c9898D384F785Ee44Acfe945efDFf5f3E0;\n    address public constant LENS = 0x507fA343d0A90786d86C7cd885f5C49263A91FF4;\n\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /**\n     * @dev Initialize function, to set up initial internal state\n     * @param _rewardTokenAddresses Address of reward token for platform\n     * @param _assets Addresses of initial supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses,\n        address[] calldata _assets,\n        address[] calldata _pTokens\n    ) external onlyGovernor initializer {\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n    }\n\n    /**\n     * @dev Approve the spending of all assets by main Morpho contract,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; i++) {\n            address asset = assetsMapped[i];\n\n            // Safe approval\n            IERC20(asset).safeApprove(MORPHO, 0);\n            IERC20(asset).safeApprove(MORPHO, type(uint256).max);\n        }\n    }\n\n    /**\n     * @dev Internal method to respond to the addition of new asset\n     *      We need to approve and allow Morpho to move them\n     * @param _asset Address of the asset to approve\n     * @param _pToken The pToken for the approval\n     */\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        override\n    {\n        IERC20(_asset).safeApprove(MORPHO, 0);\n        IERC20(_asset).safeApprove(MORPHO, type(uint256).max);\n    }\n\n    /**\n     * @dev Collect accumulated rewards and send them to Harvester.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Morpho Aave-v2 doesn't distribute reward tokens\n        // solhint-disable-next-line max-line-length\n        // Ref: https://developers.morpho.xyz/interact-with-morpho/get-started/interact-with-morpho/claim-rewards#morpho-aave-v2\n    }\n\n    /**\n     * @dev Get the amount of rewards pending to be collected from the protocol\n     */\n    function getPendingRewards() external view returns (uint256 balance) {\n        // Morpho Aave-v2 doesn't distribute reward tokens\n        // solhint-disable-next-line max-line-length\n        // Ref: https://developers.morpho.xyz/interact-with-morpho/get-started/interact-with-morpho/claim-rewards#morpho-aave-v2\n        return 0;\n    }\n\n    /**\n     * @dev Deposit asset into Morpho\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @dev Deposit asset into Morpho\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_amount > 0, \"Must deposit something\");\n\n        address pToken = address(_getPTokenFor(_asset));\n\n        IMorpho(MORPHO).supply(\n            pToken,\n            address(this), // the address of the user you want to supply on behalf of\n            _amount\n        );\n        emit Deposit(_asset, pToken, _amount);\n    }\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into Morpho\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            uint256 balance = IERC20(assetsMapped[i]).balanceOf(address(this));\n            if (balance > 0) {\n                _deposit(assetsMapped[i], balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw asset from Morpho\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        _withdraw(_recipient, _asset, _amount);\n    }\n\n    function _withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) internal {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        address pToken = address(_getPTokenFor(_asset));\n\n        IMorpho(MORPHO).withdraw(pToken, _amount);\n        emit Withdrawal(_asset, pToken, _amount);\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            uint256 balance = _checkBalance(assetsMapped[i]);\n            if (balance > 0) {\n                _withdraw(vaultAddress, assetsMapped[i], balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Return total value of an asset held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        return _checkBalance(_asset);\n    }\n\n    function _checkBalance(address _asset)\n        internal\n        view\n        returns (uint256 balance)\n    {\n        address pToken = address(_getPTokenFor(_asset));\n\n        // Total value represented by decimal position of underlying token\n        (, , balance) = ILens(LENS).getCurrentSupplyBalanceInOf(\n            pToken,\n            address(this)\n        );\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @dev Get the pToken wrapped in the IERC20 interface for this asset.\n     *      Fails if the pToken doesn't exist in our mappings.\n     * @param _asset Address of the asset\n     * @return pToken Corresponding pToken to this asset\n     */\n    function _getPTokenFor(address _asset) internal view returns (IERC20) {\n        address pToken = assetToPToken[_asset];\n        require(pToken != address(0), \"pToken does not exist\");\n        return IERC20(pToken);\n    }\n}\n"
    },
    "contracts/strategies/MorphoCompoundStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD Morpho Compound Strategy\n * @notice Investment strategy for investing stablecoins via Morpho (Compound)\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20, AbstractCompoundStrategy, InitializableAbstractStrategy } from \"./AbstractCompoundStrategy.sol\";\nimport { IMorpho } from \"../interfaces/morpho/IMorpho.sol\";\nimport { ILens } from \"../interfaces/morpho/ILens.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport \"../utils/Helpers.sol\";\n\ncontract MorphoCompoundStrategy is AbstractCompoundStrategy {\n    address public constant MORPHO = 0x8888882f8f843896699869179fB6E4f7e3B58888;\n    address public constant LENS = 0x930f1b46e1D081Ec1524efD95752bE3eCe51EF67;\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /**\n     * @dev Initialize function, to set up initial internal state\n     * @param _rewardTokenAddresses Address of reward token for platform\n     * @param _assets Addresses of initial supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses,\n        address[] calldata _assets,\n        address[] calldata _pTokens\n    ) external onlyGovernor initializer {\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n    }\n\n    /**\n     * @dev Approve the spending of all assets by main Morpho contract,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; i++) {\n            address asset = assetsMapped[i];\n\n            // Safe approval\n            IERC20(asset).safeApprove(MORPHO, 0);\n            IERC20(asset).safeApprove(MORPHO, type(uint256).max);\n        }\n    }\n\n    /**\n     * @dev Internal method to respond to the addition of new asset\n     *      We need to approve and allow Morpho to move them\n     * @param _asset Address of the asset to approve\n     * @param _pToken The pToken for the approval\n     */\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        override\n    {\n        IERC20(_asset).safeApprove(MORPHO, 0);\n        IERC20(_asset).safeApprove(MORPHO, type(uint256).max);\n    }\n\n    /**\n     * @dev Collect accumulated rewards and send them to Harvester.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        /**\n         * Gas considerations. We could query Morpho LENS's `getUserUnclaimedRewards` for each\n         * cToken separately and only claimRewards where it is economically feasible. Each call\n         * (out of 3) costs ~60k gas extra.\n         *\n         * Each extra cToken in the `poolTokens` of `claimRewards` function makes that call\n         * 89-120k more expensive gas wise.\n         *\n         * With Lens query in case where:\n         *  - there is only 1 reward token to collect. Net gas usage in best case would be\n         *    3*60 - 2*120 = -60k -> saving 60k gas\n         *  - there are 2 reward tokens to collect. Net gas usage in best case would be\n         *    3*60 - 120 = 60k -> more expensive for 60k gas\n         *  - there are 3 reward tokens to collect. Net gas usage in best case would be\n         *    3*60 = 180k -> more expensive for 180k gas\n         *\n         * For the above reasoning such \"optimization\" is not implemented\n         */\n\n        address[] memory poolTokens = new address[](assetsMapped.length);\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            poolTokens[i] = assetToPToken[assetsMapped[i]];\n        }\n\n        // slither-disable-next-line unused-return\n        IMorpho(MORPHO).claimRewards(\n            poolTokens, // The addresses of the underlying protocol's pools to claim rewards from\n            false // Whether to trade the accrued rewards for MORPHO token, with a premium\n        );\n\n        // Transfer COMP to Harvester\n        IERC20 rewardToken = IERC20(rewardTokenAddresses[0]);\n        uint256 balance = rewardToken.balanceOf(address(this));\n        emit RewardTokenCollected(\n            harvesterAddress,\n            rewardTokenAddresses[0],\n            balance\n        );\n        rewardToken.safeTransfer(harvesterAddress, balance);\n    }\n\n    /**\n     * @dev Get the amount of rewards pending to be collected from the protocol\n     */\n    function getPendingRewards() external view returns (uint256 balance) {\n        address[] memory poolTokens = new address[](assetsMapped.length);\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            poolTokens[i] = assetToPToken[assetsMapped[i]];\n        }\n\n        return ILens(LENS).getUserUnclaimedRewards(poolTokens, address(this));\n    }\n\n    /**\n     * @dev Deposit asset into Morpho\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @dev Deposit asset into Morpho\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_amount > 0, \"Must deposit something\");\n\n        IMorpho(MORPHO).supply(\n            address(_getCTokenFor(_asset)),\n            address(this), // the address of the user you want to supply on behalf of\n            _amount\n        );\n        emit Deposit(_asset, address(_getCTokenFor(_asset)), _amount);\n    }\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into Morpho\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            uint256 balance = IERC20(assetsMapped[i]).balanceOf(address(this));\n            if (balance > 0) {\n                _deposit(assetsMapped[i], balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw asset from Morpho\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        _withdraw(_recipient, _asset, _amount);\n    }\n\n    function _withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) internal {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        address pToken = assetToPToken[_asset];\n\n        IMorpho(MORPHO).withdraw(pToken, _amount);\n        emit Withdrawal(_asset, address(_getCTokenFor(_asset)), _amount);\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            uint256 balance = _checkBalance(assetsMapped[i]);\n            if (balance > 0) {\n                _withdraw(vaultAddress, assetsMapped[i], balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Return total value of an asset held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        return _checkBalance(_asset);\n    }\n\n    function _checkBalance(address _asset)\n        internal\n        view\n        returns (uint256 balance)\n    {\n        address pToken = assetToPToken[_asset];\n\n        // Total value represented by decimal position of underlying token\n        (, , balance) = ILens(LENS).getCurrentSupplyBalanceInOf(\n            pToken,\n            address(this)\n        );\n    }\n}\n"
    },
    "contracts/strategies/NativeStaking/CompoundingStakingSSVStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { IWETH9 } from \"../../interfaces/IWETH9.sol\";\nimport { CompoundingValidatorManager } from \"./CompoundingValidatorManager.sol\";\n\n/// @title Compounding Staking SSV Strategy\n/// @notice Strategy to deploy funds into DVT validators powered by the SSV Network\n/// @author Origin Protocol Inc\ncontract CompoundingStakingSSVStrategy is\n    CompoundingValidatorManager,\n    InitializableAbstractStrategy\n{\n    /// @notice SSV ERC20 token that serves as a payment for operating SSV validators\n    address public immutable SSV_TOKEN;\n\n    // For future use\n    uint256[50] private __gap;\n\n    /// @param _baseConfig Base strategy config with\n    ///   `platformAddress` not used so empty address\n    ///   `vaultAddress` the address of the OETH Vault contract\n    /// @param _wethAddress Address of the WETH Token contract\n    /// @param _ssvToken Address of the SSV Token contract\n    /// @param _ssvNetwork Address of the SSV Network contract\n    /// @param _beaconChainDepositContract Address of the beacon chain deposit contract\n    /// @param _beaconProofs Address of the Beacon Proofs contract that verifies beacon chain data\n    /// @param _beaconGenesisTimestamp The timestamp of the Beacon chain's genesis.\n    constructor(\n        BaseStrategyConfig memory _baseConfig,\n        address _wethAddress,\n        address _ssvToken,\n        address _ssvNetwork,\n        address _beaconChainDepositContract,\n        address _beaconProofs,\n        uint64 _beaconGenesisTimestamp\n    )\n        InitializableAbstractStrategy(_baseConfig)\n        CompoundingValidatorManager(\n            _wethAddress,\n            _baseConfig.vaultAddress,\n            _beaconChainDepositContract,\n            _ssvNetwork,\n            _beaconProofs,\n            _beaconGenesisTimestamp\n        )\n    {\n        SSV_TOKEN = _ssvToken;\n        _disableInitializers();\n    }\n\n    /// @notice Set up initial internal state including\n    /// 1. approving the SSVNetwork to transfer SSV tokens from this strategy contract\n    /// @param _rewardTokenAddresses Not used so empty array\n    /// @param _assets Not used so empty array\n    /// @param _pTokens Not used so empty array\n    function initialize(\n        address[] memory _rewardTokenAddresses,\n        address[] memory _assets,\n        address[] memory _pTokens\n    ) external onlyGovernor initializer {\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n\n        safeApproveAllTokens();\n    }\n\n    /// @notice Unlike other strategies, this does not deposit assets into the underlying platform.\n    /// It just checks the asset is WETH and emits the Deposit event.\n    /// To deposit WETH into validators, `registerSsvValidator` and `stakeEth` must be used.\n    /// @param _asset Address of the WETH token.\n    /// @param _amount Amount of WETH that was transferred to the strategy by the vault.\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        require(_asset == WETH, \"Unsupported asset\");\n        require(_amount > 0, \"Must deposit something\");\n\n        // Account for the new WETH\n        depositedWethAccountedFor += _amount;\n\n        emit Deposit(_asset, address(0), _amount);\n    }\n\n    /// @notice Unlike other strategies, this does not deposit assets into the underlying platform.\n    /// It just emits the Deposit event.\n    /// To deposit WETH into validators `registerSsvValidator` and `stakeEth` must be used.\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 wethBalance = IERC20(WETH).balanceOf(address(this));\n        uint256 newWeth = wethBalance - depositedWethAccountedFor;\n\n        if (newWeth > 0) {\n            // Account for the new WETH\n            depositedWethAccountedFor = wethBalance;\n\n            emit Deposit(WETH, address(0), newWeth);\n        }\n    }\n\n    /// @notice Withdraw ETH and WETH from this strategy contract.\n    /// @param _recipient Address to receive withdrawn assets.\n    /// @param _asset Address of the WETH token.\n    /// @param _amount Amount of WETH to withdraw.\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_asset == WETH, \"Unsupported asset\");\n\n        _withdraw(_recipient, _amount, address(this).balance);\n    }\n\n    function _withdraw(\n        address _recipient,\n        uint256 _withdrawAmount,\n        uint256 _ethBalance\n    ) internal {\n        require(_withdrawAmount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        // Convert any ETH from validator partial withdrawals, exits\n        // or execution rewards to WETH and do the necessary accounting.\n        if (_ethBalance > 0) _convertEthToWeth(_ethBalance);\n\n        // Transfer WETH to the recipient and do the necessary accounting.\n        _transferWeth(_withdrawAmount, _recipient);\n\n        emit Withdrawal(WETH, address(0), _withdrawAmount);\n    }\n\n    /// @notice Transfer all WETH deposits, ETH from validator withdrawals and ETH from\n    /// execution rewards in this strategy to the vault.\n    /// This does not withdraw from the validators. That has to be done separately with the\n    /// `validatorWithdrawal` operation.\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        uint256 ethBalance = address(this).balance;\n        uint256 withdrawAmount = IERC20(WETH).balanceOf(address(this)) +\n            ethBalance;\n\n        if (withdrawAmount > 0) {\n            _withdraw(vaultAddress, withdrawAmount, ethBalance);\n        }\n    }\n\n    /// @notice Accounts for all the assets managed by this strategy which includes:\n    /// 1. The current WETH in this strategy contract\n    /// 2. The last verified ETH balance, total deposits and total validator balances\n    /// @param _asset      Address of WETH asset.\n    /// @return balance    Total value in ETH\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == WETH, \"Unsupported asset\");\n\n        // Load the last verified balance from the storage\n        // and add to the latest WETH balance of this strategy.\n        balance =\n            lastVerifiedEthBalance +\n            IWETH9(WETH).balanceOf(address(this));\n    }\n\n    /// @notice Returns bool indicating whether asset is supported by the strategy.\n    /// @param _asset The address of the WETH token.\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == WETH;\n    }\n\n    /// @notice Approves the SSV Network contract to transfer SSV tokens for validator registration.\n    function safeApproveAllTokens() public override {\n        // Approves the SSV Network contract to transfer SSV tokens when validators are registered\n        IERC20(SSV_TOKEN).approve(SSV_NETWORK, type(uint256).max);\n    }\n\n    /**\n     * @notice We can accept ETH directly to this contract from anyone as it does not impact our accounting\n     * like it did in the legacy NativeStakingStrategy.\n     * The new ETH will be accounted for in `checkBalance` after the next snapBalances and verifyBalances txs.\n     */\n    receive() external payable {}\n\n    /***************************************\n                Internal functions\n    ****************************************/\n\n    /// @notice is not supported for this strategy as there is no platform token.\n    function setPTokenAddress(address, address) external pure override {\n        revert(\"Unsupported function\");\n    }\n\n    /// @notice is not supported for this strategy as there is no platform token.\n    function removePToken(uint256) external pure override {\n        revert(\"Unsupported function\");\n    }\n\n    /// @dev This strategy does not use a platform token like the old Aave and Compound strategies.\n    function _abstractSetPToken(address _asset, address) internal override {}\n\n    /// @dev Consensus rewards are compounded to the validator's balance instead of being\n    /// swept to this strategy contract.\n    /// Execution rewards from MEV and tx priority accumulate as ETH in this strategy contract.\n    /// Withdrawals from validators also accumulate as ETH in this strategy contract.\n    /// It's too complex to separate the rewards from withdrawals so this function is not implemented.\n    /// Besides, ETH rewards are not sent to the Dripper any more. The Vault can now regulate\n    /// the increase in assets.\n    function _collectRewardTokens() internal pure override {\n        revert(\"Unsupported function\");\n    }\n}\n"
    },
    "contracts/strategies/NativeStaking/CompoundingValidatorManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Governable } from \"../../governance/Governable.sol\";\nimport { IDepositContract } from \"../../interfaces/IDepositContract.sol\";\nimport { IWETH9 } from \"../../interfaces/IWETH9.sol\";\nimport { ISSVNetwork, Cluster } from \"../../interfaces/ISSVNetwork.sol\";\nimport { BeaconRoots } from \"../../beacon/BeaconRoots.sol\";\nimport { PartialWithdrawal } from \"../../beacon/PartialWithdrawal.sol\";\nimport { IBeaconProofs } from \"../../interfaces/IBeaconProofs.sol\";\n\n/**\n * @title Validator lifecycle management contract\n * @notice This contract implements all the required functionality to\n * register, deposit, withdraw, exit and remove validators.\n * @author Origin Protocol Inc\n */\nabstract contract CompoundingValidatorManager is Governable {\n    using SafeERC20 for IERC20;\n\n    /// @notice The amount of ETH in wei that is required for a deposit to a new validator.\n    /// Initially this is 32 ETH, but will be reduced to 1 ETH after P2P's APIs have been updated\n    /// to support deposits of 1 ETH.\n    uint256 internal constant DEPOSIT_AMOUNT_WEI = 32 ether;\n    uint64 internal constant FAR_FUTURE_EPOCH = type(uint64).max;\n    uint64 internal constant SLOT_DURATION = 12;\n    uint64 internal constant SLOTS_PER_EPOCH = 32;\n\n    /// @notice The address of the Wrapped ETH (WETH) token contract\n    address public immutable WETH;\n    /// @notice The address of the beacon chain deposit contract\n    address public immutable BEACON_CHAIN_DEPOSIT_CONTRACT;\n    /// @notice The address of the SSV Network contract used to interface with\n    address public immutable SSV_NETWORK;\n    /// @notice Address of the OETH Vault proxy contract\n    address public immutable VAULT_ADDRESS;\n    /// @notice Address of the Beacon Proofs contract that verifies beacon chain data\n    address public immutable BEACON_PROOFS;\n    /// @notice The timestamp of the Beacon chain genesis.\n    /// @dev this is different on Testnets like Hoodi so is set at deployment time.\n    uint64 public immutable BEACON_GENESIS_TIMESTAMP;\n\n    /// @notice Address of the registrator - allowed to register, withdraw, exit and remove validators\n    address public validatorRegistrator;\n\n    /// Deposit data for new compounding validators.\n\n    enum DepositStatus {\n        UNKNOWN, // default value\n        PENDING, // deposit is pending and waiting to be  verified\n        VERIFIED // deposit has been verified and is ready to be staked\n    }\n    /// @param pubKeyHash Hash of validator's public key using the Beacon Chain's format\n    /// @param amountWei Amount of ETH in wei that has been deposited to the beacon chain deposit contract\n    /// @param blockNumber Block number when the deposit was made\n    /// @param depositIndex The index of the deposit in the list of active deposits\n    /// @param status The status of the deposit, either PENDING or PROVEN\n    struct DepositData {\n        bytes32 pubKeyHash;\n        uint64 amountGwei;\n        uint64 slot;\n        uint32 depositIndex;\n        DepositStatus status;\n        uint64 withdrawableEpoch;\n    }\n    /// @notice Unique identifier of the next validator deposit.\n    uint256 public nextDepositID;\n    /// @notice Mapping of the deposit ID to the deposit data\n    mapping(uint256 => DepositData) public deposits;\n    /// @notice List of strategy deposit IDs to a validator.\n    /// The list can be for deposits waiting to be verified as processed on the beacon chain,\n    /// or deposits that have been verified to an exiting validator and is now waiting for the\n    /// validator's balance to be swept.\n    /// The list may not be ordered by time of deposit.\n    /// Removed deposits will move the last deposit to the removed index.\n    uint256[] internal depositList;\n\n    // Validator data\n\n    enum VALIDATOR_STATE {\n        NON_REGISTERED, // validator is not registered on the SSV network\n        REGISTERED, // validator is registered on the SSV network\n        STAKED, // validator has funds staked\n        VERIFIED, // validator has been verified to exist on the beacon chain\n        EXITING, // The validator has been requested to exit or has been verified as forced exit\n        EXITED, // The validator has been verified to have a zero balance\n        REMOVED, // validator has funds withdrawn to the EigenPod and is removed from the SSV\n        INVALID // The validator has been front-run and the withdrawal address is not this strategy\n    }\n    struct ValidatorData {\n        VALIDATOR_STATE state;\n        uint64 index; // The index of the validator on the beacon chain\n    }\n    /// @notice List of validator public key hashes that have been verified to exist on the beacon chain.\n    /// These have had a deposit processed and the validator's balance increased.\n    /// Validators will be removed from this list when its verified they have a zero balance.\n    bytes32[] internal verifiedValidators;\n    /// @notice Mapping of the hash of the validator's public key to the validator state and index.\n    /// Uses the Beacon chain hashing for BLSPubkey which is sha256(abi.encodePacked(validator.pubkey, bytes16(0)))\n    mapping(bytes32 => ValidatorData) public validator;\n\n    /// @param timestamp Timestamp of the snapshot\n    /// @param ethBalance The balance of ETH in the strategy contract at the snapshot\n    struct Balances {\n        uint64 timestamp;\n        uint128 ethBalance;\n    }\n    /// @notice Mapping of the block root to the balances at that slot\n    mapping(bytes32 => Balances) internal snappedBalances;\n    uint64 public lastSnapTimestamp;\n    uint128 public lastVerifiedEthBalance;\n\n    /// @dev This contract receives WETH as the deposit asset, but unlike other strategies doesn't immediately\n    /// deposit it to an underlying platform. Rather a special privilege account stakes it to the validators.\n    /// For that reason calling WETH.balanceOf(this) in a deposit function can contain WETH that has just been\n    /// deposited and also WETH that has previously been deposited. To keep a correct count we need to keep track\n    /// of WETH that has already been accounted for.\n    /// This value represents the amount of WETH balance of this contract that has already been accounted for by the\n    /// deposit events.\n    /// It is important to note that this variable is not concerned with WETH that is a result of full/partial\n    /// withdrawal of the validators. It is strictly concerned with WETH that has been deposited and is waiting to\n    /// be staked.\n    uint256 public depositedWethAccountedFor;\n\n    // For future use\n    uint256[50] private __gap;\n\n    event RegistratorChanged(address indexed newAddress);\n    event StakingMonitorChanged(address indexed newAddress);\n    event SSVValidatorRegistered(\n        bytes32 indexed pubKeyHash,\n        uint64[] operatorIds\n    );\n    event SSVValidatorRemoved(bytes32 indexed pubKeyHash, uint64[] operatorIds);\n    event ETHStaked(\n        bytes32 indexed pubKeyHash,\n        uint256 indexed depositID,\n        bytes pubKey,\n        uint256 amountWei\n    );\n    event ValidatorVerified(\n        bytes32 indexed pubKeyHash,\n        uint64 indexed validatorIndex\n    );\n    event ValidatorInvalid(bytes32 indexed pubKeyHash);\n    event DepositVerified(uint256 indexed depositID, uint256 amountWei);\n    event DepositToValidatorExiting(\n        uint256 indexed depositID,\n        uint256 amountWei,\n        uint64 withdrawableEpoch\n    );\n    event DepositValidatorExited(uint256 indexed depositID, uint256 amountWei);\n    event ValidatorWithdraw(bytes32 indexed pubKeyHash, uint256 amountWei);\n    event BalancesSnapped(\n        uint256 indexed timestamp,\n        bytes32 indexed blockRoot,\n        uint256 ethBalance\n    );\n    event BalancesVerified(\n        uint64 indexed timestamp,\n        uint256 totalDepositsWei,\n        uint256 totalValidatorBalance,\n        uint256 ethBalance\n    );\n\n    /// @dev Throws if called by any account other than the Registrator\n    modifier onlyRegistrator() {\n        require(msg.sender == validatorRegistrator, \"Not Registrator\");\n        _;\n    }\n\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\n    /// @param _vaultAddress Address of the Vault\n    /// @param _beaconChainDepositContract Address of the beacon chain deposit contract\n    /// @param _ssvNetwork Address of the SSV Network contract\n    /// @param _beaconProofs Address of the Beacon Proofs contract that verifies beacon chain data\n    /// @param _beaconGenesisTimestamp The timestamp of the Beacon chain's genesis.\n    constructor(\n        address _wethAddress,\n        address _vaultAddress,\n        address _beaconChainDepositContract,\n        address _ssvNetwork,\n        address _beaconProofs,\n        uint64 _beaconGenesisTimestamp\n    ) {\n        WETH = _wethAddress;\n        BEACON_CHAIN_DEPOSIT_CONTRACT = _beaconChainDepositContract;\n        SSV_NETWORK = _ssvNetwork;\n        VAULT_ADDRESS = _vaultAddress;\n        BEACON_PROOFS = _beaconProofs;\n        BEACON_GENESIS_TIMESTAMP = _beaconGenesisTimestamp;\n\n        require(\n            block.timestamp > _beaconGenesisTimestamp,\n            \"Invalid genesis timestamp\"\n        );\n    }\n\n    /***************************************\n                Admin Functions\n    ****************************************/\n\n    /// @notice Set the address of the registrator which can register, exit and remove validators\n    function setRegistrator(address _address) external onlyGovernor {\n        validatorRegistrator = _address;\n        emit RegistratorChanged(_address);\n    }\n\n    /***************************************\n                Validator Management\n    ****************************************/\n\n    /// @notice Registers a single validator in a SSV Cluster.\n    /// Only the Registrator can call this function.\n    /// @param publicKey The public key of the validator\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param sharesData The shares data for the validator\n    /// @param ssvAmount The amount of SSV tokens to be deposited to the SSV cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    // slither-disable-start reentrancy-no-eth\n    function registerSsvValidator(\n        bytes calldata publicKey,\n        uint64[] calldata operatorIds,\n        bytes calldata sharesData,\n        uint256 ssvAmount,\n        Cluster calldata cluster\n    ) external onlyRegistrator {\n        // Hash the public key using the Beacon Chain's format\n        bytes32 pubKeyHash = _hashPubKey(publicKey);\n        // Check each public key has not already been used\n        require(\n            validator[pubKeyHash].state == VALIDATOR_STATE.NON_REGISTERED,\n            \"Validator already registered\"\n        );\n\n        // Store the validator state as registered\n        validator[pubKeyHash].state = VALIDATOR_STATE.REGISTERED;\n\n        ISSVNetwork(SSV_NETWORK).registerValidator(\n            publicKey,\n            operatorIds,\n            sharesData,\n            ssvAmount,\n            cluster\n        );\n\n        emit SSVValidatorRegistered(pubKeyHash, operatorIds);\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    struct ValidatorStakeData {\n        bytes pubkey;\n        bytes signature;\n        bytes32 depositDataRoot;\n    }\n\n    /// @notice Stakes WETH in this strategy to a compounding validator.\n    /// Does not convert any ETH sitting in this strategy to WETH.\n    /// @param validatorStakeData validator data needed to stake.\n    /// The `ValidatorStakeData` struct contains the pubkey, signature and depositDataRoot.\n    /// Only the registrator can call this function.\n    /// @param depositAmountGwei The amount of WETH to stake to the validator in Gwei.\n    // slither-disable-start reentrancy-eth\n    function stakeEth(\n        ValidatorStakeData calldata validatorStakeData,\n        uint64 depositAmountGwei\n    ) external onlyRegistrator {\n        uint256 depositAmountWei = uint256(depositAmountGwei) * 1 gwei;\n        // Check there is enough WETH from the deposits sitting in this strategy contract\n        // There could be ETH from withdrawals but we'll ignore that. If it's really needed\n        // the ETH can be withdrawn and then deposited back to the strategy.\n        require(\n            depositAmountWei <= IWETH9(WETH).balanceOf(address(this)),\n            \"Insufficient WETH\"\n        );\n\n        // Convert required ETH from WETH and do the necessary accounting\n        _convertWethToEth(depositAmountWei);\n\n        // Hash the public key using the Beacon Chain's hashing for BLSPubkey\n        bytes32 pubKeyHash = _hashPubKey(validatorStakeData.pubkey);\n        VALIDATOR_STATE currentState = validator[pubKeyHash].state;\n        // Can only stake to a validator has have been registered or verified.\n        // Can not stake to a validator that has been staked but not yet verified.\n        require(\n            (currentState == VALIDATOR_STATE.REGISTERED ||\n                currentState == VALIDATOR_STATE.VERIFIED),\n            \"Not registered or verified\"\n        );\n        require(\n            currentState == VALIDATOR_STATE.VERIFIED ||\n                depositAmountWei == DEPOSIT_AMOUNT_WEI,\n            \"Invalid first deposit amount\"\n        );\n        require(depositAmountWei >= 1 ether, \"Deposit too small\");\n\n        /* 0x02 to indicate that withdrawal credentials are for a compounding validator\n         * that was introduced with the Pectra upgrade.\n         * bytes11(0) to fill up the required zeros\n         * remaining bytes20 are for the address\n         */\n        bytes memory withdrawalCredentials = abi.encodePacked(\n            bytes1(0x02),\n            bytes11(0),\n            address(this)\n        );\n\n        // Deposit to the Beacon Chain deposit contract.\n        // This will create a deposit in the beacon chain's pending deposit queue.\n        IDepositContract(BEACON_CHAIN_DEPOSIT_CONTRACT).deposit{\n            value: depositAmountWei\n        }(\n            validatorStakeData.pubkey,\n            withdrawalCredentials,\n            validatorStakeData.signature,\n            validatorStakeData.depositDataRoot\n        );\n\n        //// Update contract storage\n        // Store the validator state if needed\n        if (currentState == VALIDATOR_STATE.REGISTERED) {\n            validator[pubKeyHash].state = VALIDATOR_STATE.STAKED;\n        }\n\n        /// After the Pectra upgrade the validators have a new restriction when proposing\n        /// blocks. The timestamps are at strict intervals of 12 seconds from the genesis block\n        /// forward. Each slot is created at strict 12 second intervals and those slots can\n        /// either have blocks attached to them or not. This way using the block.timestamp\n        /// the slot number can easily be calculated.\n        uint64 depositSlot = (SafeCast.toUint64(block.timestamp) -\n            BEACON_GENESIS_TIMESTAMP) / SLOT_DURATION;\n\n        // Store the deposit data for verifyDeposit and verifyBalances\n        uint256 depositID = nextDepositID++;\n        deposits[depositID] = DepositData({\n            pubKeyHash: pubKeyHash,\n            amountGwei: depositAmountGwei,\n            slot: depositSlot,\n            depositIndex: SafeCast.toUint32(depositList.length),\n            status: DepositStatus.PENDING,\n            withdrawableEpoch: FAR_FUTURE_EPOCH\n        });\n        depositList.push(depositID);\n\n        emit ETHStaked(\n            pubKeyHash,\n            depositID,\n            validatorStakeData.pubkey,\n            depositAmountWei\n        );\n    }\n\n    // slither-disable-end reentrancy-eth\n\n    /// @notice Request a full or partial withdrawal from a validator.\n    /// A zero amount will trigger a full withdrawal.\n    /// If the remaining balance is < 32 ETH then only the amount in excess of 32 ETH will be withdrawn.\n    /// Only the Registrator can call this function.\n    /// 1 wei of value should be sent with the tx to pay for the withdrawal request fee.\n    /// If no value sent, 1 wei will be taken from the strategy's ETH balance if it has any.\n    /// If no ETH balance, the tx will revert.\n    /// @param publicKey The public key of the validator\n    /// @param amountGwei The amount of ETH to be withdrawn from the validator in Gwei.\n    /// A zero amount will trigger a full withdrawal.\n    // slither-disable-start reentrancy-no-eth\n    function validatorWithdrawal(bytes calldata publicKey, uint64 amountGwei)\n        external\n        payable\n        onlyRegistrator\n    {\n        // Hash the public key using the Beacon Chain's format\n        bytes32 pubKeyHash = _hashPubKey(publicKey);\n        VALIDATOR_STATE currentState = validator[pubKeyHash].state;\n        require(\n            currentState == VALIDATOR_STATE.VERIFIED,\n            \"Validator not verified\"\n        );\n\n        PartialWithdrawal.request(publicKey, amountGwei);\n\n        // If a full withdrawal (validator exit)\n        if (amountGwei == 0) {\n            // Store the validator state as exiting so no more deposits can be made to it.\n            validator[pubKeyHash].state = VALIDATOR_STATE.EXITING;\n        }\n\n        // Do not remove from the list of verified validators.\n        // This is done in the verifyBalances function once the validator's balance has been verified to be zero.\n        // The validator state will be set to EXITED in the verifyBalances function.\n\n        emit ValidatorWithdraw(pubKeyHash, uint256(amountGwei) * 1 gwei);\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice Remove the validator from the SSV Cluster after:\n    /// - the validator has been exited from `validatorWithdrawal` or slashed\n    /// - the validator has incorrectly registered and can not be staked to\n    /// - the initial deposit was front-run and the withdrawal address is not this strategy's address.\n    /// Make sure `validatorWithdrawal` is called with a zero amount and the validator has exited the Beacon chain.\n    /// If removed before the validator has exited the beacon chain will result in the validator being slashed.\n    /// Only the registrator can call this function.\n    /// @param publicKey The public key of the validator\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    // slither-disable-start reentrancy-no-eth\n    function removeSsvValidator(\n        bytes calldata publicKey,\n        uint64[] calldata operatorIds,\n        Cluster calldata cluster\n    ) external onlyRegistrator {\n        // Hash the public key using the Beacon Chain's format\n        bytes32 pubKeyHash = _hashPubKey(publicKey);\n        VALIDATOR_STATE currentState = validator[pubKeyHash].state;\n        // Can remove SSV validators that were incorrectly registered and can not be deposited to.\n        require(\n            currentState == VALIDATOR_STATE.REGISTERED ||\n                currentState == VALIDATOR_STATE.EXITED ||\n                currentState == VALIDATOR_STATE.INVALID,\n            \"Validator not regd or exited\"\n        );\n\n        ISSVNetwork(SSV_NETWORK).removeValidator(\n            publicKey,\n            operatorIds,\n            cluster\n        );\n\n        validator[pubKeyHash].state = VALIDATOR_STATE.REMOVED;\n\n        emit SSVValidatorRemoved(pubKeyHash, operatorIds);\n    }\n\n    /***************************************\n                SSV Management\n    ****************************************/\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// `depositSSV` has been removed as `deposit` on the SSVNetwork contract can be called directly\n    /// by the Strategist which is already holding SSV tokens.\n\n    /// @notice Withdraws excess SSV Tokens from the SSV Network contract which was used to pay the SSV Operators.\n    /// @dev A SSV cluster is defined by the SSVOwnerAddress and the set of operatorIds.\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param ssvAmount The amount of SSV tokens to be deposited to the SSV cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    function withdrawSSV(\n        uint64[] memory operatorIds,\n        uint256 ssvAmount,\n        Cluster memory cluster\n    ) external onlyGovernor {\n        ISSVNetwork(SSV_NETWORK).withdraw(operatorIds, ssvAmount, cluster);\n    }\n\n    /***************************************\n                Beacon Chain Proofs\n    ****************************************/\n\n    /// @notice Verifies a validator's index to its public key.\n    /// Adds to the list of verified validators if the validator's withdrawal address is this strategy's address.\n    /// Marks the validator as invalid and removes the deposit if the withdrawal address is not this strategy's address.\n    /// @param nextBlockTimestamp The timestamp of the execution layer block after the beacon chain slot\n    /// we are verifying.\n    /// The next one is needed as the Beacon Oracle returns the parent beacon block root for a block timestamp,\n    /// which is the beacon block root of the previous block.\n    /// @param validatorIndex The index of the validator on the beacon chain.\n    /// @param pubKeyHash The hash of the validator's public key using the Beacon Chain's format\n    /// @param withdrawalAddress The withdrawal address of the validator which should be this strategy's address.\n    /// If the withdrawal address is not this strategy's address, the initial deposit was front-run\n    /// and the validator is marked as invalid.\n    /// @param validatorPubKeyProof The merkle proof for the validator public key to the beacon block root.\n    /// This is 53 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    /// BeaconBlock.state.validators[validatorIndex].pubkey\n    function verifyValidator(\n        uint64 nextBlockTimestamp,\n        uint64 validatorIndex,\n        bytes32 pubKeyHash,\n        address withdrawalAddress,\n        bytes calldata validatorPubKeyProof\n    ) external {\n        require(\n            validator[pubKeyHash].state == VALIDATOR_STATE.STAKED,\n            \"Validator not staked\"\n        );\n        // Get the beacon block root of the slot we are verifying the validator in.\n        // The parent beacon block root of the next block is the beacon block root of the slot we are verifying.\n        bytes32 blockRoot = BeaconRoots.parentBlockRoot(nextBlockTimestamp);\n\n        // Verify the validator index is for the validator with the given public key.\n        // Also verify the validator's withdrawal credential points to the `withdrawalAddress`.\n        IBeaconProofs(BEACON_PROOFS).verifyValidator(\n            blockRoot,\n            pubKeyHash,\n            validatorPubKeyProof,\n            validatorIndex,\n            withdrawalAddress\n        );\n\n        // If the initial deposit was front-run and the withdrawal address is not this strategy\n        if (withdrawalAddress != address(this)) {\n            validator[pubKeyHash] = ValidatorData({\n                state: VALIDATOR_STATE.INVALID,\n                index: validatorIndex\n            });\n\n            // Find and remove the deposit as the funds can not be recovered\n            uint256 depositCount = depositList.length;\n            for (uint256 i = 0; i < depositCount; i++) {\n                DepositData memory deposit = deposits[depositList[i]];\n                if (deposit.pubKeyHash == pubKeyHash) {\n                    _removeDeposit(depositList[i], deposit);\n                    break;\n                }\n            }\n\n            emit ValidatorInvalid(pubKeyHash);\n            return;\n        }\n\n        // Store the validator state as verified\n        validator[pubKeyHash] = ValidatorData({\n            state: VALIDATOR_STATE.VERIFIED,\n            index: validatorIndex\n        });\n\n        // Add the new validator to the list of verified validators\n        verifiedValidators.push(pubKeyHash);\n\n        emit ValidatorVerified(pubKeyHash, validatorIndex);\n    }\n\n    struct FirstPendingDepositProofData {\n        uint64 slot;\n        uint64 validatorIndex;\n        bytes32 pubKeyHash;\n        bytes pendingDepositPubKeyProof;\n        bytes withdrawableEpochProof;\n        bytes validatorPubKeyProof;\n    }\n\n    struct DepositValidatorProofData {\n        uint64 withdrawableEpoch;\n        bytes withdrawableEpochProof;\n    }\n\n    /// @notice Verifies a deposit on the execution layer has been processed by the beacon chain.\n    /// This means the accounting of the strategy's ETH moves from a pending deposit to a validator balance.\n    ///\n    /// Important: this function has a limitation where the `verificationSlot` that is passed by the off-chain\n    /// verifier requires a slot immediately after it to propose a block otherwise the `BeaconRoots.parentBlockRoot`\n    /// will fail. This shouldn't be a problem, since by the current behaviour of beacon chain only 1%-3% slots\n    /// don't propose a block.\n    /// @param depositID The deposit ID emitted in `ETHStaked` from the `stakeEth` function.\n    /// @param depositProcessedSlot Any slot on or after the strategy's deposit was processed on the beacon chain.\n    /// Can not be a slot with pending deposits with the same slot as the deposit being verified.\n    /// Can not be a slot before a missed slot as the Beacon Root contract will have the parent block root\n    /// set for the next block timestamp in 12 seconds time.\n    /// @param firstDepositValidatorCreatedSlot The slot on or after when the validator of the first pending deposit\n    /// was created on the beacon chain. This is used to verify the validator has not exited.\n    // slither-disable-start reentrancy-no-eth\n    function verifyDeposit(\n        uint256 depositID,\n        uint64 depositProcessedSlot,\n        uint64 firstDepositValidatorCreatedSlot,\n        FirstPendingDepositProofData calldata firstPendingDeposit,\n        DepositValidatorProofData calldata strategyValidatorData\n    ) external {\n        // Load into memory the previously saved deposit data\n        DepositData memory deposit = deposits[depositID];\n        ValidatorData memory strategyValidator = validator[deposit.pubKeyHash];\n        require(deposit.status == DepositStatus.PENDING, \"Deposit not pending\");\n        require(\n            strategyValidator.state == VALIDATOR_STATE.VERIFIED,\n            \"Validator not verified\"\n        );\n        // The verification slot must be after the deposit's slot.\n        // This is needed for when the deposit queue is empty.\n        require(deposit.slot < depositProcessedSlot, \"Slot not after deposit\");\n        require(\n            depositProcessedSlot <= firstDepositValidatorCreatedSlot,\n            \"Invalid verification slots\"\n        );\n\n        // Get the parent beacon block root of the next block which is the block root of the deposit verification slot.\n        // This will revert if the slot after the verification slot was missed.\n        bytes32 depositBlockRoot = BeaconRoots.parentBlockRoot(\n            _calcNextBlockTimestamp(depositProcessedSlot)\n        );\n\n        // Verify the slot of the first pending deposit matches the beacon chain\n        bool isDepositQueueEmpty = IBeaconProofs(BEACON_PROOFS)\n            .verifyFirstPendingDeposit(\n                depositBlockRoot,\n                firstPendingDeposit.slot,\n                firstPendingDeposit.pubKeyHash,\n                firstPendingDeposit.pendingDepositPubKeyProof\n            );\n\n        // If the deposit queue is not empty\n        if (!isDepositQueueEmpty) {\n            // Get the parent beacon block root of the next block which is\n            // the block root of the validator verification slot.\n            // This will revert if the slot after the verification slot was missed.\n            bytes32 validatorBlockRoot = BeaconRoots.parentBlockRoot(\n                _calcNextBlockTimestamp(firstDepositValidatorCreatedSlot)\n            );\n\n            // Verify the validator of the first pending deposit is not exiting.\n            // If it is exiting we can't be sure this deposit has not been postponed in the deposit queue.\n            // Hence we can not verify if the strategy's deposit has been processed or not.\n            IBeaconProofs(BEACON_PROOFS).verifyValidatorWithdrawable(\n                validatorBlockRoot,\n                firstPendingDeposit.validatorIndex,\n                firstPendingDeposit.pubKeyHash,\n                FAR_FUTURE_EPOCH,\n                firstPendingDeposit.withdrawableEpochProof,\n                firstPendingDeposit.validatorPubKeyProof\n            );\n        }\n\n        // Verify the withdrawableEpoch on the validator of the strategy's deposit\n        IBeaconProofs(BEACON_PROOFS).verifyValidatorWithdrawable(\n            depositBlockRoot,\n            strategyValidator.index,\n            strategyValidatorData.withdrawableEpoch,\n            strategyValidatorData.withdrawableEpochProof\n        );\n\n        // If the validator is exiting because it has been slashed\n        if (strategyValidatorData.withdrawableEpoch != FAR_FUTURE_EPOCH) {\n            // Store the exit epoch in the deposit data\n            deposit.withdrawableEpoch = strategyValidatorData.withdrawableEpoch;\n\n            emit DepositToValidatorExiting(\n                depositID,\n                uint256(deposit.amountGwei) * 1 gwei,\n                strategyValidatorData.withdrawableEpoch\n            );\n\n            // Leave the deposit status as PENDING\n            return;\n        }\n\n        // solhint-disable max-line-length\n        // Check the deposit slot is before the first pending deposit's slot on the beacon chain.\n        // If this is not true then we can't guarantee the deposit has been processed by the beacon chain.\n        // The deposit's slot can not be the same slot as the first pending deposit as there could be\n        // many deposits in the same block, hence have the same pending deposit slot.\n        // If the deposit queue is empty then our deposit must have been processed on the beacon chain.\n        // The deposit slot can be zero for validators consolidating to a compounding validator or 0x01 validator\n        // being promoted to a compounding one. Reference:\n        // - [switch_to_compounding_validator](https://ethereum.github.io/consensus-specs/specs/electra/beacon-chain/#new-switch_to_compounding_validator\n        // - [queue_excess_active_balance](https://ethereum.github.io/consensus-specs/specs/electra/beacon-chain/#new-queue_excess_active_balance)\n        // - [process_consolidation_request](https://ethereum.github.io/consensus-specs/specs/electra/beacon-chain/#new-process_consolidation_request)\n        // We can not guarantee that the deposit has been processed in that case.\n        // solhint-enable max-line-length\n        require(\n            deposit.slot < firstPendingDeposit.slot || isDepositQueueEmpty,\n            \"Deposit likely not processed\"\n        );\n\n        // Remove the deposit now it has been verified as processed on the beacon chain.\n        _removeDeposit(depositID, deposit);\n\n        emit DepositVerified(depositID, uint256(deposit.amountGwei) * 1 gwei);\n    }\n\n    function _removeDeposit(uint256 depositID, DepositData memory deposit)\n        internal\n    {\n        // After verifying the proof, update the contract storage\n        deposits[depositID].status = DepositStatus.VERIFIED;\n        // Move the last deposit to the index of the verified deposit\n        uint256 lastDeposit = depositList[depositList.length - 1];\n        depositList[deposit.depositIndex] = lastDeposit;\n        deposits[lastDeposit].depositIndex = deposit.depositIndex;\n        // Delete the last deposit from the list\n        depositList.pop();\n    }\n\n    /// @dev Calculates the timestamp of the next execution block from the given slot.\n    /// @param slot The beacon chain slot number used for merkle proof verification.\n    function _calcNextBlockTimestamp(uint64 slot)\n        internal\n        view\n        returns (uint64)\n    {\n        // Calculate the next block timestamp from the slot.\n        return SLOT_DURATION * slot + BEACON_GENESIS_TIMESTAMP + SLOT_DURATION;\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice Stores the current ETH balance at the current block and beacon block root\n    ///         of the slot that is associated with the previous block.\n    ///\n    /// When snapping / verifying balance it is of a high importance that there is no\n    /// miss-match in respect to ETH that is held by the contract and balances that are\n    /// verified on the validators.\n    ///\n    /// First some context on the beacon-chain block building behaviour. Relevant parts of\n    /// constructing a block on the beacon chain consist of:\n    ///  - process_withdrawals: ETH is deducted from the validator's balance\n    ///  - process_execution_payload: immediately after the previous step executing all the\n    ///    transactions\n    ///  - apply the withdrawals: adding ETH to the recipient which is the withdrawal address\n    ///    contained in the withdrawal credentials of the exited validators\n    ///\n    /// That means that balance increases which are part of the post-block execution state are\n    /// done within the block, but the transaction that are contained within that block can not\n    /// see / interact with the balance from the exited validators. Only transactions in the\n    /// next block can do that.\n    ///\n    /// When snap balances is performed the state of the chain is snapped across 2 separate\n    /// chain states:\n    ///  - ETH balance of the contract is recorded on block X -> and corresponding slot Y\n    ///  - beacon chain block root is recorded of block X - 1 -> and corresponding slot Y - 1\n    ///    given there were no missed slots. It could also be Y - 2, Y - 3 depending on how\n    ///    many slots have not managed to propose a block. For the sake of simplicity this slot\n    ///    will be referred to as Y - 1 as it makes no difference in the argument\n    ///\n    /// Given these 2 separate chain states it is paramount that verify balances can not experience\n    /// miss-counting ETH or much more dangerous double counting of the ETH.\n    ///\n    /// When verifyBalances is called it is performed on the current block Z where Z > X. Verify\n    /// balances adds up all the ETH (omitting WETH) controlled by this contract:\n    ///  - ETH balance in the contract on block X\n    ///  - ETH balance in Deposits on block Z that haven't been yet processed in slot Y - 1\n    ///  - ETH balance in validators that are active in slot Y - 1\n    ///  - skips the ETH balance in validators that have withdrawn in slot Y - 1 (or sooner)\n    ///    and have their balance visible to transactions in slot Y and corresponding block X\n    ///    (or sooner)\n    ///\n    /// Lets verify the correctness of ETH accounting given the above described behaviour.\n    ///\n    /// *ETH balance in the contract on block X*\n    ///\n    /// This is an ETH balance of the contract on a non current X block. Any ETH leaving the\n    /// contract as a result of a withdrawal subtracts from the ETH accounted for on block X\n    /// if `verifyBalances` has already been called. It also invalidates a `snapBalances` in\n    /// case `verifyBalances` has not been called yet. Not performing this would result in not\n    /// accounting for the withdrawn ETH that has happened anywhere in the block interval [X + 1, Z].\n    ///\n    /// Similarly to withdrawals any `stakeEth` deposits to the deposit contract adds to the ETH\n    /// accounted for since the last `verifyBalances` has been called. And it invalidates the\n    /// `snapBalances` in case `verifyBalances` hasn't been yet called. Not performing this\n    /// would result in double counting the `stakedEth` since it would be present once in the\n    /// snapped contract balance and the second time in deposit storage variables.\n    ///\n    /// This behaviour is correct.\n    ///\n    /// *ETH balance in Deposits on block Z that haven't been yet processed in slot Y - 1*\n    ///\n    /// The contract sums up all the ETH that has been deposited to the Beacon chain deposit\n    /// contract at block Z. The execution layer doesn't have direct access to the state of\n    /// deposits on the beacon chain. And if it is to sum up all the ETH that is marked to be\n    /// deposited it needs to be sure to not double count ETH that is in deposits (storage vars)\n    /// and could also be part of the validator balances. It does that by verifying that at\n    /// slot Y - 1 none of the deposits visible on block Z have been processed. Meaning since\n    /// the last snap till now all are still in queue. Which ensures they can not be part of\n    /// the validator balances in later steps.\n    ///\n    /// This behaviour is correct.\n    ///\n    /// *ETH balance in validators that are active in slot Y - 1*\n    ///\n    /// The contract is verifying none of the deposits on Y - 1 slot have been processed and\n    /// for that reason it checks the validator balances in the same slot. Ensuring accounting\n    /// correctness.\n    ///\n    /// This behaviour is correct.\n    ///\n    /// *The withdrawn validators*\n    ///\n    /// The withdrawn validators could have their balances deducted in any slot before slot\n    /// Y - 1 and the execution layer sees the balance increase in the subsequent slot. Lets\n    /// look at the \"worst case scenario\" where the validator withdrawal is processed in the\n    /// slot Y - 1 (snapped slot) and see their balance increase (in execution layer) in slot\n    /// Y -> block X. The ETH balance on the contract is snapped at block X meaning that\n    /// even if the validator exits at the latest possible time it is paramount that the ETH\n    /// balance on the execution layer is recorded in the next block. Correctly accounting\n    /// for the withdrawn ETH.\n    ///\n    /// Worth mentioning if the validator exit is processed by the slot Y and balance increase\n    /// seen on the execution layer on block X + 1 the withdrawal is ignored by both the\n    /// validator balance verification as well as execution layer contract balance snap.\n    ///\n    /// This behaviour is correct.\n    ///\n    /// The validator balances on the beacon chain can then be proved with `verifyBalances`.\n    /// Can only be called by the registrator.\n    function snapBalances() external onlyRegistrator {\n        _snapBalances();\n    }\n\n    function _snapBalances() internal {\n        bytes32 blockRoot = BeaconRoots.parentBlockRoot(\n            SafeCast.toUint64(block.timestamp)\n        );\n        // Get the current ETH balance\n        uint256 ethBalance = address(this).balance;\n\n        // Store the balances in the mapping\n        snappedBalances[blockRoot] = Balances({\n            timestamp: SafeCast.toUint64(block.timestamp),\n            ethBalance: SafeCast.toUint128(ethBalance)\n        });\n\n        // Store the snapped timestamp\n        lastSnapTimestamp = SafeCast.toUint64(block.timestamp);\n\n        emit BalancesSnapped(block.timestamp, blockRoot, ethBalance);\n    }\n\n    // A struct is used to avoid stack too deep errors\n    struct BalanceProofs {\n        // BeaconBlock.state.balances\n        bytes32 balancesContainerRoot;\n        bytes balancesContainerProof;\n        // BeaconBlock.state.balances[validatorIndex]\n        bytes32[] validatorBalanceLeaves;\n        bytes[] validatorBalanceProofs;\n    }\n\n    /// @notice Verifies the balances of all active validators on the beacon chain\n    /// and checks no pending deposits have been processed by the beacon chain.\n    /// @param snapBlockRoot The beacon block root emitted from `snapBalance` in `BalancesSnapped`.\n    /// @param balanceProofs a `BalanceProofs` struct containing the following:\n    /// balancesContainerRoot - the merkle root of the balances container\n    /// balancesContainerProof - The merkle proof for the balances container to the beacon block root.\n    ///   This is 9 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    /// validatorBalanceLeaves - Array of leaf nodes containing the validator balance with three other balances.\n    /// validatorBalanceProofs -  Array of merkle proofs for the validator balance to the Balances container root.\n    ///   This is 39 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    // slither-disable-start reentrancy-no-eth\n    function verifyBalances(\n        bytes32 snapBlockRoot,\n        uint64 validatorVerificationBlockTimestamp,\n        FirstPendingDepositProofData calldata firstPendingDeposit,\n        BalanceProofs calldata balanceProofs\n    ) external {\n        // Load previously snapped balances for the given block root\n        Balances memory balancesMem = snappedBalances[snapBlockRoot];\n        // Check the balances are the latest\n        require(lastSnapTimestamp > 0, \"No snapped balances\");\n        require(balancesMem.timestamp == lastSnapTimestamp, \"Stale snap\");\n\n        uint256 verifiedValidatorsCount = verifiedValidators.length;\n        uint256 totalValidatorBalance = 0;\n\n        // If there are no verified validators then we can skip the balance verification\n        if (verifiedValidatorsCount > 0) {\n            require(\n                balanceProofs.validatorBalanceProofs.length ==\n                    verifiedValidatorsCount,\n                \"Invalid balance proofs\"\n            );\n            require(\n                balanceProofs.validatorBalanceLeaves.length ==\n                    verifiedValidatorsCount,\n                \"Invalid balance leaves\"\n            );\n            // verify beaconBlock.state.balances root to beacon block root\n            IBeaconProofs(BEACON_PROOFS).verifyBalancesContainer(\n                snapBlockRoot,\n                balanceProofs.balancesContainerRoot,\n                balanceProofs.balancesContainerProof\n            );\n\n            // for each validator in reserve order so we can pop off exited validators at the end\n            for (uint256 i = verifiedValidatorsCount; i > 0; ) {\n                --i;\n                // verify validator's balance in beaconBlock.state.balances to the\n                // beaconBlock.state.balances container root\n                uint256 validatorBalanceGwei = IBeaconProofs(BEACON_PROOFS)\n                    .verifyValidatorBalance(\n                        balanceProofs.balancesContainerRoot,\n                        balanceProofs.validatorBalanceLeaves[i],\n                        balanceProofs.validatorBalanceProofs[i],\n                        validator[verifiedValidators[i]].index\n                    );\n\n                // If the validator balance is zero\n                if (validatorBalanceGwei == 0) {\n                    // Store the validator state as exited\n                    // This could have been in VERIFIED or EXITING state\n                    validator[verifiedValidators[i]].state = VALIDATOR_STATE\n                        .EXITED;\n\n                    // Remove the validator with a zero balance from the list of verified validators\n\n                    // Reduce the count of verified validators which is the last index before the pop removes it.\n                    verifiedValidatorsCount -= 1;\n\n                    // Move the last validator that has already been verified to the current index.\n                    // There's an extra SSTORE if i is the last active validator but that's fine,\n                    // It's not a common case and the code is simpler this way.\n                    verifiedValidators[i] = verifiedValidators[\n                        verifiedValidatorsCount\n                    ];\n                    // Delete the last validator from the list\n                    verifiedValidators.pop();\n\n                    // The validator balance is zero so not need to add to totalValidatorBalance\n                    continue;\n                }\n\n                // convert Gwei balance to Wei and add to the total validator balance\n                totalValidatorBalance += uint256(validatorBalanceGwei) * 1 gwei;\n            }\n        }\n\n        uint256 depositsCount = depositList.length;\n        uint256 totalDepositsWei = 0;\n\n        // If there are no deposits then we can skip the deposit verification.\n        // This section is after the validator balance verifications so an exited validator will be marked\n        // as EXITED before the deposits are verified. If there was a deposit to an exited validator\n        // then the deposit can only be removed once the validator is fully exited.\n        if (depositsCount > 0) {\n            // Verify the slot of the first pending deposit matches the beacon chain\n            bool isDepositQueueEmpty = IBeaconProofs(BEACON_PROOFS)\n                .verifyFirstPendingDeposit(\n                    snapBlockRoot,\n                    firstPendingDeposit.slot,\n                    firstPendingDeposit.pubKeyHash,\n                    firstPendingDeposit.pendingDepositPubKeyProof\n                );\n\n            // If there are no deposits in the beacon chain queue then our deposits must have been processed.\n            // If the deposits have been processed, each deposit will need to be verified with `verifyDeposit`\n            require(!isDepositQueueEmpty, \"Deposits have been processed\");\n\n            // The verification of the validator the first pending deposit is for must be on or after when\n            // `snapBalances` was called.\n            require(\n                balancesMem.timestamp <= validatorVerificationBlockTimestamp,\n                \"Invalid validator timestamp\"\n            );\n\n            // Verify the validator of the first pending deposit is not exiting by checking\n            // the withdrawable epoch is far into the future.\n            // If it is exiting we can't be sure this deposit has not been postponed in the deposit queue.\n            // Hence we can not verify if the strategy's deposit has been processed or not.\n            IBeaconProofs(BEACON_PROOFS).verifyValidatorWithdrawable(\n                // Get the parent beacon block root of the next block which is\n                // the block root of the validator verification slot.\n                // This will revert if the slot after the verification slot was missed.\n                BeaconRoots.parentBlockRoot(\n                    validatorVerificationBlockTimestamp\n                ),\n                firstPendingDeposit.validatorIndex,\n                firstPendingDeposit.pubKeyHash,\n                // Validator is not exiting\n                FAR_FUTURE_EPOCH,\n                firstPendingDeposit.withdrawableEpochProof,\n                firstPendingDeposit.validatorPubKeyProof\n            );\n\n            // solhint-disable max-line-length\n            // If a validator is converted from a sweeping validator to a compounding validator, any balance in excess\n            // of the min 32 ETH is put in the pending deposit queue. Reference:\n            // - [switch_to_compounding_validator](https://ethereum.github.io/consensus-specs/specs/electra/beacon-chain/#new-switch_to_compounding_validator\n            // - [queue_excess_active_balance](https://ethereum.github.io/consensus-specs/specs/electra/beacon-chain/#new-queue_excess_active_balance)\n            // - [process_consolidation_request](https://ethereum.github.io/consensus-specs/specs/electra/beacon-chain/#new-process_consolidation_request)\n            // This will have a slot value of zero unfortunately.\n            // We can not prove the strategy's deposits are still pending with a zero slot value so revert the tx.\n            // Another snapBalances will need to be taken that does not have consolidation deposits at the front of the\n            // beacon chain deposit queue.\n            // solhint-enable max-line-length\n            require(\n                firstPendingDeposit.slot > 0,\n                \"Invalid first pending deposit\"\n            );\n\n            // Calculate the epoch at the time of the snapBalances\n            uint64 verificationEpoch = (SafeCast.toUint64(\n                balancesMem.timestamp\n            ) - BEACON_GENESIS_TIMESTAMP) / (SLOT_DURATION * SLOTS_PER_EPOCH);\n\n            // For each staking strategy's deposits\n            for (uint256 i = 0; i < depositsCount; ++i) {\n                uint256 depositID = depositList[i];\n                DepositData memory depositData = deposits[depositID];\n\n                // Check the stored deposit is still waiting to be processed on the beacon chain.\n                // That is, the first pending deposit slot is before the slot of the staking strategy's deposit.\n                // If the deposit has been processed, it will need to be verified with `verifyDeposit`.\n                // OR the deposit is to an exiting validator so check it is still not withdrawable.\n                // If the validator is not withdrawable, then the deposit can not have been processed yet.\n                // If the validator is now withdrawable, then the deposit may have been processed. The strategy\n                // now has to wait until the validator's balance is verified to be zero.\n                require(\n                    firstPendingDeposit.slot < depositData.slot ||\n                        (validator[depositData.pubKeyHash].state ==\n                            VALIDATOR_STATE.EXITED &&\n                            verificationEpoch < depositData.withdrawableEpoch),\n                    \"Deposit likely processed\"\n                );\n\n                // Convert the deposit amount from Gwei to Wei and add to the total\n                totalDepositsWei += uint256(depositData.amountGwei) * 1 gwei;\n\n                // Remove the deposit if the validator has exited.\n                if (\n                    validator[depositData.pubKeyHash].state ==\n                    VALIDATOR_STATE.EXITED\n                ) {\n                    _removeDeposit(depositID, depositData);\n\n                    emit DepositValidatorExited(\n                        depositID,\n                        uint256(depositData.amountGwei) * 1 gwei\n                    );\n                }\n            }\n        }\n\n        // Store the verified balance in storage\n        lastVerifiedEthBalance = SafeCast.toUint128(\n            totalDepositsWei + totalValidatorBalance + balancesMem.ethBalance\n        );\n        // Reset the last snap timestamp so a new snapBalances has to be made\n        lastSnapTimestamp = 0;\n\n        emit BalancesVerified(\n            balancesMem.timestamp,\n            totalDepositsWei,\n            totalValidatorBalance,\n            balancesMem.ethBalance\n        );\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice Hash a validator public key using the Beacon Chain's format\n    function _hashPubKey(bytes memory pubKey) internal pure returns (bytes32) {\n        require(pubKey.length == 48, \"Invalid public key length\");\n        return sha256(abi.encodePacked(pubKey, bytes16(0)));\n    }\n\n    /***************************************\n            WETH and ETH Accounting\n    ****************************************/\n\n    /// @dev Called when WETH is transferred out of the strategy so\n    /// the strategy knows how much WETH it has on deposit.\n    /// This is so it can emit the correct amount in the Deposit event in depositAll().\n    function _transferWeth(uint256 _amount, address _recipient) internal {\n        IERC20(WETH).safeTransfer(_recipient, _amount);\n\n        // The min is required as more WETH can be withdrawn than deposited\n        // as the strategy earns consensus and execution rewards.\n        uint256 deductAmount = Math.min(_amount, depositedWethAccountedFor);\n        depositedWethAccountedFor -= deductAmount;\n\n        // No change in ETH balance so no need to snapshot the balances\n    }\n\n    /// @dev Converts ETH to WETH and updates the accounting.\n    /// @param _ethAmount The amount of ETH in wei.\n    function _convertEthToWeth(uint256 _ethAmount) internal {\n        // slither-disable-next-line arbitrary-send-eth\n        IWETH9(WETH).deposit{ value: _ethAmount }();\n\n        depositedWethAccountedFor += _ethAmount;\n\n        // Store the reduced ETH balance.\n        // The ETH balance in this strategy contract can be more than the last verified ETH balance\n        // due to partial withdrawals or full exits being processed by the beacon chain since the last snapBalances.\n        // It can also happen from execution rewards (MEV) or ETH donations.\n        lastVerifiedEthBalance -= SafeCast.toUint128(\n            Math.min(uint256(lastVerifiedEthBalance), _ethAmount)\n        );\n\n        // The ETH balance was decreased to WETH so we need to invalidate the last balances snap.\n        lastSnapTimestamp = 0;\n    }\n\n    /// @dev Converts WETH to ETH and updates the accounting.\n    /// @param _wethAmount The amount of WETH in wei.\n    function _convertWethToEth(uint256 _wethAmount) internal {\n        IWETH9(WETH).withdraw(_wethAmount);\n\n        uint256 deductAmount = Math.min(_wethAmount, depositedWethAccountedFor);\n        depositedWethAccountedFor -= deductAmount;\n\n        // Store the increased ETH balance\n        lastVerifiedEthBalance += SafeCast.toUint128(_wethAmount);\n\n        // The ETH balance was increased from WETH so we need to invalidate the last balances snap.\n        lastSnapTimestamp = 0;\n    }\n\n    /***************************************\n                View Functions\n    ****************************************/\n\n    struct ValidatorView {\n        bytes32 pubKeyHash;\n        uint64 index;\n        VALIDATOR_STATE state;\n    }\n\n    /// @notice Returns the strategy's active validators.\n    /// These are the ones that have been verified and have a non-zero balance.\n    /// @return validators An array of `ValidatorView` containing the public key hash, validator index and state.\n    function getVerifiedValidators()\n        external\n        view\n        returns (ValidatorView[] memory validators)\n    {\n        uint256 validatorCount = verifiedValidators.length;\n        validators = new ValidatorView[](validatorCount);\n        for (uint256 i = 0; i < validatorCount; ++i) {\n            bytes32 pubKeyHash = verifiedValidators[i];\n            ValidatorData memory validatorData = validator[pubKeyHash];\n            validators[i] = ValidatorView({\n                pubKeyHash: pubKeyHash,\n                index: validatorData.index,\n                state: validatorData.state\n            });\n        }\n    }\n\n    struct DepositView {\n        uint256 depositID;\n        bytes32 pubKeyHash;\n        uint64 amountGwei;\n        uint64 slot;\n        uint256 withdrawableEpoch;\n    }\n\n    /// @notice Returns the deposits that are still to be verified.\n    /// These may or may not have been processed by the beacon chain.\n    /// @return pendingDeposits An array of `DepositView` containing the deposit ID, public key hash,\n    /// amount in Gwei and the slot of the deposit.\n    function getPendingDeposits()\n        external\n        view\n        returns (DepositView[] memory pendingDeposits)\n    {\n        uint256 depositsCount = depositList.length;\n        pendingDeposits = new DepositView[](depositsCount);\n        for (uint256 i = 0; i < depositsCount; ++i) {\n            DepositData memory deposit = deposits[depositList[i]];\n            pendingDeposits[i] = DepositView({\n                depositID: depositList[i],\n                pubKeyHash: deposit.pubKeyHash,\n                amountGwei: deposit.amountGwei,\n                slot: deposit.slot,\n                withdrawableEpoch: deposit.withdrawableEpoch\n            });\n        }\n    }\n}\n"
    },
    "contracts/strategies/NativeStaking/FeeAccumulator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title Fee Accumulator for Native Staking SSV Strategy\n * @notice Receives execution rewards which includes tx fees and\n * MEV rewards like tx priority and tx ordering.\n * It does NOT include swept ETH from beacon chain consensus rewards or full validator withdrawals.\n * @author Origin Protocol Inc\n */\ncontract FeeAccumulator {\n    /// @notice The address of the Native Staking Strategy\n    address public immutable STRATEGY;\n\n    event ExecutionRewardsCollected(address indexed strategy, uint256 amount);\n\n    /**\n     * @param _strategy Address of the Native Staking Strategy\n     */\n    constructor(address _strategy) {\n        STRATEGY = _strategy;\n    }\n\n    /**\n     * @notice sends all ETH in this FeeAccumulator contract to the Native Staking Strategy.\n     * @return eth The amount of execution rewards that were sent to the Native Staking Strategy\n     */\n    function collect() external returns (uint256 eth) {\n        require(msg.sender == STRATEGY, \"Caller is not the Strategy\");\n\n        eth = address(this).balance;\n        if (eth > 0) {\n            // Send the ETH to the Native Staking Strategy\n            Address.sendValue(payable(STRATEGY), eth);\n\n            emit ExecutionRewardsCollected(STRATEGY, eth);\n        }\n    }\n\n    /**\n     * @dev Accept ETH\n     */\n    receive() external payable {}\n}\n"
    },
    "contracts/strategies/NativeStaking/NativeStakingSSVStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { IWETH9 } from \"../../interfaces/IWETH9.sol\";\nimport { FeeAccumulator } from \"./FeeAccumulator.sol\";\nimport { ValidatorAccountant } from \"./ValidatorAccountant.sol\";\nimport { ISSVNetwork } from \"../../interfaces/ISSVNetwork.sol\";\n\nstruct ValidatorStakeData {\n    bytes pubkey;\n    bytes signature;\n    bytes32 depositDataRoot;\n}\n\n/// @title Native Staking SSV Strategy\n/// @notice Strategy to deploy funds into DVT validators powered by the SSV Network\n/// @author Origin Protocol Inc\n/// @dev This contract handles WETH and ETH and in some operations interchanges between the two. Any WETH that\n/// is on the contract across multiple blocks (and not just transitory within a transaction) is considered an\n/// asset. Meaning deposits increase the balance of the asset and withdrawal decrease it. As opposed to all\n/// our other strategies the WETH doesn't immediately get deposited into an underlying strategy and can be present\n/// across multiple blocks waiting to be unwrapped to ETH and staked to validators. This separation of WETH and ETH is\n/// required since the rewards (reward token) is also in ETH.\n///\n/// To simplify the accounting of WETH there is another difference in behavior compared to the other strategies.\n/// To withdraw WETH asset - exit message is posted to validators and the ETH hits this contract with multiple days\n/// delay. In order to simplify the WETH accounting upon detection of such an event the ValidatorAccountant\n/// immediately wraps ETH to WETH and sends it to the Vault.\n///\n/// On the other hand any ETH on the contract (across multiple blocks) is there either:\n///  - as a result of already accounted for consensus rewards\n///  - as a result of not yet accounted for consensus rewards\n///  - as a results of not yet accounted for full validator withdrawals (or validator slashes)\n///\n/// Even though the strategy assets and rewards are a very similar asset the consensus layer rewards and the\n/// execution layer rewards are considered rewards and those are dripped to the Vault over a configurable time\n/// interval and not immediately.\ncontract NativeStakingSSVStrategy is\n    ValidatorAccountant,\n    InitializableAbstractStrategy\n{\n    using SafeERC20 for IERC20;\n\n    /// @notice SSV ERC20 token that serves as a payment for operating SSV validators\n    address public immutable SSV_TOKEN;\n    /// @notice Fee collector address\n    /// @dev this address will receive maximal extractable value (MEV) rewards. These are\n    /// rewards for arranging transactions in a way that benefits the validator.\n    address payable public immutable FEE_ACCUMULATOR_ADDRESS;\n\n    /// @dev This contract receives WETH as the deposit asset, but unlike other strategies doesn't immediately\n    /// deposit it to an underlying platform. Rather a special privilege account stakes it to the validators.\n    /// For that reason calling WETH.balanceOf(this) in a deposit function can contain WETH that has just been\n    /// deposited and also WETH that has previously been deposited. To keep a correct count we need to keep track\n    /// of WETH that has already been accounted for.\n    /// This value represents the amount of WETH balance of this contract that has already been accounted for by the\n    /// deposit events.\n    /// It is important to note that this variable is not concerned with WETH that is a result of full/partial\n    /// withdrawal of the validators. It is strictly concerned with WETH that has been deposited and is waiting to\n    /// be staked.\n    uint256 public depositedWethAccountedFor;\n\n    // For future use\n    uint256[49] private __gap;\n\n    /// @param _baseConfig Base strategy config with platformAddress (ERC-4626 Vault contract), eg sfrxETH or sDAI,\n    /// and vaultAddress (OToken Vault contract), eg VaultProxy or OETHVaultProxy\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\n    /// @param _ssvToken Address of the Erc20 SSV Token contract\n    /// @param _ssvNetwork Address of the SSV Network contract\n    /// @param _maxValidators Maximum number of validators that can be registered in the strategy\n    /// @param _feeAccumulator Address of the fee accumulator receiving execution layer validator rewards\n    /// @param _beaconChainDepositContract Address of the beacon chain deposit contract\n    constructor(\n        BaseStrategyConfig memory _baseConfig,\n        address _wethAddress,\n        address _ssvToken,\n        address _ssvNetwork,\n        uint256 _maxValidators,\n        address _feeAccumulator,\n        address _beaconChainDepositContract\n    )\n        InitializableAbstractStrategy(_baseConfig)\n        ValidatorAccountant(\n            _wethAddress,\n            _baseConfig.vaultAddress,\n            _beaconChainDepositContract,\n            _ssvNetwork,\n            _maxValidators\n        )\n    {\n        SSV_TOKEN = _ssvToken;\n        FEE_ACCUMULATOR_ADDRESS = payable(_feeAccumulator);\n    }\n\n    /// @notice Set up initial internal state including\n    /// 1. approving the SSVNetwork to transfer SSV tokens from this strategy contract\n    /// 2. setting the recipient of SSV validator MEV rewards to the FeeAccumulator contract.\n    /// @param _rewardTokenAddresses Address of reward token for platform\n    /// @param _assets Addresses of initial supported assets\n    /// @param _pTokens Platform Token corresponding addresses\n    function initialize(\n        address[] memory _rewardTokenAddresses,\n        address[] memory _assets,\n        address[] memory _pTokens\n    ) external onlyGovernor initializer {\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n\n        // Approves the SSV Network contract to transfer SSV tokens for deposits\n        IERC20(SSV_TOKEN).approve(SSV_NETWORK, type(uint256).max);\n\n        // Set the FeeAccumulator as the address for SSV validators to send MEV rewards to\n        ISSVNetwork(SSV_NETWORK).setFeeRecipientAddress(\n            FEE_ACCUMULATOR_ADDRESS\n        );\n    }\n\n    /// @notice Unlike other strategies, this does not deposit assets into the underlying platform.\n    /// It just checks the asset is WETH and emits the Deposit event.\n    /// To deposit WETH into validators `registerSsvValidator` and `stakeEth` must be used.\n    /// Will NOT revert if the strategy is paused from an accounting failure.\n    /// @param _asset Address of asset to deposit. Has to be WETH.\n    /// @param _amount Amount of assets that were transferred to the strategy by the vault.\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        require(_asset == WETH, \"Unsupported asset\");\n        depositedWethAccountedFor += _amount;\n        _deposit(_asset, _amount);\n    }\n\n    /// @dev Deposit WETH to this strategy so it can later be staked into a validator.\n    /// @param _asset Address of WETH\n    /// @param _amount Amount of WETH to deposit\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_amount > 0, \"Must deposit something\");\n        /*\n         * We could do a check here that would revert when \"_amount % 32 ether != 0\". With the idea of\n         * not allowing deposits that will result in WETH sitting on the strategy after all the possible batches\n         * of 32ETH have been staked.\n         * But someone could mess with our strategy by sending some WETH to it. And we might want to deposit just\n         * enough WETH to add it up to 32 so it can be staked. For that reason the check is left out.\n         *\n         * WETH sitting on the strategy won't interfere with the accounting since accounting only operates on ETH.\n         */\n        emit Deposit(_asset, address(0), _amount);\n    }\n\n    /// @notice Unlike other strategies, this does not deposit assets into the underlying platform.\n    /// It just emits the Deposit event.\n    /// To deposit WETH into validators `registerSsvValidator` and `stakeEth` must be used.\n    /// Will NOT revert if the strategy is paused from an accounting failure.\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 wethBalance = IERC20(WETH).balanceOf(address(this));\n        uint256 newWeth = wethBalance - depositedWethAccountedFor;\n\n        if (newWeth > 0) {\n            depositedWethAccountedFor = wethBalance;\n\n            _deposit(WETH, newWeth);\n        }\n    }\n\n    /// @notice Withdraw WETH from this contract. Used only if some WETH for is lingering on the contract.\n    /// That can happen when:\n    ///   - after mints if the strategy is the default\n    ///   - time between depositToStrategy and stakeEth\n    ///   - the deposit was not a multiple of 32 WETH\n    ///   - someone sent WETH directly to this contract\n    /// Will NOT revert if the strategy is paused from an accounting failure.\n    /// @param _recipient Address to receive withdrawn assets\n    /// @param _asset WETH to withdraw\n    /// @param _amount Amount of WETH to withdraw\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_asset == WETH, \"Unsupported asset\");\n        _withdraw(_recipient, _asset, _amount);\n    }\n\n    function _withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) internal {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        _wethWithdrawn(_amount);\n\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n        emit Withdrawal(_asset, address(0), _amount);\n    }\n\n    /// @notice transfer all WETH deposits back to the vault.\n    /// This does not withdraw from the validators. That has to be done separately with the\n    /// `exitSsvValidator` and `removeSsvValidator` operations.\n    /// This does not withdraw any execution rewards from the FeeAccumulator or\n    /// consensus rewards in this strategy.\n    /// Any ETH in this strategy that was swept from a full validator withdrawal will not be withdrawn.\n    /// ETH from full validator withdrawals is sent to the Vault using `doAccounting`.\n    /// Will NOT revert if the strategy is paused from an accounting failure.\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        uint256 wethBalance = IERC20(WETH).balanceOf(address(this));\n        if (wethBalance > 0) {\n            _withdraw(vaultAddress, WETH, wethBalance);\n        }\n    }\n\n    /// @notice Returns the total value of (W)ETH that is staked to the validators\n    /// and WETH deposits that are still to be staked.\n    /// This does not include ETH from consensus rewards sitting in this strategy\n    /// or ETH from MEV rewards in the FeeAccumulator. These rewards are harvested\n    /// and sent to the Dripper so will eventually be sent to the Vault as WETH.\n    /// @param _asset      Address of weth asset\n    /// @return balance    Total value of (W)ETH\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == WETH, \"Unsupported asset\");\n\n        balance =\n            // add the ETH that has been staked in validators\n            activeDepositedValidators *\n            FULL_STAKE +\n            // add the WETH in the strategy from deposits that are still to be staked\n            IERC20(WETH).balanceOf(address(this));\n    }\n\n    function pause() external onlyStrategist {\n        _pause();\n    }\n\n    /// @notice Returns bool indicating whether asset is supported by strategy.\n    /// @param _asset The address of the asset token.\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == WETH;\n    }\n\n    /// @notice Approves the SSV Network contract to transfer SSV tokens for deposits\n    function safeApproveAllTokens() external override {\n        // Approves the SSV Network contract to transfer SSV tokens for deposits\n        IERC20(SSV_TOKEN).approve(SSV_NETWORK, type(uint256).max);\n    }\n\n    /// @notice Set the FeeAccumulator as the address for SSV validators to send MEV rewards to\n    function setFeeRecipient() external {\n        ISSVNetwork(SSV_NETWORK).setFeeRecipientAddress(\n            FEE_ACCUMULATOR_ADDRESS\n        );\n    }\n\n    /**\n     * @notice Only accept ETH from the FeeAccumulator and the WETH contract - required when\n     * unwrapping WETH just before staking it to the validator.\n     * The strategy will also receive ETH from the priority fees of transactions when producing blocks\n     * as defined in EIP-1559.\n     * The tx fees come from the Beacon chain so do not need any EVM level permissions to receive ETH.\n     * The tx fees are paid with each block produced. They are not included in the consensus rewards\n     * which are periodically swept from the validators to this strategy.\n     * For accounting purposes, the priority fees of transactions will be considered consensus rewards\n     * and will be included in the AccountingConsensusRewards event.\n     * @dev don't want to receive donations from anyone else as donations over the fuse limits will\n     * mess with the accounting of the consensus rewards and validator full withdrawals.\n     */\n    receive() external payable {\n        require(\n            msg.sender == FEE_ACCUMULATOR_ADDRESS || msg.sender == WETH,\n            \"Eth not from allowed contracts\"\n        );\n    }\n\n    /***************************************\n                Internal functions\n    ****************************************/\n\n    function _abstractSetPToken(address _asset, address) internal override {}\n\n    /// @dev Convert accumulated ETH to WETH and send to the Harvester.\n    /// Will revert if the strategy is paused for accounting.\n    function _collectRewardTokens() internal override whenNotPaused {\n        // collect ETH from execution rewards from the fee accumulator\n        uint256 executionRewards = FeeAccumulator(FEE_ACCUMULATOR_ADDRESS)\n            .collect();\n\n        // total ETH rewards to be harvested = execution rewards + consensus rewards\n        uint256 ethRewards = executionRewards + consensusRewards;\n\n        require(\n            address(this).balance >= ethRewards,\n            \"Insufficient eth balance\"\n        );\n\n        if (ethRewards > 0) {\n            // reset the counter keeping track of beacon chain consensus rewards\n            consensusRewards = 0;\n\n            // Convert ETH rewards to WETH\n            IWETH9(WETH).deposit{ value: ethRewards }();\n\n            IERC20(WETH).safeTransfer(harvesterAddress, ethRewards);\n            emit RewardTokenCollected(harvesterAddress, WETH, ethRewards);\n        }\n    }\n\n    /// @dev emits Withdrawal event from NativeStakingSSVStrategy\n    function _wethWithdrawnToVault(uint256 _amount) internal override {\n        emit Withdrawal(WETH, address(0), _amount);\n    }\n\n    /// @dev Called when WETH is withdrawn from the strategy or staked to a validator so\n    /// the strategy knows how much WETH it has on deposit.\n    /// This is so it can emit the correct amount in the Deposit event in depositAll().\n    function _wethWithdrawn(uint256 _amount) internal override {\n        /* In an ideal world we wouldn't need to reduce the deduction amount when the\n         * depositedWethAccountedFor is smaller than the _amount.\n         *\n         * The reason this is required is that a malicious actor could sent WETH directly\n         * to this contract and that would circumvent the increase of depositedWethAccountedFor\n         * property. When the ETH would be staked the depositedWethAccountedFor amount could\n         * be deducted so much that it would be negative.\n         */\n        uint256 deductAmount = Math.min(_amount, depositedWethAccountedFor);\n        depositedWethAccountedFor -= deductAmount;\n    }\n}\n"
    },
    "contracts/strategies/NativeStaking/ValidatorAccountant.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ValidatorRegistrator } from \"./ValidatorRegistrator.sol\";\nimport { IWETH9 } from \"../../interfaces/IWETH9.sol\";\n\n/// @title Validator Accountant\n/// @notice Attributes the ETH swept from beacon chain validators to this strategy contract\n/// as either full or partial withdrawals. Partial withdrawals being consensus rewards.\n/// Full withdrawals are from exited validators.\n/// @author Origin Protocol Inc\nabstract contract ValidatorAccountant is ValidatorRegistrator {\n    /// @notice The minimum amount of blocks that need to pass between two calls to manuallyFixAccounting\n    uint256 public constant MIN_FIX_ACCOUNTING_CADENCE = 7200; // 1 day\n\n    /// @notice Keeps track of the total consensus rewards swept from the beacon chain\n    uint256 public consensusRewards;\n\n    /// @notice start of fuse interval\n    uint256 public fuseIntervalStart;\n    /// @notice end of fuse interval\n    uint256 public fuseIntervalEnd;\n    /// @notice last block number manuallyFixAccounting has been called\n    uint256 public lastFixAccountingBlockNumber;\n\n    uint256[49] private __gap;\n\n    event FuseIntervalUpdated(uint256 start, uint256 end);\n    event AccountingFullyWithdrawnValidator(\n        uint256 noOfValidators,\n        uint256 remainingValidators,\n        uint256 wethSentToVault\n    );\n    event AccountingValidatorSlashed(\n        uint256 remainingValidators,\n        uint256 wethSentToVault\n    );\n    event AccountingConsensusRewards(uint256 amount);\n\n    event AccountingManuallyFixed(\n        int256 validatorsDelta,\n        int256 consensusRewardsDelta,\n        uint256 wethToVault\n    );\n\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\n    /// @param _vaultAddress Address of the Vault\n    /// @param _beaconChainDepositContract Address of the beacon chain deposit contract\n    /// @param _ssvNetwork Address of the SSV Network contract\n    /// @param _maxValidators Maximum number of validators that can be registered in the strategy\n    constructor(\n        address _wethAddress,\n        address _vaultAddress,\n        address _beaconChainDepositContract,\n        address _ssvNetwork,\n        uint256 _maxValidators\n    )\n        ValidatorRegistrator(\n            _wethAddress,\n            _vaultAddress,\n            _beaconChainDepositContract,\n            _ssvNetwork,\n            _maxValidators\n        )\n    {}\n\n    /// @notice set fuse interval values\n    function setFuseInterval(\n        uint256 _fuseIntervalStart,\n        uint256 _fuseIntervalEnd\n    ) external onlyGovernor {\n        require(\n            _fuseIntervalStart < _fuseIntervalEnd &&\n                _fuseIntervalEnd < 32 ether &&\n                _fuseIntervalEnd - _fuseIntervalStart >= 4 ether,\n            \"Incorrect fuse interval\"\n        );\n\n        fuseIntervalStart = _fuseIntervalStart;\n        fuseIntervalEnd = _fuseIntervalEnd;\n\n        emit FuseIntervalUpdated(_fuseIntervalStart, _fuseIntervalEnd);\n    }\n\n    /* solhint-disable max-line-length */\n    /// This notion page offers a good explanation of how the accounting functions\n    /// https://www.notion.so/originprotocol/Limited-simplified-native-staking-accounting-67a217c8420d40678eb943b9da0ee77d\n    /// In short, after dividing by 32, if the ETH remaining on the contract falls between 0 and fuseIntervalStart,\n    /// the accounting function will treat that ETH as Beacon chain consensus rewards.\n    /// On the contrary, if after dividing by 32, the ETH remaining on the contract falls between fuseIntervalEnd and 32,\n    /// the accounting function will treat that as a validator slashing.\n    /// @notice Perform the accounting attributing beacon chain ETH to either full or partial withdrawals. Returns true when\n    /// accounting is valid and fuse isn't \"blown\". Returns false when fuse is blown.\n    /// @dev This function could in theory be permission-less but lets allow only the Registrator (Defender Action) to call it\n    /// for now.\n    /// @return accountingValid true if accounting was successful, false if fuse is blown\n    /* solhint-enable max-line-length */\n    function doAccounting()\n        external\n        onlyRegistrator\n        whenNotPaused\n        nonReentrant\n        returns (bool accountingValid)\n    {\n        // pause the accounting on failure\n        accountingValid = _doAccounting(true);\n    }\n\n    // slither-disable-start reentrancy-eth\n    function _doAccounting(bool pauseOnFail)\n        internal\n        returns (bool accountingValid)\n    {\n        if (address(this).balance < consensusRewards) {\n            return _failAccounting(pauseOnFail);\n        }\n\n        // Calculate all the new ETH that has been swept to the contract since the last accounting\n        uint256 newSweptETH = address(this).balance - consensusRewards;\n        accountingValid = true;\n\n        // send the ETH that is from fully withdrawn validators to the Vault\n        if (newSweptETH >= FULL_STAKE) {\n            uint256 fullyWithdrawnValidators;\n            // explicitly cast to uint256 as we want to round to a whole number of validators\n            fullyWithdrawnValidators = uint256(newSweptETH / FULL_STAKE);\n            activeDepositedValidators -= fullyWithdrawnValidators;\n\n            uint256 wethToVault = FULL_STAKE * fullyWithdrawnValidators;\n            IWETH9(WETH).deposit{ value: wethToVault }();\n            // slither-disable-next-line unchecked-transfer\n            IWETH9(WETH).transfer(VAULT_ADDRESS, wethToVault);\n            _wethWithdrawnToVault(wethToVault);\n\n            emit AccountingFullyWithdrawnValidator(\n                fullyWithdrawnValidators,\n                activeDepositedValidators,\n                wethToVault\n            );\n        }\n\n        uint256 ethRemaining = address(this).balance - consensusRewards;\n        // should be less than a whole validator stake\n        require(ethRemaining < FULL_STAKE, \"Unexpected accounting\");\n\n        // If no Beacon chain consensus rewards swept\n        if (ethRemaining == 0) {\n            // do nothing\n            return accountingValid;\n        } else if (ethRemaining < fuseIntervalStart) {\n            // Beacon chain consensus rewards swept (partial validator withdrawals)\n            // solhint-disable-next-line reentrancy\n            consensusRewards += ethRemaining;\n            emit AccountingConsensusRewards(ethRemaining);\n        } else if (ethRemaining > fuseIntervalEnd) {\n            // Beacon chain consensus rewards swept but also a slashed validator fully exited\n            IWETH9(WETH).deposit{ value: ethRemaining }();\n            // slither-disable-next-line unchecked-transfer\n            IWETH9(WETH).transfer(VAULT_ADDRESS, ethRemaining);\n            activeDepositedValidators -= 1;\n\n            _wethWithdrawnToVault(ethRemaining);\n\n            emit AccountingValidatorSlashed(\n                activeDepositedValidators,\n                ethRemaining\n            );\n        }\n        // Oh no... Fuse is blown. The Strategist needs to adjust the accounting values.\n        else {\n            return _failAccounting(pauseOnFail);\n        }\n    }\n\n    // slither-disable-end reentrancy-eth\n\n    /// @dev pause any further accounting if required and return false\n    function _failAccounting(bool pauseOnFail)\n        internal\n        returns (bool accountingValid)\n    {\n        // pause if not already\n        if (pauseOnFail) {\n            _pause();\n        }\n        // fail the accounting\n        accountingValid = false;\n    }\n\n    /// @notice Allow the Strategist to fix the accounting of this strategy and unpause.\n    /// @param _validatorsDelta adjust the active validators by up to plus three or minus three\n    /// @param _consensusRewardsDelta adjust the accounted for consensus rewards up or down\n    /// @param _ethToVaultAmount the amount of ETH that gets wrapped into WETH and sent to the Vault\n    /// @dev There is a case when a validator(s) gets slashed so much that the eth swept from\n    /// the beacon chain enters the fuse area and there are no consensus rewards on the contract\n    /// to \"dip into\"/use. To increase the amount of unaccounted ETH over the fuse end interval\n    /// we need to reduce the amount of active deposited validators and immediately send WETH\n    /// to the vault, so it doesn't interfere with further accounting.\n    function manuallyFixAccounting(\n        int256 _validatorsDelta,\n        int256 _consensusRewardsDelta,\n        uint256 _ethToVaultAmount\n    ) external onlyStrategist whenPaused nonReentrant {\n        require(\n            lastFixAccountingBlockNumber + MIN_FIX_ACCOUNTING_CADENCE <\n                block.number,\n            \"Fix accounting called too soon\"\n        );\n        require(\n            _validatorsDelta >= -3 &&\n                _validatorsDelta <= 3 &&\n                // new value must be positive\n                int256(activeDepositedValidators) + _validatorsDelta >= 0,\n            \"Invalid validatorsDelta\"\n        );\n        require(\n            _consensusRewardsDelta >= -332 ether &&\n                _consensusRewardsDelta <= 332 ether &&\n                // new value must be positive\n                int256(consensusRewards) + _consensusRewardsDelta >= 0,\n            \"Invalid consensusRewardsDelta\"\n        );\n        require(_ethToVaultAmount <= 32 ether * 3, \"Invalid wethToVaultAmount\");\n\n        activeDepositedValidators = uint256(\n            int256(activeDepositedValidators) + _validatorsDelta\n        );\n        consensusRewards = uint256(\n            int256(consensusRewards) + _consensusRewardsDelta\n        );\n        lastFixAccountingBlockNumber = block.number;\n        if (_ethToVaultAmount > 0) {\n            IWETH9(WETH).deposit{ value: _ethToVaultAmount }();\n            // slither-disable-next-line unchecked-transfer\n            IWETH9(WETH).transfer(VAULT_ADDRESS, _ethToVaultAmount);\n            _wethWithdrawnToVault(_ethToVaultAmount);\n        }\n\n        emit AccountingManuallyFixed(\n            _validatorsDelta,\n            _consensusRewardsDelta,\n            _ethToVaultAmount\n        );\n\n        // rerun the accounting to see if it has now been fixed.\n        // Do not pause the accounting on failure as it is already paused\n        require(_doAccounting(false), \"Fuse still blown\");\n\n        // unpause since doAccounting was successful\n        _unpause();\n    }\n\n    /***************************************\n                 Abstract\n    ****************************************/\n\n    /// @dev allows for NativeStakingSSVStrategy contract to emit the Withdrawal event\n    function _wethWithdrawnToVault(uint256 _amount) internal virtual;\n}\n"
    },
    "contracts/strategies/NativeStaking/ValidatorRegistrator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { Governable } from \"../../governance/Governable.sol\";\nimport { IDepositContract } from \"../../interfaces/IDepositContract.sol\";\nimport { IVault } from \"../../interfaces/IVault.sol\";\nimport { IWETH9 } from \"../../interfaces/IWETH9.sol\";\nimport { ISSVNetwork, Cluster } from \"../../interfaces/ISSVNetwork.sol\";\n\nstruct ValidatorStakeData {\n    bytes pubkey;\n    bytes signature;\n    bytes32 depositDataRoot;\n}\n\n/**\n * @title Registrator of the validators\n * @notice This contract implements all the required functionality to register, exit and remove validators.\n * @author Origin Protocol Inc\n */\nabstract contract ValidatorRegistrator is Governable, Pausable {\n    /// @notice The maximum amount of ETH that can be staked by a validator\n    /// @dev this can change in the future with EIP-7251, Increase the MAX_EFFECTIVE_BALANCE\n    uint256 public constant FULL_STAKE = 32 ether;\n\n    /// @notice The address of the Wrapped ETH (WETH) token contract\n    address public immutable WETH;\n    /// @notice The address of the beacon chain deposit contract\n    address public immutable BEACON_CHAIN_DEPOSIT_CONTRACT;\n    /// @notice The address of the SSV Network contract used to interface with\n    address public immutable SSV_NETWORK;\n    /// @notice Address of the OETH Vault proxy contract\n    address public immutable VAULT_ADDRESS;\n    /// @notice Maximum number of validators that can be registered in this strategy\n    uint256 public immutable MAX_VALIDATORS;\n\n    /// @notice Address of the registrator - allowed to register, exit and remove validators\n    address public validatorRegistrator;\n    /// @notice The number of validators that have 32 (!) ETH actively deposited. When a new deposit\n    /// to a validator happens this number increases, when a validator exit is detected this number\n    /// decreases.\n    uint256 public activeDepositedValidators;\n    /// @notice State of the validators keccak256(pubKey) => state\n    mapping(bytes32 => VALIDATOR_STATE) public validatorsStates;\n    /// @notice The account that is allowed to modify stakeETHThreshold and reset stakeETHTally\n    address public stakingMonitor;\n    /// @notice Amount of ETH that can be staked before staking on the contract is suspended\n    /// and the `stakingMonitor` needs to approve further staking by calling `resetStakeETHTally`\n    uint256 public stakeETHThreshold;\n    /// @notice Amount of ETH that has been staked since the `stakingMonitor` last called `resetStakeETHTally`.\n    /// This can not go above `stakeETHThreshold`.\n    uint256 public stakeETHTally;\n\n    // For future use\n    uint256[47] private __gap;\n\n    enum VALIDATOR_STATE {\n        NON_REGISTERED, // validator is not registered on the SSV network\n        REGISTERED, // validator is registered on the SSV network\n        STAKED, // validator has funds staked\n        EXITING, // exit message has been posted and validator is in the process of exiting\n        EXIT_COMPLETE // validator has funds withdrawn to the EigenPod and is removed from the SSV\n    }\n\n    event RegistratorChanged(address indexed newAddress);\n    event StakingMonitorChanged(address indexed newAddress);\n    event ETHStaked(bytes32 indexed pubKeyHash, bytes pubKey, uint256 amount);\n    event SSVValidatorRegistered(\n        bytes32 indexed pubKeyHash,\n        bytes pubKey,\n        uint64[] operatorIds\n    );\n    event SSVValidatorExitInitiated(\n        bytes32 indexed pubKeyHash,\n        bytes pubKey,\n        uint64[] operatorIds\n    );\n    event SSVValidatorExitCompleted(\n        bytes32 indexed pubKeyHash,\n        bytes pubKey,\n        uint64[] operatorIds\n    );\n    event StakeETHThresholdChanged(uint256 amount);\n    event StakeETHTallyReset();\n\n    /// @dev Throws if called by any account other than the Registrator\n    modifier onlyRegistrator() {\n        require(\n            msg.sender == validatorRegistrator,\n            \"Caller is not the Registrator\"\n        );\n        _;\n    }\n\n    /// @dev Throws if called by any account other than the Staking monitor\n    modifier onlyStakingMonitor() {\n        require(msg.sender == stakingMonitor, \"Caller is not the Monitor\");\n        _;\n    }\n\n    /// @dev Throws if called by any account other than the Strategist\n    modifier onlyStrategist() {\n        require(\n            msg.sender == IVault(VAULT_ADDRESS).strategistAddr(),\n            \"Caller is not the Strategist\"\n        );\n        _;\n    }\n\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\n    /// @param _vaultAddress Address of the Vault\n    /// @param _beaconChainDepositContract Address of the beacon chain deposit contract\n    /// @param _ssvNetwork Address of the SSV Network contract\n    /// @param _maxValidators Maximum number of validators that can be registered in the strategy\n    constructor(\n        address _wethAddress,\n        address _vaultAddress,\n        address _beaconChainDepositContract,\n        address _ssvNetwork,\n        uint256 _maxValidators\n    ) {\n        WETH = _wethAddress;\n        BEACON_CHAIN_DEPOSIT_CONTRACT = _beaconChainDepositContract;\n        SSV_NETWORK = _ssvNetwork;\n        VAULT_ADDRESS = _vaultAddress;\n        MAX_VALIDATORS = _maxValidators;\n    }\n\n    /// @notice Set the address of the registrator which can register, exit and remove validators\n    function setRegistrator(address _address) external onlyGovernor {\n        validatorRegistrator = _address;\n        emit RegistratorChanged(_address);\n    }\n\n    /// @notice Set the address of the staking monitor that is allowed to reset stakeETHTally\n    function setStakingMonitor(address _address) external onlyGovernor {\n        stakingMonitor = _address;\n        emit StakingMonitorChanged(_address);\n    }\n\n    /// @notice Set the amount of ETH that can be staked before staking monitor\n    // needs to a approve further staking by resetting the stake ETH tally\n    function setStakeETHThreshold(uint256 _amount) external onlyGovernor {\n        stakeETHThreshold = _amount;\n        emit StakeETHThresholdChanged(_amount);\n    }\n\n    /// @notice Reset the stakeETHTally\n    function resetStakeETHTally() external onlyStakingMonitor {\n        stakeETHTally = 0;\n        emit StakeETHTallyReset();\n    }\n\n    /// @notice Stakes WETH to the node validators\n    /// @param validators A list of validator data needed to stake.\n    /// The `ValidatorStakeData` struct contains the pubkey, signature and depositDataRoot.\n    /// Only the registrator can call this function.\n    // slither-disable-start reentrancy-eth\n    function stakeEth(ValidatorStakeData[] calldata validators)\n        external\n        onlyRegistrator\n        whenNotPaused\n        nonReentrant\n    {\n        uint256 requiredETH = validators.length * FULL_STAKE;\n\n        // Check there is enough WETH from the deposits sitting in this strategy contract\n        require(\n            requiredETH <= IWETH9(WETH).balanceOf(address(this)),\n            \"Insufficient WETH\"\n        );\n        require(\n            activeDepositedValidators + validators.length <= MAX_VALIDATORS,\n            \"Max validators reached\"\n        );\n\n        require(\n            stakeETHTally + requiredETH <= stakeETHThreshold,\n            \"Staking ETH over threshold\"\n        );\n        stakeETHTally += requiredETH;\n\n        // Convert required ETH from WETH\n        IWETH9(WETH).withdraw(requiredETH);\n        _wethWithdrawn(requiredETH);\n\n        /* 0x01 to indicate that withdrawal credentials will contain an EOA address that the sweeping function\n         * can sweep funds to.\n         * bytes11(0) to fill up the required zeros\n         * remaining bytes20 are for the address\n         */\n        bytes memory withdrawalCredentials = abi.encodePacked(\n            bytes1(0x01),\n            bytes11(0),\n            address(this)\n        );\n\n        // For each validator\n        for (uint256 i = 0; i < validators.length; ++i) {\n            bytes32 pubKeyHash = keccak256(validators[i].pubkey);\n\n            require(\n                validatorsStates[pubKeyHash] == VALIDATOR_STATE.REGISTERED,\n                \"Validator not registered\"\n            );\n\n            IDepositContract(BEACON_CHAIN_DEPOSIT_CONTRACT).deposit{\n                value: FULL_STAKE\n            }(\n                validators[i].pubkey,\n                withdrawalCredentials,\n                validators[i].signature,\n                validators[i].depositDataRoot\n            );\n\n            validatorsStates[pubKeyHash] = VALIDATOR_STATE.STAKED;\n\n            emit ETHStaked(pubKeyHash, validators[i].pubkey, FULL_STAKE);\n        }\n        // save gas by changing this storage variable only once rather each time in the loop.\n        activeDepositedValidators += validators.length;\n    }\n\n    // slither-disable-end reentrancy-eth\n\n    /// @notice Registers a new validator in the SSV Cluster.\n    /// Only the registrator can call this function.\n    /// @param publicKeys The public keys of the validators\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param sharesData The shares data for each validator\n    /// @param ssvAmount The amount of SSV tokens to be deposited to the SSV cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    function registerSsvValidators(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds,\n        bytes[] calldata sharesData,\n        uint256 ssvAmount,\n        Cluster calldata cluster\n    ) external onlyRegistrator whenNotPaused {\n        require(\n            publicKeys.length == sharesData.length,\n            \"Pubkey sharesData mismatch\"\n        );\n        // Check each public key has not already been used\n        bytes32 pubKeyHash;\n        VALIDATOR_STATE currentState;\n        for (uint256 i = 0; i < publicKeys.length; ++i) {\n            pubKeyHash = keccak256(publicKeys[i]);\n            currentState = validatorsStates[pubKeyHash];\n            require(\n                currentState == VALIDATOR_STATE.NON_REGISTERED,\n                \"Validator already registered\"\n            );\n\n            validatorsStates[pubKeyHash] = VALIDATOR_STATE.REGISTERED;\n\n            emit SSVValidatorRegistered(pubKeyHash, publicKeys[i], operatorIds);\n        }\n\n        ISSVNetwork(SSV_NETWORK).bulkRegisterValidator(\n            publicKeys,\n            operatorIds,\n            sharesData,\n            ssvAmount,\n            cluster\n        );\n    }\n\n    /// @notice Exit validators from the Beacon chain.\n    /// The staked ETH will eventually swept to this native staking strategy.\n    /// Only the registrator can call this function.\n    /// @param publicKeys List of SSV validator public keys\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    function exitSsvValidators(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds\n    ) external onlyRegistrator whenNotPaused nonReentrant {\n        ISSVNetwork(SSV_NETWORK).bulkExitValidator(publicKeys, operatorIds);\n\n        bytes32 pubKeyHash;\n        VALIDATOR_STATE currentState;\n        for (uint256 i = 0; i < publicKeys.length; ++i) {\n            pubKeyHash = keccak256(publicKeys[i]);\n            currentState = validatorsStates[pubKeyHash];\n\n            // Check each validator has not already been staked.\n            // This would normally be done before the external call but is after\n            // so only one for loop of the validators is needed.\n            require(\n                currentState == VALIDATOR_STATE.STAKED,\n                \"Validator not staked\"\n            );\n\n            // Store the new validator state\n            validatorsStates[pubKeyHash] = VALIDATOR_STATE.EXITING;\n\n            emit SSVValidatorExitInitiated(\n                pubKeyHash,\n                publicKeys[i],\n                operatorIds\n            );\n        }\n    }\n\n    /// @notice Remove validators from the SSV Cluster.\n    /// Make sure `exitSsvValidator` is called before and the validate has exited the Beacon chain.\n    /// If removed before the validator has exited the beacon chain will result in the validator being slashed.\n    /// Only the registrator can call this function.\n    /// @param publicKeys List of SSV validator public keys\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    function removeSsvValidators(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds,\n        Cluster calldata cluster\n    ) external onlyRegistrator whenNotPaused nonReentrant {\n        ISSVNetwork(SSV_NETWORK).bulkRemoveValidator(\n            publicKeys,\n            operatorIds,\n            cluster\n        );\n\n        bytes32 pubKeyHash;\n        VALIDATOR_STATE currentState;\n        for (uint256 i = 0; i < publicKeys.length; ++i) {\n            pubKeyHash = keccak256(publicKeys[i]);\n            currentState = validatorsStates[pubKeyHash];\n\n            // Check each validator is either registered or exited.\n            // This would normally be done before the external call but is after\n            // so only one for loop of the validators is needed.\n            require(\n                currentState == VALIDATOR_STATE.EXITING ||\n                    currentState == VALIDATOR_STATE.REGISTERED,\n                \"Validator not regd or exiting\"\n            );\n\n            // Store the new validator state\n            validatorsStates[pubKeyHash] = VALIDATOR_STATE.EXIT_COMPLETE;\n\n            emit SSVValidatorExitCompleted(\n                pubKeyHash,\n                publicKeys[i],\n                operatorIds\n            );\n        }\n    }\n\n    /// @notice Deposits more SSV Tokens to the SSV Network contract which is used to pay the SSV Operators.\n    /// @dev A SSV cluster is defined by the SSVOwnerAddress and the set of operatorIds.\n    /// uses \"onlyStrategist\" modifier so continuous front-running can't DOS our maintenance service\n    /// that tries to top up SSV tokens.\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param ssvAmount The amount of SSV tokens to be deposited to the SSV cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    function depositSSV(\n        uint64[] memory operatorIds,\n        uint256 ssvAmount,\n        Cluster memory cluster\n    ) external onlyStrategist {\n        ISSVNetwork(SSV_NETWORK).deposit(\n            address(this),\n            operatorIds,\n            ssvAmount,\n            cluster\n        );\n    }\n\n    /// @notice Withdraws excess SSV Tokens from the SSV Network contract which was used to pay the SSV Operators.\n    /// @dev A SSV cluster is defined by the SSVOwnerAddress and the set of operatorIds.\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param ssvAmount The amount of SSV tokens to be deposited to the SSV cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    function withdrawSSV(\n        uint64[] memory operatorIds,\n        uint256 ssvAmount,\n        Cluster memory cluster\n    ) external onlyGovernor {\n        ISSVNetwork(SSV_NETWORK).withdraw(operatorIds, ssvAmount, cluster);\n    }\n\n    /***************************************\n                 Abstract\n    ****************************************/\n\n    /// @dev Called when WETH is withdrawn from the strategy or staked to a validator so\n    /// the strategy knows how much WETH it has on deposit.\n    /// This is so it can emit the correct amount in the Deposit event in depositAll().\n    function _wethWithdrawn(uint256 _amount) internal virtual;\n}\n"
    },
    "contracts/strategies/plume/RoosterAMOStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Rooster AMO strategy\n * @author Origin Protocol Inc\n * @custom:security-contact security@originprotocol.com\n */\nimport { Math as MathRooster } from \"../../../lib/rooster/v2-common/libraries/Math.sol\";\nimport { Math as Math_v5 } from \"../../../lib/rooster/openzeppelin-custom/contracts/utils/math/Math.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { IERC20, InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { IVault } from \"../../interfaces/IVault.sol\";\nimport { IMaverickV2Pool } from \"../../interfaces/plume/IMaverickV2Pool.sol\";\nimport { IMaverickV2Quoter } from \"../../interfaces/plume/IMaverickV2Quoter.sol\";\nimport { IMaverickV2LiquidityManager } from \"../../interfaces/plume/IMaverickV2LiquidityManager.sol\";\nimport { IMaverickV2PoolLens } from \"../../interfaces/plume/IMaverickV2PoolLens.sol\";\nimport { IMaverickV2Position } from \"../../interfaces/plume/IMaverickV2Position.sol\";\nimport { IVotingDistributor } from \"../../interfaces/plume/IVotingDistributor.sol\";\nimport { IPoolDistributor } from \"../../interfaces/plume/IPoolDistributor.sol\";\n// importing custom version of rooster TickMath because of dependency collision. Maverick uses\n// a newer OpenZepplin Math library with functionality that is not present in 4.4.2 (the one we use)\nimport { TickMath } from \"../../../lib/rooster/v2-common/libraries/TickMath.sol\";\n\ncontract RoosterAMOStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    /***************************************\n            Storage slot members\n    ****************************************/\n\n    /// @notice NFT tokenId of the liquidity position\n    ///\n    /// @dev starts with value of 1 and can not be 0\n    //  solhint-disable-next-line max-line-length\n    ///      https://github.com/rooster-protocol/rooster-contracts/blob/fbfecbc519e4495b12598024a42630b4a8ea4489/v2-common/contracts/base/Nft.sol#L14\n    uint256 public tokenId;\n    /// @dev Minimum amount of tokens the strategy would be able to withdraw from the pool.\n    ///      minimum amount of tokens are withdrawn at a 1:1 price\n    ///      Important: Underlying assets contains only assets that are deposited in the underlying Rooster pool.\n    ///      WETH or OETH held by this contract is not accounted for in underlying assets\n    uint256 public underlyingAssets;\n    /// @notice Marks the start of the interval that defines the allowed range of WETH share in\n    /// the pre-configured pool's liquidity ticker\n    uint256 public allowedWethShareStart;\n    /// @notice Marks the end of the interval that defines the allowed range of WETH share in\n    /// the pre-configured pool's liquidity ticker\n    uint256 public allowedWethShareEnd;\n    /// @dev reserved for inheritance\n    int256[46] private __reserved;\n\n    /***************************************\n          Constants, structs and events\n    ****************************************/\n\n    /// @notice The address of the Wrapped ETH (WETH) token contract\n    address public immutable WETH;\n    /// @notice The address of the OETH token contract\n    address public immutable OETH;\n    /// @notice the underlying AMO Maverick (Rooster) pool\n    IMaverickV2Pool public immutable mPool;\n    /// @notice the Liquidity manager used to add liquidity to the pool\n    IMaverickV2LiquidityManager public immutable liquidityManager;\n    /// @notice the Maverick V2 poolLens\n    ///\n    /// @dev only used to provide the pool's current sqrtPrice\n    IMaverickV2PoolLens public immutable poolLens;\n    /// @notice the Maverick V2 position\n    ///\n    /// @dev provides details of the NFT LP position and offers functions to\n    /// remove the liquidity.\n    IMaverickV2Position public immutable maverickPosition;\n    /// @notice the Maverick Quoter\n    IMaverickV2Quoter public immutable quoter;\n    /// @notice the Maverick Voting Distributor\n    IVotingDistributor public immutable votingDistributor;\n    /// @notice the Maverick Pool Distributor\n    IPoolDistributor public immutable poolDistributor;\n\n    /// @notice sqrtPriceTickLower\n    /// @dev tick lower represents the lower price of OETH priced in WETH. Meaning the pool\n    /// offers more than 1 OETH for 1 WETH. In other terms to get 1 OETH the swap needs to offer 0.9999 WETH\n    /// this is where purchasing OETH with WETH within the liquidity position is the cheapest.\n    ///\n    ///            _____________________\n    ///            |      |            |\n    ///            | WETH |    OETH   |\n    ///            |      |            |\n    ///            |      |            |\n    ///  --------- * ---- * ---------- * ---------\n    ///               currentPrice\n    ///                          sqrtPriceHigher-(1:1 parity)\n    ///      sqrtPriceLower\n    ///\n    ///\n    /// Price is defined as price of token1 in terms of token0. (token1 / token0)\n    /// @notice sqrtPriceTickLower - OETH is priced 0.9999 WETH\n    uint256 public immutable sqrtPriceTickLower;\n    /// @notice sqrtPriceTickHigher\n    /// @dev tick higher represents 1:1 price parity of WETH to OETH\n    uint256 public immutable sqrtPriceTickHigher;\n    /// @dev price at parity (in OETH this is equal to sqrtPriceTickHigher)\n    uint256 public immutable sqrtPriceAtParity;\n    /// @notice The tick where the strategy deploys the liquidity to\n    int32 public constant TICK_NUMBER = -1;\n    /// @notice Minimum liquidity that must be exceeded to continue with the action\n    /// e.g. deposit, add liquidity\n    uint256 public constant ACTION_THRESHOLD = 1e12;\n    /// @notice Maverick pool static liquidity bin type\n    uint8 public constant MAV_STATIC_BIN_KIND = 0;\n    /// @dev a threshold under which the contract no longer allows for the protocol to rebalance. Guarding\n    ///      against a strategist / guardian being taken over and with multiple transactions draining the\n    ///      protocol funds.\n    uint256 public constant SOLVENCY_THRESHOLD = 0.998 ether;\n    /// @notice Emitted when the allowed interval within which the strategy contract is allowed to deposit\n    /// liquidity to the underlying pool is updated.\n    /// @param allowedWethShareStart The start of the interval\n    /// @param allowedWethShareEnd The end of the interval\n    event PoolWethShareIntervalUpdated(\n        uint256 allowedWethShareStart,\n        uint256 allowedWethShareEnd\n    );\n    /// @notice Emitted when liquidity is removed from the underlying pool\n    /// @param withdrawLiquidityShare Share of strategy's liquidity that has been removed\n    /// @param removedWETHAmount The amount of WETH removed\n    /// @param removedOETHAmount The amount of OETH removed\n    /// @param underlyingAssets Updated amount of strategy's underlying assets\n    event LiquidityRemoved(\n        uint256 withdrawLiquidityShare,\n        uint256 removedWETHAmount,\n        uint256 removedOETHAmount,\n        uint256 underlyingAssets\n    );\n\n    /// @notice Emitted when the underlying pool is rebalanced\n    /// @param currentPoolWethShare The resulting share of strategy's liquidity\n    /// in the TICK_NUMBER\n    event PoolRebalanced(uint256 currentPoolWethShare);\n\n    /// @notice Emitted when the amount of underlying assets the strategy hold as\n    /// liquidity in the pool is updated.\n    /// @param underlyingAssets Updated amount of strategy's underlying assets\n    event UnderlyingAssetsUpdated(uint256 underlyingAssets);\n\n    /// @notice Emitted when liquidity is added to the underlying pool\n    /// @param wethAmountDesired Amount of WETH desired to be deposited\n    /// @param oethAmountDesired Amount of OETH desired to be deposited\n    /// @param wethAmountSupplied Amount of WETH deposited\n    /// @param oethAmountSupplied Amount of OETH deposited\n    /// @param tokenId NFT liquidity token id\n    /// @param underlyingAssets Updated amount of underlying assets\n    event LiquidityAdded(\n        uint256 wethAmountDesired,\n        uint256 oethAmountDesired,\n        uint256 wethAmountSupplied,\n        uint256 oethAmountSupplied,\n        uint256 tokenId,\n        uint256 underlyingAssets\n    ); // 0x1530ec74\n\n    error PoolRebalanceOutOfBounds(\n        uint256 currentPoolWethShare,\n        uint256 allowedWethShareStart,\n        uint256 allowedWethShareEnd\n    ); // 0x3681e8e0\n\n    error NotEnoughWethForSwap(uint256 wethBalance, uint256 requiredWeth); // 0x989e5ca8\n    error NotEnoughWethLiquidity(uint256 wethBalance, uint256 requiredWeth); // 0xa6737d87\n    error OutsideExpectedTickRange(); // 0xa6e1bad2\n    error SlippageCheck(uint256 tokenReceived); // 0x355cdb78\n\n    /// @notice the constructor\n    /// @dev This contract is intended to be used as a proxy. To prevent the\n    ///      potential confusion of having a functional implementation contract\n    ///      the constructor has the `initializer` modifier. This way the\n    ///      `initialize` function can not be called on the implementation contract.\n    ///      For the same reason the implementation contract also has the governor\n    ///      set to a zero address.\n    /// @param _stratConfig the basic strategy configuration\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\n    /// @param _oethAddress Address of the Erc20 OETH Token contract\n    /// @param _liquidityManager Address of liquidity manager to add\n    ///         the liquidity\n    /// @param _poolLens Address of the pool lens contract\n    /// @param _maverickPosition Address of the Maverick's position contract\n    /// @param _maverickQuoter Address of the Maverick's Quoter contract\n    /// @param _mPool Address of the Rooster concentrated liquidity pool\n    /// @param _upperTickAtParity Bool when true upperTick is the one where the\n    ///        price of OETH and WETH are at parity\n    constructor(\n        BaseStrategyConfig memory _stratConfig,\n        address _wethAddress,\n        address _oethAddress,\n        address _liquidityManager,\n        address _poolLens,\n        address _maverickPosition,\n        address _maverickQuoter,\n        address _mPool,\n        bool _upperTickAtParity,\n        address _votingDistributor,\n        address _poolDistributor\n    ) initializer InitializableAbstractStrategy(_stratConfig) {\n        require(\n            address(IMaverickV2Pool(_mPool).tokenA()) == _wethAddress,\n            \"WETH not TokenA\"\n        );\n        require(\n            address(IMaverickV2Pool(_mPool).tokenB()) == _oethAddress,\n            \"OETH not TokenB\"\n        );\n        require(\n            _liquidityManager != address(0),\n            \"LiquidityManager zero address not allowed\"\n        );\n        require(\n            _maverickQuoter != address(0),\n            \"Quoter zero address not allowed\"\n        );\n        require(_poolLens != address(0), \"PoolLens zero address not allowed\");\n        require(\n            _maverickPosition != address(0),\n            \"Position zero address not allowed\"\n        );\n        require(\n            _votingDistributor != address(0),\n            \"Voting distributor zero address not allowed\"\n        );\n        require(\n            _poolDistributor != address(0),\n            \"Pool distributor zero address not allowed\"\n        );\n\n        uint256 _tickSpacing = IMaverickV2Pool(_mPool).tickSpacing();\n        require(_tickSpacing == 1, \"Unsupported tickSpacing\");\n\n        // tickSpacing == 1\n        (sqrtPriceTickLower, sqrtPriceTickHigher) = TickMath.tickSqrtPrices(\n            _tickSpacing,\n            TICK_NUMBER\n        );\n        sqrtPriceAtParity = _upperTickAtParity\n            ? sqrtPriceTickHigher\n            : sqrtPriceTickLower;\n\n        WETH = _wethAddress;\n        OETH = _oethAddress;\n        liquidityManager = IMaverickV2LiquidityManager(_liquidityManager);\n        poolLens = IMaverickV2PoolLens(_poolLens);\n        maverickPosition = IMaverickV2Position(_maverickPosition);\n        quoter = IMaverickV2Quoter(_maverickQuoter);\n        mPool = IMaverickV2Pool(_mPool);\n        votingDistributor = IVotingDistributor(_votingDistributor);\n        poolDistributor = IPoolDistributor(_poolDistributor);\n\n        // prevent implementation contract to be governed\n        _setGovernor(address(0));\n    }\n\n    /**\n     * @notice initialize function, to set up initial internal state\n     */\n    function initialize() external onlyGovernor initializer {\n        // Read reward\n        address[] memory _rewardTokens = new address[](1);\n        _rewardTokens[0] = poolDistributor.rewardToken();\n\n        require(_rewardTokens[0] != address(0), \"No reward token configured\");\n\n        InitializableAbstractStrategy._initialize(\n            _rewardTokens,\n            new address[](0),\n            new address[](0)\n        );\n    }\n\n    /***************************************\n                  Configuration \n    ****************************************/\n\n    /**\n     * @notice Set allowed pool weth share interval. After the rebalance happens\n     * the share of WETH token in the ticker needs to be within the specifications\n     * of the interval.\n     *\n     * @param _allowedWethShareStart Start of WETH share interval expressed as 18 decimal amount\n     * @param _allowedWethShareEnd End of WETH share interval expressed as 18 decimal amount\n     */\n    function setAllowedPoolWethShareInterval(\n        uint256 _allowedWethShareStart,\n        uint256 _allowedWethShareEnd\n    ) external onlyGovernor {\n        require(\n            _allowedWethShareStart < _allowedWethShareEnd,\n            \"Invalid interval\"\n        );\n        // can not go below 1% weth share\n        require(_allowedWethShareStart > 0.01 ether, \"Invalid interval start\");\n        // can not go above 95% weth share\n        require(_allowedWethShareEnd < 0.95 ether, \"Invalid interval end\");\n\n        allowedWethShareStart = _allowedWethShareStart;\n        allowedWethShareEnd = _allowedWethShareEnd;\n        emit PoolWethShareIntervalUpdated(\n            _allowedWethShareStart,\n            _allowedWethShareEnd\n        );\n    }\n\n    /***************************************\n               Strategy overrides \n    ****************************************/\n\n    /**\n     * @notice Deposits funds to the strategy which deposits them to the\n     * underlying Rooster pool if the pool price is within the expected interval.\n     * @param _asset   Address for the asset\n     * @param _amount  Units of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @notice Deposits all the funds to the strategy which deposits them to the\n     * underlying Rooster pool if the pool price is within the expected interval.\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        _deposit(WETH, _wethBalance);\n    }\n\n    /**\n     * @dev Deposits funds to the strategy which deposits them to the\n     * underlying Rooster pool if the pool price is within the expected interval.\n     * Before this function can be called the initial pool position needs to already\n     * be minted.\n     * @param _asset Address of the asset to deposit\n     * @param _amount Amount of assets to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_asset == WETH, \"Unsupported asset\");\n        require(_amount > 0, \"Must deposit something\");\n        require(tokenId > 0, \"Initial position not minted\");\n        emit Deposit(_asset, address(0), _amount);\n\n        // if the pool price is not within the expected interval leave the WETH on the contract\n        // as to not break the mints - in case it would be configured as a default asset strategy\n        (bool _isExpectedRange, ) = _checkForExpectedPoolPrice(false);\n        if (_isExpectedRange) {\n            // deposit funds into the underlying pool. Because no swap is performed there is no\n            // need to remove any of the liquidity beforehand.\n            _rebalance(0, false, 0, 0);\n        }\n    }\n\n    /**\n     * @notice Withdraw an `amount` of WETH from the platform and\n     *         send to the `_recipient`.\n     * @param _recipient  Address to which the asset should be sent\n     * @param _asset      WETH address\n     * @param _amount     Amount of WETH to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_asset == WETH, \"Unsupported asset\");\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient == vaultAddress, \"Only withdraw to vault allowed\");\n\n        _ensureWETHBalance(_amount);\n\n        _withdraw(_recipient, _amount);\n    }\n\n    /**\n     * @notice Withdraw WETH and sends it to the Vault.\n     */\n    function withdrawAll() external override onlyVault nonReentrant {\n        if (tokenId != 0) {\n            _removeLiquidity(1e18);\n        }\n\n        uint256 _balance = IERC20(WETH).balanceOf(address(this));\n        if (_balance > 0) {\n            _withdraw(vaultAddress, _balance);\n        }\n    }\n\n    function _withdraw(address _recipient, uint256 _amount) internal {\n        IERC20(WETH).safeTransfer(_recipient, _amount);\n        emit Withdrawal(WETH, address(0), _amount);\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset   Address of the asset\n     * @return bool    True when the _asset is WETH\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == WETH;\n    }\n\n    /**\n     * @dev Approve the spending amounts for the assets\n     */\n    function _approveTokenAmounts(\n        uint256 _wethAllowance,\n        uint256 _oethAllowance\n    ) internal {\n        IERC20(WETH).approve(address(liquidityManager), _wethAllowance);\n        IERC20(OETH).approve(address(liquidityManager), _oethAllowance);\n    }\n\n    /***************************************\n              Liquidity management\n    ****************************************/\n    /**\n     * @dev Add liquidity into the pool in the pre-configured WETH to OETH share ratios\n     * defined by the allowedPoolWethShareStart|End interval.\n     *\n     * Normally a PoolLens contract is used to prepare the parameters to add liquidity to the\n     * Rooster pools. It has some errors when doing those calculation and for that reason a\n     * much more accurate Quoter contract is used. This is possible due to our requirement of\n     * adding liquidity only to one tick - PoolLens supports adding liquidity into multiple ticks\n     * using different distribution ratios.\n     */\n    function _addLiquidity() internal {\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        uint256 _oethBalance = IERC20(OETH).balanceOf(address(this));\n        // don't deposit small liquidity amounts\n        if (_wethBalance <= ACTION_THRESHOLD) {\n            return;\n        }\n\n        (\n            bytes memory packedSqrtPriceBreaks,\n            bytes[] memory packedArgs,\n            uint256 WETHRequired,\n            uint256 OETHRequired\n        ) = _getAddLiquidityParams(_wethBalance, 1e30);\n\n        if (OETHRequired > _oethBalance) {\n            IVault(vaultAddress).mintForStrategy(OETHRequired - _oethBalance);\n        }\n\n        _approveTokenAmounts(WETHRequired, OETHRequired);\n\n        (\n            uint256 _wethAmount,\n            uint256 _oethAmount,\n            uint32[] memory binIds\n        ) = liquidityManager.addPositionLiquidityToSenderByTokenIndex(\n                mPool,\n                0, // NFT token index\n                packedSqrtPriceBreaks,\n                packedArgs\n            );\n\n        require(binIds.length == 1, \"Unexpected binIds length\");\n\n        // burn remaining OETH\n        _burnOethOnTheContract();\n        _updateUnderlyingAssets();\n\n        // needs to be called after _updateUnderlyingAssets so the updated amount\n        // is reflected in the event\n        emit LiquidityAdded(\n            _wethBalance, // wethAmountDesired\n            OETHRequired, // oethAmountDesired\n            _wethAmount, // wethAmountSupplied\n            _oethAmount, // oethAmountSupplied\n            tokenId, // tokenId\n            underlyingAssets\n        );\n    }\n\n    /**\n     * @dev The function creates liquidity parameters required to be able to add liquidity to the pool.\n     * The function needs to handle the 3 different cases of the way liquidity is added:\n     *  - only WETH present in the tick\n     *  - only OETH present in the tick\n     *  - both tokens present in the tick\n     *\n     */\n    function _getAddLiquidityParams(uint256 _maxWETH, uint256 _maxOETH)\n        internal\n        returns (\n            bytes memory packedSqrtPriceBreaks,\n            bytes[] memory packedArgs,\n            uint256 WETHRequired,\n            uint256 OETHRequired\n        )\n    {\n        IMaverickV2Pool.AddLiquidityParams[]\n            memory addParams = new IMaverickV2Pool.AddLiquidityParams[](1);\n        int32[] memory ticks = new int32[](1);\n        uint128[] memory amounts = new uint128[](1);\n        ticks[0] = TICK_NUMBER;\n        // arbitrary LP amount\n        amounts[0] = 1e24;\n\n        // construct value for Quoter with arbitrary LP amount\n        IMaverickV2Pool.AddLiquidityParams memory addParam = IMaverickV2Pool\n            .AddLiquidityParams({\n                kind: MAV_STATIC_BIN_KIND,\n                ticks: ticks,\n                amounts: amounts\n            });\n\n        // get the WETH and OETH required to get the proportion of tokens required\n        // given the arbitrary liquidity\n        (WETHRequired, OETHRequired, ) = quoter.calculateAddLiquidity(\n            mPool,\n            addParam\n        );\n\n        /**\n         * If either token required is 0 then the tick consists only of the other token. In that\n         * case the liquidity calculations need to be done using the non 0 token. By setting the\n         * tokenRequired from 0 to 1 the `min` in next step will ignore that (the bigger) value.\n         */\n        WETHRequired = WETHRequired == 0 ? 1 : WETHRequired;\n        OETHRequired = OETHRequired == 0 ? 1 : OETHRequired;\n\n        addParam.amounts[0] = Math_v5\n            .min(\n                ((_maxWETH - 1) * 1e24) / WETHRequired,\n                ((_maxOETH - 1) * 1e24) / OETHRequired\n            )\n            .toUint128();\n\n        // update the quotes with the actual amounts\n        (WETHRequired, OETHRequired, ) = quoter.calculateAddLiquidity(\n            mPool,\n            addParam\n        );\n\n        require(_maxWETH >= WETHRequired, \"More WETH required than specified\");\n        require(_maxOETH >= OETHRequired, \"More OETH required than specified\");\n\n        // organize values to be used by manager\n        addParams[0] = addParam;\n        packedArgs = liquidityManager.packAddLiquidityArgsArray(addParams);\n        // price can stay 0 if array only has one element\n        packedSqrtPriceBreaks = liquidityManager.packUint88Array(\n            new uint88[](1)\n        );\n    }\n\n    /**\n     * @dev Check that the Rooster pool price is within the expected\n     *      parameters.\n     *      This function works whether the strategy contract has liquidity\n     *      position in the pool or not. The function returns _wethSharePct\n     *      as a gas optimization measure.\n     * @param _throwException  when set to true the function throws an exception\n     *                         when pool's price is not within expected range.\n     * @return _isExpectedRange  Bool expressing price is within expected range\n     * @return _wethSharePct  Share of WETH owned by this strategy contract in the\n     *                        configured ticker.\n     */\n    function _checkForExpectedPoolPrice(bool _throwException)\n        internal\n        view\n        returns (bool _isExpectedRange, uint256 _wethSharePct)\n    {\n        require(\n            allowedWethShareStart != 0 && allowedWethShareEnd != 0,\n            \"Weth share interval not set\"\n        );\n\n        uint256 _currentPrice = getPoolSqrtPrice();\n\n        /**\n         * First check pool price is in expected tick range\n         *\n         * A revert is issued even though price being equal to the lower bound as that can not\n         * be within the approved tick range.\n         */\n        if (\n            _currentPrice <= sqrtPriceTickLower ||\n            _currentPrice >= sqrtPriceTickHigher\n        ) {\n            if (_throwException) {\n                revert OutsideExpectedTickRange();\n            }\n\n            return (false, _currentPrice <= sqrtPriceTickLower ? 0 : 1e18);\n        }\n\n        // 18 decimal number expressed WETH tick share\n        _wethSharePct = _getWethShare(_currentPrice);\n\n        if (\n            _wethSharePct < allowedWethShareStart ||\n            _wethSharePct > allowedWethShareEnd\n        ) {\n            if (_throwException) {\n                revert PoolRebalanceOutOfBounds(\n                    _wethSharePct,\n                    allowedWethShareStart,\n                    allowedWethShareEnd\n                );\n            }\n            return (false, _wethSharePct);\n        }\n\n        return (true, _wethSharePct);\n    }\n\n    /**\n     * @notice Rebalance the pool to the desired token split and Deposit any WETH on the contract to the\n     * underlying rooster pool. Print the required amount of corresponding OETH. After the rebalancing is\n     * done burn any potentially remaining OETH tokens still on the strategy contract.\n     *\n     * This function has a slightly different behaviour depending on the status of the underlying Rooster\n     * pool. The function consists of the following 3 steps:\n     * 1. withdrawLiquidityOption -> this is a configurable option where either only part of the liquidity\n     *                               necessary for the swap is removed, or all of it. This way the rebalance\n     *                               is able to optimize for volume, for efficiency or anything in between\n     * 2. swapToDesiredPosition   -> move active trading price in the pool to be able to deposit WETH & OETH\n     *                               tokens with the desired pre-configured ratios\n     * 3. addLiquidity            -> add liquidity into the pool respecting ratio split configuration\n     *\n     *\n     * Exact _amountToSwap, _swapWeth & _minTokenReceived parameters shall be determined by simulating the\n     * transaction off-chain. The strategy checks that after the swap the share of the tokens is in the\n     * expected ranges.\n     *\n     * @param _amountToSwap The amount of the token to swap\n     * @param _swapWeth Swap using WETH when true, use OETH when false\n     * @param _minTokenReceived Slippage check -> minimum amount of token expected in return\n     * @param _liquidityToRemovePct Percentage of liquidity to remove -> the percentage amount of liquidity to\n     *        remove before performing the swap. 1e18 denominated\n     */\n    function rebalance(\n        uint256 _amountToSwap,\n        bool _swapWeth,\n        uint256 _minTokenReceived,\n        uint256 _liquidityToRemovePct\n    ) external nonReentrant onlyGovernorOrStrategist {\n        _rebalance(\n            _amountToSwap,\n            _swapWeth,\n            _minTokenReceived,\n            _liquidityToRemovePct\n        );\n    }\n\n    // slither-disable-start reentrancy-no-eth\n    function _rebalance(\n        uint256 _amountToSwap,\n        bool _swapWeth,\n        uint256 _minTokenReceived,\n        uint256 _liquidityToRemovePct\n    ) internal {\n        // Remove the required amount of liquidity\n        if (_liquidityToRemovePct > 0) {\n            _removeLiquidity(_liquidityToRemovePct);\n        }\n\n        // in some cases (e.g. deposits) we will just want to add liquidity and not\n        // issue a swap to move the active trading position within the pool. Before or after a\n        // deposit or as a standalone call the strategist might issue a rebalance to move the\n        // active trading price to a more desired position.\n        if (_amountToSwap > 0) {\n            // In case liquidity has been removed and there is still not enough WETH owned by the\n            // strategy contract remove additional required amount of WETH.\n            if (_swapWeth) _ensureWETHBalance(_amountToSwap);\n\n            _swapToDesiredPosition(_amountToSwap, _swapWeth, _minTokenReceived);\n        }\n\n        // calling check liquidity early so we don't get unexpected errors when adding liquidity\n        // in the later stages of this function\n        _checkForExpectedPoolPrice(true);\n\n        _addLiquidity();\n\n        // this call shouldn't be necessary, since adding liquidity shouldn't affect the active\n        // trading price. It is a defensive programming measure.\n        (, uint256 _wethSharePct) = _checkForExpectedPoolPrice(true);\n\n        // revert if protocol insolvent\n        _solvencyAssert();\n\n        emit PoolRebalanced(_wethSharePct);\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /**\n     * @dev Perform a swap so that after the swap the tick has the desired WETH to OETH token share.\n     */\n    function _swapToDesiredPosition(\n        uint256 _amountToSwap,\n        bool _swapWeth,\n        uint256 _minTokenReceived\n    ) internal {\n        IERC20 _tokenToSwap = IERC20(_swapWeth ? WETH : OETH);\n        uint256 _balance = _tokenToSwap.balanceOf(address(this));\n\n        if (_balance < _amountToSwap) {\n            // This should never trigger since _ensureWETHBalance will already\n            // throw an error if there is not enough WETH\n            if (_swapWeth) {\n                revert NotEnoughWethForSwap(_balance, _amountToSwap);\n            }\n            // if swapping OETH\n            uint256 mintForSwap = _amountToSwap - _balance;\n            IVault(vaultAddress).mintForStrategy(mintForSwap);\n        }\n\n        // SafeERC20 is used for IERC20 transfers. Not sure why slither complains\n        // slither-disable-next-line unchecked-transfer\n        _tokenToSwap.transfer(address(mPool), _amountToSwap);\n\n        // tickLimit: the furthest tick a swap will execute in. If no limit is desired,\n        // value should be set to type(int32).max for a tokenAIn (WETH) swap\n        // and type(int32).min for a swap where tokenB (OETH) is the input\n\n        IMaverickV2Pool.SwapParams memory swapParams = IMaverickV2Pool\n        // exactOutput defines whether the amount specified is the output\n        // or the input amount of the swap\n            .SwapParams({\n                amount: _amountToSwap,\n                tokenAIn: _swapWeth,\n                exactOutput: false,\n                tickLimit: TICK_NUMBER\n            });\n\n        // swaps without a callback as the assets are already sent to the pool\n        (, uint256 amountOut) = mPool.swap(\n            address(this),\n            swapParams,\n            bytes(\"\")\n        );\n\n        /**\n         * There could be additional checks here for validating minTokenReceived is within the\n         * expected range (e.g. 99% - 101% of the token sent in). Though that doesn't provide\n         * any additional security. After the swap the `_checkForExpectedPoolPrice` validates\n         * that the swap has moved the price into the expected tick (# -1).\n         *\n         * If the guardian forgets to set a `_minTokenReceived` and a sandwich attack bends\n         * the pool before the swap the `_checkForExpectedPoolPrice` will fail the transaction.\n         *\n         * A check would not prevent a compromised guardian from stealing funds as multiple\n         * transactions each loosing smaller amount of funds are still possible.\n         */\n        if (amountOut < _minTokenReceived) {\n            revert SlippageCheck(amountOut);\n        }\n\n        /**\n         * In the interest of each function in `_rebalance` to leave the contract state as\n         * clean as possible the OETH tokens here are burned. This decreases the\n         * dependence where `_swapToDesiredPosition` function relies on later functions\n         * (`addLiquidity`) to burn the OETH. Reducing the risk of error introduction.\n         */\n        _burnOethOnTheContract();\n    }\n\n    /**\n     * @dev This function removes the appropriate amount of liquidity to ensure that the required\n     * amount of WETH is available on the contract\n     *\n     * @param _amount  WETH balance required on the contract\n     */\n    function _ensureWETHBalance(uint256 _amount) internal {\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        if (_wethBalance >= _amount) {\n            return;\n        }\n\n        require(tokenId != 0, \"No liquidity available\");\n        uint256 _additionalWethRequired = _amount - _wethBalance;\n        (uint256 _wethInThePool, ) = getPositionPrincipal();\n\n        if (_wethInThePool < _additionalWethRequired) {\n            revert NotEnoughWethLiquidity(\n                _wethInThePool,\n                _additionalWethRequired\n            );\n        }\n\n        uint256 shareOfWethToRemove = _wethInThePool <= 1\n            ? 1e18\n            : Math_v5.min(\n                /**\n                 * When dealing with shares of liquidity to remove there is always some\n                 * rounding involved. After extensive fuzz testing the below approach\n                 * yielded the best results where the strategy overdraws the least and\n                 * never removes insufficient amount of WETH.\n                 */\n                (_additionalWethRequired + 2).divPrecisely(_wethInThePool - 1) +\n                    2,\n                1e18\n            );\n\n        _removeLiquidity(shareOfWethToRemove);\n    }\n\n    /**\n     * @dev Decrease partial or all liquidity from the pool.\n     * @param _liquidityToDecrease The amount of liquidity to remove denominated in 1e18\n     */\n    function _removeLiquidity(uint256 _liquidityToDecrease) internal {\n        require(_liquidityToDecrease > 0, \"Must remove some liquidity\");\n        require(\n            _liquidityToDecrease <= 1e18,\n            \"Can not remove more than 100% of liquidity\"\n        );\n\n        // 0 indicates the first (and only) bin in the NFT LP position.\n        IMaverickV2Pool.RemoveLiquidityParams memory params = maverickPosition\n            .getRemoveParams(tokenId, 0, _liquidityToDecrease);\n        (uint256 _amountWeth, uint256 _amountOeth) = maverickPosition\n            .removeLiquidityToSender(tokenId, mPool, params);\n\n        _burnOethOnTheContract();\n        _updateUnderlyingAssets();\n\n        // needs to be called after the _updateUnderlyingAssets so the updated amount is reflected\n        // in the event\n        emit LiquidityRemoved(\n            _liquidityToDecrease,\n            _amountWeth,\n            _amountOeth,\n            underlyingAssets\n        );\n    }\n\n    /**\n     * @dev Burns any OETH tokens remaining on the strategy contract if the balance is\n     * above the action threshold.\n     */\n    function _burnOethOnTheContract() internal {\n        uint256 _oethBalance = IERC20(OETH).balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(_oethBalance);\n    }\n\n    /**\n     * @notice Returns the percentage of WETH liquidity in the configured ticker\n     *         owned by this strategy contract.\n     * @return uint256 1e18 denominated percentage expressing the share\n     */\n    function getWETHShare() external view returns (uint256) {\n        uint256 _currentPrice = getPoolSqrtPrice();\n        return _getWethShare(_currentPrice);\n    }\n\n    /**\n     * @dev Returns the share of WETH in tick denominated in 1e18\n     */\n    function _getWethShare(uint256 _currentPrice)\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            uint256 wethAmount,\n            uint256 oethAmount\n        ) = _reservesInTickForGivenPriceAndLiquidity(\n                sqrtPriceTickLower,\n                sqrtPriceTickHigher,\n                _currentPrice,\n                1e24\n            );\n\n        return wethAmount.divPrecisely(wethAmount + oethAmount);\n    }\n\n    /**\n     * @notice Returns the current pool price in square root\n     * @return Square root of the pool price\n     */\n    function getPoolSqrtPrice() public view returns (uint256) {\n        return poolLens.getPoolSqrtPrice(mPool);\n    }\n\n    /**\n     * @notice Returns the current active trading tick of the underlying pool\n     * @return _currentTick Current pool trading tick\n     */\n    function getCurrentTradingTick() public view returns (int32 _currentTick) {\n        _currentTick = mPool.getState().activeTick;\n    }\n\n    /**\n     * @notice Mint the initial NFT position\n     *\n     * @dev This amount is \"gifted\" to the strategy contract and will count as a yield\n     *      surplus.\n     */\n    // slither-disable-start reentrancy-no-eth\n    function mintInitialPosition() external onlyGovernor nonReentrant {\n        require(tokenId == 0, \"Initial position already minted\");\n        (\n            bytes memory packedSqrtPriceBreaks,\n            bytes[] memory packedArgs,\n            uint256 WETHRequired,\n            uint256 OETHRequired\n        ) = _getAddLiquidityParams(1e16, 1e16);\n\n        // Mint rounded up OETH amount\n        if (OETHRequired > 0) {\n            IVault(vaultAddress).mintForStrategy(OETHRequired);\n        }\n\n        _approveTokenAmounts(WETHRequired, OETHRequired);\n\n        // Store the tokenId before calling updateUnderlyingAssets as it relies on the tokenId\n        // not being 0\n        (, , , tokenId) = liquidityManager.mintPositionNftToSender(\n            mPool,\n            packedSqrtPriceBreaks,\n            packedArgs\n        );\n\n        // burn remaining OETH\n        _burnOethOnTheContract();\n        _updateUnderlyingAssets();\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /**\n     * @notice Returns the balance of tokens the strategy holds in the LP position\n     * @return _amountWeth Amount of WETH in position\n     * @return _amountOeth Amount of OETH in position\n     */\n    function getPositionPrincipal()\n        public\n        view\n        returns (uint256 _amountWeth, uint256 _amountOeth)\n    {\n        if (tokenId == 0) {\n            return (0, 0);\n        }\n\n        (_amountWeth, _amountOeth, ) = _getPositionInformation();\n    }\n\n    /**\n     * @dev Returns the balance of tokens the strategy holds in the LP position\n     * @return _amountWeth Amount of WETH in position\n     * @return _amountOeth Amount of OETH in position\n     * @return liquidity Amount of liquidity in the position\n     */\n    function _getPositionInformation()\n        internal\n        view\n        returns (\n            uint256 _amountWeth,\n            uint256 _amountOeth,\n            uint256 liquidity\n        )\n    {\n        IMaverickV2Position.PositionFullInformation\n            memory positionInfo = maverickPosition.tokenIdPositionInformation(\n                tokenId,\n                0\n            );\n\n        require(\n            positionInfo.liquidities.length == 1,\n            \"Unexpected liquidities length\"\n        );\n        require(positionInfo.ticks.length == 1, \"Unexpected ticks length\");\n\n        _amountWeth = positionInfo.amountA;\n        _amountOeth = positionInfo.amountB;\n        liquidity = positionInfo.liquidities[0];\n    }\n\n    /**\n     * Checks that the protocol is solvent, protecting from a rogue Strategist / Guardian that can\n     * keep rebalancing the pool in both directions making the protocol lose a tiny amount of\n     * funds each time.\n     *\n     * Protocol must be at least SOLVENCY_THRESHOLD (99.8%) backed in order for the rebalances to\n     * function.\n     */\n    function _solvencyAssert() internal view {\n        uint256 _totalVaultValue = IVault(vaultAddress).totalValue();\n        uint256 _totalOethSupply = IERC20(OETH).totalSupply();\n\n        if (\n            _totalVaultValue.divPrecisely(_totalOethSupply) < SOLVENCY_THRESHOLD\n        ) {\n            revert(\"Protocol insolvent\");\n        }\n    }\n\n    /**\n     * @dev Collect Rooster reward token, and send it to the harvesterAddress\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Do nothing if there's no position minted\n        if (tokenId > 0) {\n            uint32[] memory binIds = new uint32[](1);\n            IMaverickV2Pool.TickState memory tickState = mPool.getTick(\n                TICK_NUMBER\n            );\n            // get the binId for the MAV_STATIC_BIN_KIND in tick TICK_NUMBER (-1)\n            binIds[0] = tickState.binIdsByTick[0];\n\n            uint256 lastEpoch = votingDistributor.lastEpoch();\n\n            poolDistributor.claimLp(\n                address(this),\n                tokenId,\n                mPool,\n                binIds,\n                lastEpoch\n            );\n        }\n\n        // Run the internal inherited function\n        _collectRewardTokens();\n    }\n\n    /***************************************\n            Balances and Fees\n    ****************************************/\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(_asset == WETH, \"Only WETH supported\");\n\n        // because of PoolLens inaccuracy there is usually some dust WETH left on the contract\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        // just paranoia check, in case there is OETH in the strategy that for some reason hasn't\n        // been burned yet. This should always be 0.\n        uint256 _oethBalance = IERC20(OETH).balanceOf(address(this));\n        return underlyingAssets + _wethBalance + _oethBalance;\n    }\n\n    /// @dev This function updates the amount of underlying assets with the approach of the least possible\n    ///      total tokens extracted for the current liquidity in the pool.\n    function _updateUnderlyingAssets() internal {\n        /**\n         * Our net value represent the smallest amount of tokens we are able to extract from the position\n         * given our liquidity.\n         *\n         * The least amount of tokens ex-tractable from the position is where the active trading price is\n         * at the edge between tick -1 & tick 0. There the pool is offering 1:1 trades between WETH & OETH.\n         * At that moment the pool consists completely of WETH and no OETH.\n         *\n         * The more swaps from OETH -> WETH happen on the pool the more the price starts to move away from the tick 0\n         * towards the middle of tick -1 making OETH (priced in WETH) cheaper.\n         */\n\n        uint256 _wethAmount = tokenId == 0 ? 0 : _balanceInPosition();\n\n        underlyingAssets = _wethAmount;\n        emit UnderlyingAssetsUpdated(_wethAmount);\n    }\n\n    /**\n     * @dev Strategy reserves (which consist only of WETH in case of Rooster - Plume pool)\n     * when the tick price is closest to parity - assuring the lowest amount of tokens\n     * returned for the current position liquidity.\n     */\n    function _balanceInPosition() internal view returns (uint256 _wethBalance) {\n        (, , uint256 liquidity) = _getPositionInformation();\n\n        uint256 _oethBalance;\n\n        (_wethBalance, _oethBalance) = _reservesInTickForGivenPriceAndLiquidity(\n            sqrtPriceTickLower,\n            sqrtPriceTickHigher,\n            sqrtPriceAtParity,\n            liquidity\n        );\n\n        require(_oethBalance == 0, \"Non zero oethBalance\");\n    }\n\n    /**\n     * @notice Tick dominance   denominated in 1e18\n     * @return _tickDominance   The share of liquidity in TICK_NUMBER tick owned\n     *                          by the strategy contract denominated in 1e18\n     */\n    function tickDominance() public view returns (uint256 _tickDominance) {\n        IMaverickV2Pool.TickState memory tickState = mPool.getTick(TICK_NUMBER);\n\n        uint256 wethReserve = tickState.reserveA;\n        uint256 oethReserve = tickState.reserveB;\n\n        // prettier-ignore\n        (uint256 _amountWeth, uint256 _amountOeth, ) = _getPositionInformation();\n\n        if (wethReserve + oethReserve == 0) {\n            return 0;\n        }\n\n        _tickDominance = (_amountWeth + _amountOeth).divPrecisely(\n            wethReserve + oethReserve\n        );\n    }\n\n    /***************************************\n            Hidden functions\n    ****************************************/\n    /**\n     * @dev Unsupported\n     */\n    function setPTokenAddress(address, address) external pure override {\n        // The pool tokens can never change.\n        revert(\"Unsupported method\");\n    }\n\n    /**\n     * @dev Unsupported\n     */\n    function removePToken(uint256) external pure override {\n        // The pool tokens can never change.\n        revert(\"Unsupported method\");\n    }\n\n    /**\n     * @dev Unsupported\n     */\n    function _abstractSetPToken(address, address) internal pure override {\n        revert(\"Unsupported method\");\n    }\n\n    /**\n     * @dev Unsupported\n     */\n    function safeApproveAllTokens() external pure override {\n        // all the amounts are approved at the time required\n        revert(\"Unsupported method\");\n    }\n\n    /***************************************\n          Maverick liquidity utilities\n    ****************************************/\n\n    /// @notice Calculates deltaA = liquidity * (sqrt(upper) - sqrt(lower))\n    ///  Calculates deltaB = liquidity / sqrt(lower) - liquidity / sqrt(upper),\n    ///  i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n    ///\n    /// @dev refactored from here:\n    // solhint-disable-next-line max-line-length\n    /// https://github.com/rooster-protocol/rooster-contracts/blob/main/v2-supplemental/contracts/libraries/LiquidityUtilities.sol#L665-L695\n    function _reservesInTickForGivenPriceAndLiquidity(\n        uint256 _lowerSqrtPrice,\n        uint256 _upperSqrtPrice,\n        uint256 _newSqrtPrice,\n        uint256 _liquidity\n    ) internal pure returns (uint128 reserveA, uint128 reserveB) {\n        if (_liquidity == 0) {\n            (reserveA, reserveB) = (0, 0);\n        } else {\n            uint256 lowerEdge = MathRooster.max(_lowerSqrtPrice, _newSqrtPrice);\n\n            reserveA = MathRooster\n                .mulCeil(\n                    _liquidity,\n                    MathRooster.clip(\n                        MathRooster.min(_upperSqrtPrice, _newSqrtPrice),\n                        _lowerSqrtPrice\n                    )\n                )\n                .toUint128();\n            reserveB = MathRooster\n                .mulDivCeil(\n                    _liquidity,\n                    1e18 * MathRooster.clip(_upperSqrtPrice, lowerEdge),\n                    _upperSqrtPrice * lowerEdge\n                )\n                .toUint128();\n        }\n    }\n}\n"
    },
    "contracts/strategies/sonic/SonicStakingStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SonicValidatorDelegator } from \"./SonicValidatorDelegator.sol\";\nimport { IWrappedSonic } from \"../../interfaces/sonic/IWrappedSonic.sol\";\n\n/**\n * @title Staking Strategy for Sonic's native S currency\n * @author Origin Protocol Inc\n */\ncontract SonicStakingStrategy is SonicValidatorDelegator {\n    // For future use\n    uint256[50] private __gap;\n\n    constructor(\n        BaseStrategyConfig memory _baseConfig,\n        address _wrappedSonic,\n        address _sfc\n    ) SonicValidatorDelegator(_baseConfig, _wrappedSonic, _sfc) {}\n\n    /// @notice Deposit wrapped S asset into the underlying platform.\n    /// @param _asset Address of asset to deposit. Has to be Wrapped Sonic (wS).\n    /// @param _amount Amount of assets that were transferred to the strategy by the vault.\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        require(_asset == wrappedSonic, \"Unsupported asset\");\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @notice Deposit Wrapped Sonic (wS) to this strategy and delegate to a validator.\n     * @param _asset Address of Wrapped Sonic (wS) token\n     * @param _amount Amount of Wrapped Sonic (wS) to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal virtual {\n        require(_amount > 0, \"Must deposit something\");\n\n        _delegate(_amount);\n        emit Deposit(_asset, address(0), _amount);\n    }\n\n    /**\n     * @notice Deposit the entire balance of wrapped S in this strategy contract into\n     * the underlying platform.\n     */\n    function depositAll() external virtual override onlyVault nonReentrant {\n        uint256 wSBalance = IERC20(wrappedSonic).balanceOf(address(this));\n\n        if (wSBalance > 0) {\n            _deposit(wrappedSonic, wSBalance);\n        }\n    }\n\n    /// @notice Withdraw Wrapped Sonic (wS) from this strategy contract.\n    /// Used only if some wS is lingering on the contract.\n    /// That can happen only when someone sends wS directly to this contract\n    /// @param _recipient Address to receive withdrawn assets\n    /// @param _asset Address of the Wrapped Sonic (wS) token\n    /// @param _amount Amount of Wrapped Sonic (wS) to withdraw\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_asset == wrappedSonic, \"Unsupported asset\");\n        _withdraw(_recipient, _asset, _amount);\n    }\n\n    function _withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) internal override {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        // slither-disable-next-line unchecked-transfer unused-return\n        IERC20(_asset).transfer(_recipient, _amount);\n\n        emit Withdrawal(wrappedSonic, address(0), _amount);\n    }\n\n    /// @notice Transfer all Wrapped Sonic (wS) deposits back to the vault.\n    /// This does not withdraw from delegated validators. That has to be done separately with `undelegate`.\n    /// Any native S in this strategy will be withdrawn.\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        uint256 balance = address(this).balance;\n        if (balance > 0) {\n            IWrappedSonic(wrappedSonic).deposit{ value: balance }();\n        }\n        uint256 wSBalance = IERC20(wrappedSonic).balanceOf(address(this));\n        if (wSBalance > 0) {\n            _withdraw(vaultAddress, wrappedSonic, wSBalance);\n        }\n    }\n\n    /**\n     * @dev Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset token\n     */\n    function supportsAsset(address _asset)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _asset == wrappedSonic;\n    }\n\n    /**\n     * @notice is not supported for this strategy as the\n     * Wrapped Sonic (wS) token is set at deploy time.\n     */\n    function setPTokenAddress(address, address)\n        external\n        view\n        override\n        onlyGovernor\n    {\n        revert(\"unsupported function\");\n    }\n\n    /// @notice is not used by this strategy as all staking rewards are restaked\n    function collectRewardTokens() external override nonReentrant {\n        revert(\"unsupported function\");\n    }\n\n    /**\n     * @notice is not supported for this strategy as the\n     * Wrapped Sonic (wS) token is set at deploy time.\n     */\n    function removePToken(uint256) external view override onlyGovernor {\n        revert(\"unsupported function\");\n    }\n\n    /// @dev is not used by this strategy but must be implemented as it's abstract\n    /// in the inherited `InitializableAbstractStrategy` contract.\n    function _abstractSetPToken(address, address) internal virtual override {}\n\n    /// @notice is not used by this strategy\n    function safeApproveAllTokens() external override onlyGovernor {}\n}\n"
    },
    "contracts/strategies/sonic/SonicSwapXAMOStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title SwapX Algorithmic Market Maker (AMO) Strategy\n * @notice AMO strategy for the SwapX OS/wS stable pool\n * @author Origin Protocol Inc\n */\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IERC20, InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\nimport { sqrt } from \"../../utils/PRBMath.sol\";\nimport { IBasicToken } from \"../../interfaces/IBasicToken.sol\";\nimport { IPair } from \"../../interfaces/sonic/ISwapXPair.sol\";\nimport { IGauge } from \"../../interfaces/sonic/ISwapXGauge.sol\";\nimport { IVault } from \"../../interfaces/IVault.sol\";\n\ncontract SonicSwapXAMOStrategy is InitializableAbstractStrategy {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n    using SafeCast for uint256;\n\n    /**\n     * @notice a threshold under which the contract no longer allows for the protocol to manually rebalance.\n     *      Guarding against a strategist / guardian being taken over and with multiple transactions\n     *      draining the protocol funds.\n     */\n    uint256 public constant SOLVENCY_THRESHOLD = 0.998 ether;\n\n    /// @notice Precision for the SwapX Stable AMM (sAMM) invariant k.\n    uint256 public constant PRECISION = 1e18;\n\n    /// @notice Address of the Wrapped S (wS) token.\n    address public immutable ws;\n\n    /// @notice Address of the OS token contract.\n    address public immutable os;\n\n    /// @notice Address of the SwapX Stable pool contract.\n    address public immutable pool;\n\n    /// @notice Address of the SwapX Gauge contract.\n    address public immutable gauge;\n\n    /// @notice The max amount the OS/wS price can deviate from peg (1e18)\n    /// before deposits are reverted scaled to 18 decimals.\n    /// eg 0.01e18 or 1e16 is 1% which is 100 basis points.\n    /// This is the amount below and above peg so a 50 basis point deviation (0.005e18)\n    /// allows a price range from 0.995 to 1.005.\n    uint256 public maxDepeg;\n\n    event SwapOTokensToPool(\n        uint256 osMinted,\n        uint256 wsDepositAmount,\n        uint256 osDepositAmount,\n        uint256 lpTokens\n    );\n    event SwapAssetsToPool(\n        uint256 wsSwapped,\n        uint256 lpTokens,\n        uint256 osBurnt\n    );\n    event MaxDepegUpdated(uint256 maxDepeg);\n\n    /**\n     * @dev Verifies that the caller is the Strategist of the Vault.\n     */\n    modifier onlyStrategist() {\n        require(\n            msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Strategist\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Skim the SwapX pool in case any extra wS or OS tokens were added\n     */\n    modifier skimPool() {\n        IPair(pool).skim(address(this));\n        _;\n    }\n\n    /**\n     * @dev Checks the pool is balanced enough to allow deposits.\n     */\n    modifier nearBalancedPool() {\n        // OS/wS price = wS / OS\n        // Get the OS/wS price for selling 1 OS for wS\n        // As OS is 1, the wS amount is the OS/wS price\n        uint256 sellPrice = IPair(pool).getAmountOut(1e18, os);\n\n        // Get the amount of OS received from selling 1 wS. This is buying OS.\n        uint256 osAmount = IPair(pool).getAmountOut(1e18, ws);\n        // Convert to a OS/wS price = wS / OS\n        uint256 buyPrice = 1e36 / osAmount;\n\n        uint256 pegPrice = 1e18;\n\n        require(\n            sellPrice >= pegPrice - maxDepeg && buyPrice <= pegPrice + maxDepeg,\n            \"price out of range\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Checks the pool's balances have improved and the balances\n     * have not tipped to the other side.\n     * This modifier is only applied to functions that do swaps against the pool.\n     * Deposits and withdrawals are proportional to the pool's balances hence don't need this check.\n     */\n    modifier improvePoolBalance() {\n        // Get the asset and OToken balances in the pool\n        (uint256 wsReservesBefore, uint256 osReservesBefore, ) = IPair(pool)\n            .getReserves();\n        // diff = wS balance - OS balance\n        int256 diffBefore = wsReservesBefore.toInt256() -\n            osReservesBefore.toInt256();\n\n        _;\n\n        // Get the asset and OToken balances in the pool\n        (uint256 wsReservesAfter, uint256 osReservesAfter, ) = IPair(pool)\n            .getReserves();\n        // diff = wS balance - OS balance\n        int256 diffAfter = wsReservesAfter.toInt256() -\n            osReservesAfter.toInt256();\n\n        if (diffBefore == 0) {\n            require(diffAfter == 0, \"Position balance is worsened\");\n        } else if (diffBefore < 0) {\n            // If the pool was originally imbalanced in favor of OS, then\n            // we want to check that the pool is now more balanced\n            require(diffAfter <= 0, \"Assets overshot peg\");\n            require(diffBefore < diffAfter, \"OTokens balance worse\");\n        } else if (diffBefore > 0) {\n            // If the pool was originally imbalanced in favor of wS, then\n            // we want to check that the pool is now more balanced\n            require(diffAfter >= 0, \"OTokens overshot peg\");\n            require(diffAfter < diffBefore, \"Assets balance worse\");\n        }\n    }\n\n    /**\n     * @param _baseConfig The `platformAddress` is the address of the SwapX pool.\n     * The `vaultAddress` is the address of the Origin Sonic Vault.\n     * @param _os Address of the OS token.\n     * @param _ws Address of the Wrapped S (wS) token.\n     * @param _gauge Address of the SwapX gauge for the pool.\n     */\n    constructor(\n        BaseStrategyConfig memory _baseConfig,\n        address _os,\n        address _ws,\n        address _gauge\n    ) InitializableAbstractStrategy(_baseConfig) {\n        // Check the pool tokens are correct\n        require(\n            IPair(_baseConfig.platformAddress).token0() == _ws &&\n                IPair(_baseConfig.platformAddress).token1() == _os,\n            \"Incorrect pool tokens\"\n        );\n        // Checked both tokens are to 18 decimals\n        require(\n            IBasicToken(_ws).decimals() == 18 &&\n                IBasicToken(_os).decimals() == 18,\n            \"Incorrect token decimals\"\n        );\n        // Check the SwapX pool is a Stable AMM (sAMM)\n        require(\n            IPair(_baseConfig.platformAddress).isStable() == true,\n            \"Pool not stable\"\n        );\n        // Check the gauge is for the pool\n        require(\n            IGauge(_gauge).TOKEN() == _baseConfig.platformAddress,\n            \"Incorrect gauge\"\n        );\n\n        // Set the immutable variables\n        os = _os;\n        ws = _ws;\n        pool = _baseConfig.platformAddress;\n        gauge = _gauge;\n\n        // This is an implementation contract. The governor is set in the proxy contract.\n        _setGovernor(address(0));\n    }\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as SwapX strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Array containing SWPx token address\n     * @param _maxDepeg The max amount the OS/wS price can deviate from peg (1e18) before deposits are reverted.\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses,\n        uint256 _maxDepeg\n    ) external onlyGovernor initializer {\n        address[] memory pTokens = new address[](1);\n        pTokens[0] = pool;\n\n        address[] memory _assets = new address[](1);\n        _assets[0] = ws;\n\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            pTokens\n        );\n\n        maxDepeg = _maxDepeg;\n\n        _approveBase();\n    }\n\n    /***************************************\n                    Deposit\n    ****************************************/\n\n    /**\n     * @notice Deposit an amount of Wrapped S (wS) into the SwapX pool.\n     * Mint OS in proportion to the pool's wS and OS reserves,\n     * transfer Wrapped S (wS) and OS to the pool,\n     * mint the pool's LP token and deposit in the gauge.\n     * @dev This tx must be wrapped by the VaultValueChecker.\n     * To minimize loses, the pool should be rebalanced before depositing.\n     * The pool's OS/wS price must be within the maxDepeg range.\n     * @param _asset Address of Wrapped S (wS) token.\n     * @param _wsAmount Amount of Wrapped S (wS) tokens to deposit.\n     */\n    function deposit(address _asset, uint256 _wsAmount)\n        external\n        override\n        onlyVault\n        nonReentrant\n        skimPool\n        nearBalancedPool\n    {\n        require(_asset == ws, \"Unsupported asset\");\n        require(_wsAmount > 0, \"Must deposit something\");\n\n        (uint256 osDepositAmount, ) = _deposit(_wsAmount);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n\n        // Emit event for the deposited wS tokens\n        emit Deposit(ws, pool, _wsAmount);\n        // Emit event for the minted OS tokens\n        emit Deposit(os, pool, osDepositAmount);\n    }\n\n    /**\n     * @notice Deposit all the strategy's Wrapped S (wS) tokens into the SwapX pool.\n     * Mint OS in proportion to the pool's wS and OS reserves,\n     * transfer Wrapped S (wS) and OS to the pool,\n     * mint the pool's LP token and deposit in the gauge.\n     * @dev This tx must be wrapped by the VaultValueChecker.\n     * To minimize loses, the pool should be rebalanced before depositing.\n     * The pool's OS/wS price must be within the maxDepeg range.\n     */\n    function depositAll()\n        external\n        override\n        onlyVault\n        nonReentrant\n        skimPool\n        nearBalancedPool\n    {\n        uint256 wsBalance = IERC20(ws).balanceOf(address(this));\n        if (wsBalance > 0) {\n            (uint256 osDepositAmount, ) = _deposit(wsBalance);\n\n            // Ensure solvency of the vault\n            _solvencyAssert();\n\n            // Emit event for the deposited wS tokens\n            emit Deposit(ws, pool, wsBalance);\n            // Emit event for the minted OS tokens\n            emit Deposit(os, pool, osDepositAmount);\n        }\n    }\n\n    /**\n     * @dev Mint OS in proportion to the pool's wS and OS reserves,\n     * transfer Wrapped S (wS) and OS to the pool,\n     * mint the pool's LP token and deposit in the gauge.\n     * @param _wsAmount Amount of Wrapped S (wS) tokens to deposit.\n     * @return osDepositAmount Amount of OS tokens minted and deposited into the pool.\n     * @return lpTokens Amount of SwapX pool LP tokens minted and deposited into the gauge.\n     */\n    function _deposit(uint256 _wsAmount)\n        internal\n        returns (uint256 osDepositAmount, uint256 lpTokens)\n    {\n        // Calculate the required amount of OS to mint based on the wS amount.\n        osDepositAmount = _calcTokensToMint(_wsAmount);\n\n        // Mint the required OS tokens to this strategy\n        IVault(vaultAddress).mintForStrategy(osDepositAmount);\n\n        // Add wS and OS liquidity to the pool and stake in gauge\n        lpTokens = _depositToPoolAndGauge(_wsAmount, osDepositAmount);\n    }\n\n    /***************************************\n                    Withdraw\n    ****************************************/\n\n    /**\n     * @notice Withdraw wS and OS from the SwapX pool, burn the OS,\n     * and transfer the wS to the recipient.\n     * @param _recipient Address of the Vault.\n     * @param _asset Address of the Wrapped S (wS) contract.\n     * @param _wsAmount Amount of Wrapped S (wS) to withdraw.\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _wsAmount\n    ) external override onlyVault nonReentrant skimPool {\n        require(_wsAmount > 0, \"Must withdraw something\");\n        require(_asset == ws, \"Unsupported asset\");\n        // This strategy can't be set as a default strategy for wS in the Vault.\n        // This means the recipient must always be the Vault.\n        require(_recipient == vaultAddress, \"Only withdraw to vault allowed\");\n\n        // Calculate how much pool LP tokens to burn to get the required amount of wS tokens back\n        uint256 lpTokens = _calcTokensToBurn(_wsAmount);\n\n        // Withdraw pool LP tokens from the gauge and remove assets from from the pool\n        _withdrawFromGaugeAndPool(lpTokens);\n\n        // Burn all the removed OS and any that was left in the strategy\n        uint256 osToBurn = IERC20(os).balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(osToBurn);\n\n        // Transfer wS to the recipient\n        // Note there can be a dust amount of wS left in the strategy as\n        // the burn of the pool's LP tokens is rounded up\n        require(\n            IERC20(ws).balanceOf(address(this)) >= _wsAmount,\n            \"Not enough wS removed from pool\"\n        );\n        IERC20(ws).safeTransfer(_recipient, _wsAmount);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n\n        // Emit event for the withdrawn wS tokens\n        emit Withdrawal(ws, pool, _wsAmount);\n        // Emit event for the burnt OS tokens\n        emit Withdrawal(os, pool, osToBurn);\n    }\n\n    /**\n     * @notice Withdraw all pool LP tokens from the gauge,\n     * remove all wS and OS from the SwapX pool,\n     * burn all the OS tokens,\n     * and transfer all the wS to the Vault contract.\n     * @dev There is no solvency check here as withdrawAll can be called to\n     * quickly secure assets to the Vault in emergencies.\n     */\n    function withdrawAll()\n        external\n        override\n        onlyVaultOrGovernor\n        nonReentrant\n        skimPool\n    {\n        // Get all the pool LP tokens the strategy has staked in the gauge\n        uint256 lpTokens = IGauge(gauge).balanceOf(address(this));\n        // Can not withdraw zero LP tokens from the gauge\n        if (lpTokens == 0) return;\n\n        if (IGauge(gauge).emergency()) {\n            // The gauge is in emergency mode\n            _emergencyWithdrawFromGaugeAndPool();\n        } else {\n            // Withdraw pool LP tokens from the gauge and remove assets from from the pool\n            _withdrawFromGaugeAndPool(lpTokens);\n        }\n\n        // Burn all OS in this strategy contract\n        uint256 osToBurn = IERC20(os).balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(osToBurn);\n\n        // Get the strategy contract's wS balance.\n        // This includes all that was removed from the SwapX pool and\n        // any that was sitting in the strategy contract before the removal.\n        uint256 wsBalance = IERC20(ws).balanceOf(address(this));\n        IERC20(ws).safeTransfer(vaultAddress, wsBalance);\n\n        // Emit event for the withdrawn wS tokens\n        emit Withdrawal(ws, pool, wsBalance);\n        // Emit event for the burnt OS tokens\n        emit Withdrawal(os, pool, osToBurn);\n    }\n\n    /***************************************\n                Pool Rebalancing\n    ****************************************/\n\n    /** @notice Used when there is more OS than wS in the pool.\n     * wS and OS is removed from the pool, the received wS is swapped for OS\n     * and the left over OS in the strategy is burnt.\n     * The OS/wS price is < 1.0 so OS is being bought at a discount.\n     * @param _wsAmount Amount of Wrapped S (wS) to swap into the pool.\n     */\n    function swapAssetsToPool(uint256 _wsAmount)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n        skimPool\n    {\n        require(_wsAmount > 0, \"Must swap something\");\n\n        // 1. Partially remove liquidity so there’s enough wS for the swap\n\n        // Calculate how much pool LP tokens to burn to get the required amount of wS tokens back\n        uint256 lpTokens = _calcTokensToBurn(_wsAmount);\n        require(lpTokens > 0, \"No LP tokens to burn\");\n\n        _withdrawFromGaugeAndPool(lpTokens);\n\n        // 2. Swap wS for OS against the pool\n        // Swap exact amount of wS for OS against the pool\n        // There can be a dust amount of wS left in the strategy as the burn of the pool's LP tokens is rounded up\n        _swapExactTokensForTokens(_wsAmount, ws, os);\n\n        // 3. Burn all the OS left in the strategy from the remove liquidity and swap\n        uint256 osToBurn = IERC20(os).balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(osToBurn);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n\n        // Emit event for the burnt OS tokens\n        emit Withdrawal(os, pool, osToBurn);\n        // Emit event for the swap\n        emit SwapAssetsToPool(_wsAmount, lpTokens, osToBurn);\n    }\n\n    /**\n     * @notice Used when there is more wS than OS in the pool.\n     * OS is minted and swapped for wS against the pool,\n     * more OS is minted and added back into the pool with the swapped out wS.\n     * The OS/wS price is > 1.0 so OS is being sold at a premium.\n     * @param _osAmount Amount of OS to swap into the pool.\n     */\n    function swapOTokensToPool(uint256 _osAmount)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n        skimPool\n    {\n        require(_osAmount > 0, \"Must swap something\");\n\n        // 1. Mint OS so it can be swapped into the pool\n\n        // There can be OS in the strategy from skimming the pool\n        uint256 osInStrategy = IERC20(os).balanceOf(address(this));\n        require(_osAmount >= osInStrategy, \"Too much OS in strategy\");\n        uint256 osToMint = _osAmount - osInStrategy;\n\n        // Mint the required OS tokens to this strategy\n        IVault(vaultAddress).mintForStrategy(osToMint);\n\n        // 2. Swap OS for wS against the pool\n        _swapExactTokensForTokens(_osAmount, os, ws);\n\n        // The wS is from the swap and any wS that was sitting in the strategy\n        uint256 wsDepositAmount = IERC20(ws).balanceOf(address(this));\n\n        // 3. Add wS and OS back to the pool in proportion to the pool's reserves\n        (uint256 osDepositAmount, uint256 lpTokens) = _deposit(wsDepositAmount);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n\n        // Emit event for the minted OS tokens\n        emit Deposit(os, pool, osToMint + osDepositAmount);\n        // Emit event for the swap\n        emit SwapOTokensToPool(\n            osToMint,\n            wsDepositAmount,\n            osDepositAmount,\n            lpTokens\n        );\n    }\n\n    /***************************************\n                Assets and Rewards\n    ****************************************/\n\n    /**\n     * @notice Get the wS value of assets in the strategy and SwapX pool.\n     * The value of the assets in the pool is calculated assuming the pool is balanced.\n     * This way the value can not be manipulated by changing the pool's token balances.\n     * @param _asset      Address of the Wrapped S (wS) token\n     * @return balance    Total value in wS.\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == ws, \"Unsupported asset\");\n\n        // wS balance needed here for the balance check that happens from vault during depositing.\n        balance = IERC20(ws).balanceOf(address(this));\n\n        // This assumes 1 gauge LP token = 1 pool LP token\n        uint256 lpTokens = IGauge(gauge).balanceOf(address(this));\n        if (lpTokens == 0) return balance;\n\n        // Add the strategy’s share of the wS and OS tokens in the SwapX pool if the pool was balanced.\n        balance += _lpValue(lpTokens);\n    }\n\n    /**\n     * @notice Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == ws;\n    }\n\n    /**\n     * @notice Collect accumulated SWPx (and other) rewards and send to the Harvester.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Collect SWPx rewards from the gauge\n        IGauge(gauge).getReward();\n\n        _collectRewardTokens();\n    }\n\n    /***************************************\n        Internal SwapX Pool and Gauge Functions\n    ****************************************/\n\n    /**\n     * @dev Calculate the required amount of OS to mint based on the wS amount.\n     * This ensures the proportion of OS tokens being added to the pool matches the proportion of wS tokens.\n     * For example, if the added wS tokens is 10% of existing wS tokens in the pool,\n     * then the OS tokens being added should also be 10% of the OS tokens in the pool.\n     * @param _wsAmount Amount of Wrapped S (wS) to be added to the pool.\n     * @return osAmount Amount of OS to be minted and added to the pool.\n     */\n    function _calcTokensToMint(uint256 _wsAmount)\n        internal\n        view\n        returns (uint256 osAmount)\n    {\n        (uint256 wsReserves, uint256 osReserves, ) = IPair(pool).getReserves();\n        require(wsReserves > 0, \"Empty pool\");\n\n        // OS to add = (wS being added * OS in pool) / wS in pool\n        osAmount = (_wsAmount * osReserves) / wsReserves;\n    }\n\n    /**\n     * @dev Calculate how much pool LP tokens to burn to get the required amount of wS tokens back\n     * from the pool.\n     * @param _wsAmount Amount of Wrapped S (wS) to be removed from the pool.\n     * @return lpTokens Amount of SwapX pool LP tokens to burn.\n     */\n    function _calcTokensToBurn(uint256 _wsAmount)\n        internal\n        view\n        returns (uint256 lpTokens)\n    {\n        /* The SwapX pool proportionally returns the reserve tokens when removing liquidity.\n         * First, calculate the proportion of required wS tokens against the pools wS reserves.\n         * That same proportion is used to calculate the required amount of pool LP tokens.\n         * For example, if the required wS tokens is 10% of the pool's wS reserves,\n         * then 10% of the pool's LP supply needs to be burned.\n         *\n         * Because we are doing balanced removal we should be making profit when removing liquidity in a\n         * pool tilted to either side.\n         *\n         * Important: A downside is that the Strategist / Governor needs to be\n         * cognizant of not removing too much liquidity. And while the proposal to remove liquidity\n         * is being voted on, the pool tilt might change so much that the proposal that has been valid while\n         * created is no longer valid.\n         */\n\n        (uint256 wsReserves, , ) = IPair(pool).getReserves();\n        require(wsReserves > 0, \"Empty pool\");\n\n        lpTokens = (_wsAmount * IPair(pool).totalSupply()) / wsReserves;\n        lpTokens += 1; // Add 1 to ensure we get enough LP tokens with rounding\n    }\n\n    /**\n     * @dev Deposit Wrapped S (wS) and OS liquidity to the SwapX pool\n     * and stake the pool's LP token in the gauge.\n     * @param _wsAmount Amount of Wrapped S (wS) to deposit.\n     * @param _osAmount Amount of OS to deposit.\n     * @return lpTokens Amount of SwapX pool LP tokens minted.\n     */\n    function _depositToPoolAndGauge(uint256 _wsAmount, uint256 _osAmount)\n        internal\n        returns (uint256 lpTokens)\n    {\n        // Transfer wS to the pool\n        IERC20(ws).safeTransfer(pool, _wsAmount);\n        // Transfer OS to the pool\n        IERC20(os).safeTransfer(pool, _osAmount);\n\n        // Mint LP tokens from the pool\n        lpTokens = IPair(pool).mint(address(this));\n\n        // Deposit the pool's LP tokens into the gauge\n        IGauge(gauge).deposit(lpTokens);\n    }\n\n    /**\n     * @dev Withdraw pool LP tokens from the gauge and remove wS and OS from the pool.\n     * @param _lpTokens Amount of SwapX pool LP tokens to withdraw from the gauge\n     */\n    function _withdrawFromGaugeAndPool(uint256 _lpTokens) internal {\n        require(\n            IGauge(gauge).balanceOf(address(this)) >= _lpTokens,\n            \"Not enough LP tokens in gauge\"\n        );\n\n        // Withdraw pool LP tokens from the gauge\n        IGauge(gauge).withdraw(_lpTokens);\n\n        // Transfer the pool LP tokens to the pool\n        IERC20(pool).safeTransfer(pool, _lpTokens);\n\n        // Burn the LP tokens and transfer the wS and OS back to the strategy\n        IPair(pool).burn(address(this));\n    }\n\n    /**\n     * @dev Withdraw all pool LP tokens from the gauge when it's in emergency mode\n     * and remove wS and OS from the pool.\n     */\n    function _emergencyWithdrawFromGaugeAndPool() internal {\n        // Withdraw all pool LP tokens from the gauge\n        IGauge(gauge).emergencyWithdraw();\n\n        // Get the pool LP tokens in strategy\n        uint256 _lpTokens = IERC20(pool).balanceOf(address(this));\n\n        // Transfer the pool LP tokens to the pool\n        IERC20(pool).safeTransfer(pool, _lpTokens);\n\n        // Burn the LP tokens and transfer the wS and OS back to the strategy\n        IPair(pool).burn(address(this));\n    }\n\n    /**\n     * @dev Swap exact amount of tokens for another token against the pool.\n     * @param _amountIn Amount of tokens to swap into the pool.\n     * @param _tokenIn Address of the token going into the pool.\n     * @param _tokenOut Address of the token being swapped out of the pool.\n     */\n    function _swapExactTokensForTokens(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut\n    ) internal {\n        // Transfer in tokens to the pool\n        IERC20(_tokenIn).safeTransfer(pool, _amountIn);\n\n        // Calculate how much out tokens we get from the swap\n        uint256 amountOut = IPair(pool).getAmountOut(_amountIn, _tokenIn);\n\n        // Safety check that we are dealing with the correct pool tokens\n        require(\n            (_tokenIn == ws && _tokenOut == os) ||\n                (_tokenIn == os && _tokenOut == ws),\n            \"Unsupported swap\"\n        );\n\n        // Work out the correct order of the amounts for the pool\n        (uint256 amount0, uint256 amount1) = _tokenIn == ws\n            ? (uint256(0), amountOut)\n            : (amountOut, 0);\n\n        // Perform the swap on the pool\n        IPair(pool).swap(amount0, amount1, address(this), new bytes(0));\n\n        // The slippage protection against the amount out is indirectly done\n        // via the improvePoolBalance\n    }\n\n    /// @dev Calculate the value of a LP position in a SwapX stable pool\n    /// if the pool was balanced.\n    /// @param _lpTokens Amount of LP tokens in the SwapX pool\n    /// @return value The wS value of the LP tokens when the pool is balanced\n    function _lpValue(uint256 _lpTokens) internal view returns (uint256 value) {\n        // Get total supply of LP tokens\n        uint256 totalSupply = IPair(pool).totalSupply();\n        if (totalSupply == 0) return 0;\n\n        // Get the current reserves of the pool\n        (uint256 wsReserves, uint256 osReserves, ) = IPair(pool).getReserves();\n\n        // Calculate the invariant of the pool assuming both tokens have 18 decimals.\n        // k is scaled to 18 decimals.\n        uint256 k = _invariant(wsReserves, osReserves);\n\n        // If x = y, let’s denote x = y = z (where z is the common reserve value)\n        // Substitute z into the invariant:\n        // k = z^3 * z + z * z^3\n        // k = 2 * z^4\n        // Going back the other way to calculate the common reserve value z\n        // z = (k / 2) ^ (1/4)\n        // the total value of the pool when x = y is 2 * z, which is 2 * (k / 2) ^ (1/4)\n        uint256 zSquared = sqrt((k * 1e18) / 2); // 18 + 18 = 36 decimals becomes 18 decimals after sqrt\n        uint256 z = sqrt(zSquared * 1e18); //  18 + 18 = 36 decimals becomes 18 decimals after sqrt\n        uint256 totalValueOfPool = 2 * z;\n\n        // lp value = lp tokens * value of pool  / total supply\n        value = (_lpTokens * totalValueOfPool) / totalSupply;\n    }\n\n    /**\n     * @dev Compute the invariant for a SwapX stable pool.\n     * This assumed both x and y tokens are to 18 decimals which is checked in the constructor.\n     * invariant: k = x^3 * y + x * y^3\n     * @dev This implementation is copied from SwapX's Pair contract.\n     * @param _x The amount of Wrapped S (wS) tokens in the pool\n     * @param _y The amount of the OS tokens in the pool\n     * @return k The invariant of the SwapX stable pool\n     */\n    function _invariant(uint256 _x, uint256 _y)\n        internal\n        pure\n        returns (uint256 k)\n    {\n        uint256 _a = (_x * _y) / PRECISION;\n        uint256 _b = ((_x * _x) / PRECISION + (_y * _y) / PRECISION);\n        // slither-disable-next-line divide-before-multiply\n        k = (_a * _b) / PRECISION;\n    }\n\n    /**\n     * @dev Checks that the protocol is solvent, protecting from a rogue Strategist / Guardian that can\n     * keep rebalancing the pool in both directions making the protocol lose a tiny amount of\n     * funds each time.\n     *\n     * Protocol must be at least SOLVENCY_THRESHOLD (99,8 %) backed in order for the rebalances to\n     * function.\n     */\n    function _solvencyAssert() internal view {\n        uint256 _totalVaultValue = IVault(vaultAddress).totalValue();\n        uint256 _totalSupply = IERC20(os).totalSupply();\n\n        if (\n            _totalSupply > 0 &&\n            _totalVaultValue.divPrecisely(_totalSupply) < SOLVENCY_THRESHOLD\n        ) {\n            revert(\"Protocol insolvent\");\n        }\n    }\n\n    /***************************************\n                    Setters\n    ****************************************/\n\n    /**\n     * @notice Set the maximum deviation from the OS/wS peg (1e18) before deposits are reverted.\n     * @param _maxDepeg the OS/wS price from peg (1e18) in 18 decimals.\n     * eg 0.01e18 or 1e16 is 1% which is 100 basis points.\n     */\n    function setMaxDepeg(uint256 _maxDepeg) external onlyGovernor {\n        maxDepeg = _maxDepeg;\n\n        emit MaxDepegUpdated(_maxDepeg);\n    }\n\n    /***************************************\n                    Approvals\n    ****************************************/\n\n    /**\n     * @notice Approve the spending of all assets by their corresponding pool tokens,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        _approveBase();\n    }\n\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        override\n    {}\n\n    function _approveBase() internal {\n        // Approve SwapX gauge contract to transfer SwapX pool LP tokens\n        // This is needed for deposits of SwapX pool LP tokens into the gauge.\n        // slither-disable-next-line unused-return\n        IPair(pool).approve(address(gauge), type(uint256).max);\n    }\n}\n"
    },
    "contracts/strategies/sonic/SonicValidatorDelegator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20, InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { IVault } from \"../../interfaces/IVault.sol\";\nimport { ISFC } from \"../../interfaces/sonic/ISFC.sol\";\nimport { IWrappedSonic } from \"../../interfaces/sonic/IWrappedSonic.sol\";\n\n/**\n * @title Manages delegation to Sonic validators\n * @notice This contract implements all the required functionality to delegate to,\n   undelegate from and withdraw from validators.\n * @author Origin Protocol Inc\n */\nabstract contract SonicValidatorDelegator is InitializableAbstractStrategy {\n    /// @notice Address of Sonic's wrapped S token\n    address public immutable wrappedSonic;\n    /// @notice Sonic's Special Fee Contract (SFC)\n    ISFC public immutable sfc;\n\n    /// @notice a unique ID for each withdrawal request\n    uint256 public nextWithdrawId;\n    /// @notice Sonic (S) that is pending withdrawal after undelegating\n    uint256 public pendingWithdrawals;\n\n    /// @notice List of supported validator IDs that can be delegated to\n    uint256[] public supportedValidators;\n\n    /// @notice Default validator id to deposit to\n    uint256 public defaultValidatorId;\n\n    struct WithdrawRequest {\n        uint256 validatorId;\n        uint256 undelegatedAmount;\n        uint256 timestamp;\n    }\n    /// @notice Mapping of withdrawIds to validatorIds and undelegatedAmounts\n    mapping(uint256 => WithdrawRequest) public withdrawals;\n\n    /// @notice Address of the registrator - allowed to register, exit and remove validators\n    address public validatorRegistrator;\n\n    // For future use\n    uint256[44] private __gap;\n\n    event Delegated(uint256 indexed validatorId, uint256 delegatedAmount);\n    event Undelegated(\n        uint256 indexed withdrawId,\n        uint256 indexed validatorId,\n        uint256 undelegatedAmount\n    );\n    event Withdrawn(\n        uint256 indexed withdrawId,\n        uint256 indexed validatorId,\n        uint256 undelegatedAmount,\n        uint256 withdrawnAmount\n    );\n    event RegistratorChanged(address indexed newAddress);\n    event SupportedValidator(uint256 indexed validatorId);\n    event UnsupportedValidator(uint256 indexed validatorId);\n    event DefaultValidatorIdChanged(uint256 indexed validatorId);\n\n    /// @dev Throws if called by any account other than the Registrator or Strategist\n    modifier onlyRegistratorOrStrategist() {\n        require(\n            msg.sender == validatorRegistrator ||\n                msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Registrator or Strategist\"\n        );\n        _;\n    }\n\n    constructor(\n        BaseStrategyConfig memory _baseConfig,\n        address _wrappedSonic,\n        address _sfc\n    ) InitializableAbstractStrategy(_baseConfig) {\n        wrappedSonic = _wrappedSonic;\n        sfc = ISFC(_sfc);\n    }\n\n    function initialize() external virtual onlyGovernor initializer {\n        address[] memory rewardTokens = new address[](0);\n        address[] memory assets = new address[](1);\n        address[] memory pTokens = new address[](1);\n\n        assets[0] = address(wrappedSonic);\n        pTokens[0] = address(platformAddress);\n\n        InitializableAbstractStrategy._initialize(\n            rewardTokens,\n            assets,\n            pTokens\n        );\n    }\n\n    /// @notice Returns the total value of Sonic (S) that is delegated validators.\n    /// Wrapped Sonic (wS) deposits that are still to be delegated and any undelegated amounts\n    /// still pending a withdrawal.\n    /// @param _asset      Address of Wrapped Sonic (wS) token\n    /// @return balance    Total value managed by the strategy\n    function checkBalance(address _asset)\n        external\n        view\n        virtual\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == wrappedSonic, \"Unsupported asset\");\n\n        // add the Wrapped Sonic (wS) in the strategy from deposits that are still to be delegated\n        // and any undelegated amounts still pending a withdrawal\n        balance =\n            IERC20(wrappedSonic).balanceOf(address(this)) +\n            pendingWithdrawals;\n\n        // For each supported validator, get the staked amount and pending rewards\n        uint256 validatorLen = supportedValidators.length;\n        for (uint256 i = 0; i < validatorLen; i++) {\n            uint256 validator = supportedValidators[i];\n            balance += sfc.getStake(address(this), validator);\n            balance += sfc.pendingRewards(address(this), validator);\n        }\n    }\n\n    /**\n     * @dev Delegate from this strategy to a specific Sonic validator. Called\n     * automatically on asset deposit\n     * @param _amount the amount of Sonic (S) to delegate.\n     */\n    function _delegate(uint256 _amount) internal {\n        require(\n            isSupportedValidator(defaultValidatorId),\n            \"Validator not supported\"\n        );\n\n        // unwrap Wrapped Sonic (wS) to native Sonic (S)\n        IWrappedSonic(wrappedSonic).withdraw(_amount);\n\n        //slither-disable-next-line arbitrary-send-eth\n        sfc.delegate{ value: _amount }(defaultValidatorId);\n\n        emit Delegated(defaultValidatorId, _amount);\n    }\n\n    /**\n     * @notice Undelegate from a specific Sonic validator.\n     * This needs to be followed by a `withdrawFromSFC` two weeks later.\n     * @param _validatorId The Sonic validator ID to undelegate from.\n     * @param _undelegateAmount the amount of Sonic (S) to undelegate.\n     * @return withdrawId The unique ID of the withdrawal request.\n     */\n    function undelegate(uint256 _validatorId, uint256 _undelegateAmount)\n        external\n        onlyRegistratorOrStrategist\n        nonReentrant\n        returns (uint256 withdrawId)\n    {\n        withdrawId = _undelegate(_validatorId, _undelegateAmount);\n    }\n\n    function _undelegate(uint256 _validatorId, uint256 _undelegateAmount)\n        internal\n        returns (uint256 withdrawId)\n    {\n        // Can still undelegate even if the validator is no longer supported\n        require(_undelegateAmount > 0, \"Must undelegate something\");\n\n        uint256 amountDelegated = sfc.getStake(address(this), _validatorId);\n        require(\n            _undelegateAmount <= amountDelegated,\n            \"Insufficient delegation\"\n        );\n\n        withdrawId = nextWithdrawId++;\n\n        withdrawals[withdrawId] = WithdrawRequest(\n            _validatorId,\n            _undelegateAmount,\n            block.timestamp\n        );\n        pendingWithdrawals += _undelegateAmount;\n\n        sfc.undelegate(_validatorId, withdrawId, _undelegateAmount);\n\n        emit Undelegated(withdrawId, _validatorId, _undelegateAmount);\n    }\n\n    /**\n     * @notice Withdraw native S from a previously undelegated validator.\n     * The native S is wrapped wS and transferred to the Vault.\n     * @param _withdrawId The unique withdraw ID used to `undelegate`\n     * @return withdrawnAmount The amount of Sonic (S) withdrawn.\n     * This can be less than the undelegated amount in the event of slashing.\n     */\n    function withdrawFromSFC(uint256 _withdrawId)\n        external\n        onlyRegistratorOrStrategist\n        nonReentrant\n        returns (uint256 withdrawnAmount)\n    {\n        require(_withdrawId < nextWithdrawId, \"Invalid withdrawId\");\n\n        // Can still withdraw even if the validator is no longer supported\n        // Load the withdrawal from storage into memory\n        WithdrawRequest memory withdrawal = withdrawals[_withdrawId];\n        require(!isWithdrawnFromSFC(_withdrawId), \"Already withdrawn\");\n\n        withdrawals[_withdrawId].undelegatedAmount = 0;\n        pendingWithdrawals -= withdrawal.undelegatedAmount;\n\n        uint256 sBalanceBefore = address(this).balance;\n\n        // Try to withdraw from SFC\n        try sfc.withdraw(withdrawal.validatorId, _withdrawId) {\n            // continue below\n        } catch (bytes memory err) {\n            bytes4 errorSelector = bytes4(err);\n\n            // If the validator has been fully slashed, SFC's withdraw function will\n            // revert with a StakeIsFullySlashed custom error.\n            if (errorSelector == ISFC.StakeIsFullySlashed.selector) {\n                // The validator was fully slashed, so all the delegated amounts were lost.\n                // Will swallow the error as we still want to update the\n                // withdrawals and pendingWithdrawals storage variables.\n\n                // The return param defaults to zero but lets set it explicitly so it's clear\n                withdrawnAmount = 0;\n\n                emit Withdrawn(\n                    _withdrawId,\n                    withdrawal.validatorId,\n                    withdrawal.undelegatedAmount,\n                    withdrawnAmount\n                );\n\n                // Exit here as there is nothing to transfer to the Vault\n                return withdrawnAmount;\n            } else {\n                // Bubble up any other SFC custom errors.\n                // Inline assembly is currently the only way to generically rethrow the exact same custom error\n                // from the raw bytes err in a catch block while preserving its original selector and parameters.\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    revert(add(32, err), mload(err))\n                }\n            }\n        }\n\n        // Set return parameter\n        withdrawnAmount = address(this).balance - sBalanceBefore;\n\n        // Wrap Sonic (S) to Wrapped Sonic (wS)\n        IWrappedSonic(wrappedSonic).deposit{ value: withdrawnAmount }();\n\n        // Transfer the Wrapped Sonic (wS) to the Vault\n        _withdraw(vaultAddress, wrappedSonic, withdrawnAmount);\n\n        // withdrawal.undelegatedAmount & withdrawnAmount can differ in case of slashing\n        emit Withdrawn(\n            _withdrawId,\n            withdrawal.validatorId,\n            withdrawal.undelegatedAmount,\n            withdrawnAmount\n        );\n    }\n\n    /// @notice returns a bool whether a withdrawalId has already been withdrawn or not\n    /// @param _withdrawId The unique withdraw ID used to `undelegate`\n    function isWithdrawnFromSFC(uint256 _withdrawId)\n        public\n        view\n        returns (bool)\n    {\n        WithdrawRequest memory withdrawal = withdrawals[_withdrawId];\n        require(withdrawal.validatorId > 0, \"Invalid withdrawId\");\n        return withdrawal.undelegatedAmount == 0;\n    }\n\n    /**\n     * @notice Restake any pending validator rewards for all supported validators\n     * @param _validatorIds List of Sonic validator IDs to restake rewards\n     */\n    function restakeRewards(uint256[] calldata _validatorIds)\n        external\n        nonReentrant\n    {\n        for (uint256 i = 0; i < _validatorIds.length; ++i) {\n            require(\n                isSupportedValidator(_validatorIds[i]),\n                \"Validator not supported\"\n            );\n\n            uint256 rewards = sfc.pendingRewards(\n                address(this),\n                _validatorIds[i]\n            );\n\n            if (rewards > 0) {\n                sfc.restakeRewards(_validatorIds[i]);\n            }\n        }\n\n        // The SFC contract will emit Delegated and RestakedRewards events.\n        // The checkBalance function should not change as the pending rewards will moved to the staked amount.\n    }\n\n    /**\n     * @notice Claim any pending rewards from validators\n     * @param _validatorIds List of Sonic validator IDs to claim rewards\n     */\n    function collectRewards(uint256[] calldata _validatorIds)\n        external\n        onlyRegistratorOrStrategist\n        nonReentrant\n    {\n        uint256 sBalanceBefore = address(this).balance;\n\n        for (uint256 i = 0; i < _validatorIds.length; ++i) {\n            uint256 rewards = sfc.pendingRewards(\n                address(this),\n                _validatorIds[i]\n            );\n\n            if (rewards > 0) {\n                // The SFC contract will emit ClaimedRewards(delegator (this), validatorId, rewards)\n                sfc.claimRewards(_validatorIds[i]);\n            }\n        }\n\n        uint256 rewardsAmount = address(this).balance - sBalanceBefore;\n\n        // Wrap Sonic (S) to Wrapped Sonic (wS)\n        IWrappedSonic(wrappedSonic).deposit{ value: rewardsAmount }();\n\n        // Transfer the Wrapped Sonic (wS) to the Vault\n        _withdraw(vaultAddress, wrappedSonic, rewardsAmount);\n    }\n\n    /**\n     * @notice To receive native S from SFC and Wrapped Sonic (wS)\n     *\n     * @dev This does not prevent donating S tokens to the contract\n     * as wrappedSonic has a `withdrawTo` function where a third party\n     * owner of wrappedSonic can withdraw to this contract.\n     */\n    receive() external payable {\n        require(\n            msg.sender == address(sfc) || msg.sender == wrappedSonic,\n            \"S not from allowed contracts\"\n        );\n    }\n\n    /***************************************\n                Admin functions\n    ****************************************/\n\n    /// @notice Set the address of the Registrator which can undelegate, withdraw and collect rewards\n    /// @param _validatorRegistrator The address of the Registrator\n    function setRegistrator(address _validatorRegistrator)\n        external\n        onlyGovernor\n    {\n        validatorRegistrator = _validatorRegistrator;\n        emit RegistratorChanged(_validatorRegistrator);\n    }\n\n    /// @notice Set the default validatorId to delegate to on deposit\n    /// @param _validatorId The validator identifier. eg 18\n    function setDefaultValidatorId(uint256 _validatorId)\n        external\n        onlyRegistratorOrStrategist\n    {\n        require(isSupportedValidator(_validatorId), \"Validator not supported\");\n        defaultValidatorId = _validatorId;\n        emit DefaultValidatorIdChanged(_validatorId);\n    }\n\n    /// @notice Allows a validator to be delegated to by the Registrator\n    /// @param _validatorId The validator identifier. eg 18\n    function supportValidator(uint256 _validatorId) external onlyGovernor {\n        require(\n            !isSupportedValidator(_validatorId),\n            \"Validator already supported\"\n        );\n\n        supportedValidators.push(_validatorId);\n\n        emit SupportedValidator(_validatorId);\n    }\n\n    /// @notice Removes a validator from the supported list.\n    /// Unsupported validators can still be undelegated from, withdrawn from and rewards collected.\n    /// @param _validatorId The validator identifier. eg 18\n    function unsupportValidator(uint256 _validatorId) external onlyGovernor {\n        require(isSupportedValidator(_validatorId), \"Validator not supported\");\n\n        uint256 validatorLen = supportedValidators.length;\n        for (uint256 i = 0; i < validatorLen; ++i) {\n            if (supportedValidators[i] == _validatorId) {\n                supportedValidators[i] = supportedValidators[validatorLen - 1];\n                supportedValidators.pop();\n                break;\n            }\n        }\n\n        uint256 stake = sfc.getStake(address(this), _validatorId);\n\n        // undelegate if validator still has funds staked\n        if (stake > 0) {\n            _undelegate(_validatorId, stake);\n        }\n        emit UnsupportedValidator(_validatorId);\n    }\n\n    /// @notice Returns the length of the supportedValidators array\n    function supportedValidatorsLength() external view returns (uint256) {\n        return supportedValidators.length;\n    }\n\n    /// @notice Returns whether a validator is supported by this strategy\n    /// @param _validatorId The validator identifier\n    function isSupportedValidator(uint256 _validatorId)\n        public\n        view\n        returns (bool)\n    {\n        uint256 validatorLen = supportedValidators.length;\n        for (uint256 i = 0; i < validatorLen; ++i) {\n            if (supportedValidators[i] == _validatorId) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) internal virtual;\n}\n"
    },
    "contracts/strategies/VaultValueChecker.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IOUSD } from \"../interfaces/IOUSD.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract VaultValueChecker {\n    IVault public immutable vault;\n    IOUSD public immutable ousd;\n    // Snapshot expiration time in seconds.\n    // Used to prevent accidental use of an old snapshot, but\n    // is not zero to allow easy testing of strategist actions in fork testing\n    uint256 constant SNAPSHOT_EXPIRES = 5 * 60;\n\n    struct Snapshot {\n        uint256 vaultValue;\n        uint256 totalSupply;\n        uint256 time;\n    }\n    // By doing per user snapshots, we prevent a reentrancy attack\n    // from a third party that updates the snapshot in the middle\n    // of an allocation process\n\n    mapping(address => Snapshot) public snapshots;\n\n    constructor(address _vault, address _ousd) {\n        vault = IVault(_vault);\n        ousd = IOUSD(_ousd);\n    }\n\n    function takeSnapshot() external {\n        snapshots[msg.sender] = Snapshot({\n            vaultValue: vault.totalValue(),\n            totalSupply: ousd.totalSupply(),\n            time: block.timestamp\n        });\n    }\n\n    function checkDelta(\n        int256 expectedProfit,\n        int256 profitVariance,\n        int256 expectedVaultChange,\n        int256 vaultChangeVariance\n    ) external {\n        // Intentionaly not view so that this method shows up in TX builders\n        Snapshot memory snapshot = snapshots[msg.sender];\n        int256 vaultChange = toInt256(vault.totalValue()) -\n            toInt256(snapshot.vaultValue);\n        int256 supplyChange = toInt256(ousd.totalSupply()) -\n            toInt256(snapshot.totalSupply);\n        int256 profit = vaultChange - supplyChange;\n\n        require(\n            snapshot.time >= block.timestamp - SNAPSHOT_EXPIRES,\n            \"Snapshot too old\"\n        );\n        require(snapshot.time <= block.timestamp, \"Snapshot too new\");\n        require(profit >= expectedProfit - profitVariance, \"Profit too low\");\n        require(profit <= expectedProfit + profitVariance, \"Profit too high\");\n        require(\n            vaultChange >= expectedVaultChange - vaultChangeVariance,\n            \"Vault value change too low\"\n        );\n        require(\n            vaultChange <= expectedVaultChange + vaultChangeVariance,\n            \"Vault value change too high\"\n        );\n    }\n\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // From openzeppelin math/SafeCast.sol\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(\n            value <= uint256(type(int256).max),\n            \"SafeCast: value doesn't fit in an int256\"\n        );\n        return int256(value);\n    }\n}\n\ncontract OETHVaultValueChecker is VaultValueChecker {\n    constructor(address _vault, address _ousd)\n        VaultValueChecker(_vault, _ousd)\n    {}\n}\n"
    },
    "contracts/swapper/Swapper1InchV5.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @notice 1Inch Pathfinder V5 implementation of the general ISwapper interface.\n * @author Origin Protocol Inc\n * @dev It is possible that dust token amounts are left in this contract after a swap.\n * This can happen with some tokens that don't send the full transfer amount.\n * These dust amounts can build up over time and be used by anyone who calls the `swap` function.\n */\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IAggregationExecutor, IOneInchRouter, SwapDescription } from \"../interfaces/IOneInch.sol\";\nimport { ISwapper } from \"../interfaces/ISwapper.sol\";\n\ncontract Swapper1InchV5 is ISwapper {\n    using SafeERC20 for IERC20;\n\n    /// @notice 1Inch router contract to give allowance to perform swaps\n    address public constant SWAP_ROUTER =\n        0x1111111254EEB25477B68fb85Ed929f73A960582;\n\n    // swap(address,(address,address,address,address,uint256,uint256,uint256),bytes,bytes)\n    bytes4 internal constant SWAP_SELECTOR = 0x12aa3caf;\n    // unoswapTo(address,address,uint256,uint256,uint256[])\n    bytes4 internal constant UNISWAP_SELECTOR = 0xf78dc253;\n    // uniswapV3SwapTo(address,uint256,uint256,uint256[])\n    bytes4 internal constant UNISWAPV3_SELECTOR = 0xbc80f1a8;\n\n    /**\n     * @notice Strategist swaps assets sitting in the contract of the `assetHolder`.\n     * @param _fromAsset The token address of the asset being sold by the vault.\n     * @param _toAsset The token address of the asset being purchased by the vault.\n     * @param _fromAssetAmount The amount of assets being sold by the vault.\n     * @param _minToAssetAmount The minimum amount of assets to be purchased.\n     * @param _data RLP encoded executer address and bytes data. This is re-encoded tx.data from 1Inch swap API\n     */\n    function swap(\n        address _fromAsset,\n        address _toAsset,\n        uint256 _fromAssetAmount,\n        uint256 _minToAssetAmount,\n        bytes calldata _data\n    ) external override returns (uint256 toAssetAmount) {\n        // Decode the function selector from the RLP encoded _data param\n        bytes4 swapSelector = bytes4(_data[:4]);\n\n        if (swapSelector == SWAP_SELECTOR) {\n            // Decode the executer address and data from the RLP encoded _data param\n            (, address executer, bytes memory executerData) = abi.decode(\n                _data,\n                (bytes4, address, bytes)\n            );\n            SwapDescription memory swapDesc = SwapDescription({\n                srcToken: IERC20(_fromAsset),\n                dstToken: IERC20(_toAsset),\n                srcReceiver: payable(executer),\n                dstReceiver: payable(msg.sender),\n                amount: _fromAssetAmount,\n                minReturnAmount: _minToAssetAmount,\n                flags: 4 // 1st bit _PARTIAL_FILL, 2nd bit _REQUIRES_EXTRA_ETH, 3rd bit _SHOULD_CLAIM\n            });\n            (toAssetAmount, ) = IOneInchRouter(SWAP_ROUTER).swap(\n                IAggregationExecutor(executer),\n                swapDesc,\n                hex\"\",\n                executerData\n            );\n        } else if (swapSelector == UNISWAP_SELECTOR) {\n            // Need to get the Uniswap pools data from the _data param\n            (, uint256[] memory pools) = abi.decode(_data, (bytes4, uint256[]));\n            toAssetAmount = IOneInchRouter(SWAP_ROUTER).unoswapTo(\n                payable(msg.sender),\n                IERC20(_fromAsset),\n                _fromAssetAmount,\n                _minToAssetAmount,\n                pools\n            );\n        } else if (swapSelector == UNISWAPV3_SELECTOR) {\n            // Need to get the Uniswap pools data from the _data param\n            // slither-disable-next-line uninitialized-storage\n            (, uint256[] memory pools) = abi.decode(_data, (bytes4, uint256[]));\n            toAssetAmount = IOneInchRouter(SWAP_ROUTER).uniswapV3SwapTo(\n                payable(msg.sender),\n                _fromAssetAmount,\n                _minToAssetAmount,\n                pools\n            );\n        } else {\n            revert(\"Unsupported swap function\");\n        }\n    }\n\n    /**\n     * @notice Approve assets for swapping.\n     * @param _assets Array of token addresses to approve.\n     * @dev unlimited approval is used as no tokens sit in this contract outside a transaction.\n     */\n    function approveAssets(address[] memory _assets) external {\n        for (uint256 i = 0; i < _assets.length; ++i) {\n            // Give the 1Inch router approval to transfer unlimited assets\n            IERC20(_assets[i]).safeApprove(SWAP_ROUTER, type(uint256).max);\n        }\n    }\n}\n"
    },
    "contracts/token/BridgedWOETH.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { AccessControlEnumerable } from \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { Initializable } from \"../utils/Initializable.sol\";\n\ncontract BridgedWOETH is\n    Governable,\n    AccessControlEnumerable,\n    Initializable,\n    ERC20\n{\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n\n    constructor() ERC20(\"Wrapped OETH\", \"wOETH\") {\n        // Nobody owns the implementation\n        _setGovernor(address(0));\n    }\n\n    /**\n     * @dev Initialize the proxy and set the Governor\n     */\n    function initialize() external initializer {\n        // Governor can grant Minter/Burner roles\n        _setupRole(DEFAULT_ADMIN_ROLE, _governor());\n    }\n\n    /**\n     * @dev Mint tokens for `account`\n     * @param account Address to mint tokens for\n     * @param amount Amount of tokens to mint\n     */\n    function mint(address account, uint256 amount)\n        external\n        onlyRole(MINTER_ROLE)\n        nonReentrant\n    {\n        _mint(account, amount);\n    }\n\n    /**\n     * @dev Burns tokens from `account`\n     * @param account Address to burn tokens from\n     * @param amount Amount of tokens to burn\n     */\n    function burn(address account, uint256 amount)\n        external\n        onlyRole(BURNER_ROLE)\n        nonReentrant\n    {\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev Burns tokens from `msg.sender`\n     * @param amount Amount of tokens to burn\n     */\n    function burn(uint256 amount) external onlyRole(BURNER_ROLE) nonReentrant {\n        _burn(msg.sender, amount);\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return \"Wrapped OETH\";\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return \"wOETH\";\n    }\n\n    /**\n     * @dev Returns the decimals of the token\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n}\n"
    },
    "contracts/token/OETH.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { OUSD } from \"./OUSD.sol\";\n\n/**\n * @title OETH Token Contract\n * @author Origin Protocol Inc\n */\ncontract OETH is OUSD {\n    function symbol() external pure override returns (string memory) {\n        return \"OETH\";\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Origin Ether\";\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return 18;\n    }\n}\n"
    },
    "contracts/token/OETHBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { OUSD } from \"./OUSD.sol\";\n\n/**\n * @title OETH Token Contract\n * @author Origin Protocol Inc\n */\ncontract OETHBase is OUSD {\n    constructor() {\n        // Nobody owns the implementation contract\n        _setGovernor(address(0));\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"superOETHb\";\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Super OETH\";\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return 18;\n    }\n}\n"
    },
    "contracts/token/OETHPlume.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { OUSD } from \"./OUSD.sol\";\n\n/**\n * @title Super OETH (Plume) Token Contract\n * @author Origin Protocol Inc\n */\ncontract OETHPlume is OUSD {\n    constructor() {\n        // Nobody owns the implementation contract\n        _setGovernor(address(0));\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"superOETHp\";\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Super OETH\";\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return 18;\n    }\n}\n"
    },
    "contracts/token/OSonic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { OUSD } from \"./OUSD.sol\";\n\n/**\n * @title Origin Sonic (OS) token on Sonic\n * @author Origin Protocol Inc\n */\ncontract OSonic is OUSD {\n    function symbol() external pure override returns (string memory) {\n        return \"OS\";\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Origin Sonic\";\n    }\n}\n"
    },
    "contracts/token/OUSD.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD Token Contract\n * @dev ERC20 compatible contract for OUSD\n * @dev Implements an elastic supply\n * @author Origin Protocol Inc\n */\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\ncontract OUSD is Governable {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n\n    /// @dev Event triggered when the supply changes\n    /// @param totalSupply Updated token total supply\n    /// @param rebasingCredits Updated token rebasing credits\n    /// @param rebasingCreditsPerToken Updated token rebasing credits per token\n    event TotalSupplyUpdatedHighres(\n        uint256 totalSupply,\n        uint256 rebasingCredits,\n        uint256 rebasingCreditsPerToken\n    );\n    /// @dev Event triggered when an account opts in for rebasing\n    /// @param account Address of the account\n    event AccountRebasingEnabled(address account);\n    /// @dev Event triggered when an account opts out of rebasing\n    /// @param account Address of the account\n    event AccountRebasingDisabled(address account);\n    /// @dev Emitted when `value` tokens are moved from one account `from` to\n    ///      another `to`.\n    /// @param from Address of the account tokens are moved from\n    /// @param to Address of the account tokens are moved to\n    /// @param value Amount of tokens transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set by\n    ///      a call to {approve}. `value` is the new allowance.\n    /// @param owner Address of the owner approving allowance\n    /// @param spender Address of the spender allowance is granted to\n    /// @param value Amount of tokens spender can transfer\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    /// @dev Yield resulting from {changeSupply} that a `source` account would\n    ///      receive is directed to `target` account.\n    /// @param source Address of the source forwarding the yield\n    /// @param target Address of the target receiving the yield\n    event YieldDelegated(address source, address target);\n    /// @dev Yield delegation from `source` account to the `target` account is\n    ///      suspended.\n    /// @param source Address of the source suspending yield forwarding\n    /// @param target Address of the target no longer receiving yield from `source`\n    ///        account\n    event YieldUndelegated(address source, address target);\n\n    enum RebaseOptions {\n        NotSet,\n        StdNonRebasing,\n        StdRebasing,\n        YieldDelegationSource,\n        YieldDelegationTarget\n    }\n\n    uint256[154] private _gap; // Slots to align with deployed contract\n    uint256 private constant MAX_SUPPLY = type(uint128).max;\n    /// @dev The amount of tokens in existence\n    uint256 public totalSupply;\n    mapping(address => mapping(address => uint256)) private allowances;\n    /// @dev The vault with privileges to execute {mint}, {burn}\n    ///     and {changeSupply}\n    address public vaultAddress;\n    mapping(address => uint256) internal creditBalances;\n    // the 2 storage variables below need trailing underscores to not name collide with public functions\n    uint256 private rebasingCredits_; // Sum of all rebasing credits (creditBalances for rebasing accounts)\n    uint256 private rebasingCreditsPerToken_;\n    /// @dev The amount of tokens that are not rebasing - receiving yield\n    uint256 public nonRebasingSupply;\n    mapping(address => uint256) internal alternativeCreditsPerToken;\n    /// @dev A map of all addresses and their respective RebaseOptions\n    mapping(address => RebaseOptions) public rebaseState;\n    mapping(address => uint256) private __deprecated_isUpgraded;\n    /// @dev A map of addresses that have yields forwarded to. This is an\n    ///      inverse mapping of {yieldFrom}\n    /// Key Account forwarding yield\n    /// Value Account receiving yield\n    mapping(address => address) public yieldTo;\n    /// @dev A map of addresses that are receiving the yield. This is an\n    ///      inverse mapping of {yieldTo}\n    /// Key Account receiving yield\n    /// Value Account forwarding yield\n    mapping(address => address) public yieldFrom;\n\n    uint256 private constant RESOLUTION_INCREASE = 1e9;\n    uint256[34] private __gap; // including below gap totals up to 200\n\n    /// @dev Verifies that the caller is the Governor or Strategist.\n    modifier onlyGovernorOrStrategist() {\n        require(\n            isGovernor() || msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    /// @dev Initializes the contract and sets necessary variables.\n    /// @param _vaultAddress Address of the vault contract\n    /// @param _initialCreditsPerToken The starting rebasing credits per token.\n    function initialize(address _vaultAddress, uint256 _initialCreditsPerToken)\n        external\n        onlyGovernor\n    {\n        require(_vaultAddress != address(0), \"Zero vault address\");\n        require(vaultAddress == address(0), \"Already initialized\");\n\n        rebasingCreditsPerToken_ = _initialCreditsPerToken;\n        vaultAddress = _vaultAddress;\n    }\n\n    /// @dev Returns the symbol of the token, a shorter version\n    ///      of the name.\n    function symbol() external pure virtual returns (string memory) {\n        return \"OUSD\";\n    }\n\n    /// @dev Returns the name of the token.\n    function name() external pure virtual returns (string memory) {\n        return \"Origin Dollar\";\n    }\n\n    /// @dev Returns the number of decimals used to get its user representation.\n    function decimals() external pure virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault contract\n     */\n    modifier onlyVault() {\n        require(vaultAddress == msg.sender, \"Caller is not the Vault\");\n        _;\n    }\n\n    /**\n     * @return High resolution rebasingCreditsPerToken\n     */\n    function rebasingCreditsPerTokenHighres() external view returns (uint256) {\n        return rebasingCreditsPerToken_;\n    }\n\n    /**\n     * @return Low resolution rebasingCreditsPerToken\n     */\n    function rebasingCreditsPerToken() external view returns (uint256) {\n        return rebasingCreditsPerToken_ / RESOLUTION_INCREASE;\n    }\n\n    /**\n     * @return High resolution total number of rebasing credits\n     */\n    function rebasingCreditsHighres() external view returns (uint256) {\n        return rebasingCredits_;\n    }\n\n    /**\n     * @return Low resolution total number of rebasing credits\n     */\n    function rebasingCredits() external view returns (uint256) {\n        return rebasingCredits_ / RESOLUTION_INCREASE;\n    }\n\n    /**\n     * @notice Gets the balance of the specified address.\n     * @param _account Address to query the balance of.\n     * @return A uint256 representing the amount of base units owned by the\n     *         specified address.\n     */\n    function balanceOf(address _account) public view returns (uint256) {\n        RebaseOptions state = rebaseState[_account];\n        if (state == RebaseOptions.YieldDelegationSource) {\n            // Saves a slot read when transferring to or from a yield delegating source\n            // since we know creditBalances equals the balance.\n            return creditBalances[_account];\n        }\n        uint256 baseBalance = (creditBalances[_account] * 1e18) /\n            _creditsPerToken(_account);\n        if (state == RebaseOptions.YieldDelegationTarget) {\n            // creditBalances of yieldFrom accounts equals token balances\n            return baseBalance - creditBalances[yieldFrom[_account]];\n        }\n        return baseBalance;\n    }\n\n    /**\n     * @notice Gets the credits balance of the specified address.\n     * @dev Backwards compatible with old low res credits per token.\n     * @param _account The address to query the balance of.\n     * @return (uint256, uint256) Credit balance and credits per token of the\n     *         address\n     */\n    function creditsBalanceOf(address _account)\n        external\n        view\n        returns (uint256, uint256)\n    {\n        uint256 cpt = _creditsPerToken(_account);\n        if (cpt == 1e27) {\n            // For a period before the resolution upgrade, we created all new\n            // contract accounts at high resolution. Since they are not changing\n            // as a result of this upgrade, we will return their true values\n            return (creditBalances[_account], cpt);\n        } else {\n            return (\n                creditBalances[_account] / RESOLUTION_INCREASE,\n                cpt / RESOLUTION_INCREASE\n            );\n        }\n    }\n\n    /**\n     * @notice Gets the credits balance of the specified address.\n     * @param _account The address to query the balance of.\n     * @return (uint256, uint256, bool) Credit balance, credits per token of the\n     *         address, and isUpgraded\n     */\n    function creditsBalanceOfHighres(address _account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        return (\n            creditBalances[_account],\n            _creditsPerToken(_account),\n            true // all accounts have their resolution \"upgraded\"\n        );\n    }\n\n    // Backwards compatible view\n    function nonRebasingCreditsPerToken(address _account)\n        external\n        view\n        returns (uint256)\n    {\n        return alternativeCreditsPerToken[_account];\n    }\n\n    /**\n     * @notice Transfer tokens to a specified address.\n     * @param _to the address to transfer to.\n     * @param _value the amount to be transferred.\n     * @return true on success.\n     */\n    function transfer(address _to, uint256 _value) external returns (bool) {\n        require(_to != address(0), \"Transfer to zero address\");\n\n        _executeTransfer(msg.sender, _to, _value);\n\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n     * @notice Transfer tokens from one address to another.\n     * @param _from The address you want to send tokens from.\n     * @param _to The address you want to transfer to.\n     * @param _value The amount of tokens to be transferred.\n     * @return true on success.\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool) {\n        require(_to != address(0), \"Transfer to zero address\");\n        uint256 userAllowance = allowances[_from][msg.sender];\n        require(_value <= userAllowance, \"Allowance exceeded\");\n\n        unchecked {\n            allowances[_from][msg.sender] = userAllowance - _value;\n        }\n\n        _executeTransfer(_from, _to, _value);\n\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function _executeTransfer(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal {\n        (\n            int256 fromRebasingCreditsDiff,\n            int256 fromNonRebasingSupplyDiff\n        ) = _adjustAccount(_from, -_value.toInt256());\n        (\n            int256 toRebasingCreditsDiff,\n            int256 toNonRebasingSupplyDiff\n        ) = _adjustAccount(_to, _value.toInt256());\n\n        _adjustGlobals(\n            fromRebasingCreditsDiff + toRebasingCreditsDiff,\n            fromNonRebasingSupplyDiff + toNonRebasingSupplyDiff\n        );\n    }\n\n    function _adjustAccount(address _account, int256 _balanceChange)\n        internal\n        returns (int256 rebasingCreditsDiff, int256 nonRebasingSupplyDiff)\n    {\n        RebaseOptions state = rebaseState[_account];\n        int256 currentBalance = balanceOf(_account).toInt256();\n        if (currentBalance + _balanceChange < 0) {\n            revert(\"Transfer amount exceeds balance\");\n        }\n        uint256 newBalance = (currentBalance + _balanceChange).toUint256();\n\n        if (state == RebaseOptions.YieldDelegationSource) {\n            address target = yieldTo[_account];\n            uint256 targetOldBalance = balanceOf(target);\n            uint256 targetNewCredits = _balanceToRebasingCredits(\n                targetOldBalance + newBalance\n            );\n            rebasingCreditsDiff =\n                targetNewCredits.toInt256() -\n                creditBalances[target].toInt256();\n\n            creditBalances[_account] = newBalance;\n            creditBalances[target] = targetNewCredits;\n        } else if (state == RebaseOptions.YieldDelegationTarget) {\n            uint256 newCredits = _balanceToRebasingCredits(\n                newBalance + creditBalances[yieldFrom[_account]]\n            );\n            rebasingCreditsDiff =\n                newCredits.toInt256() -\n                creditBalances[_account].toInt256();\n            creditBalances[_account] = newCredits;\n        } else {\n            _autoMigrate(_account);\n            uint256 alternativeCreditsPerTokenMem = alternativeCreditsPerToken[\n                _account\n            ];\n            if (alternativeCreditsPerTokenMem > 0) {\n                nonRebasingSupplyDiff = _balanceChange;\n                if (alternativeCreditsPerTokenMem != 1e18) {\n                    alternativeCreditsPerToken[_account] = 1e18;\n                }\n                creditBalances[_account] = newBalance;\n            } else {\n                uint256 newCredits = _balanceToRebasingCredits(newBalance);\n                rebasingCreditsDiff =\n                    newCredits.toInt256() -\n                    creditBalances[_account].toInt256();\n                creditBalances[_account] = newCredits;\n            }\n        }\n    }\n\n    function _adjustGlobals(\n        int256 _rebasingCreditsDiff,\n        int256 _nonRebasingSupplyDiff\n    ) internal {\n        if (_rebasingCreditsDiff != 0) {\n            rebasingCredits_ = (rebasingCredits_.toInt256() +\n                _rebasingCreditsDiff).toUint256();\n        }\n        if (_nonRebasingSupplyDiff != 0) {\n            nonRebasingSupply = (nonRebasingSupply.toInt256() +\n                _nonRebasingSupplyDiff).toUint256();\n        }\n    }\n\n    /**\n     * @notice Function to check the amount of tokens that _owner has allowed\n     *      to `_spender`.\n     * @param _owner The address which owns the funds.\n     * @param _spender The address which will spend the funds.\n     * @return The number of tokens still available for the _spender.\n     */\n    function allowance(address _owner, address _spender)\n        external\n        view\n        returns (uint256)\n    {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Approve the passed address to spend the specified amount of\n     *      tokens on behalf of msg.sender.\n     * @param _spender The address which will spend the funds.\n     * @param _value The amount of tokens to be spent.\n     * @return true on success.\n     */\n    function approve(address _spender, uint256 _value) external returns (bool) {\n        allowances[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * @notice Creates `_amount` tokens and assigns them to `_account`,\n     *     increasing the total supply.\n     */\n    function mint(address _account, uint256 _amount) external onlyVault {\n        require(_account != address(0), \"Mint to the zero address\");\n\n        // Account\n        (\n            int256 toRebasingCreditsDiff,\n            int256 toNonRebasingSupplyDiff\n        ) = _adjustAccount(_account, _amount.toInt256());\n        // Globals\n        _adjustGlobals(toRebasingCreditsDiff, toNonRebasingSupplyDiff);\n        totalSupply = totalSupply + _amount;\n\n        require(totalSupply < MAX_SUPPLY, \"Max supply\");\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    /**\n     * @notice Destroys `_amount` tokens from `_account`,\n     *     reducing the total supply.\n     */\n    function burn(address _account, uint256 _amount) external onlyVault {\n        require(_account != address(0), \"Burn from the zero address\");\n        if (_amount == 0) {\n            return;\n        }\n\n        // Account\n        (\n            int256 toRebasingCreditsDiff,\n            int256 toNonRebasingSupplyDiff\n        ) = _adjustAccount(_account, -_amount.toInt256());\n        // Globals\n        _adjustGlobals(toRebasingCreditsDiff, toNonRebasingSupplyDiff);\n        totalSupply = totalSupply - _amount;\n\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    /**\n     * @dev Get the credits per token for an account. Returns a fixed amount\n     *      if the account is non-rebasing.\n     * @param _account Address of the account.\n     */\n    function _creditsPerToken(address _account)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 alternativeCreditsPerTokenMem = alternativeCreditsPerToken[\n            _account\n        ];\n        if (alternativeCreditsPerTokenMem != 0) {\n            return alternativeCreditsPerTokenMem;\n        } else {\n            return rebasingCreditsPerToken_;\n        }\n    }\n\n    /**\n     * @dev Auto migrate contracts to be non rebasing,\n     *     unless they have opted into yield.\n     * @param _account Address of the account.\n     */\n    function _autoMigrate(address _account) internal {\n        uint256 codeLen = _account.code.length;\n        bool isEOA = (codeLen == 0) ||\n            (codeLen == 23 && bytes3(_account.code) == 0xef0100);\n        // In previous code versions, contracts would not have had their\n        // rebaseState[_account] set to RebaseOptions.NonRebasing when migrated\n        // therefore we check the actual accounting used on the account as well.\n        if (\n            (!isEOA) &&\n            rebaseState[_account] == RebaseOptions.NotSet &&\n            alternativeCreditsPerToken[_account] == 0\n        ) {\n            _rebaseOptOut(_account);\n        }\n    }\n\n    /**\n     * @dev Calculates credits from contract's global rebasingCreditsPerToken_, and\n     *      also balance that corresponds to those credits. The latter is important\n     *      when adjusting the contract's global nonRebasingSupply to circumvent any\n     *      possible rounding errors.\n     *\n     * @param _balance Balance of the account.\n     */\n    function _balanceToRebasingCredits(uint256 _balance)\n        internal\n        view\n        returns (uint256 rebasingCredits)\n    {\n        // Rounds up, because we need to ensure that accounts always have\n        // at least the balance that they should have.\n        // Note this should always be used on an absolute account value,\n        // not on a possibly negative diff, because then the rounding would be wrong.\n        return ((_balance) * rebasingCreditsPerToken_ + 1e18 - 1) / 1e18;\n    }\n\n    /**\n     * @notice The calling account will start receiving yield after a successful call.\n     * @param _account Address of the account.\n     */\n    function governanceRebaseOptIn(address _account) external onlyGovernor {\n        require(_account != address(0), \"Zero address not allowed\");\n        _rebaseOptIn(_account);\n    }\n\n    /**\n     * @notice The calling account will start receiving yield after a successful call.\n     */\n    function rebaseOptIn() external {\n        _rebaseOptIn(msg.sender);\n    }\n\n    function _rebaseOptIn(address _account) internal {\n        uint256 balance = balanceOf(_account);\n\n        // prettier-ignore\n        require(\n            alternativeCreditsPerToken[_account] > 0 ||\n                // Accounts may explicitly `rebaseOptIn` regardless of\n                // accounting if they have a 0 balance.\n                creditBalances[_account] == 0\n            ,\n            \"Account must be non-rebasing\"\n        );\n        RebaseOptions state = rebaseState[_account];\n        // prettier-ignore\n        require(\n            state == RebaseOptions.StdNonRebasing ||\n                state == RebaseOptions.NotSet,\n            \"Only standard non-rebasing accounts can opt in\"\n        );\n\n        uint256 newCredits = _balanceToRebasingCredits(balance);\n\n        // Account\n        rebaseState[_account] = RebaseOptions.StdRebasing;\n        alternativeCreditsPerToken[_account] = 0;\n        creditBalances[_account] = newCredits;\n        // Globals\n        _adjustGlobals(newCredits.toInt256(), -balance.toInt256());\n\n        emit AccountRebasingEnabled(_account);\n    }\n\n    /**\n     * @notice The calling account will no longer receive yield\n     */\n    function rebaseOptOut() external {\n        _rebaseOptOut(msg.sender);\n    }\n\n    function _rebaseOptOut(address _account) internal {\n        require(\n            alternativeCreditsPerToken[_account] == 0,\n            \"Account must be rebasing\"\n        );\n        RebaseOptions state = rebaseState[_account];\n        require(\n            state == RebaseOptions.StdRebasing || state == RebaseOptions.NotSet,\n            \"Only standard rebasing accounts can opt out\"\n        );\n\n        uint256 oldCredits = creditBalances[_account];\n        uint256 balance = balanceOf(_account);\n\n        // Account\n        rebaseState[_account] = RebaseOptions.StdNonRebasing;\n        alternativeCreditsPerToken[_account] = 1e18;\n        creditBalances[_account] = balance;\n        // Globals\n        _adjustGlobals(-oldCredits.toInt256(), balance.toInt256());\n\n        emit AccountRebasingDisabled(_account);\n    }\n\n    /**\n     * @notice Distribute yield to users. This changes the exchange rate\n     *  between \"credits\" and OUSD tokens to change rebasing user's balances.\n     * @param _newTotalSupply New total supply of OUSD.\n     */\n    function changeSupply(uint256 _newTotalSupply) external onlyVault {\n        require(totalSupply > 0, \"Cannot increase 0 supply\");\n\n        if (totalSupply == _newTotalSupply) {\n            emit TotalSupplyUpdatedHighres(\n                totalSupply,\n                rebasingCredits_,\n                rebasingCreditsPerToken_\n            );\n            return;\n        }\n\n        totalSupply = _newTotalSupply > MAX_SUPPLY\n            ? MAX_SUPPLY\n            : _newTotalSupply;\n\n        uint256 rebasingSupply = totalSupply - nonRebasingSupply;\n        // round up in the favour of the protocol\n        rebasingCreditsPerToken_ =\n            (rebasingCredits_ * 1e18 + rebasingSupply - 1) /\n            rebasingSupply;\n\n        require(rebasingCreditsPerToken_ > 0, \"Invalid change in supply\");\n\n        emit TotalSupplyUpdatedHighres(\n            totalSupply,\n            rebasingCredits_,\n            rebasingCreditsPerToken_\n        );\n    }\n\n    /*\n     * @notice Send the yield from one account to another account.\n     *         Each account keeps its own balances.\n     */\n    function delegateYield(address _from, address _to)\n        external\n        onlyGovernorOrStrategist\n    {\n        require(_from != address(0), \"Zero from address not allowed\");\n        require(_to != address(0), \"Zero to address not allowed\");\n\n        require(_from != _to, \"Cannot delegate to self\");\n        require(\n            yieldFrom[_to] == address(0) &&\n                yieldTo[_to] == address(0) &&\n                yieldFrom[_from] == address(0) &&\n                yieldTo[_from] == address(0),\n            \"Blocked by existing yield delegation\"\n        );\n        RebaseOptions stateFrom = rebaseState[_from];\n        RebaseOptions stateTo = rebaseState[_to];\n\n        require(\n            stateFrom == RebaseOptions.NotSet ||\n                stateFrom == RebaseOptions.StdNonRebasing ||\n                stateFrom == RebaseOptions.StdRebasing,\n            \"Invalid rebaseState from\"\n        );\n\n        require(\n            stateTo == RebaseOptions.NotSet ||\n                stateTo == RebaseOptions.StdNonRebasing ||\n                stateTo == RebaseOptions.StdRebasing,\n            \"Invalid rebaseState to\"\n        );\n\n        if (alternativeCreditsPerToken[_from] == 0) {\n            _rebaseOptOut(_from);\n        }\n        if (alternativeCreditsPerToken[_to] > 0) {\n            _rebaseOptIn(_to);\n        }\n\n        uint256 fromBalance = balanceOf(_from);\n        uint256 toBalance = balanceOf(_to);\n        uint256 oldToCredits = creditBalances[_to];\n        uint256 newToCredits = _balanceToRebasingCredits(\n            fromBalance + toBalance\n        );\n\n        // Set up the bidirectional links\n        yieldTo[_from] = _to;\n        yieldFrom[_to] = _from;\n\n        // Local\n        rebaseState[_from] = RebaseOptions.YieldDelegationSource;\n        alternativeCreditsPerToken[_from] = 1e18;\n        creditBalances[_from] = fromBalance;\n        rebaseState[_to] = RebaseOptions.YieldDelegationTarget;\n        creditBalances[_to] = newToCredits;\n\n        // Global\n        int256 creditsChange = newToCredits.toInt256() -\n            oldToCredits.toInt256();\n        _adjustGlobals(creditsChange, -(fromBalance).toInt256());\n        emit YieldDelegated(_from, _to);\n    }\n\n    /*\n     * @notice Stop sending the yield from one account to another account.\n     */\n    function undelegateYield(address _from) external onlyGovernorOrStrategist {\n        // Require a delegation, which will also ensure a valid delegation\n        require(yieldTo[_from] != address(0), \"Zero address not allowed\");\n\n        address to = yieldTo[_from];\n        uint256 fromBalance = balanceOf(_from);\n        uint256 toBalance = balanceOf(to);\n        uint256 oldToCredits = creditBalances[to];\n        uint256 newToCredits = _balanceToRebasingCredits(toBalance);\n\n        // Remove the bidirectional links\n        yieldFrom[to] = address(0);\n        yieldTo[_from] = address(0);\n\n        // Local\n        rebaseState[_from] = RebaseOptions.StdNonRebasing;\n        // alternativeCreditsPerToken[from] already 1e18 from `delegateYield()`\n        creditBalances[_from] = fromBalance;\n        rebaseState[to] = RebaseOptions.StdRebasing;\n        // alternativeCreditsPerToken[to] already 0 from `delegateYield()`\n        creditBalances[to] = newToCredits;\n\n        // Global\n        int256 creditsChange = newToCredits.toInt256() -\n            oldToCredits.toInt256();\n        _adjustGlobals(creditsChange, fromBalance.toInt256());\n        emit YieldUndelegated(_from, to);\n    }\n}\n"
    },
    "contracts/token/OUSDResolutionUpgrade.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ncontract OUSDResolutionUpgrade {\n    enum RebaseOptions {\n        NotSet,\n        OptOut,\n        OptIn\n    }\n\n    // From Initializable\n    bool private initialized;\n    bool private initializing;\n    uint256[50] private ______igap;\n\n    // From InitializableERC20Detailed\n    uint256[100] private _____ugap;\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    // From OUSD\n    uint256 private constant MAX_SUPPLY = ~uint128(0); // (2^128) - 1\n    uint256 public _totalSupply;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    address public vaultAddress = address(0);\n    mapping(address => uint256) private _creditBalances;\n    uint256 private _rebasingCredits;\n    uint256 private _rebasingCreditsPerToken;\n    uint256 public nonRebasingSupply;\n    mapping(address => uint256) public nonRebasingCreditsPerToken;\n    mapping(address => RebaseOptions) public rebaseState;\n    mapping(address => uint256) public isUpgraded;\n\n    uint256 private constant RESOLUTION_INCREASE = 1e9;\n\n    /**\n     * @return High resolution rebasingCreditsPerToken\n     */\n    function rebasingCreditsPerToken() public view returns (uint256) {\n        return _rebasingCreditsPerToken / RESOLUTION_INCREASE;\n    }\n\n    /**\n     * @return High resolution total number of rebasing credits\n     */\n    function rebasingCredits() public view returns (uint256) {\n        return _rebasingCredits / RESOLUTION_INCREASE;\n    }\n\n    /**\n     * @return High resolution rebasingCreditsPerToken\n     */\n    function rebasingCreditsPerTokenHighres() public view returns (uint256) {\n        return _rebasingCreditsPerToken;\n    }\n\n    /**\n     * @return High resolution total number of rebasing credits\n     */\n    function rebasingCreditsHighres() public view returns (uint256) {\n        return _rebasingCredits;\n    }\n\n    function upgradeGlobals() external {\n        require(isUpgraded[address(0)] == 0, \"Globals already upgraded\");\n        require(_rebasingCredits > 0, \"Sanity _rebasingCredits\");\n        require(\n            _rebasingCreditsPerToken > 0,\n            \"Sanity _rebasingCreditsPerToken\"\n        );\n        isUpgraded[address(0)] = 1;\n        _rebasingCredits = _rebasingCredits * RESOLUTION_INCREASE;\n        _rebasingCreditsPerToken =\n            _rebasingCreditsPerToken *\n            RESOLUTION_INCREASE;\n    }\n\n    function upgradeAccounts(address[] calldata accounts) external {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            address account = accounts[i];\n            require(account != address(0), \"Reserved\");\n            require(isUpgraded[account] == 0, \"Account already upgraded\");\n            isUpgraded[account] = 1;\n\n            // Handle special for non-rebasing accounts\n            uint256 nrc = nonRebasingCreditsPerToken[account];\n            if (nrc > 0) {\n                require(nrc < 1e18, \"Account already highres\");\n                nonRebasingCreditsPerToken[account] = nrc * RESOLUTION_INCREASE;\n            }\n            // Upgrade balance\n            uint256 balance = _creditBalances[account];\n            require(balance > 0, \"Will not upgrade zero balance\");\n            _creditBalances[account] = balance * RESOLUTION_INCREASE;\n        }\n    }\n\n    function creditsBalanceOfHighres(address _account)\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        return (\n            _creditBalances[_account],\n            _creditsPerToken(_account),\n            isUpgraded[_account] == 1\n        );\n    }\n\n    /**\n     * @dev Get the credits per token for an account. Returns a fixed amount\n     *      if the account is non-rebasing.\n     * @param _account Address of the account.\n     */\n    function _creditsPerToken(address _account)\n        internal\n        view\n        returns (uint256)\n    {\n        if (nonRebasingCreditsPerToken[_account] != 0) {\n            return nonRebasingCreditsPerToken[_account];\n        } else {\n            return _rebasingCreditsPerToken;\n        }\n    }\n}\n"
    },
    "contracts/token/WOETH.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ERC4626 } from \"../../lib/openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { Governable } from \"../governance/Governable.sol\";\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { OETH } from \"./OETH.sol\";\n\n/**\n * @title Wrapped OETH Token Contract\n * @author Origin Protocol Inc\n *\n * @dev An important capability of this contract is that it isn't susceptible to changes of the\n * exchange rate of WOETH/OETH if/when someone sends the underlying asset (OETH) to the contract.\n * If OETH weren't rebasing this could be achieved by solely tracking the ERC20 transfers of the OETH\n * token on mint, deposit, redeem, withdraw. The issue is that OETH is rebasing and OETH balances\n * will change when the token rebases.\n * For that reason the contract logic checks the actual underlying OETH token balance only once\n * (either on a fresh contract creation or upgrade) and considering the WOETH supply and\n * rebasingCreditsPerToken calculates the _adjuster. Once the adjuster is calculated any donations\n * to the contract are ignored. The totalSupply (instead of querying OETH balance) works off of\n * adjuster the current WOETH supply and rebasingCreditsPerToken. This makes WOETH value accrual\n * completely follow OETH's value accrual.\n * WOETH is safe to use in lending markets as the VualtCore's _rebase contains safeguards preventing\n * any sudden large rebases.\n */\n\ncontract WOETH is ERC4626, Governable, Initializable {\n    using SafeERC20 for IERC20;\n    /* This is a 1e27 adjustment constant that expresses the difference in exchange rate between\n     * OETH's rebase since inception (expressed with rebasingCreditsPerToken) and WOETH to OETH\n     * conversion.\n     *\n     * If WOETH and OETH are deployed at the same time, the value of adjuster is a neutral 1e27\n     */\n    uint256 public adjuster;\n    uint256[49] private __gap;\n\n    // no need to set ERC20 name and symbol since they are overridden in WOETH & WOETHBase\n    constructor(ERC20 underlying_) ERC20(\"\", \"\") ERC4626(underlying_) {}\n\n    /**\n     * @notice Enable OETH rebasing for this contract\n     */\n    function initialize() external onlyGovernor initializer {\n        OETH(address(asset())).rebaseOptIn();\n\n        initialize2();\n    }\n\n    /**\n     * @notice secondary initializer that newly deployed contracts will execute as part\n     *         of primary initialize function and the existing contracts will have it called\n     *         as a governance operation.\n     */\n    function initialize2() public onlyGovernor {\n        require(adjuster == 0, \"Initialize2 already called\");\n\n        if (totalSupply() == 0) {\n            adjuster = 1e27;\n        } else {\n            adjuster =\n                (rebasingCreditsPerTokenHighres() *\n                    ERC20(asset()).balanceOf(address(this))) /\n                totalSupply();\n        }\n    }\n\n    function name()\n        public\n        view\n        virtual\n        override(ERC20, IERC20Metadata)\n        returns (string memory)\n    {\n        return \"Wrapped OETH\";\n    }\n\n    function symbol()\n        public\n        view\n        virtual\n        override(ERC20, IERC20Metadata)\n        returns (string memory)\n    {\n        return \"wOETH\";\n    }\n\n    /**\n     * @notice Transfer token to governor. Intended for recovering tokens stuck in\n     *      contract, i.e. mistaken sends. Cannot transfer OETH\n     * @param asset_ Address for the asset\n     * @param amount_ Amount of the asset to transfer\n     */\n    function transferToken(address asset_, uint256 amount_)\n        external\n        onlyGovernor\n    {\n        require(asset_ != address(asset()), \"Cannot collect core asset\");\n        IERC20(asset_).safeTransfer(governor(), amount_);\n    }\n\n    /// @inheritdoc ERC4626\n    function convertToShares(uint256 assets)\n        public\n        view\n        virtual\n        override\n        returns (uint256 shares)\n    {\n        return (assets * rebasingCreditsPerTokenHighres()) / adjuster;\n    }\n\n    /// @inheritdoc ERC4626\n    function convertToAssets(uint256 shares)\n        public\n        view\n        virtual\n        override\n        returns (uint256 assets)\n    {\n        return (shares * adjuster) / rebasingCreditsPerTokenHighres();\n    }\n\n    /// @inheritdoc ERC4626\n    function totalAssets() public view override returns (uint256) {\n        return (totalSupply() * adjuster) / rebasingCreditsPerTokenHighres();\n    }\n\n    function rebasingCreditsPerTokenHighres() internal view returns (uint256) {\n        return OETH(asset()).rebasingCreditsPerTokenHighres();\n    }\n}\n"
    },
    "contracts/token/WOETHBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { WOETH } from \"./WOETH.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title OETH Token Contract\n * @author Origin Protocol Inc\n */\n\ncontract WOETHBase is WOETH {\n    constructor(ERC20 underlying_) WOETH(underlying_) {}\n\n    function name() public view virtual override returns (string memory) {\n        return \"Wrapped Super OETH\";\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return \"wsuperOETHb\";\n    }\n}\n"
    },
    "contracts/token/WOETHPlume.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { WOETH } from \"./WOETH.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title wOETH (Plume) Token Contract\n * @author Origin Protocol Inc\n */\n\ncontract WOETHPlume is WOETH {\n    constructor(ERC20 underlying_) WOETH(underlying_) {}\n\n    function name() public view virtual override returns (string memory) {\n        return \"Wrapped Super OETH\";\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return \"wsuperOETHp\";\n    }\n}\n"
    },
    "contracts/token/WOSonic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { WOETH } from \"./WOETH.sol\";\n\n/**\n * @title Wrapped Origin Sonic (wOS) token on Sonic\n * @author Origin Protocol Inc\n */\ncontract WOSonic is WOETH {\n    constructor(ERC20 underlying_) WOETH(underlying_) {}\n\n    function name()\n        public\n        view\n        virtual\n        override(WOETH)\n        returns (string memory)\n    {\n        return \"Wrapped OS\";\n    }\n\n    function symbol()\n        public\n        view\n        virtual\n        override(WOETH)\n        returns (string memory)\n    {\n        return \"wOS\";\n    }\n}\n"
    },
    "contracts/token/WrappedOusd.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { WOETH } from \"./WOETH.sol\";\n\n/**\n * @title Wrapped OUSD Token Contract\n * @author Origin Protocol Inc\n */\ncontract WrappedOusd is WOETH {\n    constructor(ERC20 underlying_) WOETH(underlying_) {}\n\n    function name()\n        public\n        view\n        virtual\n        override(WOETH)\n        returns (string memory)\n    {\n        return \"Wrapped OUSD\";\n    }\n\n    function symbol()\n        public\n        view\n        virtual\n        override(WOETH)\n        returns (string memory)\n    {\n        return \"WOUSD\";\n    }\n}\n"
    },
    "contracts/utils/AerodromeAMOQuoter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.7;\n\nimport { ICLPool } from \"../interfaces/aerodrome/ICLPool.sol\";\nimport { IQuoterV2 } from \"../interfaces/aerodrome/IQuoterV2.sol\";\nimport { IAMOStrategy } from \"../interfaces/aerodrome/IAMOStrategy.sol\";\n\n/// @title QuoterHelper\n/// @author Origin Protocol\n/// @notice Helper for Aerodrome AMO Quoter, as `_quoteAmountToSwapBeforeRebalance` use try/catch method and\n///         this can only be used when calling external contracts.\ncontract QuoterHelper {\n    ////////////////////////////////////////////////////////////////\n    /// --- STRUCTS & ENUMS\n    ////////////////////////////////////////////////////////////////\n    enum RevertReasons {\n        DefaultStatus,\n        RebalanceOutOfBounds,\n        NotInExpectedTickRange,\n        NotEnoughWethForSwap,\n        NotEnoughWethLiquidity,\n        UnexpectedError,\n        Found,\n        NotFound\n    }\n\n    struct RebalanceStatus {\n        RevertReasons reason;\n        uint256 currentPoolWETHShare; // Case 1\n        uint256 allowedWETHShareStart; // Case 1\n        uint256 allowedWETHShareEnd; // Case 1\n        int24 currentTick; // Case 2\n        uint256 balanceWETH; // Case 3\n        uint256 amountWETH; // Case 3\n        string revertMessage;\n    }\n\n    ////////////////////////////////////////////////////////////////\n    /// --- CONSTANT & IMMUTABLE\n    ////////////////////////////////////////////////////////////////\n    uint256 public constant BINARY_MIN_AMOUNT = 1 wei;\n\n    uint256 public constant BINARY_MAX_ITERATIONS = 40;\n    uint256 public constant PERCENTAGE_BASE = 1e18; // 100%\n    uint256 public constant ALLOWED_VARIANCE_PERCENTAGE = 1e15; // 0.1%\n\n    ////////////////////////////////////////////////////////////////\n    /// --- VARIABLES STORAGE\n    ////////////////////////////////////////////////////////////////\n    ICLPool public immutable clPool;\n    IQuoterV2 public immutable quoterV2;\n    IAMOStrategy public immutable strategy;\n\n    address public originalGovernor;\n\n    ////////////////////////////////////////////////////////////////\n    /// --- ERRORS & EVENTS\n    ////////////////////////////////////////////////////////////////\n    error UnexpectedError(string message);\n    error OutOfIterations(uint256 iterations);\n    error ValidAmount(\n        uint256 amount,\n        uint256 iterations,\n        bool swapWETHForOETHB\n    );\n\n    ////////////////////////////////////////////////////////////////\n    /// --- CONSTRUCTOR\n    ////////////////////////////////////////////////////////////////\n    constructor(IAMOStrategy _strategy, IQuoterV2 _quoterV2) {\n        strategy = _strategy;\n        quoterV2 = _quoterV2;\n        clPool = _strategy.clPool();\n    }\n\n    ////////////////////////////////////////////////////////////////\n    /// --- FUNCTIONS\n    ////////////////////////////////////////////////////////////////\n    /// @notice This call can only end with a revert.\n    function getAmountToSwapBeforeRebalance(\n        uint256 overrideBottomWethShare,\n        uint256 overrideTopWethShare\n    ) public {\n        if (\n            overrideBottomWethShare != type(uint256).max ||\n            overrideTopWethShare != type(uint256).max\n        ) {\n            // Current values\n            uint256 shareStart = strategy.allowedWethShareStart();\n            uint256 shareEnd = strategy.allowedWethShareEnd();\n\n            // Override values\n            if (overrideBottomWethShare != type(uint256).max) {\n                shareStart = overrideBottomWethShare;\n            }\n            if (overrideTopWethShare != type(uint256).max) {\n                shareEnd = overrideTopWethShare;\n            }\n\n            strategy.setAllowedPoolWethShareInterval(shareStart, shareEnd);\n        }\n\n        uint256 iterations = 0;\n        uint256 low = BINARY_MIN_AMOUNT;\n        uint256 high;\n        (high, ) = strategy.getPositionPrincipal();\n        int24 lowerTick = strategy.lowerTick();\n        int24 upperTick = strategy.upperTick();\n        bool swapWETHForOETHB = getSwapDirectionForRebalance();\n\n        while (low <= high && iterations < BINARY_MAX_ITERATIONS) {\n            uint256 mid = (low + high) / 2;\n\n            RebalanceStatus memory status = getRebalanceStatus(\n                mid,\n                swapWETHForOETHB\n            );\n\n            // Best case, we found the `amount` that will reach the target pool share!\n            // We can revert with the amount and the number of iterations\n            if (status.reason == RevertReasons.Found) {\n                revert ValidAmount(mid, iterations, swapWETHForOETHB);\n            }\n\n            // If the rebalance failed then we should try to change the amount.\n            // We will handle all possible revert reasons here.\n\n            // Case 1: Rebalance out of bounds\n            // If the pool is out of bounds, we need to adjust the amount to reach the target pool share\n            if (status.reason == RevertReasons.RebalanceOutOfBounds) {\n                // If the current pool share is less than the target pool share, we need to increase the amount\n                if (\n                    swapWETHForOETHB\n                        ? status.currentPoolWETHShare <\n                            status.allowedWETHShareStart\n                        : status.currentPoolWETHShare >\n                            status.allowedWETHShareEnd\n                ) {\n                    low = mid + 1;\n                }\n                // Else we need to decrease the amount\n                else {\n                    high = mid;\n                }\n            }\n\n            // Case 2: Not in expected tick range\n            // If the pool is not in the expected tick range, we need to adjust the amount\n            // to reach the target pool share\n            if (status.reason == RevertReasons.NotInExpectedTickRange) {\n                // If we are buying OETHb and the current tick is greater than the lower tick,\n                //we need to increase the amount in order to continue to push price down.\n                // If we are selling OETHb and the current tick is less than the upper tick,\n                // we need to increase the amount in order to continue to push price up.\n                if (\n                    swapWETHForOETHB\n                        ? status.currentTick > lowerTick\n                        : status.currentTick < upperTick\n                ) {\n                    low = mid + 1;\n                }\n                // Else we need to decrease the amount\n                else {\n                    high = mid;\n                }\n            }\n\n            // Case 3: Not enough WETH for swap\n            // If we don't have enough WETH to swap, we need to decrease the amount\n            // This error can happen, when initial value of mid is too high, so we need to decrease it\n            if (status.reason == RevertReasons.NotEnoughWethForSwap) {\n                high = mid;\n            }\n\n            // Case 4: Not enough WETH liquidity\n            // If we don't have enough WETH liquidity\n            // Revert for the moment, we need to improve this\n            if (status.reason == RevertReasons.NotEnoughWethLiquidity) {\n                revert(\"Quoter: Not enough WETH liquidity\");\n            }\n\n            // Case 5: Unexpected error\n            // Worst case, it reverted with an unexpected error.\n            if (status.reason == RevertReasons.UnexpectedError) {\n                revert UnexpectedError(status.revertMessage);\n            }\n\n            iterations++;\n        }\n\n        // Case 6: Out of iterations\n        // If we didn't find the amount after the max iterations, we need to revert.\n        revert OutOfIterations(iterations);\n    }\n\n    /// @notice Get the status of the rebalance\n    /// @param amount The amount of token to swap\n    /// @param swapWETH True if we need to swap WETH for OETHb, false otherwise\n    /// @return status The status of the rebalance\n    function getRebalanceStatus(uint256 amount, bool swapWETH)\n        public\n        returns (RebalanceStatus memory status)\n    {\n        try strategy.rebalance(amount, swapWETH, 0) {\n            status.reason = RevertReasons.Found;\n            return status;\n        } catch Error(string memory reason) {\n            status.reason = RevertReasons.UnexpectedError;\n            status.revertMessage = reason;\n        } catch (bytes memory reason) {\n            bytes4 receivedSelector = bytes4(reason);\n\n            // Case 1: Rebalance out of bounds\n            if (\n                receivedSelector ==\n                IAMOStrategy.PoolRebalanceOutOfBounds.selector\n            ) {\n                uint256 currentPoolWETHShare;\n                uint256 allowedWETHShareStart;\n                uint256 allowedWETHShareEnd;\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    currentPoolWETHShare := mload(add(reason, 0x24))\n                    allowedWETHShareStart := mload(add(reason, 0x44))\n                    allowedWETHShareEnd := mload(add(reason, 0x64))\n                }\n                return\n                    RebalanceStatus({\n                        reason: RevertReasons.RebalanceOutOfBounds,\n                        currentPoolWETHShare: currentPoolWETHShare,\n                        allowedWETHShareStart: allowedWETHShareStart,\n                        allowedWETHShareEnd: allowedWETHShareEnd,\n                        currentTick: 0,\n                        balanceWETH: 0,\n                        amountWETH: 0,\n                        revertMessage: \"\"\n                    });\n            }\n\n            // Case 2: Not in expected tick range\n            if (\n                receivedSelector ==\n                IAMOStrategy.OutsideExpectedTickRange.selector\n            ) {\n                int24 currentTick;\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    currentTick := mload(add(reason, 0x24))\n                }\n                return\n                    RebalanceStatus({\n                        reason: RevertReasons.NotInExpectedTickRange,\n                        currentPoolWETHShare: 0,\n                        allowedWETHShareStart: 0,\n                        allowedWETHShareEnd: 0,\n                        currentTick: currentTick,\n                        balanceWETH: 0,\n                        amountWETH: 0,\n                        revertMessage: \"\"\n                    });\n            }\n\n            // Case 3: Not enough WETH for swap\n            if (\n                receivedSelector == IAMOStrategy.NotEnoughWethForSwap.selector\n            ) {\n                uint256 balanceWETH;\n                uint256 amountWETH;\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    balanceWETH := mload(add(reason, 0x24))\n                    amountWETH := mload(add(reason, 0x44))\n                }\n                return\n                    RebalanceStatus({\n                        reason: RevertReasons.NotEnoughWethForSwap,\n                        currentPoolWETHShare: 0,\n                        allowedWETHShareStart: 0,\n                        allowedWETHShareEnd: 0,\n                        currentTick: 0,\n                        balanceWETH: balanceWETH,\n                        amountWETH: amountWETH,\n                        revertMessage: \"\"\n                    });\n            }\n\n            // Case 4: Not enough WETH liquidity\n            if (\n                receivedSelector == IAMOStrategy.NotEnoughWethLiquidity.selector\n            ) {\n                return\n                    RebalanceStatus({\n                        reason: RevertReasons.NotEnoughWethLiquidity,\n                        currentPoolWETHShare: 0,\n                        allowedWETHShareStart: 0,\n                        allowedWETHShareEnd: 0,\n                        currentTick: 0,\n                        balanceWETH: 0,\n                        amountWETH: 0,\n                        revertMessage: \"\"\n                    });\n            }\n\n            // Case 5: Unexpected error\n            return\n                RebalanceStatus({\n                    reason: RevertReasons.UnexpectedError,\n                    currentPoolWETHShare: 0,\n                    allowedWETHShareStart: 0,\n                    allowedWETHShareEnd: 0,\n                    currentTick: 0,\n                    balanceWETH: 0,\n                    amountWETH: 0,\n                    revertMessage: abi.decode(reason, (string))\n                });\n        }\n    }\n\n    /// @notice Get the swap direction to reach the target price before rebalance.\n    /// @return bool True if we need to swap WETH for OETHb, false otherwise.\n    function getSwapDirectionForRebalance() public view returns (bool) {\n        uint160 currentPrice = strategy.getPoolX96Price();\n        uint160 ticker0Price = strategy.sqrtRatioX96TickLower();\n        uint160 ticker1Price = strategy.sqrtRatioX96TickHigher();\n        uint256 allowedWethShareStart = strategy.allowedWethShareStart();\n        uint256 allowedWethShareEnd = strategy.allowedWethShareEnd();\n        uint160 mid = uint160(allowedWethShareStart + allowedWethShareEnd) / 2;\n        // slither-disable-start divide-before-multiply\n        uint160 targetPrice = (ticker0Price *\n            mid +\n            ticker1Price *\n            (1 ether - mid)) / 1 ether;\n        // slither-disable-end divide-before-multiply\n\n        return currentPrice > targetPrice;\n    }\n\n    // returns total amount in the position principal of the Aerodrome AMO strategy. Needed as a\n    // separate function because of the limitation in local variable count in getAmountToSwapToReachPrice\n    function getTotalStrategyPosition() internal returns (uint256) {\n        (uint256 wethAmount, uint256 oethBalance) = strategy\n            .getPositionPrincipal();\n        return wethAmount + oethBalance;\n    }\n\n    /// @notice Get the amount of tokens to swap to reach the target price.\n    /// @dev This act like a quoter, i.e. the transaction is not performed.\n    /// @dev Because the amount to swap can be largely overestimated, because CLAMM alow partial orders,\n    /// i.e. when we ask to swap a very large amount, with a close priceLimite, it will swap only a part of it,\n    /// and not revert. So if overestimated amount is to high, use a custom maxAmount to avoid this issue.\n    /// @param sqrtPriceTargetX96 The target price to reach.\n    /// @return amount The amount of tokens to swap.\n    /// @return iterations The number of iterations to find the amount.\n    /// @return swapWETHForOETHB True if we need to swap WETH for OETHb, false otherwise.\n    /// @return sqrtPriceX96After The price after the swap.\n    function getAmountToSwapToReachPrice(uint160 sqrtPriceTargetX96)\n        public\n        returns (\n            uint256,\n            uint256,\n            bool,\n            uint160\n        )\n    {\n        uint256 iterations = 0;\n        uint256 low = BINARY_MIN_AMOUNT;\n        // high search start is twice the position principle of Aerodrome AMO strategy.\n        // should be more than enough\n        uint256 high = getTotalStrategyPosition() * 2;\n        bool swapWETHForOETHB = getSwapDirection(sqrtPriceTargetX96);\n\n        while (low <= high && iterations < BINARY_MAX_ITERATIONS) {\n            uint256 mid = (low + high) / 2;\n\n            // Call QuoterV2 from SugarHelper\n            (uint256 amountOut, uint160 sqrtPriceX96After, , ) = quoterV2\n                .quoteExactInputSingle(\n                    IQuoterV2.QuoteExactInputSingleParams({\n                        tokenIn: swapWETHForOETHB\n                            ? clPool.token0()\n                            : clPool.token1(),\n                        tokenOut: swapWETHForOETHB\n                            ? clPool.token1()\n                            : clPool.token0(),\n                        amountIn: mid,\n                        tickSpacing: strategy.tickSpacing(),\n                        sqrtPriceLimitX96: sqrtPriceTargetX96\n                    })\n                );\n\n            if (\n                isWithinAllowedVariance(sqrtPriceX96After, sqrtPriceTargetX96)\n            ) {\n                /** Very important to return `amountOut` instead of `mid` as the first return parameter.\n                 * The issues was that when quoting we impose a swap price limit (sqrtPriceLimitX96: sqrtPriceTargetX96)\n                 * and in that case the `amountIn` acts like a maximum amount to swap. And we don't know how much\n                 * of that amount was actually consumed. For that reason we \"estimate\" it by returning the\n                 * amountOut since that is only going to be a couple of basis point away from amountIn in the\n                 * worst cases.\n                 *\n                 * Note: we could be returning mid instead of amountOut in cases when those values are only basis\n                 * points apart (assuming that complete balance of amountIn has been consumed) but that might increase\n                 * complexity too much in an already complex contract.\n                 */\n                return (\n                    amountOut,\n                    iterations,\n                    swapWETHForOETHB,\n                    sqrtPriceX96After\n                );\n            } else if (low == high) {\n                // target swap amount not found.\n                // might be that \"high\" amount is too low on start\n                revert(\"SwapAmountNotFound\");\n            } else if (\n                swapWETHForOETHB\n                    ? sqrtPriceX96After > sqrtPriceTargetX96\n                    : sqrtPriceX96After < sqrtPriceTargetX96\n            ) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n            iterations++;\n        }\n\n        revert OutOfIterations(iterations);\n    }\n\n    /// @notice Check if the current price is within the allowed variance in comparison to the target price\n    /// @return bool True if the current price is within the allowed variance, false otherwise\n    function isWithinAllowedVariance(\n        uint160 sqrtPriceCurrentX96,\n        uint160 sqrtPriceTargetX96\n    ) public view returns (bool) {\n        uint160 range = strategy.sqrtRatioX96TickHigher() -\n            strategy.sqrtRatioX96TickLower();\n        if (sqrtPriceCurrentX96 > sqrtPriceTargetX96) {\n            return\n                (sqrtPriceCurrentX96 - sqrtPriceTargetX96) <=\n                (ALLOWED_VARIANCE_PERCENTAGE * range) / PERCENTAGE_BASE;\n        } else {\n            return\n                (sqrtPriceTargetX96 - sqrtPriceCurrentX96) <=\n                (ALLOWED_VARIANCE_PERCENTAGE * range) / PERCENTAGE_BASE;\n        }\n    }\n\n    /// @notice Get the swap direction to reach the target price.\n    /// @param sqrtPriceTargetX96 The target price to reach.\n    /// @return bool True if we need to swap WETH for OETHb, false otherwise.\n    function getSwapDirection(uint160 sqrtPriceTargetX96)\n        public\n        view\n        returns (bool)\n    {\n        uint160 currentPrice = strategy.getPoolX96Price();\n        return currentPrice > sqrtPriceTargetX96;\n    }\n\n    function claimGovernanceOnAMO() public {\n        originalGovernor = strategy.governor();\n        strategy.claimGovernance();\n    }\n\n    function giveBackGovernanceOnAMO() public {\n        require(\n            originalGovernor != address(0),\n            \"Quoter: Original governor not set\"\n        );\n        strategy.transferGovernance(originalGovernor);\n    }\n}\n\n/// @title AerodromeAMOQuoter\n/// @author Origin Protocol\n/// @notice Quoter for Aerodrome AMO\ncontract AerodromeAMOQuoter {\n    ////////////////////////////////////////////////////////////////\n    /// --- STRUCTS & ENUMS\n    ///////////////////////////////////////////////////////////////\n    struct Data {\n        uint256 amount;\n        uint256 iterations;\n    }\n\n    ////////////////////////////////////////////////////////////////\n    /// --- VARIABLES STORAGE\n    ////////////////////////////////////////////////////////////////\n    QuoterHelper public immutable quoterHelper;\n\n    ////////////////////////////////////////////////////////////////\n    /// --- CONSTRUCTOR\n    ////////////////////////////////////////////////////////////////\n    constructor(address _strategy, address _quoterV2) {\n        quoterHelper = new QuoterHelper(\n            IAMOStrategy(_strategy),\n            IQuoterV2(_quoterV2)\n        );\n    }\n\n    ////////////////////////////////////////////////////////////////\n    /// --- ERRORS & EVENTS\n    ////////////////////////////////////////////////////////////////\n    event ValueFound(uint256 value, uint256 iterations, bool swapWETHForOETHB);\n    event ValueFoundBis(\n        uint256 value,\n        uint256 iterations,\n        bool swapWETHForOETHB,\n        uint160 sqrtPriceAfterX96\n    );\n    event ValueNotFound(string message);\n\n    ////////////////////////////////////////////////////////////////\n    /// --- FUNCTIONS\n    ////////////////////////////////////////////////////////////////\n    /// @notice Use this to get the amount to swap before rebalance\n    /// @dev This call will only revert, check the logs to get returned values.\n    /// @dev Need to perform this call while impersonating the governor or strategist of AMO.\n    /// @return data Data struct with the amount and the number of iterations\n    function quoteAmountToSwapBeforeRebalance()\n        public\n        returns (Data memory data)\n    {\n        return\n            _quoteAmountToSwapBeforeRebalance(\n                type(uint256).max,\n                type(uint256).max\n            );\n    }\n\n    /// @notice Use this to get the amount to swap before rebalance and\n    ///         update allowedWethShareStart and allowedWethShareEnd on AMO.\n    /// @dev This call will only revert, check the logs to get returned values.\n    /// @dev Need to perform this call while impersonating the governor of AMO.\n    /// @param overrideBottomWethShare New value for the allowedWethShareStart on AMO.\n    ///         Use type(uint256).max to keep same value.\n    /// @param overrideTopWethShare New value for the allowedWethShareEnd on AMO.\n    ///         Use type(uint256).max to keep same value.\n    /// @return data Data struct with the amount and the number of iterations\n    function quoteAmountToSwapBeforeRebalance(\n        uint256 overrideBottomWethShare,\n        uint256 overrideTopWethShare\n    ) public returns (Data memory data) {\n        return\n            _quoteAmountToSwapBeforeRebalance(\n                overrideBottomWethShare,\n                overrideTopWethShare\n            );\n    }\n\n    /// @notice Internal logic for quoteAmountToSwapBeforeRebalance.\n    function _quoteAmountToSwapBeforeRebalance(\n        uint256 overrideBottomWethShare,\n        uint256 overrideTopWethShare\n    ) internal returns (Data memory data) {\n        try\n            quoterHelper.getAmountToSwapBeforeRebalance(\n                overrideBottomWethShare,\n                overrideTopWethShare\n            )\n        {\n            revert(\"Previous call should only revert, it cannot succeed\");\n        } catch (bytes memory reason) {\n            bytes4 receivedSelector = bytes4(reason);\n            if (receivedSelector == QuoterHelper.ValidAmount.selector) {\n                uint256 value;\n                uint256 iterations;\n                bool swapWETHForOETHB;\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    value := mload(add(reason, 0x24))\n                    iterations := mload(add(reason, 0x44))\n                    swapWETHForOETHB := mload(add(reason, 0x64))\n                }\n                emit ValueFound(value, iterations, swapWETHForOETHB);\n                return Data({ amount: value, iterations: iterations });\n            }\n\n            if (receivedSelector == QuoterHelper.OutOfIterations.selector) {\n                emit ValueNotFound(\"Out of iterations\");\n                revert(\"Out of iterations\");\n            }\n\n            emit ValueNotFound(\"Unexpected error\");\n            revert(abi.decode(reason, (string)));\n        }\n    }\n\n    /// @notice Use this to get the amount to swap to reach the target price after swap.\n    /// @dev This call will only revert, check the logs to get returned values.\n    /// @param sqrtPriceTargetX96 The target price to reach.\n    function quoteAmountToSwapToReachPrice(uint160 sqrtPriceTargetX96) public {\n        (\n            uint256 amount,\n            uint256 iterations,\n            bool swapWETHForOETHB,\n            uint160 sqrtPriceAfterX96\n        ) = quoterHelper.getAmountToSwapToReachPrice(sqrtPriceTargetX96);\n\n        emit ValueFoundBis(\n            amount,\n            iterations,\n            swapWETHForOETHB,\n            sqrtPriceAfterX96\n        );\n    }\n\n    function claimGovernance() public {\n        quoterHelper.claimGovernanceOnAMO();\n    }\n\n    function giveBackGovernance() public {\n        quoterHelper.giveBackGovernanceOnAMO();\n    }\n}\n"
    },
    "contracts/utils/BalancerErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.7.4 <0.9.0;\n\n// solhint-disable\n\n/**\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n * supported.\n * Uses the default 'BAL' prefix for the error code\n */\nfunction _require(bool condition, uint256 errorCode) pure {\n    if (!condition) _revert(errorCode);\n}\n\n/**\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n * supported.\n */\nfunction _require(\n    bool condition,\n    uint256 errorCode,\n    bytes3 prefix\n) pure {\n    if (!condition) _revert(errorCode, prefix);\n}\n\n/**\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n * Uses the default 'BAL' prefix for the error code\n */\nfunction _revert(uint256 errorCode) pure {\n    _revert(errorCode, 0x42414c); // This is the raw byte representation of \"BAL\"\n}\n\n/**\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n */\nfunction _revert(uint256 errorCode, bytes3 prefix) pure {\n    uint256 prefixUint = uint256(uint24(prefix));\n    // We're going to dynamically create a revert string based on the error code, with the following format:\n    // 'BAL#{errorCode}'\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\n    //\n    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\n    // number (8 to 16 bits) than the individual string characters.\n    //\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\n    assembly {\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\n        // the '0' character.\n\n        let units := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let tenths := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let hundreds := add(mod(errorCode, 10), 0x30)\n\n        // With the individual characters, we can now construct the full string.\n        // We first append the '#' character (0x23) to the prefix. In the case of 'BAL', it results in 0x42414c23 ('BAL#')\n        // Then, we shift this by 24 (to provide space for the 3 bytes of the error code), and add the\n        // characters to it, each shifted by a multiple of 8.\n        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\n        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\n        // array).\n        let formattedPrefix := shl(24, add(0x23, shl(8, prefixUint)))\n\n        let revertReason := shl(\n            200,\n            add(\n                formattedPrefix,\n                add(add(units, shl(8, tenths)), shl(16, hundreds))\n            )\n        )\n\n        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\n        // message will have the following layout:\n        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\n\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\n        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\n        mstore(\n            0x0,\n            0x08c379a000000000000000000000000000000000000000000000000000000000\n        )\n        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\n        mstore(\n            0x04,\n            0x0000000000000000000000000000000000000000000000000000000000000020\n        )\n        // The string length is fixed: 7 characters.\n        mstore(0x24, 7)\n        // Finally, the string itself is stored.\n        mstore(0x44, revertReason)\n\n        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\n        revert(0, 100)\n    }\n}\n\nlibrary Errors {\n    // Math\n    uint256 internal constant ADD_OVERFLOW = 0;\n    uint256 internal constant SUB_OVERFLOW = 1;\n    uint256 internal constant SUB_UNDERFLOW = 2;\n    uint256 internal constant MUL_OVERFLOW = 3;\n    uint256 internal constant ZERO_DIVISION = 4;\n    uint256 internal constant DIV_INTERNAL = 5;\n    uint256 internal constant X_OUT_OF_BOUNDS = 6;\n    uint256 internal constant Y_OUT_OF_BOUNDS = 7;\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\n    uint256 internal constant INVALID_EXPONENT = 9;\n\n    // Input\n    uint256 internal constant OUT_OF_BOUNDS = 100;\n    uint256 internal constant UNSORTED_ARRAY = 101;\n    uint256 internal constant UNSORTED_TOKENS = 102;\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\n    uint256 internal constant ZERO_TOKEN = 104;\n    uint256 internal constant INSUFFICIENT_DATA = 105;\n\n    // Shared pools\n    uint256 internal constant MIN_TOKENS = 200;\n    uint256 internal constant MAX_TOKENS = 201;\n    uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\n    uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\n    uint256 internal constant MINIMUM_BPT = 204;\n    uint256 internal constant CALLER_NOT_VAULT = 205;\n    uint256 internal constant UNINITIALIZED = 206;\n    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\n    uint256 internal constant EXPIRED_PERMIT = 209;\n    uint256 internal constant NOT_TWO_TOKENS = 210;\n    uint256 internal constant DISABLED = 211;\n\n    // Pools\n    uint256 internal constant MIN_AMP = 300;\n    uint256 internal constant MAX_AMP = 301;\n    uint256 internal constant MIN_WEIGHT = 302;\n    uint256 internal constant MAX_STABLE_TOKENS = 303;\n    uint256 internal constant MAX_IN_RATIO = 304;\n    uint256 internal constant MAX_OUT_RATIO = 305;\n    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\n    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\n    uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\n    uint256 internal constant INVALID_TOKEN = 309;\n    uint256 internal constant UNHANDLED_JOIN_KIND = 310;\n    uint256 internal constant ZERO_INVARIANT = 311;\n    uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;\n    uint256 internal constant ORACLE_NOT_INITIALIZED = 313;\n    uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;\n    uint256 internal constant ORACLE_INVALID_INDEX = 315;\n    uint256 internal constant ORACLE_BAD_SECS = 316;\n    uint256 internal constant AMP_END_TIME_TOO_CLOSE = 317;\n    uint256 internal constant AMP_ONGOING_UPDATE = 318;\n    uint256 internal constant AMP_RATE_TOO_HIGH = 319;\n    uint256 internal constant AMP_NO_ONGOING_UPDATE = 320;\n    uint256 internal constant STABLE_INVARIANT_DIDNT_CONVERGE = 321;\n    uint256 internal constant STABLE_GET_BALANCE_DIDNT_CONVERGE = 322;\n    uint256 internal constant RELAYER_NOT_CONTRACT = 323;\n    uint256 internal constant BASE_POOL_RELAYER_NOT_CALLED = 324;\n    uint256 internal constant REBALANCING_RELAYER_REENTERED = 325;\n    uint256 internal constant GRADUAL_UPDATE_TIME_TRAVEL = 326;\n    uint256 internal constant SWAPS_DISABLED = 327;\n    uint256 internal constant CALLER_IS_NOT_LBP_OWNER = 328;\n    uint256 internal constant PRICE_RATE_OVERFLOW = 329;\n    uint256 internal constant INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED = 330;\n    uint256 internal constant WEIGHT_CHANGE_TOO_FAST = 331;\n    uint256 internal constant LOWER_GREATER_THAN_UPPER_TARGET = 332;\n    uint256 internal constant UPPER_TARGET_TOO_HIGH = 333;\n    uint256 internal constant UNHANDLED_BY_LINEAR_POOL = 334;\n    uint256 internal constant OUT_OF_TARGET_RANGE = 335;\n    uint256 internal constant UNHANDLED_EXIT_KIND = 336;\n    uint256 internal constant UNAUTHORIZED_EXIT = 337;\n    uint256 internal constant MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE = 338;\n    uint256 internal constant UNHANDLED_BY_MANAGED_POOL = 339;\n    uint256 internal constant UNHANDLED_BY_PHANTOM_POOL = 340;\n    uint256 internal constant TOKEN_DOES_NOT_HAVE_RATE_PROVIDER = 341;\n    uint256 internal constant INVALID_INITIALIZATION = 342;\n    uint256 internal constant OUT_OF_NEW_TARGET_RANGE = 343;\n    uint256 internal constant FEATURE_DISABLED = 344;\n    uint256 internal constant UNINITIALIZED_POOL_CONTROLLER = 345;\n    uint256 internal constant SET_SWAP_FEE_DURING_FEE_CHANGE = 346;\n    uint256 internal constant SET_SWAP_FEE_PENDING_FEE_CHANGE = 347;\n    uint256 internal constant CHANGE_TOKENS_DURING_WEIGHT_CHANGE = 348;\n    uint256 internal constant CHANGE_TOKENS_PENDING_WEIGHT_CHANGE = 349;\n    uint256 internal constant MAX_WEIGHT = 350;\n    uint256 internal constant UNAUTHORIZED_JOIN = 351;\n    uint256 internal constant MAX_MANAGEMENT_AUM_FEE_PERCENTAGE = 352;\n    uint256 internal constant FRACTIONAL_TARGET = 353;\n    uint256 internal constant ADD_OR_REMOVE_BPT = 354;\n    uint256 internal constant INVALID_CIRCUIT_BREAKER_BOUNDS = 355;\n    uint256 internal constant CIRCUIT_BREAKER_TRIPPED = 356;\n    uint256 internal constant MALICIOUS_QUERY_REVERT = 357;\n    uint256 internal constant JOINS_EXITS_DISABLED = 358;\n\n    // Lib\n    uint256 internal constant REENTRANCY = 400;\n    uint256 internal constant SENDER_NOT_ALLOWED = 401;\n    uint256 internal constant PAUSED = 402;\n    uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\n    uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\n    uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\n    uint256 internal constant INSUFFICIENT_BALANCE = 406;\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\n    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\n    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\n    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\n    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\n    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\n    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\n    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\n    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\n    uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\n    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\n    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\n    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\n    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\n    uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\n    uint256 internal constant CALLER_IS_NOT_OWNER = 426;\n    uint256 internal constant NEW_OWNER_IS_ZERO = 427;\n    uint256 internal constant CODE_DEPLOYMENT_FAILED = 428;\n    uint256 internal constant CALL_TO_NON_CONTRACT = 429;\n    uint256 internal constant LOW_LEVEL_CALL_FAILED = 430;\n    uint256 internal constant NOT_PAUSED = 431;\n    uint256 internal constant ADDRESS_ALREADY_ALLOWLISTED = 432;\n    uint256 internal constant ADDRESS_NOT_ALLOWLISTED = 433;\n    uint256 internal constant ERC20_BURN_EXCEEDS_BALANCE = 434;\n    uint256 internal constant INVALID_OPERATION = 435;\n    uint256 internal constant CODEC_OVERFLOW = 436;\n    uint256 internal constant IN_RECOVERY_MODE = 437;\n    uint256 internal constant NOT_IN_RECOVERY_MODE = 438;\n    uint256 internal constant INDUCED_FAILURE = 439;\n    uint256 internal constant EXPIRED_SIGNATURE = 440;\n    uint256 internal constant MALFORMED_SIGNATURE = 441;\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_UINT64 = 442;\n    uint256 internal constant UNHANDLED_FEE_TYPE = 443;\n    uint256 internal constant BURN_FROM_ZERO = 444;\n\n    // Vault\n    uint256 internal constant INVALID_POOL_ID = 500;\n    uint256 internal constant CALLER_NOT_POOL = 501;\n    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\n    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\n    uint256 internal constant INVALID_SIGNATURE = 504;\n    uint256 internal constant EXIT_BELOW_MIN = 505;\n    uint256 internal constant JOIN_ABOVE_MAX = 506;\n    uint256 internal constant SWAP_LIMIT = 507;\n    uint256 internal constant SWAP_DEADLINE = 508;\n    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\n    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\n    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\n    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\n    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\n    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\n    uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\n    uint256 internal constant INSUFFICIENT_ETH = 516;\n    uint256 internal constant UNALLOCATED_ETH = 517;\n    uint256 internal constant ETH_TRANSFER = 518;\n    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\n    uint256 internal constant TOKENS_MISMATCH = 520;\n    uint256 internal constant TOKEN_NOT_REGISTERED = 521;\n    uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\n    uint256 internal constant TOKENS_ALREADY_SET = 523;\n    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\n    uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\n    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\n    uint256 internal constant POOL_NO_TOKENS = 527;\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\n\n    // Fees\n    uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\n    uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\n    uint256 internal constant AUM_FEE_PERCENTAGE_TOO_HIGH = 603;\n\n    // FeeSplitter\n    uint256 internal constant SPLITTER_FEE_PERCENTAGE_TOO_HIGH = 700;\n\n    // Misc\n    uint256 internal constant UNIMPLEMENTED = 998;\n    uint256 internal constant SHOULD_NOT_HAPPEN = 999;\n}\n"
    },
    "contracts/utils/DepositContractUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ncontract DepositContractUtils {\n    function calculateDepositDataRoot(\n        bytes calldata pubkey,\n        bytes calldata withdrawal_credentials,\n        bytes calldata signature\n    ) public pure returns (bytes32 node) {\n        uint256 deposit_amount = 32 ether / 1 gwei;\n        bytes memory amount = to_little_endian_64(uint64(deposit_amount));\n\n        // Compute deposit data root (`DepositData` hash tree root)\n        bytes32 pubkey_root = sha256(abi.encodePacked(pubkey, bytes16(0)));\n        bytes32 signature_root = sha256(\n            abi.encodePacked(\n                sha256(abi.encodePacked(signature[:64])),\n                sha256(abi.encodePacked(signature[64:], bytes32(0)))\n            )\n        );\n        node = sha256(\n            abi.encodePacked(\n                sha256(abi.encodePacked(pubkey_root, withdrawal_credentials)),\n                sha256(abi.encodePacked(amount, bytes24(0), signature_root))\n            )\n        );\n    }\n\n    function to_little_endian_64(uint64 value)\n        internal\n        pure\n        returns (bytes memory ret)\n    {\n        ret = new bytes(8);\n        bytes8 bytesValue = bytes8(value);\n        // Byteswapping during copying to bytes.\n        ret[0] = bytesValue[7];\n        ret[1] = bytesValue[6];\n        ret[2] = bytesValue[5];\n        ret[3] = bytesValue[4];\n        ret[4] = bytesValue[3];\n        ret[5] = bytesValue[2];\n        ret[6] = bytesValue[1];\n        ret[7] = bytesValue[0];\n    }\n}\n"
    },
    "contracts/utils/Helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IBasicToken } from \"../interfaces/IBasicToken.sol\";\n\nlibrary Helpers {\n    /**\n     * @notice Fetch the `symbol()` from an ERC20 token\n     * @dev Grabs the `symbol()` from a contract\n     * @param _token Address of the ERC20 token\n     * @return string Symbol of the ERC20 token\n     */\n    function getSymbol(address _token) internal view returns (string memory) {\n        string memory symbol = IBasicToken(_token).symbol();\n        return symbol;\n    }\n\n    /**\n     * @notice Fetch the `decimals()` from an ERC20 token\n     * @dev Grabs the `decimals()` from a contract and fails if\n     *      the decimal value does not live within a certain range\n     * @param _token Address of the ERC20 token\n     * @return uint256 Decimals of the ERC20 token\n     */\n    function getDecimals(address _token) internal view returns (uint256) {\n        uint256 decimals = IBasicToken(_token).decimals();\n        require(\n            decimals >= 4 && decimals <= 18,\n            \"Token must have sufficient decimal places\"\n        );\n\n        return decimals;\n    }\n}\n"
    },
    "contracts/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Base contract any contracts that need to initialize state after deployment.\n * @author Origin Protocol Inc\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(initializing || !initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!initializing, \"Initializable: contract is initializing\");\n        initialized = true;\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/utils/InitializableAbstractStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Base contract for vault strategies.\n * @author Origin Protocol Inc\n */\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\nabstract contract InitializableAbstractStrategy is Initializable, Governable {\n    using SafeERC20 for IERC20;\n\n    event PTokenAdded(address indexed _asset, address _pToken);\n    event PTokenRemoved(address indexed _asset, address _pToken);\n    event Deposit(address indexed _asset, address _pToken, uint256 _amount);\n    event Withdrawal(address indexed _asset, address _pToken, uint256 _amount);\n    event RewardTokenCollected(\n        address recipient,\n        address rewardToken,\n        uint256 amount\n    );\n    event RewardTokenAddressesUpdated(\n        address[] _oldAddresses,\n        address[] _newAddresses\n    );\n    event HarvesterAddressesUpdated(\n        address _oldHarvesterAddress,\n        address _newHarvesterAddress\n    );\n\n    /// @notice Address of the underlying platform\n    address public immutable platformAddress;\n    /// @notice Address of the OToken vault\n    address public immutable vaultAddress;\n\n    /// @dev Replaced with an immutable variable\n    // slither-disable-next-line constable-states\n    address private _deprecated_platformAddress;\n\n    /// @dev Replaced with an immutable\n    // slither-disable-next-line constable-states\n    address private _deprecated_vaultAddress;\n\n    /// @notice asset => pToken (Platform Specific Token Address)\n    mapping(address => address) public assetToPToken;\n\n    /// @notice Full list of all assets supported by the strategy\n    address[] internal assetsMapped;\n\n    // Deprecated: Reward token address\n    // slither-disable-next-line constable-states\n    address private _deprecated_rewardTokenAddress;\n\n    // Deprecated: now resides in Harvester's rewardTokenConfigs\n    // slither-disable-next-line constable-states\n    uint256 private _deprecated_rewardLiquidationThreshold;\n\n    /// @notice Address of the Harvester contract allowed to collect reward tokens\n    address public harvesterAddress;\n\n    /// @notice Address of the reward tokens. eg CRV, BAL, CVX, AURA\n    address[] public rewardTokenAddresses;\n\n    /* Reserved for future expansion. Used to be 100 storage slots\n     * and has decreased to accommodate:\n     * - harvesterAddress\n     * - rewardTokenAddresses\n     */\n    int256[98] private _reserved;\n\n    struct BaseStrategyConfig {\n        address platformAddress; // Address of the underlying platform\n        address vaultAddress; // Address of the OToken's Vault\n    }\n\n    /**\n     * @dev Verifies that the caller is the Governor or Strategist.\n     */\n    modifier onlyGovernorOrStrategist() {\n        require(\n            isGovernor() || msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    /**\n     * @param _config The platform and OToken vault addresses\n     */\n    constructor(BaseStrategyConfig memory _config) {\n        platformAddress = _config.platformAddress;\n        vaultAddress = _config.vaultAddress;\n    }\n\n    /**\n     * @dev Internal initialize function, to set up initial internal state\n     * @param _rewardTokenAddresses Address of reward token for platform\n     * @param _assets Addresses of initial supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function _initialize(\n        address[] memory _rewardTokenAddresses,\n        address[] memory _assets,\n        address[] memory _pTokens\n    ) internal {\n        rewardTokenAddresses = _rewardTokenAddresses;\n\n        uint256 assetCount = _assets.length;\n        require(assetCount == _pTokens.length, \"Invalid input arrays\");\n        for (uint256 i = 0; i < assetCount; ++i) {\n            _setPTokenAddress(_assets[i], _pTokens[i]);\n        }\n    }\n\n    /**\n     * @notice Collect accumulated reward token and send to Vault.\n     */\n    function collectRewardTokens() external virtual onlyHarvester nonReentrant {\n        _collectRewardTokens();\n    }\n\n    /**\n     * @dev Default implementation that transfers reward tokens to the Harvester\n     * Implementing strategies need to add custom logic to collect the rewards.\n     */\n    function _collectRewardTokens() internal virtual {\n        uint256 rewardTokenCount = rewardTokenAddresses.length;\n        for (uint256 i = 0; i < rewardTokenCount; ++i) {\n            IERC20 rewardToken = IERC20(rewardTokenAddresses[i]);\n            uint256 balance = rewardToken.balanceOf(address(this));\n            if (balance > 0) {\n                emit RewardTokenCollected(\n                    harvesterAddress,\n                    address(rewardToken),\n                    balance\n                );\n                rewardToken.safeTransfer(harvesterAddress, balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault.\n     */\n    modifier onlyVault() {\n        require(msg.sender == vaultAddress, \"Caller is not the Vault\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Harvester.\n     */\n    modifier onlyHarvester() {\n        require(msg.sender == harvesterAddress, \"Caller is not the Harvester\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault or Governor.\n     */\n    modifier onlyVaultOrGovernor() {\n        require(\n            msg.sender == vaultAddress || msg.sender == governor(),\n            \"Caller is not the Vault or Governor\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault, Governor, or Strategist.\n     */\n    modifier onlyVaultOrGovernorOrStrategist() {\n        require(\n            msg.sender == vaultAddress ||\n                msg.sender == governor() ||\n                msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Vault, Governor, or Strategist\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Set the reward token addresses. Any old addresses will be overwritten.\n     * @param _rewardTokenAddresses Array of reward token addresses\n     */\n    function setRewardTokenAddresses(address[] calldata _rewardTokenAddresses)\n        external\n        onlyGovernor\n    {\n        uint256 rewardTokenCount = _rewardTokenAddresses.length;\n        for (uint256 i = 0; i < rewardTokenCount; ++i) {\n            require(\n                _rewardTokenAddresses[i] != address(0),\n                \"Can not set an empty address as a reward token\"\n            );\n        }\n\n        emit RewardTokenAddressesUpdated(\n            rewardTokenAddresses,\n            _rewardTokenAddresses\n        );\n        rewardTokenAddresses = _rewardTokenAddresses;\n    }\n\n    /**\n     * @notice Get the reward token addresses.\n     * @return address[] the reward token addresses.\n     */\n    function getRewardTokenAddresses()\n        external\n        view\n        returns (address[] memory)\n    {\n        return rewardTokenAddresses;\n    }\n\n    /**\n     * @notice Provide support for asset by passing its pToken address.\n     *      This method can only be called by the system Governor\n     * @param _asset    Address for the asset\n     * @param _pToken   Address for the corresponding platform token\n     */\n    function setPTokenAddress(address _asset, address _pToken)\n        external\n        virtual\n        onlyGovernor\n    {\n        _setPTokenAddress(_asset, _pToken);\n    }\n\n    /**\n     * @notice Remove a supported asset by passing its index.\n     *      This method can only be called by the system Governor\n     * @param _assetIndex Index of the asset to be removed\n     */\n    function removePToken(uint256 _assetIndex) external virtual onlyGovernor {\n        require(_assetIndex < assetsMapped.length, \"Invalid index\");\n        address asset = assetsMapped[_assetIndex];\n        address pToken = assetToPToken[asset];\n\n        if (_assetIndex < assetsMapped.length - 1) {\n            assetsMapped[_assetIndex] = assetsMapped[assetsMapped.length - 1];\n        }\n        assetsMapped.pop();\n        assetToPToken[asset] = address(0);\n\n        emit PTokenRemoved(asset, pToken);\n    }\n\n    /**\n     * @notice Provide support for asset by passing its pToken address.\n     *      Add to internal mappings and execute the platform specific,\n     * abstract method `_abstractSetPToken`\n     * @param _asset    Address for the asset\n     * @param _pToken   Address for the corresponding platform token\n     */\n    function _setPTokenAddress(address _asset, address _pToken) internal {\n        require(assetToPToken[_asset] == address(0), \"pToken already set\");\n        require(\n            _asset != address(0) && _pToken != address(0),\n            \"Invalid addresses\"\n        );\n\n        assetToPToken[_asset] = _pToken;\n        assetsMapped.push(_asset);\n\n        emit PTokenAdded(_asset, _pToken);\n\n        _abstractSetPToken(_asset, _pToken);\n    }\n\n    /**\n     * @notice Transfer token to governor. Intended for recovering tokens stuck in\n     *      strategy contracts, i.e. mistaken sends.\n     * @param _asset Address for the asset\n     * @param _amount Amount of the asset to transfer\n     */\n    function transferToken(address _asset, uint256 _amount)\n        public\n        virtual\n        onlyGovernor\n    {\n        require(!supportsAsset(_asset), \"Cannot transfer supported asset\");\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /**\n     * @notice Set the Harvester contract that can collect rewards.\n     * @param _harvesterAddress Address of the harvester contract.\n     */\n    function setHarvesterAddress(address _harvesterAddress)\n        external\n        onlyGovernor\n    {\n        emit HarvesterAddressesUpdated(harvesterAddress, _harvesterAddress);\n        harvesterAddress = _harvesterAddress;\n    }\n\n    /***************************************\n                 Abstract\n    ****************************************/\n\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        virtual;\n\n    function safeApproveAllTokens() external virtual;\n\n    /**\n     * @notice Deposit an amount of assets into the platform\n     * @param _asset               Address for the asset\n     * @param _amount              Units of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount) external virtual;\n\n    /**\n     * @notice Deposit all supported assets in this strategy contract to the platform\n     */\n    function depositAll() external virtual;\n\n    /**\n     * @notice Withdraw an `amount` of assets from the platform and\n     * send to the `_recipient`.\n     * @param _recipient         Address to which the asset should be sent\n     * @param _asset             Address of the asset\n     * @param _amount            Units of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external virtual;\n\n    /**\n     * @notice Withdraw all supported assets from platform and\n     * sends to the OToken's Vault.\n     */\n    function withdrawAll() external virtual;\n\n    /**\n     * @notice Get the total asset value held in the platform.\n     *      This includes any interest that was generated since depositing.\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        virtual\n        returns (uint256 balance);\n\n    /**\n     * @notice Check if an asset is supported.\n     * @param _asset    Address of the asset\n     * @return bool     Whether asset is supported\n     */\n    function supportsAsset(address _asset) public view virtual returns (bool);\n}\n"
    },
    "contracts/utils/InitializableERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n * Converted from openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\n * @author Origin Protocol Inc\n */\nabstract contract InitializableERC20Detailed is IERC20 {\n    // Storage gap to skip storage from prior to OUSD reset\n    uint256[100] private _____gap;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     * @notice To avoid variable shadowing appended `Arg` after arguments name.\n     */\n    function _initialize(\n        string memory nameArg,\n        string memory symbolArg,\n        uint8 decimalsArg\n    ) internal {\n        _name = nameArg;\n        _symbol = symbolArg;\n        _decimals = decimalsArg;\n    }\n\n    /**\n     * @notice Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @notice Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @notice Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/utils/PRBMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n// Copied from the PRBMath library\n// https://github.com/PaulRBerg/prb-math/blob/main/src/Common.sol\n\n/// @notice Calculates the square root of x using the Babylonian method.\n///\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n///\n/// Notes:\n/// - If x is not a perfect square, the result is rounded down.\n/// - Credits to OpenZeppelin for the explanations in comments below.\n///\n/// @param x The uint256 number for which to calculate the square root.\n/// @return result The result as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction sqrt(uint256 x) pure returns (uint256 result) {\n    if (x == 0) {\n        return 0;\n    }\n\n    // For our first guess, we calculate the biggest power of 2 which is smaller than the square root of x.\n    //\n    // We know that the \"msb\" (most significant bit) of x is a power of 2 such that we have:\n    //\n    // $$\n    // msb(x) <= x <= 2*msb(x)$\n    // $$\n    //\n    // We write $msb(x)$ as $2^k$, and we get:\n    //\n    // $$\n    // k = log_2(x)\n    // $$\n    //\n    // Thus, we can write the initial inequality as:\n    //\n    // $$\n    // 2^{log_2(x)} <= x <= 2*2^{log_2(x)+1} \\\\\n    // sqrt(2^k) <= sqrt(x) < sqrt(2^{k+1}) \\\\\n    // 2^{k/2} <= sqrt(x) < 2^{(k+1)/2} <= 2^{(k/2)+1}\n    // $$\n    //\n    // Consequently, $2^{log_2(x) /2} is a good first approximation of sqrt(x) with at least one correct bit.\n    uint256 xAux = uint256(x);\n    result = 1;\n    if (xAux >= 2**128) {\n        xAux >>= 128;\n        result <<= 64;\n    }\n    if (xAux >= 2**64) {\n        xAux >>= 64;\n        result <<= 32;\n    }\n    if (xAux >= 2**32) {\n        xAux >>= 32;\n        result <<= 16;\n    }\n    if (xAux >= 2**16) {\n        xAux >>= 16;\n        result <<= 8;\n    }\n    if (xAux >= 2**8) {\n        xAux >>= 8;\n        result <<= 4;\n    }\n    if (xAux >= 2**4) {\n        xAux >>= 4;\n        result <<= 2;\n    }\n    if (xAux >= 2**2) {\n        result <<= 1;\n    }\n\n    // At this point, `result` is an estimation with at least one bit of precision. We know the true value has at\n    // most 128 bits, since it is the square root of a uint256. Newton's method converges quadratically (precision\n    // doubles at every iteration). We thus need at most 7 iteration to turn our partial result with one bit of\n    // precision into the expected uint128 result.\n    unchecked {\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n\n        // If x is not a perfect square, round the result toward zero.\n        uint256 roundedResult = x / result;\n        if (result >= roundedResult) {\n            result = roundedResult;\n        }\n    }\n}\n"
    },
    "contracts/utils/StableMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n// Based on StableMath from Stability Labs Pty. Ltd.\n// https://github.com/mstable/mStable-contracts/blob/master/contracts/shared/StableMath.sol\n\nlibrary StableMath {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Scaling unit for use in specific calculations,\n     * where 1 * 10**18, or 1e18 represents a unit '1'\n     */\n    uint256 private constant FULL_SCALE = 1e18;\n\n    /***************************************\n                    Helpers\n    ****************************************/\n\n    /**\n     * @dev Adjust the scale of an integer\n     * @param to Decimals to scale to\n     * @param from Decimals to scale from\n     */\n    function scaleBy(\n        uint256 x,\n        uint256 to,\n        uint256 from\n    ) internal pure returns (uint256) {\n        if (to > from) {\n            x = x.mul(10**(to - from));\n        } else if (to < from) {\n            // slither-disable-next-line divide-before-multiply\n            x = x.div(10**(from - to));\n        }\n        return x;\n    }\n\n    /***************************************\n               Precise Arithmetic\n    ****************************************/\n\n    /**\n     * @dev Multiplies two precise units, and then truncates by the full scale\n     * @param x Left hand input to multiplication\n     * @param y Right hand input to multiplication\n     * @return Result after multiplying the two inputs and then dividing by the shared\n     *         scale unit\n     */\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulTruncateScale(x, y, FULL_SCALE);\n    }\n\n    /**\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\n     * @param x Left hand input to multiplication\n     * @param y Right hand input to multiplication\n     * @param scale Scale unit\n     * @return Result after multiplying the two inputs and then dividing by the shared\n     *         scale unit\n     */\n    function mulTruncateScale(\n        uint256 x,\n        uint256 y,\n        uint256 scale\n    ) internal pure returns (uint256) {\n        // e.g. assume scale = fullScale\n        // z = 10e18 * 9e17 = 9e36\n        uint256 z = x.mul(y);\n        // return 9e36 / 1e18 = 9e18\n        return z.div(scale);\n    }\n\n    /**\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\n     * @param x Left hand input to multiplication\n     * @param y Right hand input to multiplication\n     * @return Result after multiplying the two inputs and then dividing by the shared\n     *          scale unit, rounded up to the closest base unit.\n     */\n    function mulTruncateCeil(uint256 x, uint256 y)\n        internal\n        pure\n        returns (uint256)\n    {\n        // e.g. 8e17 * 17268172638 = 138145381104e17\n        uint256 scaled = x.mul(y);\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\n        uint256 ceil = scaled.add(FULL_SCALE.sub(1));\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\n        return ceil.div(FULL_SCALE);\n    }\n\n    /**\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\n     * @param x Left hand input to division\n     * @param y Right hand input to division\n     * @return Result after multiplying the left operand by the scale, and\n     *         executing the division on the right hand input.\n     */\n    function divPrecisely(uint256 x, uint256 y)\n        internal\n        pure\n        returns (uint256)\n    {\n        // e.g. 8e18 * 1e18 = 8e36\n        uint256 z = x.mul(FULL_SCALE);\n        // e.g. 8e36 / 10e18 = 8e17\n        return z.div(y);\n    }\n}\n"
    },
    "contracts/vault/OETHBaseVaultAdmin.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { OETHVaultAdmin } from \"./OETHVaultAdmin.sol\";\n\n/**\n * @title OETH Base VaultAdmin Contract\n * @author Origin Protocol Inc\n */\ncontract OETHBaseVaultAdmin is OETHVaultAdmin {\n    constructor(address _weth) OETHVaultAdmin(_weth) {}\n}\n"
    },
    "contracts/vault/OETHBaseVaultCore.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { OETHVaultCore } from \"./OETHVaultCore.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\n\n/**\n * @title OETH Base VaultCore Contract\n * @author Origin Protocol Inc\n */\ncontract OETHBaseVaultCore is OETHVaultCore {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    constructor(address _weth) OETHVaultCore(_weth) {}\n\n    // @inheritdoc OETHVaultCore\n    function _redeem(uint256 _amount, uint256 _minimumUnitAmount)\n        internal\n        virtual\n        override\n    {\n        // Only Strategist or Governor can redeem using the Vault for now.\n        // We don't have the onlyGovernorOrStrategist modifier on VaultCore.\n        // Since we won't be using that modifier anywhere in the VaultCore as well,\n        // the check has been added inline instead of moving it to VaultStorage.\n        require(\n            msg.sender == strategistAddr || isGovernor(),\n            \"Caller is not the Strategist or Governor\"\n        );\n\n        super._redeem(_amount, _minimumUnitAmount);\n    }\n}\n"
    },
    "contracts/vault/OETHBaseZapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { IERC4626 } from \"../../lib/openzeppelin/interfaces/IERC4626.sol\";\n\ncontract OETHBaseZapper {\n    IERC20 public immutable oethb;\n    IERC4626 public immutable woethb;\n    IVault public immutable vault;\n\n    IWETH9 public constant weth =\n        IWETH9(0x4200000000000000000000000000000000000006);\n    address private constant ETH_MARKER =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    event Zap(address indexed minter, address indexed asset, uint256 amount);\n\n    constructor(\n        address _oethb,\n        address _woethb,\n        address _vault\n    ) {\n        oethb = IERC20(_oethb);\n        woethb = IERC4626(_woethb);\n        vault = IVault(_vault);\n\n        weth.approve(address(_vault), type(uint256).max);\n        IERC20(_oethb).approve(_woethb, type(uint256).max);\n    }\n\n    /**\n     * @dev Deposit ETH and receive OETH in return.\n     * Will verify that the user is sent 1:1 for ETH.\n     */\n    receive() external payable {\n        deposit();\n    }\n\n    /**\n     * @dev Deposit ETH and receive superOETHb in return\n     * Will verify that the user is sent 1:1 for ETH.\n     * @return Amount of OETH sent to user\n     */\n    function deposit() public payable returns (uint256) {\n        uint256 balance = address(this).balance;\n\n        emit Zap(msg.sender, ETH_MARKER, balance);\n\n        // Wrap ETH\n        weth.deposit{ value: balance }();\n\n        // Mint with WETH\n        return _mint(balance, msg.sender);\n    }\n\n    /**\n     * @dev Deposit ETH and receive superOETHb in return\n     * @param minReceived min amount of wsuperOETHb to receive\n     * @return Amount of wsuperOETHb sent to user\n     */\n    function depositETHForWrappedTokens(uint256 minReceived)\n        external\n        payable\n        returns (uint256)\n    {\n        uint256 balance = address(this).balance;\n\n        emit Zap(msg.sender, ETH_MARKER, balance);\n\n        // Wrap ETH\n        weth.deposit{ value: balance }();\n\n        // Mint with WETH\n        uint256 mintedOethb = _mint(balance, address(this));\n\n        // Wrap superOETHb into wsuperOETHb\n        uint256 mintedWoethb = woethb.deposit(mintedOethb, msg.sender);\n\n        require(mintedWoethb >= minReceived, \"Zapper: not enough minted\");\n\n        return mintedWoethb;\n    }\n\n    /**\n     * @dev Deposit WETH and receive superOETHb in return\n     * @param wethAmount Amount of WETH to deposit\n     * @param minReceived min amount of wsuperOETHb to receive\n     * @return Amount of wsuperOETHb sent to user\n     */\n    function depositWETHForWrappedTokens(\n        uint256 wethAmount,\n        uint256 minReceived\n    ) external returns (uint256) {\n        // slither-disable-next-line unchecked-transfer unused-return\n        weth.transferFrom(msg.sender, address(this), wethAmount);\n\n        emit Zap(msg.sender, address(weth), wethAmount);\n\n        // Mint with WETH\n        uint256 mintedOethb = _mint(wethAmount, address(this));\n\n        // Wrap superOETHb into wsuperOETHb\n        uint256 mintedWoethb = woethb.deposit(mintedOethb, msg.sender);\n\n        require(mintedWoethb >= minReceived, \"Zapper: not enough minted\");\n\n        return mintedWoethb;\n    }\n\n    /**\n     * @dev Internal function to mint superOETHb with WETH\n     * @param minOETH Minimum amount of OETH to for user to receive\n     * @param recipient Address that receives the tokens\n     * @return Amount of OETH sent to user\n     */\n    function _mint(uint256 minOETH, address recipient)\n        internal\n        returns (uint256)\n    {\n        uint256 toMint = weth.balanceOf(address(this));\n        vault.mint(address(weth), toMint, minOETH);\n        uint256 mintedAmount = oethb.balanceOf(address(this));\n        require(mintedAmount >= minOETH, \"Zapper: not enough minted\");\n\n        if (recipient != address(this)) {\n            require(oethb.transfer(recipient, mintedAmount));\n        }\n\n        return mintedAmount;\n    }\n}\n"
    },
    "contracts/vault/OETHVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Vault } from \"./Vault.sol\";\n\n/**\n * @title OETH Vault Contract\n * @author Origin Protocol Inc\n */\ncontract OETHVault is Vault {\n\n}\n"
    },
    "contracts/vault/OETHVaultAdmin.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { VaultAdmin } from \"./VaultAdmin.sol\";\n\n/**\n * @title OETH VaultAdmin Contract\n * @author Origin Protocol Inc\n */\ncontract OETHVaultAdmin is VaultAdmin {\n    using SafeERC20 for IERC20;\n\n    address public immutable weth;\n\n    constructor(address _weth) {\n        weth = _weth;\n    }\n\n    /**\n     * @notice Adds a strategy to the mint whitelist.\n     *          Reverts if strategy isn't approved on Vault.\n     * @param strategyAddr Strategy address\n     */\n    function addStrategyToMintWhitelist(address strategyAddr)\n        external\n        onlyGovernor\n    {\n        require(strategies[strategyAddr].isSupported, \"Strategy not approved\");\n\n        require(\n            !isMintWhitelistedStrategy[strategyAddr],\n            \"Already whitelisted\"\n        );\n\n        isMintWhitelistedStrategy[strategyAddr] = true;\n\n        emit StrategyAddedToMintWhitelist(strategyAddr);\n    }\n\n    /**\n     * @notice Removes a strategy from the mint whitelist.\n     * @param strategyAddr Strategy address\n     */\n    function removeStrategyFromMintWhitelist(address strategyAddr)\n        external\n        onlyGovernor\n    {\n        // Intentionally skipping `strategies.isSupported` check since\n        // we may wanna remove an address even after removing the strategy\n\n        require(isMintWhitelistedStrategy[strategyAddr], \"Not whitelisted\");\n\n        isMintWhitelistedStrategy[strategyAddr] = false;\n\n        emit StrategyRemovedFromMintWhitelist(strategyAddr);\n    }\n\n    /// @dev Simplified version of the deposit function as WETH is the only supported asset.\n    function _depositToStrategy(\n        address _strategyToAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) internal override {\n        require(\n            strategies[_strategyToAddress].isSupported,\n            \"Invalid to Strategy\"\n        );\n        require(\n            _assets.length == 1 && _amounts.length == 1 && _assets[0] == weth,\n            \"Only WETH is supported\"\n        );\n\n        // Check the there is enough WETH to transfer once the WETH reserved for the withdrawal queue is accounted for\n        require(_amounts[0] <= _wethAvailable(), \"Not enough WETH available\");\n\n        // Send required amount of funds to the strategy\n        IERC20(weth).safeTransfer(_strategyToAddress, _amounts[0]);\n\n        // Deposit all the funds that have been sent to the strategy\n        IStrategy(_strategyToAddress).depositAll();\n    }\n\n    function _withdrawFromStrategy(\n        address _recipient,\n        address _strategyFromAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) internal override {\n        super._withdrawFromStrategy(\n            _recipient,\n            _strategyFromAddress,\n            _assets,\n            _amounts\n        );\n\n        IVault(address(this)).addWithdrawalQueueLiquidity();\n    }\n\n    function _withdrawAllFromStrategy(address _strategyAddr) internal override {\n        super._withdrawAllFromStrategy(_strategyAddr);\n\n        IVault(address(this)).addWithdrawalQueueLiquidity();\n    }\n\n    function _withdrawAllFromStrategies() internal override {\n        super._withdrawAllFromStrategies();\n\n        IVault(address(this)).addWithdrawalQueueLiquidity();\n    }\n\n    /// @dev Calculate how much WETH in the vault is not reserved for the withdrawal queue.\n    // That is, it is available to be redeemed or deposited into a strategy.\n    function _wethAvailable() internal view returns (uint256 wethAvailable) {\n        WithdrawalQueueMetadata memory queue = withdrawalQueueMetadata;\n\n        // The amount of WETH that is still to be claimed in the withdrawal queue\n        uint256 outstandingWithdrawals = queue.queued - queue.claimed;\n\n        // The amount of sitting in WETH in the vault\n        uint256 wethBalance = IERC20(weth).balanceOf(address(this));\n\n        // If there is not enough WETH in the vault to cover the outstanding withdrawals\n        if (wethBalance <= outstandingWithdrawals) {\n            return 0;\n        }\n\n        return wethBalance - outstandingWithdrawals;\n    }\n\n    function _swapCollateral(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) internal pure override returns (uint256) {\n        revert(\"Collateral swap not supported\");\n    }\n}\n"
    },
    "contracts/vault/OETHVaultCore.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { VaultCore } from \"./VaultCore.sol\";\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\n\n/**\n * @title OETH VaultCore Contract\n * @author Origin Protocol Inc\n */\ncontract OETHVaultCore is VaultCore {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    address public immutable weth;\n    uint256 public wethAssetIndex;\n\n    // For future use (because OETHBaseVaultCore inherits from this)\n    uint256[50] private __gap;\n\n    constructor(address _weth) {\n        weth = _weth;\n    }\n\n    /**\n     * @dev Caches WETH's index in `allAssets` variable.\n     *      Reduces gas usage by redeem by caching that.\n     */\n    function cacheWETHAssetIndex() external onlyGovernor {\n        uint256 assetCount = allAssets.length;\n        for (uint256 i; i < assetCount; ++i) {\n            if (allAssets[i] == weth) {\n                wethAssetIndex = i;\n                break;\n            }\n        }\n\n        require(allAssets[wethAssetIndex] == weth, \"Invalid WETH Asset Index\");\n    }\n\n    // @inheritdoc VaultCore\n    function mintForStrategy(uint256 amount)\n        external\n        override\n        whenNotCapitalPaused\n    {\n        require(\n            strategies[msg.sender].isSupported == true,\n            \"Unsupported strategy\"\n        );\n        require(\n            isMintWhitelistedStrategy[msg.sender] == true,\n            \"Not whitelisted strategy\"\n        );\n\n        emit Mint(msg.sender, amount);\n\n        // Mint matching amount of OTokens\n        oUSD.mint(msg.sender, amount);\n    }\n\n    // @inheritdoc VaultCore\n    function burnForStrategy(uint256 amount)\n        external\n        override\n        whenNotCapitalPaused\n    {\n        require(\n            strategies[msg.sender].isSupported == true,\n            \"Unsupported strategy\"\n        );\n        require(\n            isMintWhitelistedStrategy[msg.sender] == true,\n            \"Not whitelisted strategy\"\n        );\n\n        emit Redeem(msg.sender, amount);\n\n        // Burn OTokens\n        oUSD.burn(msg.sender, amount);\n    }\n\n    // @inheritdoc VaultCore\n    // slither-disable-start reentrancy-no-eth\n    function _mint(\n        address _asset,\n        uint256 _amount,\n        uint256 _minimumOusdAmount\n    ) internal virtual override {\n        require(_asset == weth, \"Unsupported asset for minting\");\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(\n            _amount >= _minimumOusdAmount,\n            \"Mint amount lower than minimum\"\n        );\n\n        emit Mint(msg.sender, _amount);\n\n        // Rebase must happen before any transfers occur.\n        if (!rebasePaused && _amount >= rebaseThreshold) {\n            _rebase();\n        }\n\n        // Mint oTokens\n        oUSD.mint(msg.sender, _amount);\n\n        // Transfer the deposited coins to the vault\n        IERC20(_asset).safeTransferFrom(msg.sender, address(this), _amount);\n\n        // Give priority to the withdrawal queue for the new WETH liquidity\n        _addWithdrawalQueueLiquidity();\n\n        // Auto-allocate if necessary\n        if (_amount >= autoAllocateThreshold) {\n            _allocate();\n        }\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    // @inheritdoc VaultCore\n    function _calculateRedeemOutputs(uint256 _amount)\n        internal\n        view\n        virtual\n        override\n        returns (uint256[] memory outputs)\n    {\n        // Overrides `VaultCore._calculateRedeemOutputs` to redeem with only\n        // WETH instead of LST-mix. Doesn't change the function signature\n        // for backward compatibility\n\n        // Calculate redeem fee\n        if (redeemFeeBps > 0) {\n            uint256 redeemFee = _amount.mulTruncateScale(redeemFeeBps, 1e4);\n            _amount = _amount - redeemFee;\n        }\n\n        // Ensure that the WETH index is cached\n        uint256 _wethAssetIndex = wethAssetIndex;\n        require(\n            allAssets[_wethAssetIndex] == weth,\n            \"WETH Asset index not cached\"\n        );\n\n        outputs = new uint256[](allAssets.length);\n        outputs[_wethAssetIndex] = _amount;\n    }\n\n    // @inheritdoc VaultCore\n    function _redeem(uint256 _amount, uint256 _minimumUnitAmount)\n        internal\n        virtual\n        override\n    {\n        // Override `VaultCore._redeem` to simplify it. Gets rid of oracle\n        // usage and looping through all assets for LST-mix redeem. Instead\n        // does a simple WETH-only redeem.\n        emit Redeem(msg.sender, _amount);\n\n        if (_amount == 0) {\n            return;\n        }\n\n        // Amount excluding fees\n        // No fee for the strategist or the governor, makes it easier to do operations\n        uint256 amountMinusFee = (msg.sender == strategistAddr || isGovernor())\n            ? _amount\n            : _calculateRedeemOutputs(_amount)[wethAssetIndex];\n\n        require(\n            amountMinusFee >= _minimumUnitAmount,\n            \"Redeem amount lower than minimum\"\n        );\n\n        // Is there enough WETH in the Vault available after accounting for the withdrawal queue\n        require(_wethAvailable() >= amountMinusFee, \"Liquidity error\");\n\n        // Transfer WETH minus the fee to the redeemer\n        IERC20(weth).safeTransfer(msg.sender, amountMinusFee);\n\n        // Burn OETH from user (including fees)\n        oUSD.burn(msg.sender, _amount);\n\n        // Prevent insolvency\n        _postRedeem(_amount);\n    }\n\n    /**\n     * @notice Request an asynchronous withdrawal of WETH in exchange for OETH.\n     * The OETH is burned on request and the WETH is transferred to the withdrawer on claim.\n     * This request can be claimed once the withdrawal queue's `claimable` amount\n     * is greater than or equal this request's `queued` amount.\n     * There is a minimum of 10 minutes before a request can be claimed. After that, the request just needs\n     * enough WETH liquidity in the Vault to satisfy all the outstanding requests to that point in the queue.\n     * OETH is converted to WETH at 1:1.\n     * @param _amount Amount of OETH to burn.\n     * @return requestId Unique ID for the withdrawal request\n     * @return queued Cumulative total of all WETH queued including already claimed requests.\n     */\n    function requestWithdrawal(uint256 _amount)\n        external\n        virtual\n        whenNotCapitalPaused\n        nonReentrant\n        returns (uint256 requestId, uint256 queued)\n    {\n        require(withdrawalClaimDelay > 0, \"Async withdrawals not enabled\");\n\n        // The check that the requester has enough OETH is done in to later burn call\n\n        requestId = withdrawalQueueMetadata.nextWithdrawalIndex;\n        queued = withdrawalQueueMetadata.queued + _amount;\n\n        // Store the next withdrawal request\n        withdrawalQueueMetadata.nextWithdrawalIndex = SafeCast.toUint128(\n            requestId + 1\n        );\n        // Store the updated queued amount which reserves WETH in the withdrawal queue\n        // and reduces the vault's total assets\n        withdrawalQueueMetadata.queued = SafeCast.toUint128(queued);\n        // Store the user's withdrawal request\n        withdrawalRequests[requestId] = WithdrawalRequest({\n            withdrawer: msg.sender,\n            claimed: false,\n            timestamp: uint40(block.timestamp),\n            amount: SafeCast.toUint128(_amount),\n            queued: SafeCast.toUint128(queued)\n        });\n\n        // Burn the user's OETH\n        oUSD.burn(msg.sender, _amount);\n\n        // Prevent withdrawal if the vault is solvent by more than the allowed percentage\n        _postRedeem(_amount);\n\n        emit WithdrawalRequested(msg.sender, requestId, _amount, queued);\n    }\n\n    // slither-disable-start reentrancy-no-eth\n    /**\n     * @notice Claim a previously requested withdrawal once it is claimable.\n     * This request can be claimed once the withdrawal queue's `claimable` amount\n     * is greater than or equal this request's `queued` amount and 10 minutes has passed.\n     * If the requests is not claimable, the transaction will revert with `Queue pending liquidity`.\n     * If the request is not older than 10 minutes, the transaction will revert with `Claim delay not met`.\n     * OETH is converted to WETH at 1:1.\n     * @param _requestId Unique ID for the withdrawal request\n     * @return amount Amount of WETH transferred to the withdrawer\n     */\n    function claimWithdrawal(uint256 _requestId)\n        external\n        virtual\n        whenNotCapitalPaused\n        nonReentrant\n        returns (uint256 amount)\n    {\n        // Try and get more liquidity if there is not enough available\n        if (\n            withdrawalRequests[_requestId].queued >\n            withdrawalQueueMetadata.claimable\n        ) {\n            // Add any WETH to the withdrawal queue\n            // this needs to remain here as:\n            //  - Vault can be funded and `addWithdrawalQueueLiquidity` is not externally called\n            //  - funds can be withdrawn from a strategy\n            //\n            // Those funds need to be added to withdrawal queue liquidity\n            _addWithdrawalQueueLiquidity();\n        }\n\n        amount = _claimWithdrawal(_requestId);\n\n        // transfer WETH from the vault to the withdrawer\n        IERC20(weth).safeTransfer(msg.sender, amount);\n\n        // Prevent insolvency\n        _postRedeem(amount);\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /**\n     * @notice Claim a previously requested withdrawals once they are claimable.\n     * This requests can be claimed once the withdrawal queue's `claimable` amount\n     * is greater than or equal each request's `queued` amount and 10 minutes has passed.\n     * If one of the requests is not claimable, the whole transaction will revert with `Queue pending liquidity`.\n     * If one of the requests is not older than 10 minutes,\n     * the whole transaction will revert with `Claim delay not met`.\n     * @param _requestIds Unique ID of each withdrawal request\n     * @return amounts Amount of WETH received for each request\n     * @return totalAmount Total amount of WETH transferred to the withdrawer\n     */\n    function claimWithdrawals(uint256[] calldata _requestIds)\n        external\n        virtual\n        whenNotCapitalPaused\n        nonReentrant\n        returns (uint256[] memory amounts, uint256 totalAmount)\n    {\n        // Add any WETH to the withdrawal queue\n        // this needs to remain here as:\n        //  - Vault can be funded and `addWithdrawalQueueLiquidity` is not externally called\n        //  - funds can be withdrawn from a strategy\n        //\n        // Those funds need to be added to withdrawal queue liquidity\n        _addWithdrawalQueueLiquidity();\n\n        amounts = new uint256[](_requestIds.length);\n        for (uint256 i; i < _requestIds.length; ++i) {\n            amounts[i] = _claimWithdrawal(_requestIds[i]);\n            totalAmount += amounts[i];\n        }\n\n        // transfer all the claimed WETH from the vault to the withdrawer\n        IERC20(weth).safeTransfer(msg.sender, totalAmount);\n\n        // Prevent insolvency\n        _postRedeem(totalAmount);\n    }\n\n    function _claimWithdrawal(uint256 requestId)\n        internal\n        returns (uint256 amount)\n    {\n        require(withdrawalClaimDelay > 0, \"Async withdrawals not enabled\");\n\n        // Load the structs from storage into memory\n        WithdrawalRequest memory request = withdrawalRequests[requestId];\n        WithdrawalQueueMetadata memory queue = withdrawalQueueMetadata;\n\n        require(\n            request.timestamp + withdrawalClaimDelay <= block.timestamp,\n            \"Claim delay not met\"\n        );\n        // If there isn't enough reserved liquidity in the queue to claim\n        require(request.queued <= queue.claimable, \"Queue pending liquidity\");\n        require(request.withdrawer == msg.sender, \"Not requester\");\n        require(request.claimed == false, \"Already claimed\");\n\n        // Store the request as claimed\n        withdrawalRequests[requestId].claimed = true;\n        // Store the updated claimed amount\n        withdrawalQueueMetadata.claimed = queue.claimed + request.amount;\n\n        emit WithdrawalClaimed(msg.sender, requestId, request.amount);\n\n        return request.amount;\n    }\n\n    /// @notice Adds WETH to the withdrawal queue if there is a funding shortfall.\n    /// @dev is called from the Native Staking strategy when validator withdrawals are processed.\n    /// It also called before any WETH is allocated to a strategy.\n    function addWithdrawalQueueLiquidity() external {\n        _addWithdrawalQueueLiquidity();\n    }\n\n    /// @dev Adds WETH to the withdrawal queue if there is a funding shortfall.\n    /// This assumes 1 WETH equal 1 OETH.\n    function _addWithdrawalQueueLiquidity()\n        internal\n        returns (uint256 addedClaimable)\n    {\n        WithdrawalQueueMetadata memory queue = withdrawalQueueMetadata;\n\n        // Check if the claimable WETH is less than the queued amount\n        uint256 queueShortfall = queue.queued - queue.claimable;\n\n        // No need to do anything is the withdrawal queue is full funded\n        if (queueShortfall == 0) {\n            return 0;\n        }\n\n        uint256 wethBalance = IERC20(weth).balanceOf(address(this));\n\n        // Of the claimable withdrawal requests, how much is unclaimed?\n        // That is, the amount of WETH that is currently allocated for the withdrawal queue\n        uint256 allocatedWeth = queue.claimable - queue.claimed;\n\n        // If there is no unallocated WETH then there is nothing to add to the queue\n        if (wethBalance <= allocatedWeth) {\n            return 0;\n        }\n\n        uint256 unallocatedWeth = wethBalance - allocatedWeth;\n\n        // the new claimable amount is the smaller of the queue shortfall or unallocated weth\n        addedClaimable = queueShortfall < unallocatedWeth\n            ? queueShortfall\n            : unallocatedWeth;\n        uint256 newClaimable = queue.claimable + addedClaimable;\n\n        // Store the new claimable amount back to storage\n        withdrawalQueueMetadata.claimable = SafeCast.toUint128(newClaimable);\n\n        // emit a WithdrawalClaimable event\n        emit WithdrawalClaimable(newClaimable, addedClaimable);\n    }\n\n    /***************************************\n                View Functions\n    ****************************************/\n\n    /// @dev Calculate how much WETH in the vault is not reserved for the withdrawal queue.\n    // That is, it is available to be redeemed or deposited into a strategy.\n    function _wethAvailable() internal view returns (uint256 wethAvailable) {\n        WithdrawalQueueMetadata memory queue = withdrawalQueueMetadata;\n\n        // The amount of WETH that is still to be claimed in the withdrawal queue\n        uint256 outstandingWithdrawals = queue.queued - queue.claimed;\n\n        // The amount of sitting in WETH in the vault\n        uint256 wethBalance = IERC20(weth).balanceOf(address(this));\n\n        // If there is not enough WETH in the vault to cover the outstanding withdrawals\n        if (wethBalance <= outstandingWithdrawals) {\n            return 0;\n        }\n\n        return wethBalance - outstandingWithdrawals;\n    }\n\n    /// @dev Get the balance of an asset held in Vault and all strategies\n    /// less any WETH that is reserved for the withdrawal queue.\n    /// WETH is the only asset that can return a non-zero balance.\n    /// All other assets will return 0 even if there is some dust amounts left in the Vault.\n    /// For example, there is 1 wei left of stETH in the OETH Vault but will return 0 in this function.\n    ///\n    /// If there is not enough WETH in the vault and all strategies to cover all outstanding\n    /// withdrawal requests then return a WETH balance of 0\n    function _checkBalance(address _asset)\n        internal\n        view\n        override\n        returns (uint256 balance)\n    {\n        if (_asset != weth) {\n            return 0;\n        }\n\n        // Get the WETH in the vault and the strategies\n        balance = super._checkBalance(_asset);\n\n        WithdrawalQueueMetadata memory queue = withdrawalQueueMetadata;\n\n        // If the vault becomes insolvent enough that the total value in the vault and all strategies\n        // is less than the outstanding withdrawals.\n        // For example, there was a mass slashing event and most users request a withdrawal.\n        if (balance + queue.claimed < queue.queued) {\n            return 0;\n        }\n\n        // Need to remove WETH that is reserved for the withdrawal queue\n        return balance + queue.claimed - queue.queued;\n    }\n\n    /**\n     * @notice Allocate unallocated funds on Vault to strategies.\n     **/\n    function allocate() external override whenNotCapitalPaused nonReentrant {\n        // Add any unallocated WETH to the withdrawal queue first\n        _addWithdrawalQueueLiquidity();\n\n        _allocate();\n    }\n\n    /// @dev Allocate WETH to the default WETH strategy if there is excess to the Vault buffer.\n    /// This is called from either `mint` or `allocate` and assumes `_addWithdrawalQueueLiquidity`\n    /// has been called before this function.\n    function _allocate() internal override {\n        // No need to do anything if no default strategy for WETH\n        address depositStrategyAddr = assetDefaultStrategies[weth];\n        if (depositStrategyAddr == address(0)) return;\n\n        uint256 wethAvailableInVault = _wethAvailable();\n        // No need to do anything if there isn't any WETH in the vault to allocate\n        if (wethAvailableInVault == 0) return;\n\n        // Calculate the target buffer for the vault using the total supply\n        uint256 totalSupply = oUSD.totalSupply();\n        uint256 targetBuffer = totalSupply.mulTruncate(vaultBuffer);\n\n        // If available WETH in the Vault is below or equal the target buffer then there's nothing to allocate\n        if (wethAvailableInVault <= targetBuffer) return;\n\n        // The amount of assets to allocate to the default strategy\n        uint256 allocateAmount = wethAvailableInVault - targetBuffer;\n\n        IStrategy strategy = IStrategy(depositStrategyAddr);\n        // Transfer WETH to the strategy and call the strategy's deposit function\n        IERC20(weth).safeTransfer(address(strategy), allocateAmount);\n        strategy.deposit(weth, allocateAmount);\n\n        emit AssetAllocated(weth, depositStrategyAddr, allocateAmount);\n    }\n\n    /// @dev The total value of all WETH held by the vault and all its strategies\n    /// less any WETH that is reserved for the withdrawal queue.\n    ///\n    // If there is not enough WETH in the vault and all strategies to cover all outstanding\n    // withdrawal requests then return a total value of 0.\n    function _totalValue() internal view override returns (uint256 value) {\n        // As WETH is the only asset, just return the WETH balance\n        return _checkBalance(weth);\n    }\n\n    /// @dev Only WETH is supported in the OETH Vault so return the WETH balance only\n    /// Any ETH balances in the Vault will be ignored.\n    /// Amounts from previously supported vault assets will also be ignored.\n    /// For example, there is 1 wei left of stETH in the OETH Vault but is will be ignored.\n    function _totalValueInVault()\n        internal\n        view\n        override\n        returns (uint256 value)\n    {\n        value = IERC20(weth).balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/vault/OETHZapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { ISfrxETH } from \"../interfaces/ISfrxETH.sol\";\n\ncontract OETHZapper {\n    IERC20 public immutable oeth;\n    IVault public immutable vault;\n\n    IWETH9 public constant weth =\n        IWETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20 public constant frxeth =\n        IERC20(0x5E8422345238F34275888049021821E8E08CAa1f);\n    ISfrxETH public constant sfrxeth =\n        ISfrxETH(0xac3E018457B222d93114458476f3E3416Abbe38F);\n    address private constant ETH_MARKER =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    event Zap(address indexed minter, address indexed asset, uint256 amount);\n\n    constructor(address _oeth, address _vault) {\n        oeth = IERC20(_oeth);\n        vault = IVault(_vault);\n\n        weth.approve(address(_vault), type(uint256).max);\n        frxeth.approve(address(_vault), type(uint256).max);\n    }\n\n    /**\n     * @dev Deposit ETH and receive OETH in return.\n     * Will verify that the user is sent 1:1 for ETH.\n     */\n    receive() external payable {\n        deposit();\n    }\n\n    /**\n     * @dev Deposit ETH and receive OETH in return\n     * Will verify that the user is sent 1:1 for ETH.\n     * @return Amount of OETH sent to user\n     */\n    function deposit() public payable returns (uint256) {\n        uint256 balance = address(this).balance;\n        weth.deposit{ value: balance }();\n        emit Zap(msg.sender, ETH_MARKER, balance);\n        return _mint(address(weth), balance);\n    }\n\n    /**\n     * @dev Deposit SFRXETH to the vault and receive OETH in return\n     * @param amount Amount of SFRXETH to deposit\n     * @param minOETH Minimum amount of OETH to receive\n     * @return Amount of OETH sent to user\n     */\n    function depositSFRXETH(uint256 amount, uint256 minOETH)\n        external\n        returns (uint256)\n    {\n        sfrxeth.redeem(amount, address(this), msg.sender);\n        emit Zap(msg.sender, address(sfrxeth), amount);\n        return _mint(address(frxeth), minOETH);\n    }\n\n    /**\n     * @dev Internal function to mint OETH from an asset\n     * @param asset Address of asset for the vault to mint from\n     * @param minOETH Minimum amount of OETH to for user to receive\n     * @return Amount of OETH sent to user\n     */\n    function _mint(address asset, uint256 minOETH) internal returns (uint256) {\n        uint256 toMint = IERC20(asset).balanceOf(address(this));\n        vault.mint(asset, toMint, minOETH);\n        uint256 mintedAmount = oeth.balanceOf(address(this));\n        require(mintedAmount >= minOETH, \"Zapper: not enough minted\");\n        require(oeth.transfer(msg.sender, mintedAmount));\n        return mintedAmount;\n    }\n}\n"
    },
    "contracts/vault/OSonicVaultAdmin.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { OETHVaultAdmin } from \"./OETHVaultAdmin.sol\";\n\n/**\n * @title Origin Sonic VaultAdmin contract on Sonic\n * @author Origin Protocol Inc\n */\ncontract OSonicVaultAdmin is OETHVaultAdmin {\n    /// @param _wS Sonic's Wrapped S token\n    constructor(address _wS) OETHVaultAdmin(_wS) {}\n\n    /***************************************\n                Asset Config\n    ****************************************/\n\n    /**\n     * @notice Add a supported asset to the contract, i.e. one that can be to mint OTokens.\n     * @dev Overridden to remove price provider integration\n     * @param _asset Address of asset\n     * @param _unitConversion 0 decimals, 1 exchange rate\n     */\n    function supportAsset(address _asset, uint8 _unitConversion)\n        external\n        override\n        onlyGovernor\n    {\n        require(!assets[_asset].isSupported, \"Asset already supported\");\n\n        assets[_asset] = Asset({\n            isSupported: true,\n            unitConversion: UnitConversion(_unitConversion),\n            decimals: 0, // will be overridden in _cacheDecimals\n            allowedOracleSlippageBps: 0 // 0% by default\n        });\n\n        _cacheDecimals(_asset);\n        allAssets.push(_asset);\n\n        emit AssetSupported(_asset);\n    }\n}\n"
    },
    "contracts/vault/OSonicVaultCore.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { OETHVaultCore } from \"./OETHVaultCore.sol\";\n\n/**\n * @title Origin Sonic VaultCore contract on Sonic\n * @author Origin Protocol Inc\n */\ncontract OSonicVaultCore is OETHVaultCore {\n    /// @param _wS Sonic's Wrapped S token\n    constructor(address _wS) OETHVaultCore(_wS) {}\n\n    /**\n     * @notice Instant redeem is not supported on Sonic.\n     * Use the asynchronous `requestWithdrawal` a `claimWithdrawal` instead.\n     */\n    function _redeem(uint256, uint256) internal override {\n        revert(\"unsupported function\");\n    }\n}\n"
    },
    "contracts/vault/OSonicZapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IWrappedSonic } from \"../interfaces/sonic/IWrappedSonic.sol\";\nimport { IERC4626 } from \"../../lib/openzeppelin/interfaces/IERC4626.sol\";\n\n/**\n * @title Zapper for Origin Sonic (OS) tokens\n * @author Origin Protocol Inc\n */\ncontract OSonicZapper {\n    IERC20 public immutable OS;\n    IERC4626 public immutable wOS;\n    IVault public immutable vault;\n\n    IWrappedSonic public constant wS =\n        IWrappedSonic(0x039e2fB66102314Ce7b64Ce5Ce3E5183bc94aD38);\n    address private constant ETH_MARKER =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    event Zap(address indexed minter, address indexed asset, uint256 amount);\n\n    constructor(\n        address _OS,\n        address _wOS,\n        address _vault\n    ) {\n        OS = IERC20(_OS);\n        wOS = IERC4626(_wOS);\n        vault = IVault(_vault);\n\n        wS.approve(address(_vault), type(uint256).max);\n        IERC20(_OS).approve(_wOS, type(uint256).max);\n    }\n\n    /**\n     * @dev Deposit native S currency and receive Origin Sonic (OS) tokens in return.\n     * Will verify that the user is sent 1:1 for S.\n     */\n    receive() external payable {\n        deposit();\n    }\n\n    /**\n     * @dev Deposit native S currency and receive Origin Sonic (OS) tokens in return.\n     * Will verify that the user is sent 1:1 for S.\n     * @return Amount of Origin Sonic (OS) tokens sent to user\n     */\n    function deposit() public payable returns (uint256) {\n        uint256 balance = address(this).balance;\n\n        emit Zap(msg.sender, ETH_MARKER, balance);\n\n        // Wrap native S\n        wS.deposit{ value: balance }();\n\n        // Mint Origin Sonic (OS) with Wrapped Sonic (wS)\n        return _mint(balance, msg.sender);\n    }\n\n    /**\n     * @dev Deposit S and receive Wrapped Origin Sonic (wOS) in return\n     * @param minReceived min amount of Wrapped Origin Sonic (wOS) to receive\n     * @return Amount of Wrapped Origin Sonic (wOS) tokens sent to user\n     */\n    function depositSForWrappedTokens(uint256 minReceived)\n        external\n        payable\n        returns (uint256)\n    {\n        uint256 balance = address(this).balance;\n\n        emit Zap(msg.sender, ETH_MARKER, balance);\n\n        // Wrap S\n        wS.deposit{ value: balance }();\n\n        // Mint with Wrapped Sonic\n        uint256 mintOS = _mint(balance, address(this));\n\n        // Wrap Origin Sonic (OS) into Wrapped Origin Sonic (wOS)\n        uint256 mintedWOS = wOS.deposit(mintOS, msg.sender);\n\n        require(mintedWOS >= minReceived, \"Zapper: not enough minted\");\n\n        return mintedWOS;\n    }\n\n    /**\n     * @dev Deposit Wrapped Sonic (wS) tokens and receive Wrapped Origin Sonic (wOS) tokens in return\n     * @param wSAmount Amount of Wrapped Sonic (wS) to deposit\n     * @param minReceived min amount of Wrapped Origin Sonic (wOS) token to receive\n     * @return Amount of Wrapped Origin Sonic (wOS) tokens sent to user\n     */\n    function depositWSForWrappedTokens(uint256 wSAmount, uint256 minReceived)\n        external\n        returns (uint256)\n    {\n        // slither-disable-next-line unchecked-transfer unused-return\n        wS.transferFrom(msg.sender, address(this), wSAmount);\n\n        emit Zap(msg.sender, address(wS), wSAmount);\n\n        // Mint with Wrapped Sonic (wS)\n        uint256 mintedOS = _mint(wSAmount, address(this));\n\n        // Wrap Origin Sonic (OS) tokens into Wrapped Origin Sonic (wOS) tokens\n        uint256 mintedWOS = wOS.deposit(mintedOS, msg.sender);\n\n        require(mintedWOS >= minReceived, \"Zapper: not enough minted\");\n\n        return mintedWOS;\n    }\n\n    /**\n     * @dev Internal function to mint Origin Sonic (OS) with Wrapped S (wS)\n     * @param minOS Minimum amount of Origin Sonic (OS) tokens the user can receive\n     * @param recipient Address that receives the tokens\n     * @return Amount of Origin Sonic (OS) tokens sent to the recipient\n     */\n    function _mint(uint256 minOS, address recipient)\n        internal\n        returns (uint256)\n    {\n        uint256 toMint = wS.balanceOf(address(this));\n        vault.mint(address(wS), toMint, minOS);\n        uint256 mintedAmount = OS.balanceOf(address(this));\n        require(mintedAmount >= minOS, \"Zapper: not enough minted\");\n\n        if (recipient != address(this)) {\n            require(OS.transfer(recipient, mintedAmount));\n        }\n\n        return mintedAmount;\n    }\n}\n"
    },
    "contracts/vault/Vault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD VaultInitializer Contract\n * @notice The VaultInitializer sets up the initial contract.\n * @author Origin Protocol Inc\n */\nimport { VaultInitializer } from \"./VaultInitializer.sol\";\nimport { VaultAdmin } from \"./VaultAdmin.sol\";\n\ncontract Vault is VaultInitializer, VaultAdmin {}\n"
    },
    "contracts/vault/VaultAdmin.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OToken VaultAdmin contract\n * @notice The VaultAdmin contract makes configuration and admin calls on the vault.\n * @author Origin Protocol Inc\n */\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { ISwapper } from \"../interfaces/ISwapper.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./VaultStorage.sol\";\n\ncontract VaultAdmin is VaultStorage {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n    using SafeCast for uint256;\n\n    /**\n     * @dev Verifies that the caller is the Governor or Strategist.\n     */\n    modifier onlyGovernorOrStrategist() {\n        require(\n            msg.sender == strategistAddr || isGovernor(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    /***************************************\n                 Configuration\n    ****************************************/\n\n    /**\n     * @notice Set address of price provider.\n     * @param _priceProvider Address of price provider\n     */\n    function setPriceProvider(address _priceProvider) external onlyGovernor {\n        priceProvider = _priceProvider;\n        emit PriceProviderUpdated(_priceProvider);\n    }\n\n    /**\n     * @notice Set a fee in basis points to be charged for a redeem.\n     * @param _redeemFeeBps Basis point fee to be charged\n     */\n    function setRedeemFeeBps(uint256 _redeemFeeBps) external onlyGovernor {\n        require(_redeemFeeBps <= 1000, \"Redeem fee should not be over 10%\");\n        redeemFeeBps = _redeemFeeBps;\n        emit RedeemFeeUpdated(_redeemFeeBps);\n    }\n\n    /**\n     * @notice Set a buffer of assets to keep in the Vault to handle most\n     * redemptions without needing to spend gas unwinding assets from a Strategy.\n     * @param _vaultBuffer Percentage using 18 decimals. 100% = 1e18.\n     */\n    function setVaultBuffer(uint256 _vaultBuffer)\n        external\n        onlyGovernorOrStrategist\n    {\n        require(_vaultBuffer <= 1e18, \"Invalid value\");\n        vaultBuffer = _vaultBuffer;\n        emit VaultBufferUpdated(_vaultBuffer);\n    }\n\n    /**\n     * @notice Sets the minimum amount of OTokens in a mint to trigger an\n     * automatic allocation of funds afterwords.\n     * @param _threshold OToken amount with 18 fixed decimals.\n     */\n    function setAutoAllocateThreshold(uint256 _threshold)\n        external\n        onlyGovernor\n    {\n        autoAllocateThreshold = _threshold;\n        emit AllocateThresholdUpdated(_threshold);\n    }\n\n    /**\n     * @notice Set a minimum amount of OTokens in a mint or redeem that triggers a\n     * rebase\n     * @param _threshold OToken amount with 18 fixed decimals.\n     */\n    function setRebaseThreshold(uint256 _threshold) external onlyGovernor {\n        rebaseThreshold = _threshold;\n        emit RebaseThresholdUpdated(_threshold);\n    }\n\n    /**\n     * @notice Set address of Strategist\n     * @param _address Address of Strategist\n     */\n    function setStrategistAddr(address _address) external onlyGovernor {\n        strategistAddr = _address;\n        emit StrategistUpdated(_address);\n    }\n\n    /**\n     * @notice Set the default Strategy for an asset, i.e. the one which the asset\n            will be automatically allocated to and withdrawn from\n     * @param _asset Address of the asset\n     * @param _strategy Address of the Strategy\n     */\n    function setAssetDefaultStrategy(address _asset, address _strategy)\n        external\n        onlyGovernorOrStrategist\n    {\n        emit AssetDefaultStrategyUpdated(_asset, _strategy);\n        // If its a zero address being passed for the strategy we are removing\n        // the default strategy\n        if (_strategy != address(0)) {\n            // Make sure the strategy meets some criteria\n            require(strategies[_strategy].isSupported, \"Strategy not approved\");\n            IStrategy strategy = IStrategy(_strategy);\n            require(assets[_asset].isSupported, \"Asset is not supported\");\n            require(\n                strategy.supportsAsset(_asset),\n                \"Asset not supported by Strategy\"\n            );\n        }\n        assetDefaultStrategies[_asset] = _strategy;\n    }\n\n    /**\n     * @notice Set maximum amount of OTokens that can at any point be minted and deployed\n     * to strategy (used only by ConvexOUSDMetaStrategy for now).\n     * @param _threshold OToken amount with 18 fixed decimals.\n     */\n    function setNetOusdMintForStrategyThreshold(uint256 _threshold)\n        external\n        onlyGovernor\n    {\n        /**\n         * Because `netOusdMintedForStrategy` check in vault core works both ways\n         * (positive and negative) the actual impact of the amount of OToken minted\n         * could be double the threshold. E.g.:\n         *  - contract has threshold set to 100\n         *  - state of netOusdMinted is -90\n         *  - in effect it can mint 190 OToken and still be within limits\n         *\n         * We are somewhat mitigating this behaviour by resetting the netOusdMinted\n         * counter whenever new threshold is set. So it can only move one threshold\n         * amount in each direction. This also enables us to reduce the threshold\n         * amount and not have problems with current netOusdMinted being near\n         * limits on either side.\n         */\n        netOusdMintedForStrategy = 0;\n        netOusdMintForStrategyThreshold = _threshold;\n        emit NetOusdMintForStrategyThresholdChanged(_threshold);\n    }\n\n    /**\n     * @notice Changes the async withdrawal claim period for OETH & superOETHb\n     * @param _delay Delay period (should be between 10 mins to 7 days).\n     *          Set to 0 to disable async withdrawals\n     */\n    function setWithdrawalClaimDelay(uint256 _delay) external onlyGovernor {\n        require(\n            _delay == 0 || (_delay >= 10 minutes && _delay <= 15 days),\n            \"Invalid claim delay period\"\n        );\n        withdrawalClaimDelay = _delay;\n        emit WithdrawalClaimDelayUpdated(_delay);\n    }\n\n    /**\n     * @notice Set a yield streaming max rate. This spreads yield over\n     * time if it is above the max rate.\n     * @param yearlyApr in 1e18 notation. 3 * 1e18 = 3% APR\n     */\n    function setRebaseRateMax(uint256 yearlyApr)\n        external\n        onlyGovernorOrStrategist\n    {\n        // The old yield will be at the old rate\n        IVault(address(this)).rebase();\n        // Change the rate\n        uint256 newPerSecond = yearlyApr / 100 / 365 days;\n        require(newPerSecond <= MAX_REBASE_PER_SECOND, \"Rate too high\");\n        rebasePerSecondMax = newPerSecond.toUint64();\n        emit RebasePerSecondMaxChanged(newPerSecond);\n    }\n\n    /**\n     * @notice Set the drip duration period\n     * @param _dripDuration Time in seconds to target a constant yield rate\n     */\n    function setDripDuration(uint256 _dripDuration)\n        external\n        onlyGovernorOrStrategist\n    {\n        // The old yield will be at the old rate\n        IVault(address(this)).rebase();\n        dripDuration = _dripDuration.toUint64();\n        emit DripDurationChanged(_dripDuration);\n    }\n\n    /***************************************\n                    Swaps\n    ****************************************/\n\n    /**\n     * @notice Strategist swaps collateral assets sitting in the vault.\n     * @param _fromAsset The token address of the asset being sold by the vault.\n     * @param _toAsset The token address of the asset being purchased by the vault.\n     * @param _fromAssetAmount The amount of assets being sold by the vault.\n     * @param _minToAssetAmount The minimum amount of assets to be purchased.\n     * @param _data implementation specific data. eg 1Inch swap data\n     * @return toAssetAmount The amount of toAssets that was received from the swap\n     */\n    function swapCollateral(\n        address _fromAsset,\n        address _toAsset,\n        uint256 _fromAssetAmount,\n        uint256 _minToAssetAmount,\n        bytes calldata _data\n    )\n        external\n        nonReentrant\n        onlyGovernorOrStrategist\n        returns (uint256 toAssetAmount)\n    {\n        toAssetAmount = _swapCollateral(\n            _fromAsset,\n            _toAsset,\n            _fromAssetAmount,\n            _minToAssetAmount,\n            _data\n        );\n    }\n\n    function _swapCollateral(\n        address _fromAsset,\n        address _toAsset,\n        uint256 _fromAssetAmount,\n        uint256 _minToAssetAmount,\n        bytes calldata _data\n    ) internal virtual returns (uint256 toAssetAmount) {\n        // Check fromAsset and toAsset are valid\n        Asset memory fromAssetConfig = assets[_fromAsset];\n        Asset memory toAssetConfig = assets[_toAsset];\n        require(fromAssetConfig.isSupported, \"From asset is not supported\");\n        require(toAssetConfig.isSupported, \"To asset is not supported\");\n\n        // Load swap config into memory to avoid separate SLOADs\n        SwapConfig memory config = swapConfig;\n\n        // Scope a new block to remove toAssetBalBefore from the scope of swapCollateral.\n        // This avoids a stack too deep error.\n        {\n            uint256 toAssetBalBefore = IERC20(_toAsset).balanceOf(\n                address(this)\n            );\n\n            // Transfer from assets to the swapper contract\n            IERC20(_fromAsset).safeTransfer(config.swapper, _fromAssetAmount);\n\n            // Call to the Swapper contract to do the actual swap\n            // The -1 is required for stETH which sometimes transfers 1 wei less than what was specified.\n            // slither-disable-next-line unused-return\n            ISwapper(config.swapper).swap(\n                _fromAsset,\n                _toAsset,\n                _fromAssetAmount - 1,\n                _minToAssetAmount,\n                _data\n            );\n\n            // Compute the change in asset balance held by the Vault\n            toAssetAmount =\n                IERC20(_toAsset).balanceOf(address(this)) -\n                toAssetBalBefore;\n        }\n\n        // Check the to assets returned is above slippage amount specified by the strategist\n        require(\n            toAssetAmount >= _minToAssetAmount,\n            \"Strategist slippage limit\"\n        );\n\n        // Scope a new block to remove minOracleToAssetAmount from the scope of swapCollateral.\n        // This avoids a stack too deep error.\n        {\n            // Check the slippage against the Oracle in case the strategist made a mistake or has become malicious.\n            // to asset amount = from asset amount * from asset price / to asset price\n            uint256 minOracleToAssetAmount = (_fromAssetAmount *\n                (1e4 - fromAssetConfig.allowedOracleSlippageBps) *\n                IOracle(priceProvider).price(_fromAsset)) /\n                (IOracle(priceProvider).price(_toAsset) *\n                    (1e4 + toAssetConfig.allowedOracleSlippageBps));\n\n            // Scale both sides up to 18 decimals to compare\n            require(\n                toAssetAmount.scaleBy(18, toAssetConfig.decimals) >=\n                    minOracleToAssetAmount.scaleBy(\n                        18,\n                        fromAssetConfig.decimals\n                    ),\n                \"Oracle slippage limit exceeded\"\n            );\n        }\n\n        // Check the vault's total value hasn't gone below the OToken total supply\n        // by more than the allowed percentage.\n        require(\n            IVault(address(this)).totalValue() >=\n                (oUSD.totalSupply() * ((1e4 - config.allowedUndervalueBps))) /\n                    1e4,\n            \"Allowed value < supply\"\n        );\n\n        emit Swapped(_fromAsset, _toAsset, _fromAssetAmount, toAssetAmount);\n    }\n\n    /***************************************\n                    Swap Config\n    ****************************************/\n\n    /**\n     * @notice Set the contract the performs swaps of collateral assets.\n     * @param _swapperAddr Address of the Swapper contract that implements the ISwapper interface.\n     */\n    function setSwapper(address _swapperAddr) external onlyGovernor {\n        swapConfig.swapper = _swapperAddr;\n        emit SwapperChanged(_swapperAddr);\n    }\n\n    /// @notice Contract that swaps the vault's collateral assets\n    function swapper() external view returns (address swapper_) {\n        swapper_ = swapConfig.swapper;\n    }\n\n    /**\n     * @notice Set max allowed percentage the vault total value can drop below the OToken total supply in basis points\n     * when executing collateral swaps.\n     * @param _basis Percentage in basis points. eg 100 == 1%\n     */\n    function setSwapAllowedUndervalue(uint16 _basis) external onlyGovernor {\n        require(_basis < 10001, \"Invalid basis points\");\n        swapConfig.allowedUndervalueBps = _basis;\n        emit SwapAllowedUndervalueChanged(_basis);\n    }\n\n    /**\n     * @notice Max allowed percentage the vault total value can drop below the OToken total supply in basis points\n     * when executing a collateral swap.\n     * For example 100 == 1%\n     * @return value Percentage in basis points.\n     */\n    function allowedSwapUndervalue() external view returns (uint256 value) {\n        value = swapConfig.allowedUndervalueBps;\n    }\n\n    /**\n     * @notice Set the allowed slippage from the Oracle price for collateral asset swaps.\n     * @param _asset Address of the asset token.\n     * @param _allowedOracleSlippageBps allowed slippage from Oracle in basis points. eg 20 = 0.2%. Max 10%.\n     */\n    function setOracleSlippage(address _asset, uint16 _allowedOracleSlippageBps)\n        external\n        onlyGovernor\n    {\n        require(assets[_asset].isSupported, \"Asset not supported\");\n        require(_allowedOracleSlippageBps < 1000, \"Slippage too high\");\n\n        assets[_asset].allowedOracleSlippageBps = _allowedOracleSlippageBps;\n\n        emit SwapSlippageChanged(_asset, _allowedOracleSlippageBps);\n    }\n\n    /***************************************\n                Asset Config\n    ****************************************/\n\n    /**\n     * @notice Add a supported asset to the contract, i.e. one that can be\n     *         to mint OTokens.\n     * @param _asset Address of asset\n     */\n    function supportAsset(address _asset, uint8 _unitConversion)\n        external\n        virtual\n        onlyGovernor\n    {\n        require(!assets[_asset].isSupported, \"Asset already supported\");\n\n        assets[_asset] = Asset({\n            isSupported: true,\n            unitConversion: UnitConversion(_unitConversion),\n            decimals: 0, // will be overridden in _cacheDecimals\n            allowedOracleSlippageBps: 0 // 0% by default\n        });\n\n        _cacheDecimals(_asset);\n        allAssets.push(_asset);\n\n        // Verify that our oracle supports the asset\n        // slither-disable-next-line unused-return\n        IOracle(priceProvider).price(_asset);\n\n        emit AssetSupported(_asset);\n    }\n\n    /**\n     * @notice Remove a supported asset from the Vault\n     * @param _asset Address of asset\n     */\n    function removeAsset(address _asset) external onlyGovernor {\n        require(assets[_asset].isSupported, \"Asset not supported\");\n\n        // 1e13 for 18 decimals. And 10 for 6 decimals\n        uint256 maxDustBalance = uint256(1e13).scaleBy(\n            assets[_asset].decimals,\n            18\n        );\n\n        require(\n            IVault(address(this)).checkBalance(_asset) <= maxDustBalance,\n            \"Vault still holds asset\"\n        );\n\n        uint256 assetsCount = allAssets.length;\n        uint256 assetIndex = assetsCount; // initialize at invalid index\n        for (uint256 i = 0; i < assetsCount; ++i) {\n            if (allAssets[i] == _asset) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // Note: If asset is not found in `allAssets`, the following line\n        // will revert with an out-of-bound error. However, there's no\n        // reason why an asset would have `Asset.isSupported = true` but\n        // not exist in `allAssets`.\n\n        // Update allAssets array\n        allAssets[assetIndex] = allAssets[assetsCount - 1];\n        allAssets.pop();\n\n        // Reset default strategy\n        assetDefaultStrategies[_asset] = address(0);\n        emit AssetDefaultStrategyUpdated(_asset, address(0));\n\n        // Remove asset from storage\n        delete assets[_asset];\n\n        emit AssetRemoved(_asset);\n    }\n\n    /**\n     * @notice Cache decimals on OracleRouter for a particular asset. This action\n     *      is required before that asset's price can be accessed.\n     * @param _asset Address of asset token\n     */\n    function cacheDecimals(address _asset) external onlyGovernor {\n        _cacheDecimals(_asset);\n    }\n\n    /***************************************\n                Strategy Config\n    ****************************************/\n\n    /**\n     * @notice Add a strategy to the Vault.\n     * @param _addr Address of the strategy to add\n     */\n    function approveStrategy(address _addr) external onlyGovernor {\n        require(!strategies[_addr].isSupported, \"Strategy already approved\");\n        strategies[_addr] = Strategy({ isSupported: true, _deprecated: 0 });\n        allStrategies.push(_addr);\n        emit StrategyApproved(_addr);\n    }\n\n    /**\n     * @notice Remove a strategy from the Vault.\n     * @param _addr Address of the strategy to remove\n     */\n\n    function removeStrategy(address _addr) external onlyGovernor {\n        require(strategies[_addr].isSupported, \"Strategy not approved\");\n\n        uint256 assetCount = allAssets.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            require(\n                assetDefaultStrategies[allAssets[i]] != _addr,\n                \"Strategy is default for an asset\"\n            );\n        }\n\n        // Initialize strategyIndex with out of bounds result so function will\n        // revert if no valid index found\n        uint256 stratCount = allStrategies.length;\n        uint256 strategyIndex = stratCount;\n        for (uint256 i = 0; i < stratCount; ++i) {\n            if (allStrategies[i] == _addr) {\n                strategyIndex = i;\n                break;\n            }\n        }\n\n        if (strategyIndex < stratCount) {\n            allStrategies[strategyIndex] = allStrategies[stratCount - 1];\n            allStrategies.pop();\n\n            // Mark the strategy as not supported\n            strategies[_addr].isSupported = false;\n\n            // Withdraw all assets\n            IStrategy strategy = IStrategy(_addr);\n            strategy.withdrawAll();\n\n            emit StrategyRemoved(_addr);\n        }\n    }\n\n    /***************************************\n                Strategies\n    ****************************************/\n\n    /**\n     * @notice Deposit multiple assets from the vault into the strategy.\n     * @param _strategyToAddress Address of the Strategy to deposit assets into.\n     * @param _assets Array of asset address that will be deposited into the strategy.\n     * @param _amounts Array of amounts of each corresponding asset to deposit.\n     */\n    function depositToStrategy(\n        address _strategyToAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external onlyGovernorOrStrategist nonReentrant {\n        _depositToStrategy(_strategyToAddress, _assets, _amounts);\n    }\n\n    function _depositToStrategy(\n        address _strategyToAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) internal virtual {\n        require(\n            strategies[_strategyToAddress].isSupported,\n            \"Invalid to Strategy\"\n        );\n        require(_assets.length == _amounts.length, \"Parameter length mismatch\");\n\n        uint256 assetCount = _assets.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            address assetAddr = _assets[i];\n            require(\n                IStrategy(_strategyToAddress).supportsAsset(assetAddr),\n                \"Asset unsupported\"\n            );\n            // Send required amount of funds to the strategy\n            IERC20(assetAddr).safeTransfer(_strategyToAddress, _amounts[i]);\n        }\n\n        // Deposit all the funds that have been sent to the strategy\n        IStrategy(_strategyToAddress).depositAll();\n    }\n\n    /**\n     * @notice Withdraw multiple assets from the strategy to the vault.\n     * @param _strategyFromAddress Address of the Strategy to withdraw assets from.\n     * @param _assets Array of asset address that will be withdrawn from the strategy.\n     * @param _amounts Array of amounts of each corresponding asset to withdraw.\n     */\n    function withdrawFromStrategy(\n        address _strategyFromAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external onlyGovernorOrStrategist nonReentrant {\n        _withdrawFromStrategy(\n            address(this),\n            _strategyFromAddress,\n            _assets,\n            _amounts\n        );\n    }\n\n    /**\n     * @param _recipient can either be a strategy or the Vault\n     */\n    function _withdrawFromStrategy(\n        address _recipient,\n        address _strategyFromAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) internal virtual {\n        require(\n            strategies[_strategyFromAddress].isSupported,\n            \"Invalid from Strategy\"\n        );\n        require(_assets.length == _amounts.length, \"Parameter length mismatch\");\n\n        uint256 assetCount = _assets.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            // Withdraw from Strategy to the recipient\n            IStrategy(_strategyFromAddress).withdraw(\n                _recipient,\n                _assets[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /**\n     * @notice Sets the maximum allowable difference between\n     * total supply and backing assets' value.\n     */\n    function setMaxSupplyDiff(uint256 _maxSupplyDiff) external onlyGovernor {\n        maxSupplyDiff = _maxSupplyDiff;\n        emit MaxSupplyDiffChanged(_maxSupplyDiff);\n    }\n\n    /**\n     * @notice Sets the trusteeAddress that can receive a portion of yield.\n     *      Setting to the zero address disables this feature.\n     */\n    function setTrusteeAddress(address _address) external onlyGovernor {\n        trusteeAddress = _address;\n        emit TrusteeAddressChanged(_address);\n    }\n\n    /**\n     * @notice Sets the TrusteeFeeBps to the percentage of yield that should be\n     *      received in basis points.\n     */\n    function setTrusteeFeeBps(uint256 _basis) external onlyGovernor {\n        require(_basis <= 5000, \"basis cannot exceed 50%\");\n        trusteeFeeBps = _basis;\n        emit TrusteeFeeBpsChanged(_basis);\n    }\n\n    /**\n     * @notice Set OToken Metapool strategy\n     * @param _ousdMetaStrategy Address of OToken metapool strategy\n     */\n    function setOusdMetaStrategy(address _ousdMetaStrategy)\n        external\n        onlyGovernor\n    {\n        ousdMetaStrategy = _ousdMetaStrategy;\n        emit OusdMetaStrategyUpdated(_ousdMetaStrategy);\n    }\n\n    /***************************************\n                    Pause\n    ****************************************/\n\n    /**\n     * @notice Set the deposit paused flag to true to prevent rebasing.\n     */\n    function pauseRebase() external onlyGovernorOrStrategist {\n        rebasePaused = true;\n        emit RebasePaused();\n    }\n\n    /**\n     * @notice Set the deposit paused flag to true to allow rebasing.\n     */\n    function unpauseRebase() external onlyGovernorOrStrategist {\n        rebasePaused = false;\n        emit RebaseUnpaused();\n    }\n\n    /**\n     * @notice Set the deposit paused flag to true to prevent capital movement.\n     */\n    function pauseCapital() external onlyGovernorOrStrategist {\n        capitalPaused = true;\n        emit CapitalPaused();\n    }\n\n    /**\n     * @notice Set the deposit paused flag to false to enable capital movement.\n     */\n    function unpauseCapital() external onlyGovernorOrStrategist {\n        capitalPaused = false;\n        emit CapitalUnpaused();\n    }\n\n    /***************************************\n                    Utils\n    ****************************************/\n\n    /**\n     * @notice Transfer token to governor. Intended for recovering tokens stuck in\n     *      contract, i.e. mistaken sends.\n     * @param _asset Address for the asset\n     * @param _amount Amount of the asset to transfer\n     */\n    function transferToken(address _asset, uint256 _amount)\n        external\n        onlyGovernor\n    {\n        require(!assets[_asset].isSupported, \"Only unsupported assets\");\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /***************************************\n             Strategies Admin\n    ****************************************/\n\n    /**\n     * @notice Withdraws all assets from the strategy and sends assets to the Vault.\n     * @param _strategyAddr Strategy address.\n     */\n    function withdrawAllFromStrategy(address _strategyAddr)\n        external\n        onlyGovernorOrStrategist\n    {\n        _withdrawAllFromStrategy(_strategyAddr);\n    }\n\n    function _withdrawAllFromStrategy(address _strategyAddr) internal virtual {\n        require(\n            strategies[_strategyAddr].isSupported,\n            \"Strategy is not supported\"\n        );\n        IStrategy strategy = IStrategy(_strategyAddr);\n        strategy.withdrawAll();\n    }\n\n    /**\n     * @notice Withdraws all assets from all the strategies and sends assets to the Vault.\n     */\n    function withdrawAllFromStrategies() external onlyGovernorOrStrategist {\n        _withdrawAllFromStrategies();\n    }\n\n    function _withdrawAllFromStrategies() internal virtual {\n        uint256 stratCount = allStrategies.length;\n        for (uint256 i = 0; i < stratCount; ++i) {\n            IStrategy(allStrategies[i]).withdrawAll();\n        }\n    }\n\n    /***************************************\n                    Utils\n    ****************************************/\n\n    function _cacheDecimals(address token) internal {\n        Asset storage tokenAsset = assets[token];\n        if (tokenAsset.decimals != 0) {\n            return;\n        }\n        uint8 decimals = IBasicToken(token).decimals();\n        require(decimals >= 6 && decimals <= 18, \"Unexpected precision\");\n        tokenAsset.decimals = decimals;\n    }\n}\n"
    },
    "contracts/vault/VaultCore.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OToken VaultCore contract\n * @notice The Vault contract stores assets. On a deposit, OTokens will be minted\n           and sent to the depositor. On a withdrawal, OTokens will be burned and\n           assets will be sent to the withdrawer. The Vault accepts deposits of\n           interest from yield bearing strategies which will modify the supply\n           of OTokens.\n * @author Origin Protocol Inc\n */\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { IGetExchangeRateToken } from \"../interfaces/IGetExchangeRateToken.sol\";\n\nimport \"./VaultInitializer.sol\";\n\ncontract VaultCore is VaultInitializer {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n    /// @dev max signed int\n    uint256 internal constant MAX_INT = uint256(type(int256).max);\n\n    /**\n     * @dev Verifies that the rebasing is not paused.\n     */\n    modifier whenNotRebasePaused() {\n        require(!rebasePaused, \"Rebasing paused\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the deposits are not paused.\n     */\n    modifier whenNotCapitalPaused() {\n        require(!capitalPaused, \"Capital paused\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the AMO strategy.\n     */\n    modifier onlyOusdMetaStrategy() {\n        require(\n            msg.sender == ousdMetaStrategy,\n            \"Caller is not the OUSD meta strategy\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Deposit a supported asset and mint OTokens.\n     * @param _asset Address of the asset being deposited\n     * @param _amount Amount of the asset being deposited\n     * @param _minimumOusdAmount Minimum OTokens to mint\n     */\n    function mint(\n        address _asset,\n        uint256 _amount,\n        uint256 _minimumOusdAmount\n    ) external whenNotCapitalPaused nonReentrant {\n        _mint(_asset, _amount, _minimumOusdAmount);\n    }\n\n    /**\n     * @dev Deposit a supported asset and mint OTokens.\n     * @param _asset Address of the asset being deposited\n     * @param _amount Amount of the asset being deposited\n     * @param _minimumOusdAmount Minimum OTokens to mint\n     */\n    function _mint(\n        address _asset,\n        uint256 _amount,\n        uint256 _minimumOusdAmount\n    ) internal virtual {\n        require(assets[_asset].isSupported, \"Asset is not supported\");\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        uint256 units = _toUnits(_amount, _asset);\n        uint256 unitPrice = _toUnitPrice(_asset, true);\n        uint256 priceAdjustedDeposit = (units * unitPrice) / 1e18;\n\n        if (_minimumOusdAmount > 0) {\n            require(\n                priceAdjustedDeposit >= _minimumOusdAmount,\n                \"Mint amount lower than minimum\"\n            );\n        }\n\n        emit Mint(msg.sender, priceAdjustedDeposit);\n\n        // Rebase must happen before any transfers occur.\n        if (priceAdjustedDeposit >= rebaseThreshold && !rebasePaused) {\n            _rebase();\n        }\n\n        // Mint matching amount of OTokens\n        oUSD.mint(msg.sender, priceAdjustedDeposit);\n\n        // Transfer the deposited coins to the vault\n        IERC20 asset = IERC20(_asset);\n        asset.safeTransferFrom(msg.sender, address(this), _amount);\n\n        if (priceAdjustedDeposit >= autoAllocateThreshold) {\n            _allocate();\n        }\n    }\n\n    /**\n     * @notice Mint OTokens for a Metapool Strategy\n     * @param _amount Amount of the asset being deposited\n     *\n     * Notice: can't use `nonReentrant` modifier since the `mint` function can\n     * call `allocate`, and that can trigger `ConvexOUSDMetaStrategy` to call this function\n     * while the execution of the `mint` has not yet completed -> causing a `nonReentrant` collision.\n     *\n     * Also important to understand is that this is a limitation imposed by the test suite.\n     * Production / mainnet contracts should never be configured in a way where mint/redeem functions\n     * that are moving funds between the Vault and end user wallets can influence strategies\n     * utilizing this function.\n     */\n    function mintForStrategy(uint256 _amount)\n        external\n        virtual\n        whenNotCapitalPaused\n        onlyOusdMetaStrategy\n    {\n        require(_amount < MAX_INT, \"Amount too high\");\n\n        emit Mint(msg.sender, _amount);\n\n        // safe to cast because of the require check at the beginning of the function\n        netOusdMintedForStrategy += int256(_amount);\n\n        require(\n            abs(netOusdMintedForStrategy) < netOusdMintForStrategyThreshold,\n            \"Minted ousd surpassed netOusdMintForStrategyThreshold.\"\n        );\n\n        // Mint matching amount of OTokens\n        oUSD.mint(msg.sender, _amount);\n    }\n\n    // In memoriam\n\n    /**\n     * @notice Withdraw a supported asset and burn OTokens.\n     * @param _amount Amount of OTokens to burn\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function redeem(uint256 _amount, uint256 _minimumUnitAmount)\n        external\n        whenNotCapitalPaused\n        nonReentrant\n    {\n        _redeem(_amount, _minimumUnitAmount);\n    }\n\n    /**\n     * @notice Withdraw a supported asset and burn OTokens.\n     * @param _amount Amount of OTokens to burn\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function _redeem(uint256 _amount, uint256 _minimumUnitAmount)\n        internal\n        virtual\n    {\n        // Calculate redemption outputs\n        uint256[] memory outputs = _calculateRedeemOutputs(_amount);\n\n        emit Redeem(msg.sender, _amount);\n\n        // Send outputs\n        uint256 assetCount = allAssets.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            if (outputs[i] == 0) continue;\n\n            address assetAddr = allAssets[i];\n\n            if (IERC20(assetAddr).balanceOf(address(this)) >= outputs[i]) {\n                // Use Vault funds first if sufficient\n                IERC20(assetAddr).safeTransfer(msg.sender, outputs[i]);\n            } else {\n                address strategyAddr = assetDefaultStrategies[assetAddr];\n                if (strategyAddr != address(0)) {\n                    // Nothing in Vault, but something in Strategy, send from there\n                    IStrategy strategy = IStrategy(strategyAddr);\n                    strategy.withdraw(msg.sender, assetAddr, outputs[i]);\n                } else {\n                    // Cant find funds anywhere\n                    revert(\"Liquidity error\");\n                }\n            }\n        }\n\n        if (_minimumUnitAmount > 0) {\n            uint256 unitTotal = 0;\n            for (uint256 i = 0; i < outputs.length; ++i) {\n                unitTotal += _toUnits(outputs[i], allAssets[i]);\n            }\n            require(\n                unitTotal >= _minimumUnitAmount,\n                \"Redeem amount lower than minimum\"\n            );\n        }\n\n        oUSD.burn(msg.sender, _amount);\n\n        _postRedeem(_amount);\n    }\n\n    function _postRedeem(uint256 _amount) internal {\n        // Until we can prove that we won't affect the prices of our assets\n        // by withdrawing them, this should be here.\n        // It's possible that a strategy was off on its asset total, perhaps\n        // a reward token sold for more or for less than anticipated.\n        uint256 totalUnits = 0;\n        if (_amount >= rebaseThreshold && !rebasePaused) {\n            totalUnits = _rebase();\n        } else {\n            totalUnits = _totalValue();\n        }\n\n        // Check that the OTokens are backed by enough assets\n        if (maxSupplyDiff > 0) {\n            // If there are more outstanding withdrawal requests than assets in the vault and strategies\n            // then the available assets will be negative and totalUnits will be rounded up to zero.\n            // As we don't know the exact shortfall amount, we will reject all redeem and withdrawals\n            require(totalUnits > 0, \"Too many outstanding requests\");\n\n            // Allow a max difference of maxSupplyDiff% between\n            // backing assets value and OUSD total supply\n            uint256 diff = oUSD.totalSupply().divPrecisely(totalUnits);\n            require(\n                (diff > 1e18 ? diff - 1e18 : 1e18 - diff) <= maxSupplyDiff,\n                \"Backing supply liquidity error\"\n            );\n        }\n    }\n\n    /**\n     * @notice Burn OTokens for Metapool Strategy\n     * @param _amount Amount of OUSD to burn\n     *\n     * @dev Notice: can't use `nonReentrant` modifier since the `redeem` function could\n     * require withdrawal on `ConvexOUSDMetaStrategy` and that one can call `burnForStrategy`\n     * while the execution of the `redeem` has not yet completed -> causing a `nonReentrant` collision.\n     *\n     * Also important to understand is that this is a limitation imposed by the test suite.\n     * Production / mainnet contracts should never be configured in a way where mint/redeem functions\n     * that are moving funds between the Vault and end user wallets can influence strategies\n     * utilizing this function.\n     */\n    function burnForStrategy(uint256 _amount)\n        external\n        virtual\n        whenNotCapitalPaused\n        onlyOusdMetaStrategy\n    {\n        require(_amount < MAX_INT, \"Amount too high\");\n\n        emit Redeem(msg.sender, _amount);\n\n        // safe to cast because of the require check at the beginning of the function\n        netOusdMintedForStrategy -= int256(_amount);\n\n        require(\n            abs(netOusdMintedForStrategy) < netOusdMintForStrategyThreshold,\n            \"Attempting to burn too much OUSD.\"\n        );\n\n        // Burn OTokens\n        oUSD.burn(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Allocate unallocated funds on Vault to strategies.\n     **/\n    function allocate() external virtual whenNotCapitalPaused nonReentrant {\n        _allocate();\n    }\n\n    /**\n     * @dev Allocate unallocated funds on Vault to strategies.\n     **/\n    function _allocate() internal virtual {\n        uint256 vaultValue = _totalValueInVault();\n        // Nothing in vault to allocate\n        if (vaultValue == 0) return;\n        uint256 strategiesValue = _totalValueInStrategies();\n        // We have a method that does the same as this, gas optimisation\n        uint256 calculatedTotalValue = vaultValue + strategiesValue;\n\n        // We want to maintain a buffer on the Vault so calculate a percentage\n        // modifier to multiply each amount being allocated by to enforce the\n        // vault buffer\n        uint256 vaultBufferModifier;\n        if (strategiesValue == 0) {\n            // Nothing in Strategies, allocate 100% minus the vault buffer to\n            // strategies\n            vaultBufferModifier = uint256(1e18) - vaultBuffer;\n        } else {\n            vaultBufferModifier =\n                (vaultBuffer * calculatedTotalValue) /\n                vaultValue;\n            if (1e18 > vaultBufferModifier) {\n                // E.g. 1e18 - (1e17 * 10e18)/5e18 = 8e17\n                // (5e18 * 8e17) / 1e18 = 4e18 allocated from Vault\n                vaultBufferModifier = uint256(1e18) - vaultBufferModifier;\n            } else {\n                // We need to let the buffer fill\n                return;\n            }\n        }\n        if (vaultBufferModifier == 0) return;\n\n        // Iterate over all assets in the Vault and allocate to the appropriate\n        // strategy\n        uint256 assetCount = allAssets.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            IERC20 asset = IERC20(allAssets[i]);\n            uint256 assetBalance = asset.balanceOf(address(this));\n            // No balance, nothing to do here\n            if (assetBalance == 0) continue;\n\n            // Multiply the balance by the vault buffer modifier and truncate\n            // to the scale of the asset decimals\n            uint256 allocateAmount = assetBalance.mulTruncate(\n                vaultBufferModifier\n            );\n\n            address depositStrategyAddr = assetDefaultStrategies[\n                address(asset)\n            ];\n\n            if (depositStrategyAddr != address(0) && allocateAmount > 0) {\n                IStrategy strategy = IStrategy(depositStrategyAddr);\n                // Transfer asset to Strategy and call deposit method to\n                // mint or take required action\n                asset.safeTransfer(address(strategy), allocateAmount);\n                strategy.deposit(address(asset), allocateAmount);\n                emit AssetAllocated(\n                    address(asset),\n                    depositStrategyAddr,\n                    allocateAmount\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Calculate the total value of assets held by the Vault and all\n     *      strategies and update the supply of OTokens.\n     */\n    function rebase() external virtual nonReentrant {\n        _rebase();\n    }\n\n    /**\n     * @dev Calculate the total value of assets held by the Vault and all\n     *      strategies and update the supply of OTokens, optionally sending a\n     *      portion of the yield to the trustee.\n     * @return totalUnits Total balance of Vault in units\n     */\n    function _rebase() internal whenNotRebasePaused returns (uint256) {\n        uint256 supply = oUSD.totalSupply();\n        uint256 vaultValue = _totalValue();\n        // If no supply yet, do not rebase\n        if (supply == 0) {\n            return vaultValue;\n        }\n\n        // Calculate yield and new supply\n        (uint256 yield, uint256 targetRate) = _nextYield(supply, vaultValue);\n        uint256 newSupply = supply + yield;\n        // Only rebase upwards and if we have enough backing funds\n        if (newSupply <= supply || newSupply > vaultValue) {\n            return vaultValue;\n        }\n\n        rebasePerSecondTarget = uint64(_min(targetRate, type(uint64).max));\n        lastRebase = uint64(block.timestamp); // Intentional cast\n\n        // Fee collection on yield\n        address _trusteeAddress = trusteeAddress; // gas savings\n        uint256 fee = 0;\n        if (_trusteeAddress != address(0)) {\n            fee = (yield * trusteeFeeBps) / 1e4;\n            if (fee > 0) {\n                require(fee < yield, \"Fee must not be greater than yield\");\n                oUSD.mint(_trusteeAddress, fee);\n            }\n        }\n        emit YieldDistribution(_trusteeAddress, yield, fee);\n\n        // Only ratchet OToken supply upwards\n        // Final check uses latest totalSupply\n        if (newSupply > oUSD.totalSupply()) {\n            oUSD.changeSupply(newSupply);\n        }\n        return vaultValue;\n    }\n\n    /**\n     * @notice Calculates the amount that would rebase at next rebase.\n     * This is before any fees.\n     * @return yield amount of expected yield\n     */\n    function previewYield() external view returns (uint256 yield) {\n        (yield, ) = _nextYield(oUSD.totalSupply(), _totalValue());\n        return yield;\n    }\n\n    function _nextYield(uint256 supply, uint256 vaultValue)\n        internal\n        view\n        virtual\n        returns (uint256 yield, uint256 targetRate)\n    {\n        uint256 nonRebasing = oUSD.nonRebasingSupply();\n        uint256 rebasing = supply - nonRebasing;\n        uint256 elapsed = block.timestamp - lastRebase;\n        targetRate = rebasePerSecondTarget;\n\n        if (\n            elapsed == 0 || // Yield only once per block.\n            rebasing == 0 || // No yield if there are no rebasing tokens to give it to.\n            supply > vaultValue || // No yield if we do not have yield to give.\n            block.timestamp >= type(uint64).max // No yield if we are too far in the future to calculate it correctly.\n        ) {\n            return (0, targetRate);\n        }\n\n        // Start with the full difference available\n        yield = vaultValue - supply;\n\n        // Cap via optional automatic duration smoothing\n        uint256 _dripDuration = dripDuration;\n        if (_dripDuration > 1) {\n            // If we are able to sustain an increased drip rate for\n            // double the duration, then increase the target drip rate\n            targetRate = _max(targetRate, yield / (_dripDuration * 2));\n            // If we cannot sustain the target rate any more,\n            // then rebase what we can, and reduce the target\n            targetRate = _min(targetRate, yield / _dripDuration);\n            // drip at the new target rate\n            yield = _min(yield, targetRate * elapsed);\n        }\n\n        // Cap per second. elapsed is not 1e18 denominated\n        yield = _min(yield, (rebasing * elapsed * rebasePerSecondMax) / 1e18);\n\n        // Cap at a hard max per rebase, to avoid long durations resulting in huge rebases\n        yield = _min(yield, (rebasing * MAX_REBASE) / 1e18);\n\n        return (yield, targetRate);\n    }\n\n    /**\n     * @notice Determine the total value of assets held by the vault and its\n     *         strategies.\n     * @return value Total value in USD/ETH (1e18)\n     */\n    function totalValue() external view virtual returns (uint256 value) {\n        value = _totalValue();\n    }\n\n    /**\n     * @dev Internal Calculate the total value of the assets held by the\n     *         vault and its strategies.\n     * @return value Total value in USD/ETH (1e18)\n     */\n    function _totalValue() internal view virtual returns (uint256 value) {\n        return _totalValueInVault() + _totalValueInStrategies();\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held in Vault.\n     * @return value Total value in USD/ETH (1e18)\n     */\n    function _totalValueInVault()\n        internal\n        view\n        virtual\n        returns (uint256 value)\n    {\n        uint256 assetCount = allAssets.length;\n        for (uint256 y; y < assetCount; ++y) {\n            address assetAddr = allAssets[y];\n            uint256 balance = IERC20(assetAddr).balanceOf(address(this));\n            if (balance > 0) {\n                value += _toUnits(balance, assetAddr);\n            }\n        }\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held in Strategies.\n     * @return value Total value in USD/ETH (1e18)\n     */\n    function _totalValueInStrategies() internal view returns (uint256 value) {\n        uint256 stratCount = allStrategies.length;\n        for (uint256 i = 0; i < stratCount; ++i) {\n            value = value + _totalValueInStrategy(allStrategies[i]);\n        }\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held by strategy.\n     * @param _strategyAddr Address of the strategy\n     * @return value Total value in USD/ETH (1e18)\n     */\n    function _totalValueInStrategy(address _strategyAddr)\n        internal\n        view\n        returns (uint256 value)\n    {\n        IStrategy strategy = IStrategy(_strategyAddr);\n        uint256 assetCount = allAssets.length;\n        for (uint256 y; y < assetCount; ++y) {\n            address assetAddr = allAssets[y];\n            if (strategy.supportsAsset(assetAddr)) {\n                uint256 balance = strategy.checkBalance(assetAddr);\n                if (balance > 0) {\n                    value += _toUnits(balance, assetAddr);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Get the balance of an asset held in Vault and all strategies.\n     * @param _asset Address of asset\n     * @return uint256 Balance of asset in decimals of asset\n     */\n    function checkBalance(address _asset) external view returns (uint256) {\n        return _checkBalance(_asset);\n    }\n\n    /**\n     * @notice Get the balance of an asset held in Vault and all strategies.\n     * @param _asset Address of asset\n     * @return balance Balance of asset in decimals of asset\n     */\n    function _checkBalance(address _asset)\n        internal\n        view\n        virtual\n        returns (uint256 balance)\n    {\n        IERC20 asset = IERC20(_asset);\n        balance = asset.balanceOf(address(this));\n        uint256 stratCount = allStrategies.length;\n        for (uint256 i = 0; i < stratCount; ++i) {\n            IStrategy strategy = IStrategy(allStrategies[i]);\n            if (strategy.supportsAsset(_asset)) {\n                balance = balance + strategy.checkBalance(_asset);\n            }\n        }\n    }\n\n    /**\n     * @notice Calculate the outputs for a redeem function, i.e. the mix of\n     * coins that will be returned\n     */\n    function calculateRedeemOutputs(uint256 _amount)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return _calculateRedeemOutputs(_amount);\n    }\n\n    /**\n     * @dev Calculate the outputs for a redeem function, i.e. the mix of\n     * coins that will be returned.\n     * @return outputs Array of amounts respective to the supported assets\n     */\n    function _calculateRedeemOutputs(uint256 _amount)\n        internal\n        view\n        virtual\n        returns (uint256[] memory outputs)\n    {\n        // We always give out coins in proportion to how many we have,\n        // Now if all coins were the same value, this math would easy,\n        // just take the percentage of each coin, and multiply by the\n        // value to be given out. But if coins are worth more than $1,\n        // then we would end up handing out too many coins. We need to\n        // adjust by the total value of coins.\n        //\n        // To do this, we total up the value of our coins, by their\n        // percentages. Then divide what we would otherwise give out by\n        // this number.\n        //\n        // Let say we have 100 DAI at $1.06  and 200 USDT at $1.00.\n        // So for every 1 DAI we give out, we'll be handing out 2 USDT\n        // Our total output ratio is: 33% * 1.06 + 66% * 1.00 = 1.02\n        //\n        // So when calculating the output, we take the percentage of\n        // each coin, times the desired output value, divided by the\n        // totalOutputRatio.\n        //\n        // For example, withdrawing: 30 OUSD:\n        // DAI 33% * 30 / 1.02 = 9.80 DAI\n        // USDT = 66 % * 30 / 1.02 = 19.60 USDT\n        //\n        // Checking these numbers:\n        // 9.80 DAI * 1.06 = $10.40\n        // 19.60 USDT * 1.00 = $19.60\n        //\n        // And so the user gets $10.40 + $19.60 = $30 worth of value.\n\n        uint256 assetCount = allAssets.length;\n        uint256[] memory assetUnits = new uint256[](assetCount);\n        uint256[] memory assetBalances = new uint256[](assetCount);\n        outputs = new uint256[](assetCount);\n\n        // Calculate redeem fee\n        if (redeemFeeBps > 0) {\n            uint256 redeemFee = _amount.mulTruncateScale(redeemFeeBps, 1e4);\n            _amount = _amount - redeemFee;\n        }\n\n        // Calculate assets balances and decimals once,\n        // for a large gas savings.\n        uint256 totalUnits = 0;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            address assetAddr = allAssets[i];\n            uint256 balance = _checkBalance(assetAddr);\n            assetBalances[i] = balance;\n            assetUnits[i] = _toUnits(balance, assetAddr);\n            totalUnits = totalUnits + assetUnits[i];\n        }\n        // Calculate totalOutputRatio\n        uint256 totalOutputRatio = 0;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            uint256 unitPrice = _toUnitPrice(allAssets[i], false);\n            uint256 ratio = (assetUnits[i] * unitPrice) / totalUnits;\n            totalOutputRatio = totalOutputRatio + ratio;\n        }\n        // Calculate final outputs\n        uint256 factor = _amount.divPrecisely(totalOutputRatio);\n        for (uint256 i = 0; i < assetCount; ++i) {\n            outputs[i] = (assetBalances[i] * factor) / totalUnits;\n        }\n    }\n\n    /***************************************\n                    Pricing\n    ****************************************/\n\n    /**\n     * @notice Returns the total price in 18 digit units for a given asset.\n     *      Never goes above 1, since that is how we price mints.\n     * @param asset address of the asset\n     * @return price uint256: unit (USD / ETH) price for 1 unit of the asset, in 18 decimal fixed\n     */\n    function priceUnitMint(address asset)\n        external\n        view\n        returns (uint256 price)\n    {\n        /* need to supply 1 asset unit in asset's decimals and can not just hard-code\n         * to 1e18 and ignore calling `_toUnits` since we need to consider assets\n         * with the exchange rate\n         */\n        uint256 units = _toUnits(\n            uint256(1e18).scaleBy(_getDecimals(asset), 18),\n            asset\n        );\n        price = (_toUnitPrice(asset, true) * units) / 1e18;\n    }\n\n    /**\n     * @notice Returns the total price in 18 digit unit for a given asset.\n     *      Never goes below 1, since that is how we price redeems\n     * @param asset Address of the asset\n     * @return price uint256: unit (USD / ETH) price for 1 unit of the asset, in 18 decimal fixed\n     */\n    function priceUnitRedeem(address asset)\n        external\n        view\n        returns (uint256 price)\n    {\n        /* need to supply 1 asset unit in asset's decimals and can not just hard-code\n         * to 1e18 and ignore calling `_toUnits` since we need to consider assets\n         * with the exchange rate\n         */\n        uint256 units = _toUnits(\n            uint256(1e18).scaleBy(_getDecimals(asset), 18),\n            asset\n        );\n        price = (_toUnitPrice(asset, false) * units) / 1e18;\n    }\n\n    /***************************************\n                    Utils\n    ****************************************/\n\n    /**\n     * @dev Convert a quantity of a token into 1e18 fixed decimal \"units\"\n     * in the underlying base (USD/ETH) used by the vault.\n     * Price is not taken into account, only quantity.\n     *\n     * Examples of this conversion:\n     *\n     * - 1e18 DAI becomes 1e18 units (same decimals)\n     * - 1e6 USDC becomes 1e18 units (decimal conversion)\n     * - 1e18 rETH becomes 1.2e18 units (exchange rate conversion)\n     *\n     * @param _raw Quantity of asset\n     * @param _asset Core Asset address\n     * @return value 1e18 normalized quantity of units\n     */\n    function _toUnits(uint256 _raw, address _asset)\n        internal\n        view\n        returns (uint256)\n    {\n        UnitConversion conversion = assets[_asset].unitConversion;\n        if (conversion == UnitConversion.DECIMALS) {\n            return _raw.scaleBy(18, _getDecimals(_asset));\n        } else if (conversion == UnitConversion.GETEXCHANGERATE) {\n            uint256 exchangeRate = IGetExchangeRateToken(_asset)\n                .getExchangeRate();\n            return (_raw * exchangeRate) / 1e18;\n        } else {\n            revert(\"Unsupported conversion type\");\n        }\n    }\n\n    /**\n     * @dev Returns asset's unit price accounting for different asset types\n     *      and takes into account the context in which that price exists -\n     *      - mint or redeem.\n     *\n     * Note: since we are returning the price of the unit and not the one of the\n     * asset (see comment above how 1 rETH exchanges for 1.2 units) we need\n     * to make the Oracle price adjustment as well since we are pricing the\n     * units and not the assets.\n     *\n     * The price also snaps to a \"full unit price\" in case a mint or redeem\n     * action would be unfavourable to the protocol.\n     *\n     */\n    function _toUnitPrice(address _asset, bool isMint)\n        internal\n        view\n        returns (uint256 price)\n    {\n        UnitConversion conversion = assets[_asset].unitConversion;\n        price = IOracle(priceProvider).price(_asset);\n\n        if (conversion == UnitConversion.GETEXCHANGERATE) {\n            uint256 exchangeRate = IGetExchangeRateToken(_asset)\n                .getExchangeRate();\n            price = (price * 1e18) / exchangeRate;\n        } else if (conversion != UnitConversion.DECIMALS) {\n            revert(\"Unsupported conversion type\");\n        }\n\n        /* At this stage the price is already adjusted to the unit\n         * so the price checks are agnostic to underlying asset being\n         * pegged to a USD or to an ETH or having a custom exchange rate.\n         */\n        require(price <= MAX_UNIT_PRICE_DRIFT, \"Vault: Price exceeds max\");\n        require(price >= MIN_UNIT_PRICE_DRIFT, \"Vault: Price under min\");\n\n        if (isMint) {\n            /* Never price a normalized unit price for more than one\n             * unit of OETH/OUSD when minting.\n             */\n            if (price > 1e18) {\n                price = 1e18;\n            }\n            require(price >= MINT_MINIMUM_UNIT_PRICE, \"Asset price below peg\");\n        } else {\n            /* Never give out more than 1 normalized unit amount of assets\n             * for one unit of OETH/OUSD when redeeming.\n             */\n            if (price < 1e18) {\n                price = 1e18;\n            }\n        }\n    }\n\n    /**\n     * @dev Get the number of decimals of a token asset\n     * @param _asset Address of the asset\n     * @return decimals number of decimals\n     */\n    function _getDecimals(address _asset)\n        internal\n        view\n        returns (uint256 decimals)\n    {\n        decimals = assets[_asset].decimals;\n        require(decimals > 0, \"Decimals not cached\");\n    }\n\n    /**\n     * @notice Return the number of assets supported by the Vault.\n     */\n    function getAssetCount() public view returns (uint256) {\n        return allAssets.length;\n    }\n\n    /**\n     * @notice Gets the vault configuration of a supported asset.\n     * @param _asset Address of the token asset\n     */\n    function getAssetConfig(address _asset)\n        public\n        view\n        returns (Asset memory config)\n    {\n        config = assets[_asset];\n    }\n\n    /**\n     * @notice Return all vault asset addresses in order\n     */\n    function getAllAssets() external view returns (address[] memory) {\n        return allAssets;\n    }\n\n    /**\n     * @notice Return the number of strategies active on the Vault.\n     */\n    function getStrategyCount() external view returns (uint256) {\n        return allStrategies.length;\n    }\n\n    /**\n     * @notice Return the array of all strategies\n     */\n    function getAllStrategies() external view returns (address[] memory) {\n        return allStrategies;\n    }\n\n    /**\n     * @notice Returns whether the vault supports the asset\n     * @param _asset address of the asset\n     * @return true if supported\n     */\n    function isSupportedAsset(address _asset) external view returns (bool) {\n        return assets[_asset].isSupported;\n    }\n\n    function ADMIN_IMPLEMENTATION() external view returns (address adminImpl) {\n        bytes32 slot = adminImplPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            adminImpl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Falldown to the admin implementation\n     * @notice This is a catch all for all functions not declared in core\n     */\n    // solhint-disable-next-line no-complex-fallback\n    fallback() external {\n        bytes32 slot = adminImplPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(\n                gas(),\n                sload(slot),\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    function abs(int256 x) private pure returns (uint256) {\n        require(x < int256(MAX_INT), \"Amount too high\");\n        return x >= 0 ? uint256(x) : uint256(-x);\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function _max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n}\n"
    },
    "contracts/vault/VaultInitializer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OToken VaultInitializer contract\n * @notice The Vault contract initializes the vault.\n * @author Origin Protocol Inc\n */\n\nimport \"./VaultStorage.sol\";\n\ncontract VaultInitializer is VaultStorage {\n    function initialize(address _priceProvider, address _oToken)\n        external\n        onlyGovernor\n        initializer\n    {\n        require(_priceProvider != address(0), \"PriceProvider address is zero\");\n        require(_oToken != address(0), \"oToken address is zero\");\n\n        oUSD = OUSD(_oToken);\n\n        priceProvider = _priceProvider;\n\n        rebasePaused = false;\n        capitalPaused = true;\n\n        // Initial redeem fee of 0 basis points\n        redeemFeeBps = 0;\n        // Initial Vault buffer of 0%\n        vaultBuffer = 0;\n        // Initial allocate threshold of 25,000 OUSD\n        autoAllocateThreshold = 25000e18;\n        // Threshold for rebasing\n        rebaseThreshold = 1000e18;\n        // Initialize all strategies\n        allStrategies = new address[](0);\n        // Start with drip duration disabled\n        dripDuration = 1;\n    }\n}\n"
    },
    "contracts/vault/VaultStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OToken VaultStorage contract\n * @notice The VaultStorage contract defines the storage for the Vault contracts\n * @author Origin Protocol Inc\n */\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { OUSD } from \"../token/OUSD.sol\";\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport \"../utils/Helpers.sol\";\n\ncontract VaultStorage is Initializable, Governable {\n    using SafeERC20 for IERC20;\n\n    event AssetSupported(address _asset);\n    event AssetRemoved(address _asset);\n    event AssetDefaultStrategyUpdated(address _asset, address _strategy);\n    event AssetAllocated(address _asset, address _strategy, uint256 _amount);\n    event StrategyApproved(address _addr);\n    event StrategyRemoved(address _addr);\n    event Mint(address _addr, uint256 _value);\n    event Redeem(address _addr, uint256 _value);\n    event CapitalPaused();\n    event CapitalUnpaused();\n    event RebasePaused();\n    event RebaseUnpaused();\n    event VaultBufferUpdated(uint256 _vaultBuffer);\n    event OusdMetaStrategyUpdated(address _ousdMetaStrategy);\n    event RedeemFeeUpdated(uint256 _redeemFeeBps);\n    event PriceProviderUpdated(address _priceProvider);\n    event AllocateThresholdUpdated(uint256 _threshold);\n    event RebaseThresholdUpdated(uint256 _threshold);\n    event StrategistUpdated(address _address);\n    event MaxSupplyDiffChanged(uint256 maxSupplyDiff);\n    event YieldDistribution(address _to, uint256 _yield, uint256 _fee);\n    event TrusteeFeeBpsChanged(uint256 _basis);\n    event TrusteeAddressChanged(address _address);\n    event NetOusdMintForStrategyThresholdChanged(uint256 _threshold);\n    event SwapperChanged(address _address);\n    event SwapAllowedUndervalueChanged(uint256 _basis);\n    event SwapSlippageChanged(address _asset, uint256 _basis);\n    event Swapped(\n        address indexed _fromAsset,\n        address indexed _toAsset,\n        uint256 _fromAssetAmount,\n        uint256 _toAssetAmount\n    );\n    event StrategyAddedToMintWhitelist(address indexed strategy);\n    event StrategyRemovedFromMintWhitelist(address indexed strategy);\n    event RebasePerSecondMaxChanged(uint256 rebaseRatePerSecond);\n    event DripDurationChanged(uint256 dripDuration);\n    event WithdrawalRequested(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount,\n        uint256 _queued\n    );\n    event WithdrawalClaimed(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount\n    );\n    event WithdrawalClaimable(uint256 _claimable, uint256 _newClaimable);\n    event WithdrawalClaimDelayUpdated(uint256 _newDelay);\n\n    // Since we are proxy, all state should be uninitalized.\n    // Since this storage contract does not have logic directly on it\n    // we should not be checking for to see if these variables can be constant.\n    // slither-disable-start uninitialized-state\n    // slither-disable-start constable-states\n\n    // Assets supported by the Vault, i.e. Stablecoins\n    enum UnitConversion {\n        DECIMALS,\n        GETEXCHANGERATE\n    }\n    // Changed to fit into a single storage slot so the decimals needs to be recached\n    struct Asset {\n        // Note: OETHVaultCore doesn't use `isSupported` when minting,\n        // redeeming or checking balance of assets.\n        bool isSupported;\n        UnitConversion unitConversion;\n        uint8 decimals;\n        // Max allowed slippage from the Oracle price when swapping collateral assets in basis points.\n        // For example 40 == 0.4% slippage\n        uint16 allowedOracleSlippageBps;\n    }\n\n    /// @dev mapping of supported vault assets to their configuration\n    mapping(address => Asset) internal assets;\n    /// @dev list of all assets supported by the vault.\n    address[] internal allAssets;\n\n    // Strategies approved for use by the Vault\n    struct Strategy {\n        bool isSupported;\n        uint256 _deprecated; // Deprecated storage slot\n    }\n    /// @dev mapping of strategy contracts to their configuration\n    mapping(address => Strategy) public strategies;\n    /// @dev list of all vault strategies\n    address[] internal allStrategies;\n\n    /// @notice Address of the Oracle price provider contract\n    address public priceProvider;\n    /// @notice pause rebasing if true\n    bool public rebasePaused;\n    /// @notice pause operations that change the OToken supply.\n    /// eg mint, redeem, allocate, mint/burn for strategy\n    bool public capitalPaused;\n    /// @notice Redemption fee in basis points. eg 50 = 0.5%\n    uint256 public redeemFeeBps;\n    /// @notice Percentage of assets to keep in Vault to handle (most) withdrawals. 100% = 1e18.\n    uint256 public vaultBuffer;\n    /// @notice OToken mints over this amount automatically allocate funds. 18 decimals.\n    uint256 public autoAllocateThreshold;\n    /// @notice OToken mints over this amount automatically rebase. 18 decimals.\n    uint256 public rebaseThreshold;\n\n    /// @dev Address of the OToken token. eg OUSD or OETH.\n    OUSD public oUSD;\n\n    /// @dev Storage slot for the address of the VaultAdmin contract that is delegated to\n    // keccak256(\"OUSD.vault.governor.admin.impl\");\n    bytes32 public constant adminImplPosition =\n        0xa2bd3d3cf188a41358c8b401076eb59066b09dec5775650c0de4c55187d17bd9;\n\n    /// @dev Address of the contract responsible for post rebase syncs with AMMs\n    address private _deprecated_rebaseHooksAddr = address(0);\n\n    /// @dev Deprecated: Address of Uniswap\n    address private _deprecated_uniswapAddr = address(0);\n\n    /// @notice Address of the Strategist\n    address public strategistAddr = address(0);\n\n    /// @notice Mapping of asset address to the Strategy that they should automatically\n    // be allocated to\n    mapping(address => address) public assetDefaultStrategies;\n\n    /// @notice Max difference between total supply and total value of assets. 18 decimals.\n    uint256 public maxSupplyDiff;\n\n    /// @notice Trustee contract that can collect a percentage of yield\n    address public trusteeAddress;\n\n    /// @notice Amount of yield collected in basis points. eg 2000 = 20%\n    uint256 public trusteeFeeBps;\n\n    /// @dev Deprecated: Tokens that should be swapped for stablecoins\n    address[] private _deprecated_swapTokens;\n\n    uint256 constant MINT_MINIMUM_UNIT_PRICE = 0.998e18;\n\n    /// @notice Metapool strategy that is allowed to mint/burn OTokens without changing collateral\n\n    address public ousdMetaStrategy;\n\n    /// @notice How much OTokens are currently minted by the strategy\n    int256 public netOusdMintedForStrategy;\n\n    /// @notice How much net total OTokens are allowed to be minted by all strategies\n    uint256 public netOusdMintForStrategyThreshold;\n\n    uint256 constant MIN_UNIT_PRICE_DRIFT = 0.7e18;\n    uint256 constant MAX_UNIT_PRICE_DRIFT = 1.3e18;\n\n    /// @notice Collateral swap configuration.\n    /// @dev is packed into a single storage slot to save gas.\n    struct SwapConfig {\n        // Contract that swaps the vault's collateral assets\n        address swapper;\n        // Max allowed percentage the total value can drop below the total supply in basis points.\n        // For example 100 == 1%\n        uint16 allowedUndervalueBps;\n    }\n    SwapConfig internal swapConfig = SwapConfig(address(0), 0);\n\n    // List of strategies that can mint oTokens directly\n    // Used in OETHBaseVaultCore\n    mapping(address => bool) public isMintWhitelistedStrategy;\n\n    /// @notice Address of the Dripper contract that streams harvested rewards to the Vault\n    /// @dev The vault is proxied so needs to be set with setDripper against the proxy contract.\n    address private _deprecated_dripper;\n\n    /// Withdrawal Queue Storage /////\n\n    struct WithdrawalQueueMetadata {\n        // cumulative total of all withdrawal requests included the ones that have already been claimed\n        uint128 queued;\n        // cumulative total of all the requests that can be claimed including the ones that have already been claimed\n        uint128 claimable;\n        // total of all the requests that have been claimed\n        uint128 claimed;\n        // index of the next withdrawal request starting at 0\n        uint128 nextWithdrawalIndex;\n    }\n\n    /// @notice Global metadata for the withdrawal queue including:\n    /// queued - cumulative total of all withdrawal requests included the ones that have already been claimed\n    /// claimable - cumulative total of all the requests that can be claimed including the ones already claimed\n    /// claimed - total of all the requests that have been claimed\n    /// nextWithdrawalIndex - index of the next withdrawal request starting at 0\n    WithdrawalQueueMetadata public withdrawalQueueMetadata;\n\n    struct WithdrawalRequest {\n        address withdrawer;\n        bool claimed;\n        uint40 timestamp; // timestamp of the withdrawal request\n        // Amount of oTokens to redeem. eg OETH\n        uint128 amount;\n        // cumulative total of all withdrawal requests including this one.\n        // this request can be claimed when this queued amount is less than or equal to the queue's claimable amount.\n        uint128 queued;\n    }\n\n    /// @notice Mapping of withdrawal request indices to the user withdrawal request data\n    mapping(uint256 => WithdrawalRequest) public withdrawalRequests;\n\n    /// @notice Sets a minimum delay that is required to elapse between\n    ///     requesting async withdrawals and claiming the request.\n    ///     When set to 0 async withdrawals are disabled.\n    uint256 public withdrawalClaimDelay;\n\n    /// @notice Time in seconds that the vault last rebased yield.\n    uint64 public lastRebase;\n\n    /// @notice Automatic rebase yield calculations. In seconds. Set to 0 or 1 to disable.\n    uint64 public dripDuration;\n\n    /// @notice max rebase percentage per second\n    ///   Can be used to set maximum yield of the protocol,\n    ///   spreading out yield over time\n    uint64 public rebasePerSecondMax;\n\n    /// @notice target rebase rate limit, based on past rates and funds available.\n    uint64 public rebasePerSecondTarget;\n\n    uint256 internal constant MAX_REBASE = 0.02 ether;\n    uint256 internal constant MAX_REBASE_PER_SECOND =\n        uint256(0.05 ether) / 1 days;\n\n    // For future use\n    uint256[43] private __gap;\n\n    // slither-disable-end constable-states\n    // slither-disable-end uninitialized-state\n\n    /**\n     * @notice set the implementation for the admin, this needs to be in a base class else we cannot set it\n     * @param newImpl address of the implementation\n     */\n    function setAdminImpl(address newImpl) external onlyGovernor {\n        require(\n            Address.isContract(newImpl),\n            \"new implementation is not a contract\"\n        );\n        bytes32 position = adminImplPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, newImpl)\n        }\n    }\n}\n"
    },
    "contracts/zapper/WOETHCCIPZapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IRouterClient } from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport { Client } from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\n// solhint-disable-next-line  max-line-length\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC4626 } from \"./../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { IOETHZapper } from \"./../interfaces/IOETHZapper.sol\";\n\n/**\n * @title WOETH CCIP Zapper Contract\n * @notice Helps to directly convert ETH on mainnet into WOETH on L2s.\n * @author Origin Protocol Inc\n */\n\ncontract WOETHCCIPZapper {\n    /**\n     * @dev Event emitted when a zap occurs\n     * @param messageId Unique message identifier for each zap\n     * @param sender Address initiating the zap\n     * @param recipient Recipient address at destination chain\n     * @param amount Amount of ETH zapped\n     */\n    event Zap(\n        bytes32 indexed messageId,\n        address sender,\n        address recipient,\n        uint256 amount\n    );\n\n    // @dev Thrown when Zap amount is less than fee.\n    error AmountLessThanFee();\n\n    /**\n     * @dev The destination chain selector\n     */\n    uint64 public immutable destinationChainSelector;\n\n    /**\n     * @dev The WOETH source chain (Mainnet)\n     */\n    IERC4626 public immutable woethOnSourceChain;\n\n    /**\n     * @dev The WOETH destination chain (Arbitrum)\n     */\n    IERC20 public immutable woethOnDestinationChain;\n\n    /**\n     * @dev The OETH zapper contract address\n     */\n    IOETHZapper public immutable oethZapper;\n\n    /**\n     * @dev The CCIP router contract address\n     */\n    IRouterClient public immutable ccipRouter;\n\n    /**\n     * @dev The OETH token contract address\n     */\n    IERC20 public immutable oeth;\n\n    constructor(\n        address _ccipRouter,\n        uint64 _destinationChainSelector,\n        IERC4626 _woethOnSourceChain,\n        IERC20 _woethOnDestinationChain,\n        IOETHZapper _oethZapper,\n        IERC20 _oeth\n    ) {\n        ccipRouter = IRouterClient(_ccipRouter);\n        destinationChainSelector = _destinationChainSelector;\n        woethOnSourceChain = _woethOnSourceChain;\n        woethOnDestinationChain = _woethOnDestinationChain;\n        oethZapper = _oethZapper;\n        oeth = _oeth;\n\n        // Max allowance for Router and WOETH contracts\n        _oeth.approve(address(_woethOnSourceChain), type(uint256).max); // for wrapping\n        _woethOnSourceChain.approve(address(_ccipRouter), type(uint256).max); // for zapping\n    }\n\n    /**\n     * @notice Accepts ETH, zaps for OETH, wraps it for WOETH and sends it to the destination chain (arbitrum)\n     * @param receiver The address of the EOA on the destination chain\n     * @return messageId The ID of the message that was sent\n     */\n    function zap(address receiver)\n        external\n        payable\n        returns (bytes32 messageId)\n    {\n        return _zap(receiver, msg.value);\n    }\n\n    /**\n     * @notice Used to estimate fee for CCIP transaction\n     * @param amount The amount of ETH to be zapped\n     * @param receiver The address of the EOA on the destination chain\n     * @return feeAmount The CCIP tx fee in ETH.\n     */\n\n    function getFee(uint256 amount, address receiver)\n        public\n        view\n        returns (uint256 feeAmount)\n    {\n        Client.EVMTokenAmount[]\n            memory tokenAmounts = new Client.EVMTokenAmount[](1);\n        Client.EVMTokenAmount memory tokenAmount = Client.EVMTokenAmount({\n            token: address(woethOnSourceChain),\n            amount: amount\n        });\n        tokenAmounts[0] = tokenAmount;\n\n        Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({\n            receiver: abi.encode(receiver), // ABI-encoded receiver address\n            data: abi.encode(\"\"),\n            tokenAmounts: tokenAmounts,\n            extraArgs: Client._argsToBytes(\n                Client.EVMExtraArgsV1({ gasLimit: 0 })\n            ),\n            feeToken: address(0)\n        });\n\n        feeAmount = ccipRouter.getFee(destinationChainSelector, message);\n    }\n\n    /**\n     * @dev Deposit ETH and receive WOETH in L2.\n     * @dev Note that the WOETH will be sent to the msg.sender at destination chain as well.\n     */\n    receive() external payable {\n        _zap(msg.sender, msg.value);\n    }\n\n    function _zap(address receiver, uint256 amount)\n        internal\n        returns (bytes32 messageId)\n    {\n        // Estimate fee for zapping.\n        uint256 feeAmount = getFee(amount, receiver);\n        if (amount < feeAmount) {\n            revert AmountLessThanFee();\n        }\n\n        // Convert only the msg.value - fees amount to WOETH.\n        amount -= feeAmount;\n\n        // 1.) Zap for OETH\n        uint256 oethReceived = oethZapper.deposit{ value: amount }();\n\n        // 2.) Wrap the received woeth\n        uint256 woethReceived = woethOnSourceChain.deposit(\n            oethReceived,\n            address(this)\n        );\n\n        // 3.) Setup params for CCIP transfer\n\n        Client.EVMTokenAmount[]\n            memory tokenAmounts = new Client.EVMTokenAmount[](1);\n        Client.EVMTokenAmount memory tokenAmount = Client.EVMTokenAmount({\n            token: address(woethOnSourceChain),\n            amount: woethReceived\n        });\n        tokenAmounts[0] = tokenAmount;\n\n        Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({\n            receiver: abi.encode(receiver), // ABI-encoded receiver address\n            data: abi.encode(\"\"),\n            tokenAmounts: tokenAmounts,\n            extraArgs: Client._argsToBytes(\n                // See: https://docs.chain.link/ccip/best-practices#setting-gaslimit\n                Client.EVMExtraArgsV1({ gasLimit: 0 })\n            ),\n            feeToken: address(0)\n        });\n\n        // ZAP ϟ\n        //slither-disable-next-line arbitrary-send-eth\n        messageId = ccipRouter.ccipSend{ value: feeAmount }(\n            destinationChainSelector,\n            message\n        );\n\n        // Emit Zap event with message details\n        emit Zap(messageId, msg.sender, receiver, amount);\n\n        // Return the message ID\n        return messageId;\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n"
    },
    "lib/openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC4626 } from \"../../../../interfaces/IERC4626.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n// From Open Zeppelin draft PR commit:\n// fac43034dca85ff539db3fc8aa2a7084b843d454\n// https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3171\n\nabstract contract ERC4626 is ERC20, IERC4626 {\n    IERC20Metadata private immutable _asset;\n\n    constructor(IERC20Metadata __asset) {\n        _asset = __asset;\n    }\n\n    /** @dev See {IERC4262-asset} */\n    function asset() public view virtual override returns (address) {\n        return address(_asset);\n    }\n\n    /** @dev See {IERC4262-totalAssets} */\n    function totalAssets() public view virtual override returns (uint256) {\n        return _asset.balanceOf(address(this));\n    }\n\n    /**\n     * @dev See {IERC4262-convertToShares}\n     *\n     * Will revert if asserts > 0, totalSupply > 0 and totalAssets = 0. That corresponds to a case where any asset\n     * would represent an infinite amout of shares.\n     */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n\n        return\n            (assets == 0 || supply == 0)\n                ? (assets * 10**decimals()) / 10**_asset.decimals()\n                : (assets * supply) / totalAssets();\n    }\n\n    /** @dev See {IERC4262-convertToAssets} */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n\n        return (supply == 0) ? (shares * 10**_asset.decimals()) / 10**decimals() : (shares * totalAssets()) / supply;\n    }\n\n    /** @dev See {IERC4262-maxDeposit} */\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4262-maxMint} */\n    function maxMint(address) public view virtual override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4262-maxWithdraw} */\n    function maxWithdraw(address owner) public view virtual override returns (uint256) {\n        return convertToAssets(balanceOf(owner));\n    }\n\n    /** @dev See {IERC4262-maxRedeem} */\n    function maxRedeem(address owner) public view virtual override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4262-previewDeposit} */\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /** @dev See {IERC4262-previewMint} */\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        uint256 assets = convertToAssets(shares);\n        return assets + (convertToShares(assets) < shares ? 1 : 0);\n    }\n\n    /** @dev See {IERC4262-previewWithdraw} */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        uint256 shares = convertToShares(assets);\n        return shares + (convertToAssets(shares) < assets ? 1 : 0);\n    }\n\n    /** @dev See {IERC4262-previewRedeem} */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /** @dev See {IERC4262-deposit} */\n    function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {\n        require(assets <= maxDeposit(receiver), \"ERC4626: deposit more then max\");\n\n        address caller = _msgSender();\n        uint256 shares = previewDeposit(assets);\n\n        // if _asset is ERC777, transferFrom can call reenter BEFORE the transfer happens through\n        // the tokensToSend hook, so we need to transfer before we mint to keep the invariants.\n        SafeERC20.safeTransferFrom(_asset, caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4262-mint} */\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256) {\n        require(shares <= maxMint(receiver), \"ERC4626: mint more then max\");\n\n        address caller = _msgSender();\n        uint256 assets = previewMint(shares);\n\n        // if _asset is ERC777, transferFrom can call reenter BEFORE the transfer happens through\n        // the tokensToSend hook, so we need to transfer before we mint to keep the invariants.\n        SafeERC20.safeTransferFrom(_asset, caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n\n        return assets;\n    }\n\n    /** @dev See {IERC4262-withdraw} */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(assets <= maxWithdraw(owner), \"ERC4626: withdraw more then max\");\n\n        address caller = _msgSender();\n        uint256 shares = previewWithdraw(assets);\n\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // if _asset is ERC777, transfer can call reenter AFTER the transfer happens through\n        // the tokensReceived hook, so we need to transfer after we burn to keep the invariants.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(_asset, receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4262-redeem} */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(shares <= maxRedeem(owner), \"ERC4626: redeem more then max\");\n\n        address caller = _msgSender();\n        uint256 assets = previewRedeem(shares);\n\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // if _asset is ERC777, transfer can call reenter AFTER the transfer happens through\n        // the tokensReceived hook, so we need to transfer after we burn to keep the invariants.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(_asset, receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    // Included here, since this method was not yet present in\n    // the version of Open Zeppelin ERC20 code we use.\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n}"
    },
    "lib/openzeppelin/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n}"
    },
    "lib/rooster/openzeppelin-custom/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2²⁵⁶ + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2²⁵⁶ + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2²⁵⁶ + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}"
    },
    "lib/rooster/openzeppelin-custom/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}"
    },
    "lib/rooster/openzeppelin-custom/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}"
    },
    "lib/rooster/v2-common/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// As the copyright holder of this work, Ubiquity Labs retains\n// the right to distribute, use, and modify this code under any license of\n// their choosing, in addition to the terms of the GPL-v2 or later.\npragma solidity ^0.8.25;\n\n// factory contraints on pools\nuint8 constant MAX_PROTOCOL_FEE_RATIO_D3 = 0.25e3; // 25%\nuint256 constant MAX_PROTOCOL_LENDING_FEE_RATE_D18 = 0.02e18; // 2%\nuint64 constant MAX_POOL_FEE_D18 = 0.9e18; // 90%\nuint64 constant MIN_LOOKBACK = 1 seconds;\n\n// pool constraints\nuint8 constant NUMBER_OF_KINDS = 4;\nint32 constant NUMBER_OF_KINDS_32 = int32(int8(NUMBER_OF_KINDS));\nuint256 constant MAX_TICK = 322_378; // max price 1e14 in D18 scale\nint32 constant MAX_TICK_32 = int32(int256(MAX_TICK));\nint32 constant MIN_TICK_32 = int32(-int256(MAX_TICK));\nuint256 constant MAX_BINS_TO_MERGE = 3;\nuint128 constant MINIMUM_LIQUIDITY = 1e8;\n\n// accessor named constants\nuint8 constant ALL_KINDS_MASK = 0xF; // 0b1111\nuint8 constant PERMISSIONED_LIQUIDITY_MASK = 0x10; // 0b010000\nuint8 constant PERMISSIONED_SWAP_MASK = 0x20; // 0b100000\nuint8 constant OPTIONS_MASK = ALL_KINDS_MASK | PERMISSIONED_LIQUIDITY_MASK | PERMISSIONED_SWAP_MASK; // 0b111111\n\n// named values\naddress constant MERGED_LP_BALANCE_ADDRESS = address(0);\nuint256 constant MERGED_LP_BALANCE_SUBACCOUNT = 0;\nuint128 constant ONE = 1e18;\nuint128 constant ONE_SQUARED = 1e36;\nint256 constant INT256_ONE = 1e18;\nuint256 constant ONE_D8 = 1e8;\nuint256 constant ONE_D3 = 1e3;\nint40 constant INT_ONE_D8 = 1e8;\nint40 constant HALF_TICK_D8 = 0.5e8;\nuint8 constant DEFAULT_DECIMALS = 18;\nuint256 constant DEFAULT_SCALE = 1;\nbytes constant EMPTY_PRICE_BREAKS = hex\"010000000000000000000000\";"
    },
    "lib/rooster/v2-common/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// As the copyright holder of this work, Ubiquity Labs retains\n// the right to distribute, use, and modify this code under any license of\n// their choosing, in addition to the terms of the GPL-v2 or later.\npragma solidity ^0.8.25;\n\nimport {Math as OzMath} from \"../../openzeppelin-custom/contracts/utils/math/Math.sol\";\n\nimport {ONE, DEFAULT_SCALE, DEFAULT_DECIMALS, INT_ONE_D8, ONE_SQUARED} from \"./Constants.sol\";\n\n/**\n * @notice Math functions.\n */\nlibrary Math {\n    /**\n     * @notice Returns the lesser of two values.\n     * @param x First uint256 value.\n     * @param y Second uint256 value.\n     */\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly (\"memory-safe\") {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /**\n     * @notice Returns the lesser of two uint128 values.\n     * @param x First uint128 value.\n     * @param y Second uint128 value.\n     */\n    function min128(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        assembly (\"memory-safe\") {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /**\n     * @notice Returns the lesser of two int256 values.\n     * @param x First int256 value.\n     * @param y Second int256 value.\n     */\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\n        assembly (\"memory-safe\") {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }\n\n    /**\n     * @notice Returns the greater of two uint256 values.\n     * @param x First uint256 value.\n     * @param y Second uint256 value.\n     */\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly (\"memory-safe\") {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /**\n     * @notice Returns the greater of two int256 values.\n     * @param x First int256 value.\n     * @param y Second int256 value.\n     */\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\n        assembly (\"memory-safe\") {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }\n\n    /**\n     * @notice Returns the greater of two uint128 values.\n     * @param x First uint128 value.\n     * @param y Second uint128 value.\n     */\n    function max128(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        assembly (\"memory-safe\") {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /**\n     * @notice Thresholds a value to be within the specified bounds.\n     * @param value The value to bound.\n     * @param lowerLimit The minimum allowable value.\n     * @param upperLimit The maximum allowable value.\n     */\n    function boundValue(\n        uint256 value,\n        uint256 lowerLimit,\n        uint256 upperLimit\n    ) internal pure returns (uint256 outputValue) {\n        outputValue = min(max(value, lowerLimit), upperLimit);\n    }\n\n    /**\n     * @notice Returns the difference between two uint128 values or zero if the result would be negative.\n     * @param x The minuend.\n     * @param y The subtrahend.\n     */\n    function clip128(uint128 x, uint128 y) internal pure returns (uint128) {\n        unchecked {\n            return x < y ? 0 : x - y;\n        }\n    }\n\n    /**\n     * @notice Returns the difference between two uint256 values or zero if the result would be negative.\n     * @param x The minuend.\n     * @param y The subtrahend.\n     */\n    function clip(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            return x < y ? 0 : x - y;\n        }\n    }\n\n    /**\n     * @notice Divides one uint256 by another, rounding down to the nearest\n     * integer.\n     * @param x The dividend.\n     * @param y The divisor.\n     */\n    function divFloor(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivFloor(x, ONE, y);\n    }\n\n    /**\n     * @notice Divides one uint256 by another, rounding up to the nearest integer.\n     * @param x The dividend.\n     * @param y The divisor.\n     */\n    function divCeil(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivCeil(x, ONE, y);\n    }\n\n    /**\n     * @notice Multiplies two uint256 values and then divides by ONE, rounding down.\n     * @param x The multiplicand.\n     * @param y The multiplier.\n     */\n    function mulFloor(uint256 x, uint256 y) internal pure returns (uint256) {\n        return OzMath.mulDiv(x, y, ONE);\n    }\n\n    /**\n     * @notice Multiplies two uint256 values and then divides by ONE, rounding up.\n     * @param x The multiplicand.\n     * @param y The multiplier.\n     */\n    function mulCeil(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivCeil(x, y, ONE);\n    }\n\n    /**\n     * @notice Calculates the multiplicative inverse of a uint256, rounding down.\n     * @param x The value to invert.\n     */\n    function invFloor(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return ONE_SQUARED / x;\n        }\n    }\n\n    /**\n     * @notice Calculates the multiplicative inverse of a uint256, rounding up.\n     * @param denominator The value to invert.\n     */\n    function invCeil(uint256 denominator) internal pure returns (uint256 z) {\n        assembly (\"memory-safe\") {\n            // divide z - 1 by the denominator and add 1.\n            z := add(div(sub(ONE_SQUARED, 1), denominator), 1)\n        }\n    }\n\n    /**\n     * @notice Multiplies two uint256 values and divides by a third, rounding down.\n     * @param x The multiplicand.\n     * @param y The multiplier.\n     * @param k The divisor.\n     */\n    function mulDivFloor(uint256 x, uint256 y, uint256 k) internal pure returns (uint256 result) {\n        result = OzMath.mulDiv(x, y, max(1, k));\n    }\n\n    /**\n     * @notice Multiplies two uint256 values and divides by a third, rounding up if there's a remainder.\n     * @param x The multiplicand.\n     * @param y The multiplier.\n     * @param k The divisor.\n     */\n    function mulDivCeil(uint256 x, uint256 y, uint256 k) internal pure returns (uint256 result) {\n        result = mulDivFloor(x, y, k);\n        if (mulmod(x, y, max(1, k)) != 0) result = result + 1;\n    }\n\n    /**\n     * @notice Multiplies two uint256 values and divides by a third, rounding\n     * down. Will revert if `x * y` is larger than `type(uint256).max`.\n     * @param x The first operand for multiplication.\n     * @param y The second operand for multiplication.\n     * @param denominator The divisor after multiplication.\n     */\n    function mulDivDown(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 z) {\n        assembly (\"memory-safe\") {\n            // Store x * y in z for now.\n            z := mul(x, y)\n            if iszero(denominator) {\n                denominator := 1\n            }\n\n            if iszero(or(iszero(x), eq(div(z, x), y))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    /**\n     * @notice Multiplies two uint256 values and divides by a third, rounding\n     * up. Will revert if `x * y` is larger than `type(uint256).max`.\n     * @param x The first operand for multiplication.\n     * @param y The second operand for multiplication.\n     * @param denominator The divisor after multiplication.\n     */\n    function mulDivUp(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 z) {\n        assembly (\"memory-safe\") {\n            // Store x * y in z for now.\n            z := mul(x, y)\n            if iszero(denominator) {\n                denominator := 1\n            }\n\n            if iszero(or(iszero(x), eq(div(z, x), y))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    /**\n     * @notice Multiplies a uint256 by another and divides by a constant,\n     * rounding down. Will revert if `x * y` is larger than\n     * `type(uint256).max`.\n     * @param x The multiplicand.\n     * @param y The multiplier.\n     */\n    function mulDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, ONE);\n    }\n\n    /**\n     * @notice Divides a uint256 by another, rounding down the result. Will\n     * revert if `x * 1e18` is larger than `type(uint256).max`.\n     * @param x The dividend.\n     * @param y The divisor.\n     */\n    function divDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, ONE, y);\n    }\n\n    /**\n     * @notice Divides a uint256 by another, rounding up the result. Will\n     * revert if `x * 1e18` is larger than `type(uint256).max`.\n     * @param x The dividend.\n     * @param y The divisor.\n     */\n    function divUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, ONE, y);\n    }\n\n    /**\n     * @notice Scales a number based on a difference in decimals from a default.\n     * @param decimals The new decimal precision.\n     */\n    function scale(uint8 decimals) internal pure returns (uint256) {\n        unchecked {\n            if (decimals == DEFAULT_DECIMALS) {\n                return DEFAULT_SCALE;\n            } else {\n                return 10 ** (DEFAULT_DECIMALS - decimals);\n            }\n        }\n    }\n\n    /**\n     * @notice Adjusts a scaled amount to the token decimal scale.\n     * @param amount The scaled amount.\n     * @param scaleFactor The scaling factor to adjust by.\n     * @param ceil Whether to round up (true) or down (false).\n     */\n    function ammScaleToTokenScale(uint256 amount, uint256 scaleFactor, bool ceil) internal pure returns (uint256 z) {\n        unchecked {\n            if (scaleFactor == DEFAULT_SCALE || amount == 0) {\n                return amount;\n            } else {\n                if (!ceil) return amount / scaleFactor;\n                assembly (\"memory-safe\") {\n                    z := add(div(sub(amount, 1), scaleFactor), 1)\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Adjusts a token amount to the D18 AMM scale.\n     * @param amount The amount in token scale.\n     * @param scaleFactor The scale factor for adjustment.\n     */\n    function tokenScaleToAmmScale(uint256 amount, uint256 scaleFactor) internal pure returns (uint256) {\n        if (scaleFactor == DEFAULT_SCALE) {\n            return amount;\n        } else {\n            return amount * scaleFactor;\n        }\n    }\n\n    /**\n     * @notice Returns the absolute value of a signed 32-bit integer.\n     * @param x The integer to take the absolute value of.\n     */\n    function abs32(int32 x) internal pure returns (uint32) {\n        unchecked {\n            return uint32(x < 0 ? -x : x);\n        }\n    }\n\n    /**\n     * @notice Returns the absolute value of a signed 256-bit integer.\n     * @param x The integer to take the absolute value of.\n     */\n    function abs(int256 x) internal pure returns (uint256) {\n        unchecked {\n            return uint256(x < 0 ? -x : x);\n        }\n    }\n\n    /**\n     * @notice Calculates the integer square root of a uint256 rounded down.\n     * @param x The number to take the square root of.\n     */\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        // from https://github.com/transmissions11/solmate/blob/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/FixedPointMathLib.sol\n        assembly (\"memory-safe\") {\n            let y := x\n            z := 181\n\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            z := shr(18, mul(z, add(y, 65536)))\n\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /**\n     * @notice Computes the floor of a D8-scaled number as an int32, ignoring\n     * potential overflow in the cast.\n     * @param val The D8-scaled number.\n     */\n    function floorD8Unchecked(int256 val) internal pure returns (int32) {\n        int32 val32;\n        bool check;\n        unchecked {\n            val32 = int32(val / INT_ONE_D8);\n            check = (val < 0 && val % INT_ONE_D8 != 0);\n        }\n        return check ? val32 - 1 : val32;\n    }\n}"
    },
    "lib/rooster/v2-common/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// As the copyright holder of this work, Ubiquity Labs retains\n// the right to distribute, use, and modify this code under any license of\n// their choosing, in addition to the terms of the GPL-v2 or later.\npragma solidity ^0.8.25;\n\nimport {Math as OzMath} from \"../../openzeppelin-custom/contracts/utils/math/Math.sol\";\nimport {Math} from \"./Math.sol\";\nimport {MAX_TICK, ONE} from \"./Constants.sol\";\n\n/**\n * @notice Math functions related to tick operations.\n */\n// slither-disable-start divide-before-multiply\nlibrary TickMath {\n    using Math for uint256;\n\n    error TickMaxExceeded(int256 tick);\n\n    /**\n     * @notice Compute the lower and upper sqrtPrice of a tick.\n     * @param tickSpacing The tick spacing used for calculations.\n     * @param _tick The input tick value.\n     */\n    function tickSqrtPrices(\n        uint256 tickSpacing,\n        int32 _tick\n    ) internal pure returns (uint256 sqrtLowerPrice, uint256 sqrtUpperPrice) {\n        unchecked {\n            sqrtLowerPrice = tickSqrtPrice(tickSpacing, _tick);\n            sqrtUpperPrice = tickSqrtPrice(tickSpacing, _tick + 1);\n        }\n    }\n\n    /**\n     * @notice Compute the base tick value from the pool tick and the\n     * tickSpacing.  Revert if base tick is beyond the max tick boundary.\n     * @param tickSpacing The tick spacing used for calculations.\n     * @param _tick The input tick value.\n     */\n    function subTickIndex(uint256 tickSpacing, int32 _tick) internal pure returns (uint32 subTick) {\n        subTick = Math.abs32(_tick);\n        subTick *= uint32(tickSpacing);\n        if (subTick > MAX_TICK) {\n            revert TickMaxExceeded(_tick);\n        }\n    }\n\n    /**\n     * @notice Calculate the square root price for a given tick and tick spacing.\n     * @param tickSpacing The tick spacing used for calculations.\n     * @param _tick The input tick value.\n     * @return _result The square root price.\n     */\n    function tickSqrtPrice(uint256 tickSpacing, int32 _tick) internal pure returns (uint256 _result) {\n        unchecked {\n            uint256 tick = subTickIndex(tickSpacing, _tick);\n\n            uint256 ratio = tick & 0x1 != 0 ? 0xfffcb933bd6fad9d3af5f0b9f25db4d6 : 0x100000000000000000000000000000000;\n            if (tick & 0x2 != 0) ratio = (ratio * 0xfff97272373d41fd789c8cb37ffcaa1c) >> 128;\n            if (tick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656ac9229c67059486f389) >> 128;\n            if (tick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e81259b3cddc7a064941) >> 128;\n            if (tick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f67b19e8887e0bd251eb7) >> 128;\n            if (tick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98cd2e57b660be99eb2c4a) >> 128;\n            if (tick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c9838804e327cb417cafcb) >> 128;\n            if (tick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99d51e2cc356c2f617dbe0) >> 128;\n            if (tick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900aecf64236ab31f1f9dcb5) >> 128;\n            if (tick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac4d9194200696907cf2e37) >> 128;\n            if (tick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b88206f8abe8a3b44dd9be) >> 128;\n            if (tick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c578ef4f1d17b2b235d480) >> 128;\n            if (tick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd254ee83bdd3f248e7e785e) >> 128;\n            if (tick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d8f7dd10e744d913d033333) >> 128;\n            if (tick & 0x4000 != 0) ratio = (ratio * 0x70d869a156ddd32a39e257bc3f50aa9b) >> 128;\n            if (tick & 0x8000 != 0) ratio = (ratio * 0x31be135f97da6e09a19dc367e3b6da40) >> 128;\n            if (tick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7e5a9780b0cc4e25d61a56) >> 128;\n            if (tick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedbcb3a6ccb7ce618d14225) >> 128;\n            if (tick & 0x40000 != 0) ratio = (ratio * 0x2216e584f630389b2052b8db590e) >> 128;\n            if (_tick > 0) ratio = type(uint256).max / ratio;\n            _result = (ratio * ONE) >> 128;\n        }\n    }\n\n    /**\n     * @notice Calculate liquidity of a tick.\n     * @param reserveA Tick reserve of token A.\n     * @param reserveB Tick reserve of token B.\n     * @param sqrtLowerTickPrice The square root price of the lower tick edge.\n     * @param sqrtUpperTickPrice The square root price of the upper tick edge.\n     */\n    function getTickL(\n        uint256 reserveA,\n        uint256 reserveB,\n        uint256 sqrtLowerTickPrice,\n        uint256 sqrtUpperTickPrice\n    ) internal pure returns (uint256 liquidity) {\n        // known:\n        // - sqrt price values are different\n        // - reserveA and reserveB fit in 128 bit\n        // - sqrt price is in (1e-7, 1e7)\n        // - D18 max for uint256 is 1.15e59\n        // - D18 min is 1e-18\n\n        unchecked {\n            // diff is in (5e-12, 4e6); max tick spacing is 10_000\n            uint256 diff = sqrtUpperTickPrice - sqrtLowerTickPrice;\n\n            // Need to maximize precision by shifting small values A and B up so\n            // that they use more of the available bit range. Two constraints to\n            // consider: we need A * B * diff / sqrtPrice to be bigger than 1e-18\n            // when the bump is not in play.  This constrains the threshold for\n            // bumping to be at least 77 bit; ie, either a or b needs 2^77 which\n            // means that term A * B * diff / sqrtPrice > 1e-18.\n            //\n            // At the other end, the second constraint is that b^2 needs to fit in\n            // a 256-bit number, so, post bump, the max reserve value needs to be\n            // less than 6e22. With a 78-bit threshold and a 57-bit bump, we have A\n            // and B are in (1.4e-1, 4.4e22 (2^(78+57))) with bump, and one of A or\n            // B is at least 2^78 without the bump, but the other reserve value may\n            // be as small as 1 wei.\n            uint256 precisionBump = 0;\n            if ((reserveA >> 78) == 0 && (reserveB >> 78) == 0) {\n                precisionBump = 57;\n                reserveA <<= precisionBump;\n                reserveB <<= precisionBump;\n            }\n\n            if (reserveB == 0) return Math.divDown(reserveA, diff) >> precisionBump;\n            if (reserveA == 0)\n                return Math.mulDivDown(reserveB.mulDown(sqrtLowerTickPrice), sqrtUpperTickPrice, diff) >> precisionBump;\n\n            // b is in (7.2e-9 (2^57 / 1e7 / 2), 2.8e29  (2^(78+57) * 1e7 / 2)) with bump\n            // b is in a subset of the same range without bump\n            uint256 b = (reserveA.divDown(sqrtUpperTickPrice) + reserveB.mulDown(sqrtLowerTickPrice)) >> 1;\n\n            // b^2 is in (5.1e-17, 4.8e58); and will not overflow on either end;\n            // A*B is in (3e-13 (2^78 / 1e18 * 1e-18), 1.9e45) without bump and is in a subset range with bump\n            // A*B*diff/sqrtUpper is in (1.5e-17 (3e-13 * 5e-12 * 1e7), 7.6e58);\n\n            // Since b^2 is at the upper edge of the precision range, we are not\n            // able to multiply the argument of the sqrt by 1e18, instead, we move\n            // this factor outside of the sqrt. The resulting loss of precision\n            // means that this liquidity value is a lower bound on the tick\n            // liquidity\n            return\n                OzMath.mulDiv(\n                    b +\n                        Math.sqrt(\n                            (OzMath.mulDiv(b, b, ONE) +\n                                OzMath.mulDiv(reserveB.mulFloor(reserveA), diff, sqrtUpperTickPrice))\n                        ) *\n                        1e9,\n                    sqrtUpperTickPrice,\n                    diff\n                ) >> precisionBump;\n        }\n    }\n\n    /**\n     * @notice Calculate square root price of a tick. Returns left edge of the\n     * tick if the tick has no reserves.\n     * @param reserveA Tick reserve of token A.\n     * @param reserveB Tick reserve of token B.\n     * @param sqrtLowerTickPrice The square root price of the lower tick edge.\n     * @param sqrtUpperTickPrice The square root price of the upper tick edge.\n     * @return sqrtPrice The calculated square root price.\n     */\n    function getSqrtPrice(\n        uint256 reserveA,\n        uint256 reserveB,\n        uint256 sqrtLowerTickPrice,\n        uint256 sqrtUpperTickPrice,\n        uint256 liquidity\n    ) internal pure returns (uint256 sqrtPrice) {\n        unchecked {\n            if (reserveA == 0) {\n                return sqrtLowerTickPrice;\n            }\n            if (reserveB == 0) {\n                return sqrtUpperTickPrice;\n            }\n            sqrtPrice = Math.sqrt(\n                ONE *\n                    (reserveA + liquidity.mulDown(sqrtLowerTickPrice)).divDown(\n                        reserveB + liquidity.divDown(sqrtUpperTickPrice)\n                    )\n            );\n            sqrtPrice = Math.boundValue(sqrtPrice, sqrtLowerTickPrice, sqrtUpperTickPrice);\n        }\n    }\n\n    /**\n     * @notice Calculate square root price of a tick. Returns left edge of the\n     * tick if the tick has no reserves.\n     * @param reserveA Tick reserve of token A.\n     * @param reserveB Tick reserve of token B.\n     * @param sqrtLowerTickPrice The square root price of the lower tick edge.\n     * @param sqrtUpperTickPrice The square root price of the upper tick edge.\n     * @return sqrtPrice The calculated square root price.\n     * @return liquidity The calculated liquidity.\n     */\n    function getTickSqrtPriceAndL(\n        uint256 reserveA,\n        uint256 reserveB,\n        uint256 sqrtLowerTickPrice,\n        uint256 sqrtUpperTickPrice\n    ) internal pure returns (uint256 sqrtPrice, uint256 liquidity) {\n        liquidity = getTickL(reserveA, reserveB, sqrtLowerTickPrice, sqrtUpperTickPrice);\n        sqrtPrice = getSqrtPrice(reserveA, reserveB, sqrtLowerTickPrice, sqrtUpperTickPrice, liquidity);\n    }\n}\n// slither-disable-end divide-before-multiply"
    },
    "solidity-bytes-utils/contracts/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        // We're using the unchecked block below because otherwise execution ends \n        // with the native overflow error code.\n        unchecked {\n            require(_length + 31 >= _length, \"slice_overflow\");\n        }\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}