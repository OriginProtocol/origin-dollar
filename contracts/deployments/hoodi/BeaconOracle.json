{
  "address": "0x246594d0276ffAeB0442c3edcdfB026e6924B3B3",
  "abi": [
    {
      "inputs": [],
      "name": "InvalidProofLength",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "blockRoot",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "blockNumber",
          "type": "uint64"
        },
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "slot",
          "type": "uint64"
        }
      ],
      "name": "BlockToSlot",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "blockNumber",
          "type": "uint64"
        }
      ],
      "name": "blockToSlot",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "slot",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "blockNumber",
          "type": "uint64"
        }
      ],
      "name": "isBlockMapped",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "slot",
          "type": "uint64"
        }
      ],
      "name": "isSlotMapped",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "slot",
          "type": "uint64"
        }
      ],
      "name": "slotToBlock",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "blockNumber",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "slot",
          "type": "uint64"
        }
      ],
      "name": "slotToRoot",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "blockRoot",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "nextBlockTimestamp",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "blockNumber",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "slot",
          "type": "uint64"
        },
        {
          "internalType": "bytes",
          "name": "slotProof",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "blockProof",
          "type": "bytes"
        }
      ],
      "name": "verifySlot",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "blockRoot",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x6190f8fcd61729af5f4fb7465f838c78c1ccb30dca316d9167cd63b9168ae972",
  "receipt": {
    "to": null,
    "from": "0xFD9E6005187F448957a0972a7d0C0A6dA2911236",
    "contractAddress": "0x246594d0276ffAeB0442c3edcdfB026e6924B3B3",
    "transactionIndex": 2,
    "gasUsed": "559627",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x879ebbfe6031668744292e95430d8bd4666eccdfc8cb6bdd12b9b9ff66207cca",
    "transactionHash": "0x6190f8fcd61729af5f4fb7465f838c78c1ccb30dca316d9167cd63b9168ae972",
    "logs": [],
    "blockNumber": 828254,
    "cumulativeGasUsed": "601627",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "e971b2fb0f925bb0e94e79f6b234f436",
  "metadata": "{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"InvalidProofLength\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"blockRoot\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"}],\"name\":\"BlockToSlot\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"}],\"name\":\"blockToSlot\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"}],\"name\":\"isBlockMapped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"}],\"name\":\"isSlotMapped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"}],\"name\":\"slotToBlock\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"}],\"name\":\"slotToRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"blockRoot\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"nextBlockTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"slotProof\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"blockProof\",\"type\":\"bytes\"}],\"name\":\"verifySlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"blockRoot\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Origin Protocol Inc\",\"kind\":\"dev\",\"methods\":{\"verifySlot(uint64,uint64,uint64,bytes,bytes)\":{\"params\":{\"blockNumber\":\"The execution layer block number.\",\"blockProof\":\"The merkle proof witnesses for the block number against the beacon block root.\",\"nextBlockTimestamp\":\"The timestamp of the block after the one being proven.\",\"slot\":\"The beacon chain slot.\",\"slotProof\":\"The merkle proof witnesses for the slot against the beacon block root.\"}}},\"title\":\"Beacon Chain Oracle\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"blockToSlot(uint64)\":{\"notice\":\"Returns the beacon chain slot for a given execution layer block number.\"},\"isBlockMapped(uint64)\":{\"notice\":\"Returns true if an execution layer block number has been mapped to a beacon chain slot.\"},\"isSlotMapped(uint64)\":{\"notice\":\"Returns true if a beacon chain slot has been mapped to an execution layer block number.\"},\"slotToBlock(uint64)\":{\"notice\":\"Returns the execution layer block number for a given beacon chain slot.\"},\"slotToRoot(uint64)\":{\"notice\":\"Returns the beacon block root for a given beacon chain slot.\"},\"verifySlot(uint64,uint64,uint64,bytes,bytes)\":{\"notice\":\"Uses merkle a proof against the beacon block root to link an execution layer block number to a beacon chain slot.\"}},\"notice\":\"An Oracle for mapping execution layer block numbers to beacon chain slots.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/beacon/BeaconOracle.sol\":\"BeaconOracle\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/beacon/BeaconOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { BeaconProofsLib } from \\\"./BeaconProofsLib.sol\\\";\\nimport { BeaconRoots } from \\\"./BeaconRoots.sol\\\";\\n\\n/// @title Beacon Chain Oracle\\n/// @notice An Oracle for mapping execution layer block numbers to beacon chain slots.\\n/// @author Origin Protocol Inc\\ncontract BeaconOracle {\\n    /// @notice Maps a block number to slot\\n    mapping(uint64 => uint64) internal _blockToSlot;\\n    /// @notice Maps a slot to a number\\n    mapping(uint64 => uint64) internal _slotToBlock;\\n    /// @notice Maps a slot to a beacon block root\\n    mapping(uint64 => bytes32) internal _slotToRoot;\\n\\n    event BlockToSlot(\\n        bytes32 indexed blockRoot,\\n        uint64 indexed blockNumber,\\n        uint64 indexed slot\\n    );\\n\\n    /// @notice Uses merkle a proof against the beacon block root to link\\n    /// an execution layer block number to a beacon chain slot.\\n    /// @param nextBlockTimestamp The timestamp of the block after the one being proven.\\n    /// @param blockNumber The execution layer block number.\\n    /// @param slot The beacon chain slot.\\n    /// @param slotProof The merkle proof witnesses for the slot against the beacon block root.\\n    /// @param blockProof The merkle proof witnesses for the block number against the beacon block root.\\n    function verifySlot(\\n        uint64 nextBlockTimestamp,\\n        uint64 blockNumber,\\n        uint64 slot,\\n        bytes calldata slotProof,\\n        bytes calldata blockProof\\n    ) external returns (bytes32 blockRoot) {\\n        require(_blockToSlot[blockNumber] == 0, \\\"Block already mapped\\\");\\n\\n        // Get the parent beacon block root for the given timestamp.\\n        // This is the beacon block root of the previous slot.\\n        blockRoot = BeaconRoots.parentBlockRoot(nextBlockTimestamp);\\n\\n        // Verify the slot to the beacon block root\\n        BeaconProofsLib.verifySlot(blockRoot, slot, slotProof);\\n\\n        // Verify the block number to the beacon block root\\n        BeaconProofsLib.verifyBlockNumber(blockRoot, blockNumber, blockProof);\\n\\n        // Store mappings\\n        _blockToSlot[blockNumber] = slot;\\n        _slotToBlock[slot] = blockNumber;\\n        _slotToRoot[slot] = blockRoot;\\n\\n        emit BlockToSlot(blockRoot, blockNumber, slot);\\n    }\\n\\n    /// @notice Returns the beacon chain slot for a given execution layer block number.\\n    function blockToSlot(uint64 blockNumber)\\n        external\\n        view\\n        returns (uint64 slot)\\n    {\\n        slot = _blockToSlot[blockNumber];\\n\\n        require(slot != 0, \\\"Block not mapped\\\");\\n    }\\n\\n    /// @notice Returns the execution layer block number for a given beacon chain slot.\\n    function slotToBlock(uint64 slot)\\n        external\\n        view\\n        returns (uint64 blockNumber)\\n    {\\n        blockNumber = _slotToBlock[slot];\\n\\n        require(blockNumber != 0, \\\"Slot not mapped\\\");\\n    }\\n\\n    /// @notice Returns the beacon block root for a given beacon chain slot.\\n    function slotToRoot(uint64 slot) external view returns (bytes32 blockRoot) {\\n        blockRoot = _slotToRoot[slot];\\n\\n        require(blockRoot != 0, \\\"Slot not mapped\\\");\\n    }\\n\\n    /// @notice Returns true if an execution layer block number has been mapped to a beacon chain slot.\\n    function isBlockMapped(uint64 blockNumber) external view returns (bool) {\\n        return _blockToSlot[blockNumber] != 0;\\n    }\\n\\n    /// @notice Returns true if a beacon chain slot has been mapped to an execution layer block number.\\n    function isSlotMapped(uint64 slot) external view returns (bool) {\\n        return _slotToBlock[slot] != 0;\\n    }\\n}\\n\",\"keccak256\":\"0x66093d2922dec7e8381b4694f46afc1396ff7ac2687d2c49b494bf56b865d20f\",\"license\":\"MIT\"},\"contracts/beacon/BeaconProofsLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport { Merkle } from \\\"./Merkle.sol\\\";\\nimport { Endian } from \\\"./Endian.sol\\\";\\n\\nlibrary BeaconProofsLib {\\n    // Known generalized indices in the beacon block\\n    // BeaconBlock.slot\\n    uint256 internal constant SLOT_GENERALIZED_INDEX = 8;\\n    // BeaconBlock.state.PendingDeposits[0].slot\\n    uint256 internal constant FIRST_PENDING_DEPOSIT_SLOT_GENERALIZED_INDEX =\\n        1584842932228;\\n    // BeaconBlock.body.executionPayload.blockNumber\\n    uint256 internal constant BLOCK_NUMBER_GENERALIZED_INDEX = 6438;\\n    // BeaconBlock.state.validators\\n    uint256 internal constant VALIDATORS_CONTAINER_GENERALIZED_INDEX = 715;\\n    // BeaconBlock.state.balances\\n    uint256 internal constant BALANCES_CONTAINER_GENERALIZED_INDEX = 716;\\n\\n    // Beacon Container Tree Heights\\n    uint256 internal constant BALANCES_HEIGHT = 39;\\n    uint256 internal constant VALIDATORS_HEIGHT = 41;\\n    uint256 internal constant VALIDATOR_HEIGHT = 3;\\n\\n    /// @notice Fields in the Validator container for phase 0\\n    /// See https://ethereum.github.io/consensus-specs/specs/phase0/beacon-chain/#validator\\n    uint256 internal constant VALIDATOR_PUBKEY_INDEX = 0;\\n\\n    enum BalanceProofLevel {\\n        Container,\\n        BeaconBlock\\n    }\\n\\n    /// @notice Verifies the validator public key against the beacon block root\\n    /// BeaconBlock.state.validators[validatorIndex].pubkey\\n    /// @param beaconBlockRoot The root of the beacon block\\n    /// @param pubKeyHash The beacon chain hash of the validator public key\\n    /// @param validatorPubKeyProof The merkle proof for the validator public key to the beacon block root.\\n    /// This is the witness hashes concatenated together starting from the leaf node.\\n    /// @param validatorIndex The validator index\\n    function verifyValidatorPubkey(\\n        bytes32 beaconBlockRoot,\\n        bytes32 pubKeyHash,\\n        bytes calldata validatorPubKeyProof,\\n        uint64 validatorIndex\\n    ) internal view {\\n        // BeaconBlock.state.validators[validatorIndex].pubkey\\n        uint256 generalizedIndex = concatGenIndices(\\n            VALIDATORS_CONTAINER_GENERALIZED_INDEX,\\n            VALIDATORS_HEIGHT,\\n            validatorIndex\\n        );\\n        generalizedIndex = concatGenIndices(\\n            generalizedIndex,\\n            VALIDATOR_HEIGHT,\\n            VALIDATOR_PUBKEY_INDEX\\n        );\\n\\n        require(\\n            Merkle.verifyInclusionSha256({\\n                proof: validatorPubKeyProof,\\n                root: beaconBlockRoot,\\n                leaf: pubKeyHash,\\n                index: generalizedIndex\\n            }),\\n            \\\"Invalid validator pubkey proof\\\"\\n        );\\n    }\\n\\n    /// @notice Verifies the balances container against the beacon block root\\n    /// BeaconBlock.state.balances\\n    /// @param beaconBlockRoot The root of the beacon block\\n    /// @param balancesContainerLeaf The leaf node containing the balances container\\n    /// @param balancesContainerProof The merkle proof for the balances container to the beacon block root.\\n    /// This is the witness hashes concatenated together starting from the leaf node.\\n    function verifyBalancesContainer(\\n        bytes32 beaconBlockRoot,\\n        bytes32 balancesContainerLeaf,\\n        bytes calldata balancesContainerProof\\n    ) internal view {\\n        // BeaconBlock.state.balances\\n        require(\\n            Merkle.verifyInclusionSha256({\\n                proof: balancesContainerProof,\\n                root: beaconBlockRoot,\\n                leaf: balancesContainerLeaf,\\n                index: BALANCES_CONTAINER_GENERALIZED_INDEX\\n            }),\\n            \\\"Invalid balance container proof\\\"\\n        );\\n    }\\n\\n    /// @notice Verifies the validator balance against the root of the Balances container\\n    /// or the beacon block root\\n    /// @param root The root of the Balances container or the beacon block root\\n    /// @param validatorBalanceLeaf The leaf node containing the validator balance with three other balances\\n    /// @param balanceProof The merkle proof for the validator balance against the root.\\n    /// This is the witness hashes concatenated together starting from the leaf node.\\n    /// @param validatorIndex The validator index to verify the balance for\\n    /// @param level The level of the balance proof, either Container or BeaconBlock\\n    /// @return validatorBalanceGwei The balance in Gwei of the validator at the given index\\n    function verifyValidatorBalance(\\n        bytes32 root,\\n        bytes32 validatorBalanceLeaf,\\n        bytes calldata balanceProof,\\n        uint64 validatorIndex,\\n        BalanceProofLevel level\\n    ) internal view returns (uint256 validatorBalanceGwei) {\\n        // Four balances are stored in each leaf so the validator index is divided by 4\\n        uint64 balanceIndex = validatorIndex / 4;\\n\\n        uint256 generalizedIndex;\\n        if (level == BalanceProofLevel.Container) {\\n            // Get the index within the balances container, not the Beacon Block\\n            // BeaconBlock.state.balances[balanceIndex]\\n            generalizedIndex = concatGenIndices(\\n                1,\\n                BALANCES_HEIGHT,\\n                balanceIndex\\n            );\\n        }\\n\\n        if (level == BalanceProofLevel.BeaconBlock) {\\n            generalizedIndex = concatGenIndices(\\n                BALANCES_CONTAINER_GENERALIZED_INDEX,\\n                BALANCES_HEIGHT,\\n                balanceIndex\\n            );\\n        }\\n\\n        validatorBalanceGwei = balanceAtIndex(\\n            validatorBalanceLeaf,\\n            validatorIndex\\n        );\\n\\n        require(\\n            Merkle.verifyInclusionSha256({\\n                proof: balanceProof,\\n                root: root,\\n                leaf: validatorBalanceLeaf,\\n                index: generalizedIndex\\n            }),\\n            \\\"Invalid balance container proof\\\"\\n        );\\n    }\\n\\n    /// @notice Verifies the slot of the first pending deposit against the beacon block root\\n    /// BeaconBlock.state.PendingDeposits[0].slot\\n    /// @param beaconBlockRoot The root of the beacon block\\n    /// @param slot The beacon chain slot to verify\\n    /// @param firstPendingDepositSlotProof The merkle proof for the first pending deposit's slot\\n    /// against the beacon block root.\\n    /// This is the witness hashes concatenated together starting from the leaf node.\\n    function verifyFirstPendingDepositSlot(\\n        bytes32 beaconBlockRoot,\\n        uint64 slot,\\n        bytes calldata firstPendingDepositSlotProof\\n    ) internal view {\\n        // Convert uint64 slot number to a little endian bytes32\\n        bytes32 slotLeaf = Endian.toLittleEndianUint64(slot);\\n\\n        require(\\n            Merkle.verifyInclusionSha256({\\n                proof: firstPendingDepositSlotProof,\\n                root: beaconBlockRoot,\\n                leaf: slotLeaf,\\n                index: FIRST_PENDING_DEPOSIT_SLOT_GENERALIZED_INDEX\\n            }),\\n            \\\"Invalid pending deposit proof\\\"\\n        );\\n    }\\n\\n    /// @notice Verifies the block number to the the beacon block root\\n    /// BeaconBlock.body.executionPayload.blockNumber\\n    /// @param beaconBlockRoot The root of the beacon block\\n    /// @param blockNumber The execution layer block number to verify\\n    /// @param blockNumberProof The merkle proof for the block number against the beacon block\\n    /// This is the witness hashes concatenated together starting from the leaf node.\\n    function verifyBlockNumber(\\n        bytes32 beaconBlockRoot,\\n        uint256 blockNumber,\\n        bytes calldata blockNumberProof\\n    ) internal view {\\n        // Convert uint64 block number to a little endian bytes32\\n        bytes32 blockNumberLeaf = Endian.toLittleEndianUint64(\\n            uint64(blockNumber)\\n        );\\n        require(\\n            Merkle.verifyInclusionSha256({\\n                proof: blockNumberProof,\\n                root: beaconBlockRoot,\\n                leaf: blockNumberLeaf,\\n                index: BLOCK_NUMBER_GENERALIZED_INDEX\\n            }),\\n            \\\"Invalid block number proof\\\"\\n        );\\n    }\\n\\n    /// @notice Verifies the slot number against the beacon block root.\\n    /// BeaconBlock.slot\\n    /// @param beaconBlockRoot The root of the beacon block\\n    /// @param slot The beacon chain slot to verify\\n    /// @param slotProof The merkle proof for the slot against the beacon block root.\\n    /// This is the witness hashes concatenated together starting from the leaf node.\\n    function verifySlot(\\n        bytes32 beaconBlockRoot,\\n        uint256 slot,\\n        bytes calldata slotProof\\n    ) internal view {\\n        require(\\n            Merkle.verifyInclusionSha256({\\n                proof: slotProof,\\n                root: beaconBlockRoot,\\n                leaf: Endian.toLittleEndianUint64(uint64(slot)),\\n                index: SLOT_GENERALIZED_INDEX\\n            }),\\n            \\\"Invalid slot number proof\\\"\\n        );\\n    }\\n\\n    ////////////////////////////////////////////////////\\n    ///       Internal Helper Functions\\n    ////////////////////////////////////////////////////\\n\\n    function balanceAtIndex(bytes32 validatorBalanceLeaf, uint64 validatorIndex)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 bitShiftAmount = (validatorIndex % 4) * 64;\\n        return\\n            Endian.fromLittleEndianUint64(\\n                bytes32((uint256(validatorBalanceLeaf) << bitShiftAmount))\\n            );\\n    }\\n\\n    /// @notice Concatenates two beacon chain generalized indices into one.\\n    /// @param genIndex The first generalized index or 1 if calculating for a single container.\\n    /// @param height The merkle tree height of the second container. eg 39 for balances, 41 for validators.\\n    /// @param index The index within the second container. eg the validator index.\\n    /// @return genIndex The concatenated generalized index.\\n    function concatGenIndices(\\n        uint256 genIndex,\\n        uint256 height,\\n        uint256 index\\n    ) internal pure returns (uint256) {\\n        return (genIndex << height) | index;\\n    }\\n}\\n\",\"keccak256\":\"0x01c6034907baa5f649309b7392da4734f444f0edbbdfca459da66d6a5b9b97fe\",\"license\":\"BUSL-1.1\"},\"contracts/beacon/BeaconRoots.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nlibrary BeaconRoots {\\n    /// @notice The address of beacon block roots oracle\\n    /// See https://eips.ethereum.org/EIPS/eip-4788\\n    address internal constant BEACON_ROOTS_ADDRESS =\\n        0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02;\\n\\n    /// @notice The length of the beacon block root ring buffer\\n    uint256 internal constant BEACON_ROOTS_HISTORY_BUFFER_LENGTH = 8191;\\n\\n    /// @notice Returns the Beacon Block Root for the previous block.\\n    /// This comes from the Beacon Roots contract defined in EIP-4788\\n    /// @param timestamp The timestamp of the block for which to get the parent root.\\n    /// @return parentRoot The parent block root for the given timestamp.\\n    function parentBlockRoot(uint64 timestamp)\\n        internal\\n        view\\n        returns (bytes32 parentRoot)\\n    {\\n        // Commented out the following checks as it makes unit and fork testing very difficult.\\n        // require(block.timestamp >= timestamp, \\\"Timestamp in future\\\");\\n        // require(\\n        //     block.timestamp - timestamp <\\n        //         BEACON_ROOTS_HISTORY_BUFFER_LENGTH * 12,\\n        //     \\\"Timestamp too old\\\"\\n        // );\\n\\n        // Call the Beacon Block Root Oracle to get the parent block root\\n        // This does not have a function signature, so we use a staticcall\\n        (bool success, bytes memory result) = BEACON_ROOTS_ADDRESS.staticcall(\\n            abi.encode(timestamp)\\n        );\\n\\n        require(success && result.length > 0, \\\"Invalid beacon timestamp\\\");\\n        parentRoot = abi.decode(result, (bytes32));\\n    }\\n}\\n\",\"keccak256\":\"0xdbf9d944c36476ef702716288f425eb0236a51aa2bfca150ead2a59495beb422\",\"license\":\"BUSL-1.1\"},\"contracts/beacon/Endian.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nlibrary Endian {\\n    /**\\n     * @notice Converts a little endian-formatted uint64 to a big endian-formatted uint64\\n     * @param lenum little endian-formatted uint64 input, provided as 'bytes32' type\\n     * @return n The big endian-formatted uint64\\n     * @dev Note that the input is formatted as a 'bytes32' type (i.e. 256 bits),\\n     * but it is immediately truncated to a uint64 (i.e. 64 bits)\\n     * through a right-shift/shr operation.\\n     */\\n    function fromLittleEndianUint64(bytes32 lenum)\\n        internal\\n        pure\\n        returns (uint64 n)\\n    {\\n        // the number needs to be stored in little-endian encoding (ie in bytes 0-8)\\n        n = uint64(uint256(lenum >> 192));\\n        // forgefmt: disable-next-item\\n        return\\n            (n >> 56) |\\n            ((0x00FF000000000000 & n) >> 40) |\\n            ((0x0000FF0000000000 & n) >> 24) |\\n            ((0x000000FF00000000 & n) >> 8) |\\n            ((0x00000000FF000000 & n) << 8) |\\n            ((0x0000000000FF0000 & n) << 24) |\\n            ((0x000000000000FF00 & n) << 40) |\\n            ((0x00000000000000FF & n) << 56);\\n    }\\n\\n    function toLittleEndianUint64(uint64 benum)\\n        internal\\n        pure\\n        returns (bytes32 n)\\n    {\\n        // Convert to little-endian by reversing byte order\\n        uint64 reversed = (benum >> 56) |\\n            ((0x00FF000000000000 & benum) >> 40) |\\n            ((0x0000FF0000000000 & benum) >> 24) |\\n            ((0x000000FF00000000 & benum) >> 8) |\\n            ((0x00000000FF000000 & benum) << 8) |\\n            ((0x0000000000FF0000 & benum) << 24) |\\n            ((0x000000000000FF00 & benum) << 40) |\\n            ((0x00000000000000FF & benum) << 56);\\n\\n        // Store the little-endian uint64 in the least significant 64 bits of bytes32\\n        n = bytes32(uint256(reversed));\\n        // Shift to most significant bits\\n        n = n << 192;\\n    }\\n}\\n\",\"keccak256\":\"0xd4454a33ddd56dda4c514e15028e642d3b95ef3e61cd487256567af371f9caba\",\"license\":\"BUSL-1.1\"},\"contracts/beacon/Merkle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Adapted from OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary Merkle {\\n    error InvalidProofLength();\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. The tree is built assuming `leaf` is\\n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\\n     *\\n     * Note this is for a Merkle tree using the sha256 hash function\\n     */\\n    function verifyInclusionSha256(\\n        bytes memory proof,\\n        bytes32 root,\\n        bytes32 leaf,\\n        uint256 index\\n    ) internal view returns (bool) {\\n        return processInclusionProofSha256(proof, leaf, index) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. The tree is built assuming `leaf` is\\n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\\n     *\\n     * _Available since v4.4._\\n     *\\n     * Note this is for a Merkle tree using the sha256 hash function\\n     */\\n    function processInclusionProofSha256(\\n        bytes memory proof,\\n        bytes32 leaf,\\n        uint256 index\\n    ) internal view returns (bytes32) {\\n        require(\\n            proof.length != 0 && proof.length % 32 == 0,\\n            InvalidProofLength()\\n        );\\n        bytes32[1] memory computedHash = [leaf];\\n        for (uint256 i = 32; i <= proof.length; i += 32) {\\n            if (index % 2 == 0) {\\n                // if ith bit of index is 0, then computedHash is a left sibling\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    mstore(0x00, mload(computedHash))\\n                    mstore(0x20, mload(add(proof, i)))\\n                    if iszero(\\n                        staticcall(\\n                            sub(gas(), 2000),\\n                            2,\\n                            0x00,\\n                            0x40,\\n                            computedHash,\\n                            0x20\\n                        )\\n                    ) {\\n                        revert(0, 0)\\n                    }\\n                    index := div(index, 2)\\n                }\\n            } else {\\n                // if ith bit of index is 1, then computedHash is a right sibling\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    mstore(0x00, mload(add(proof, i)))\\n                    mstore(0x20, mload(computedHash))\\n                    if iszero(\\n                        staticcall(\\n                            sub(gas(), 2000),\\n                            2,\\n                            0x00,\\n                            0x40,\\n                            computedHash,\\n                            0x20\\n                        )\\n                    ) {\\n                        revert(0, 0)\\n                    }\\n                    index := div(index, 2)\\n                }\\n            }\\n        }\\n        return computedHash[0];\\n    }\\n}\\n\",\"keccak256\":\"0x01e60fb19fe4439b27c4b7fa6e7fc68892b2affa3c4ef8769fa24ad3d20e2273\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080604052348015600f57600080fd5b5061092b8061001f6000396000f3fe608060405234801561001057600080fd5b50600436106100625760003560e01c806347b59153146100675780635f09d08c146100975780638e514b5b146100d5578063984f9c32146100e8578063c5242c0214610116578063fbbd18bc14610137575b600080fd5b61007a610075366004610755565b61014a565b6040516001600160401b0390911681526020015b60405180910390f35b6100c56100a5366004610755565b6001600160401b0390811660009081526001602052604090205416151590565b604051901515815260200161008e565b61007a6100e3366004610755565b6101b3565b6100c56100f6366004610755565b6001600160401b0390811660009081526020819052604090205416151590565b610129610124366004610755565b610213565b60405190815260200161008e565b6101296101453660046107bf565b61026e565b6001600160401b03808216600090815260016020526040812054909116908190036101ae5760405162461bcd60e51b815260206004820152600f60248201526e14db1bdd081b9bdd081b585c1c1959608a1b60448201526064015b60405180910390fd5b919050565b6001600160401b03808216600090815260208190526040812054909116908190036101ae5760405162461bcd60e51b815260206004820152601060248201526f109b1bd8dac81b9bdd081b585c1c195960821b60448201526064016101a5565b6001600160401b038116600090815260026020526040812054908190036101ae5760405162461bcd60e51b815260206004820152600f60248201526e14db1bdd081b9bdd081b585c1c1959608a1b60448201526064016101a5565b6001600160401b03808716600090815260208190526040812054909116156102cf5760405162461bcd60e51b8152602060048201526014602482015273109b1bd8dac8185b1c9958591e481b585c1c195960621b60448201526064016101a5565b6102d888610385565b90506102ef81876001600160401b0316878761048a565b61030481886001600160401b03168585610529565b6001600160401b038088166000818152602081815260408083208054958c1667ffffffffffffffff199687168117909155808452600183528184208054909616851790955560029091528082208590555184917f1269041f7d9261ffae4d51c46319f36ddae183581e04ce1532817b3e36ddef7f91a4979650505050505050565b604080516001600160401b038316602082015260009182918291720f3df6d732807ef1319fb7b8bb8522d0beac02910160408051601f19818403018152908290526103cf91610864565b600060405180830381855afa9150503d806000811461040a576040519150601f19603f3d011682016040523d82523d6000602084013e61040f565b606091505b5091509150818015610422575060008151115b61046e5760405162461bcd60e51b815260206004820152601860248201527f496e76616c696420626561636f6e2074696d657374616d70000000000000000060448201526064016101a5565b808060200190518101906104829190610893565b949350505050565b6104d782828080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508892506104d091508790506105cf565b6008610649565b6105235760405162461bcd60e51b815260206004820152601960248201527f496e76616c696420736c6f74206e756d6265722070726f6f660000000000000060448201526064016101a5565b50505050565b6000610534846105cf565b905061057c83838080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508992508591506119269050610649565b6105c85760405162461bcd60e51b815260206004820152601a60248201527f496e76616c696420626c6f636b206e756d6265722070726f6f6600000000000060448201526064016101a5565b5050505050565b603881811c60ff16602883811c61ff001691909117601884811c62ff00001691909117600885811c63ff000000169190911764ff000000009186901b919091161765ff00000000009185901b919091161766ff0000000000009184901b919091161767ff000000000000009290911b919091161760c01b90565b600083610657868585610661565b1495945050505050565b6000835160001415801561068057506020845161067e91906108ac565b155b61069d576040516313717da960e21b815260040160405180910390fd5b604080516020808201909252848152905b85518111610734576106c16002856108ac565b6000036106f7578151600052808601516020526020826040600060026107d05a03fa6106ec57600080fd5b600284049350610722565b8086015160005281516020526020826040600060026107d05a03fa61071b57600080fd5b6002840493505b61072d6020826108ce565b90506106ae565b5051949350505050565b80356001600160401b03811681146101ae57600080fd5b60006020828403121561076757600080fd5b6107708261073e565b9392505050565b60008083601f84011261078957600080fd5b5081356001600160401b038111156107a057600080fd5b6020830191508360208285010111156107b857600080fd5b9250929050565b600080600080600080600060a0888a0312156107da57600080fd5b6107e38861073e565b96506107f16020890161073e565b95506107ff6040890161073e565b945060608801356001600160401b0381111561081a57600080fd5b6108268a828b01610777565b90955093505060808801356001600160401b0381111561084557600080fd5b6108518a828b01610777565b989b979a50959850939692959293505050565b6000825160005b81811015610885576020818601810151858301520161086b565b506000920191825250919050565b6000602082840312156108a557600080fd5b5051919050565b6000826108c957634e487b7160e01b600052601260045260246000fd5b500690565b808201808211156108ef57634e487b7160e01b600052601160045260246000fd5b9291505056fea2646970667358221220314466f329a43ef8d0fcc2d0ee94aebf6021c4e572b5de4daf24676d6067a07264736f6c634300081c0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100625760003560e01c806347b59153146100675780635f09d08c146100975780638e514b5b146100d5578063984f9c32146100e8578063c5242c0214610116578063fbbd18bc14610137575b600080fd5b61007a610075366004610755565b61014a565b6040516001600160401b0390911681526020015b60405180910390f35b6100c56100a5366004610755565b6001600160401b0390811660009081526001602052604090205416151590565b604051901515815260200161008e565b61007a6100e3366004610755565b6101b3565b6100c56100f6366004610755565b6001600160401b0390811660009081526020819052604090205416151590565b610129610124366004610755565b610213565b60405190815260200161008e565b6101296101453660046107bf565b61026e565b6001600160401b03808216600090815260016020526040812054909116908190036101ae5760405162461bcd60e51b815260206004820152600f60248201526e14db1bdd081b9bdd081b585c1c1959608a1b60448201526064015b60405180910390fd5b919050565b6001600160401b03808216600090815260208190526040812054909116908190036101ae5760405162461bcd60e51b815260206004820152601060248201526f109b1bd8dac81b9bdd081b585c1c195960821b60448201526064016101a5565b6001600160401b038116600090815260026020526040812054908190036101ae5760405162461bcd60e51b815260206004820152600f60248201526e14db1bdd081b9bdd081b585c1c1959608a1b60448201526064016101a5565b6001600160401b03808716600090815260208190526040812054909116156102cf5760405162461bcd60e51b8152602060048201526014602482015273109b1bd8dac8185b1c9958591e481b585c1c195960621b60448201526064016101a5565b6102d888610385565b90506102ef81876001600160401b0316878761048a565b61030481886001600160401b03168585610529565b6001600160401b038088166000818152602081815260408083208054958c1667ffffffffffffffff199687168117909155808452600183528184208054909616851790955560029091528082208590555184917f1269041f7d9261ffae4d51c46319f36ddae183581e04ce1532817b3e36ddef7f91a4979650505050505050565b604080516001600160401b038316602082015260009182918291720f3df6d732807ef1319fb7b8bb8522d0beac02910160408051601f19818403018152908290526103cf91610864565b600060405180830381855afa9150503d806000811461040a576040519150601f19603f3d011682016040523d82523d6000602084013e61040f565b606091505b5091509150818015610422575060008151115b61046e5760405162461bcd60e51b815260206004820152601860248201527f496e76616c696420626561636f6e2074696d657374616d70000000000000000060448201526064016101a5565b808060200190518101906104829190610893565b949350505050565b6104d782828080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508892506104d091508790506105cf565b6008610649565b6105235760405162461bcd60e51b815260206004820152601960248201527f496e76616c696420736c6f74206e756d6265722070726f6f660000000000000060448201526064016101a5565b50505050565b6000610534846105cf565b905061057c83838080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508992508591506119269050610649565b6105c85760405162461bcd60e51b815260206004820152601a60248201527f496e76616c696420626c6f636b206e756d6265722070726f6f6600000000000060448201526064016101a5565b5050505050565b603881811c60ff16602883811c61ff001691909117601884811c62ff00001691909117600885811c63ff000000169190911764ff000000009186901b919091161765ff00000000009185901b919091161766ff0000000000009184901b919091161767ff000000000000009290911b919091161760c01b90565b600083610657868585610661565b1495945050505050565b6000835160001415801561068057506020845161067e91906108ac565b155b61069d576040516313717da960e21b815260040160405180910390fd5b604080516020808201909252848152905b85518111610734576106c16002856108ac565b6000036106f7578151600052808601516020526020826040600060026107d05a03fa6106ec57600080fd5b600284049350610722565b8086015160005281516020526020826040600060026107d05a03fa61071b57600080fd5b6002840493505b61072d6020826108ce565b90506106ae565b5051949350505050565b80356001600160401b03811681146101ae57600080fd5b60006020828403121561076757600080fd5b6107708261073e565b9392505050565b60008083601f84011261078957600080fd5b5081356001600160401b038111156107a057600080fd5b6020830191508360208285010111156107b857600080fd5b9250929050565b600080600080600080600060a0888a0312156107da57600080fd5b6107e38861073e565b96506107f16020890161073e565b95506107ff6040890161073e565b945060608801356001600160401b0381111561081a57600080fd5b6108268a828b01610777565b90955093505060808801356001600160401b0381111561084557600080fd5b6108518a828b01610777565b989b979a50959850939692959293505050565b6000825160005b81811015610885576020818601810151858301520161086b565b506000920191825250919050565b6000602082840312156108a557600080fd5b5051919050565b6000826108c957634e487b7160e01b600052601260045260246000fd5b500690565b808201808211156108ef57634e487b7160e01b600052601160045260246000fd5b9291505056fea2646970667358221220314466f329a43ef8d0fcc2d0ee94aebf6021c4e572b5de4daf24676d6067a07264736f6c634300081c0033",
  "libraries": {},
  "devdoc": {
    "author": "Origin Protocol Inc",
    "kind": "dev",
    "methods": {
      "verifySlot(uint64,uint64,uint64,bytes,bytes)": {
        "params": {
          "blockNumber": "The execution layer block number.",
          "blockProof": "The merkle proof witnesses for the block number against the beacon block root.",
          "nextBlockTimestamp": "The timestamp of the block after the one being proven.",
          "slot": "The beacon chain slot.",
          "slotProof": "The merkle proof witnesses for the slot against the beacon block root."
        }
      }
    },
    "title": "Beacon Chain Oracle",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "blockToSlot(uint64)": {
        "notice": "Returns the beacon chain slot for a given execution layer block number."
      },
      "isBlockMapped(uint64)": {
        "notice": "Returns true if an execution layer block number has been mapped to a beacon chain slot."
      },
      "isSlotMapped(uint64)": {
        "notice": "Returns true if a beacon chain slot has been mapped to an execution layer block number."
      },
      "slotToBlock(uint64)": {
        "notice": "Returns the execution layer block number for a given beacon chain slot."
      },
      "slotToRoot(uint64)": {
        "notice": "Returns the beacon block root for a given beacon chain slot."
      },
      "verifySlot(uint64,uint64,uint64,bytes,bytes)": {
        "notice": "Uses merkle a proof against the beacon block root to link an execution layer block number to a beacon chain slot."
      }
    },
    "notice": "An Oracle for mapping execution layer block numbers to beacon chain slots.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 1205,
        "contract": "contracts/beacon/BeaconOracle.sol:BeaconOracle",
        "label": "_blockToSlot",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_uint64,t_uint64)"
      },
      {
        "astId": 1210,
        "contract": "contracts/beacon/BeaconOracle.sol:BeaconOracle",
        "label": "_slotToBlock",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_uint64,t_uint64)"
      },
      {
        "astId": 1215,
        "contract": "contracts/beacon/BeaconOracle.sol:BeaconOracle",
        "label": "_slotToRoot",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_uint64,t_bytes32)"
      }
    ],
    "types": {
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_uint64,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_mapping(t_uint64,t_uint64)": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => uint64)",
        "numberOfBytes": "32",
        "value": "t_uint64"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      }
    }
  }
}