{
  "address": "0x7476F56EB07e71CeD2fB417D1Aaa925549B2a7f5",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_stakingStrategy",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "getPendingDeposits",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "depositID",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "pubKeyHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "amountGwei",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "slot",
              "type": "uint64"
            },
            {
              "internalType": "uint256",
              "name": "withdrawableEpoch",
              "type": "uint256"
            }
          ],
          "internalType": "struct CompoundingStakingStrategyView.DepositView[]",
          "name": "pendingDeposits",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getVerifiedValidators",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "pubKeyHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "index",
              "type": "uint64"
            },
            {
              "internalType": "enum CompoundingValidatorManager.ValidatorState",
              "name": "state",
              "type": "uint8"
            }
          ],
          "internalType": "struct CompoundingStakingStrategyView.ValidatorView[]",
          "name": "validators",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "stakingStrategy",
      "outputs": [
        {
          "internalType": "contract CompoundingValidatorManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x1e8ec0561c1bf3fb2068844e7d7f595422ddac84b866763a183867c4aa1da0d9",
  "receipt": {
    "to": null,
    "from": "0xf7749B41db006860cEc0650D18b8013d69C44Eeb",
    "contractAddress": "0x7476F56EB07e71CeD2fB417D1Aaa925549B2a7f5",
    "transactionIndex": 20,
    "gasUsed": "542101",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x4c7b25577f26d5217fc74bac057c8d0280d1dbc7bda7765fd74542882ce3cc6a",
    "transactionHash": "0x1e8ec0561c1bf3fb2068844e7d7f595422ddac84b866763a183867c4aa1da0d9",
    "logs": [],
    "blockNumber": 1068404,
    "cumulativeGasUsed": "8953289",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xE0c7B62f75c54Cc75573965C566f37B266F216FB"
  ],
  "numDeployments": 2,
  "solcInputHash": "df854a646f7e413f41affca8d5e99ba6",
  "metadata": "{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingStrategy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"getPendingDeposits\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"depositID\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"pubKeyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"amountGwei\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableEpoch\",\"type\":\"uint256\"}],\"internalType\":\"struct CompoundingStakingStrategyView.DepositView[]\",\"name\":\"pendingDeposits\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVerifiedValidators\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"pubKeyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"index\",\"type\":\"uint64\"},{\"internalType\":\"enum CompoundingValidatorManager.ValidatorState\",\"name\":\"state\",\"type\":\"uint8\"}],\"internalType\":\"struct CompoundingStakingStrategyView.ValidatorView[]\",\"name\":\"validators\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingStrategy\",\"outputs\":[{\"internalType\":\"contract CompoundingValidatorManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Origin Protocol Inc\",\"kind\":\"dev\",\"methods\":{\"getPendingDeposits()\":{\"returns\":{\"pendingDeposits\":\"An array of `DepositView` containing the deposit ID, public key hash, amount in Gwei and the slot of the deposit.\"}},\"getVerifiedValidators()\":{\"returns\":{\"validators\":\"An array of `ValidatorView` containing the public key hash, validator index and state.\"}}},\"title\":\"Viewing contract for the Compounding Staking Strategy.\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getPendingDeposits()\":{\"notice\":\"Returns the deposits that are still to be verified. These may or may not have been processed by the beacon chain.\"},\"getVerifiedValidators()\":{\"notice\":\"Returns the strategy's active validators. These are the ones that have been verified and have a non-zero balance.\"},\"stakingStrategy()\":{\"notice\":\"The address of the Compounding Staking Strategy contract\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/strategies/NativeStaking/CompoundingStakingView.sol\":\"CompoundingStakingStrategyView\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x61437cb513a887a1bbad006e7b1c8b414478427d33de47c5600af3c748f108da\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc3d946432c0ddbb1f846a0d3985be71299df331b91d06732152117f62f0be2b5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x51b758a8815ecc9596c66c37d56b1d33883a444631a3f916b9fe65cb863ef7c4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\",\"keccak256\":\"0xfaad496c1c944b6259b7dc70b4865eb1775d6402bc0c81b38a0b24d9f525ae37\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x5c6caab697d302ad7eb59c234a4d2dbc965c1bae87709bd2850060b7695b28c7\",\"license\":\"MIT\"},\"contracts/beacon/BeaconRoots.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Library to retrieve beacon block roots.\\n * @author Origin Protocol Inc\\n */\\nlibrary BeaconRoots {\\n    /// @notice The address of beacon block roots oracle\\n    /// See https://eips.ethereum.org/EIPS/eip-4788\\n    address internal constant BEACON_ROOTS_ADDRESS =\\n        0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02;\\n\\n    /// @notice Returns the beacon block root for the previous block.\\n    /// This comes from the Beacon Roots contract defined in EIP-4788.\\n    /// This will revert if the block is more than 8,191 blocks old as\\n    /// that is the size of the beacon root's ring buffer.\\n    /// @param timestamp The timestamp of the block for which to get the parent root.\\n    /// @return parentRoot The parent block root for the given timestamp.\\n    function parentBlockRoot(uint64 timestamp)\\n        internal\\n        view\\n        returns (bytes32 parentRoot)\\n    {\\n        // Call the Beacon Roots contract to get the parent block root.\\n        // This does not have a function signature, so we use a staticcall.\\n        (bool success, bytes memory result) = BEACON_ROOTS_ADDRESS.staticcall(\\n            abi.encode(timestamp)\\n        );\\n\\n        require(success && result.length > 0, \\\"Invalid beacon timestamp\\\");\\n        parentRoot = abi.decode(result, (bytes32));\\n    }\\n}\\n\",\"keccak256\":\"0x4005989f852a68bbcdc1cdc3472ebd3911395e75b4e6366ffcaae4d1c128691e\",\"license\":\"BUSL-1.1\"},\"contracts/beacon/PartialWithdrawal.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Library to request full or partial withdrawals from validators on the beacon chain.\\n * @author Origin Protocol Inc\\n */\\nlibrary PartialWithdrawal {\\n    /// @notice The address where the withdrawal request is sent to\\n    /// See https://eips.ethereum.org/EIPS/eip-7002\\n    address internal constant WITHDRAWAL_REQUEST_ADDRESS =\\n        0x00000961Ef480Eb55e80D19ad83579A64c007002;\\n\\n    /// @notice Requests a partial withdrawal for a given validator public key and amount.\\n    /// @param validatorPubKey The public key of the validator to withdraw from\\n    /// @param amount The amount of ETH to withdraw\\n    function request(bytes calldata validatorPubKey, uint64 amount)\\n        internal\\n        returns (uint256 fee_)\\n    {\\n        require(validatorPubKey.length == 48, \\\"Invalid validator byte length\\\");\\n        fee_ = fee();\\n\\n        // Call the Withdrawal Request contract with the validator public key\\n        // and amount to be withdrawn packed together\\n\\n        // This is a general purpose EL to CL request:\\n        // https://eips.ethereum.org/EIPS/eip-7685\\n        (bool success, ) = WITHDRAWAL_REQUEST_ADDRESS.call{ value: fee_ }(\\n            abi.encodePacked(validatorPubKey, amount)\\n        );\\n\\n        require(success, \\\"Withdrawal request failed\\\");\\n    }\\n\\n    /// @notice Gets fee for withdrawal requests contract on Beacon chain\\n    function fee() internal view returns (uint256) {\\n        // Get fee from the withdrawal request contract\\n        (bool success, bytes memory result) = WITHDRAWAL_REQUEST_ADDRESS\\n            .staticcall(\\\"\\\");\\n\\n        require(success && result.length > 0, \\\"Failed to get fee\\\");\\n        return abi.decode(result, (uint256));\\n    }\\n}\\n\",\"keccak256\":\"0x80d29153ff7eb5c6841692aca98eb0cc14ac43ad2d8e402890b6c6b6e4a9719d\",\"license\":\"BUSL-1.1\"},\"contracts/governance/Governable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Base for contracts that are managed by the Origin Protocol's Governor.\\n * @dev Copy of the openzeppelin Ownable.sol contract with nomenclature change\\n *      from owner to governor and renounce methods removed. Does not use\\n *      Context.sol like Ownable.sol does for simplification.\\n * @author Origin Protocol Inc\\n */\\nabstract contract Governable {\\n    // Storage position of the owner and pendingOwner of the contract\\n    // keccak256(\\\"OUSD.governor\\\");\\n    bytes32 private constant governorPosition =\\n        0x7bea13895fa79d2831e0a9e28edede30099005a50d652d8957cf8a607ee6ca4a;\\n\\n    // keccak256(\\\"OUSD.pending.governor\\\");\\n    bytes32 private constant pendingGovernorPosition =\\n        0x44c4d30b2eaad5130ad70c3ba6972730566f3e6359ab83e800d905c61b1c51db;\\n\\n    // keccak256(\\\"OUSD.reentry.status\\\");\\n    bytes32 private constant reentryStatusPosition =\\n        0x53bf423e48ed90e97d02ab0ebab13b2a235a6bfbe9c321847d5c175333ac4535;\\n\\n    // See OpenZeppelin ReentrancyGuard implementation\\n    uint256 constant _NOT_ENTERED = 1;\\n    uint256 constant _ENTERED = 2;\\n\\n    event PendingGovernorshipTransfer(\\n        address indexed previousGovernor,\\n        address indexed newGovernor\\n    );\\n\\n    event GovernorshipTransferred(\\n        address indexed previousGovernor,\\n        address indexed newGovernor\\n    );\\n\\n    /**\\n     * @notice Returns the address of the current Governor.\\n     */\\n    function governor() public view returns (address) {\\n        return _governor();\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current Governor.\\n     */\\n    function _governor() internal view returns (address governorOut) {\\n        bytes32 position = governorPosition;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            governorOut := sload(position)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address of the pending Governor.\\n     */\\n    function _pendingGovernor()\\n        internal\\n        view\\n        returns (address pendingGovernor)\\n    {\\n        bytes32 position = pendingGovernorPosition;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            pendingGovernor := sload(position)\\n        }\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the Governor.\\n     */\\n    modifier onlyGovernor() {\\n        require(isGovernor(), \\\"Caller is not the Governor\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Returns true if the caller is the current Governor.\\n     */\\n    function isGovernor() public view returns (bool) {\\n        return msg.sender == _governor();\\n    }\\n\\n    function _setGovernor(address newGovernor) internal {\\n        emit GovernorshipTransferred(_governor(), newGovernor);\\n\\n        bytes32 position = governorPosition;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(position, newGovernor)\\n        }\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        bytes32 position = reentryStatusPosition;\\n        uint256 _reentry_status;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            _reentry_status := sload(position)\\n        }\\n\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_reentry_status != _ENTERED, \\\"Reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(position, _ENTERED)\\n        }\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(position, _NOT_ENTERED)\\n        }\\n    }\\n\\n    function _setPendingGovernor(address newGovernor) internal {\\n        bytes32 position = pendingGovernorPosition;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(position, newGovernor)\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfers Governance of the contract to a new account (`newGovernor`).\\n     * Can only be called by the current Governor. Must be claimed for this to complete\\n     * @param _newGovernor Address of the new Governor\\n     */\\n    function transferGovernance(address _newGovernor) external onlyGovernor {\\n        _setPendingGovernor(_newGovernor);\\n        emit PendingGovernorshipTransfer(_governor(), _newGovernor);\\n    }\\n\\n    /**\\n     * @notice Claim Governance of the contract to a new account (`newGovernor`).\\n     * Can only be called by the new Governor.\\n     */\\n    function claimGovernance() external {\\n        require(\\n            msg.sender == _pendingGovernor(),\\n            \\\"Only the pending Governor can complete the claim\\\"\\n        );\\n        _changeGovernor(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Change Governance of the contract to a new account (`newGovernor`).\\n     * @param _newGovernor Address of the new Governor\\n     */\\n    function _changeGovernor(address _newGovernor) internal {\\n        require(_newGovernor != address(0), \\\"New Governor is address(0)\\\");\\n        _setGovernor(_newGovernor);\\n    }\\n}\\n\",\"keccak256\":\"0xf32f873c8bfbacf2e5f01d0cf37bc7f54fbd5aa656e95c8a599114229946f107\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IBeaconProofs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\ninterface IBeaconProofs {\\n    function verifyValidator(\\n        bytes32 beaconBlockRoot,\\n        bytes32 pubKeyHash,\\n        bytes calldata validatorPubKeyProof,\\n        uint64 validatorIndex,\\n        address withdrawalAddress\\n    ) external view;\\n\\n    function verifyValidatorWithdrawable(\\n        bytes32 beaconBlockRoot,\\n        uint64 validatorIndex,\\n        bytes32 pubKeyHash,\\n        uint64 withdrawableEpoch,\\n        bytes calldata withdrawableEpochProof,\\n        bytes calldata validatorPubKeyProof\\n    ) external view;\\n\\n    function verifyValidatorWithdrawable(\\n        bytes32 beaconBlockRoot,\\n        uint64 validatorIndex,\\n        uint64 withdrawableEpoch,\\n        bytes calldata withdrawableEpochProof\\n    ) external view;\\n\\n    function verifyBalancesContainer(\\n        bytes32 beaconBlockRoot,\\n        bytes32 balancesContainerLeaf,\\n        bytes calldata balancesContainerProof\\n    ) external view;\\n\\n    function verifyValidatorBalance(\\n        bytes32 balancesContainerRoot,\\n        bytes32 validatorBalanceLeaf,\\n        bytes calldata balanceProof,\\n        uint64 validatorIndex\\n    ) external view returns (uint256 validatorBalance);\\n\\n    function verifyFirstPendingDeposit(\\n        bytes32 beaconBlockRoot,\\n        uint64 slot,\\n        bytes32 pubKeyHash,\\n        bytes calldata firstPendingDepositProof\\n    ) external view returns (bool isEmptyDepositQueue);\\n}\\n\",\"keccak256\":\"0x0dfb664d21c67f8ad5b7e52262c52e1dd9556f3683d48503e7e0f902c036f5c3\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IDepositContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IDepositContract {\\n    /// @notice A processed deposit event.\\n    event DepositEvent(\\n        bytes pubkey,\\n        bytes withdrawal_credentials,\\n        bytes amount,\\n        bytes signature,\\n        bytes index\\n    );\\n\\n    /// @notice Submit a Phase 0 DepositData object.\\n    /// @param pubkey A BLS12-381 public key.\\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\\n    /// @param signature A BLS12-381 signature.\\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\\n    /// Used as a protection against malformed input.\\n    function deposit(\\n        bytes calldata pubkey,\\n        bytes calldata withdrawal_credentials,\\n        bytes calldata signature,\\n        bytes32 deposit_data_root\\n    ) external payable;\\n\\n    /// @notice Query the current deposit root hash.\\n    /// @return The deposit root hash.\\n    function get_deposit_root() external view returns (bytes32);\\n\\n    /// @notice Query the current deposit count.\\n    /// @return The deposit count encoded as a little endian 64-bit number.\\n    function get_deposit_count() external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x598f90bdbc854250bbd5991426bfb43367207e64e33109c41aa8b54323fd8d8e\",\"license\":\"MIT\"},\"contracts/interfaces/ISSVNetwork.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nstruct Cluster {\\n    uint32 validatorCount;\\n    uint64 networkFeeIndex;\\n    uint64 index;\\n    bool active;\\n    uint256 balance;\\n}\\n\\ninterface ISSVNetwork {\\n    /**********/\\n    /* Errors */\\n    /**********/\\n\\n    error CallerNotOwner(); // 0x5cd83192\\n    error CallerNotWhitelisted(); // 0x8c6e5d71\\n    error FeeTooLow(); // 0x732f9413\\n    error FeeExceedsIncreaseLimit(); // 0x958065d9\\n    error NoFeeDeclared(); // 0x1d226c30\\n    error ApprovalNotWithinTimeframe(); // 0x97e4b518\\n    error OperatorDoesNotExist(); // 0x961e3e8c\\n    error InsufficientBalance(); // 0xf4d678b8\\n    error ValidatorDoesNotExist(); // 0xe51315d2\\n    error ClusterNotLiquidatable(); // 0x60300a8d\\n    error InvalidPublicKeyLength(); // 0x637297a4\\n    error InvalidOperatorIdsLength(); // 0x38186224\\n    error ClusterAlreadyEnabled(); // 0x3babafd2\\n    error ClusterIsLiquidated(); // 0x95a0cf33\\n    error ClusterDoesNotExists(); // 0x185e2b16\\n    error IncorrectClusterState(); // 0x12e04c87\\n    error UnsortedOperatorsList(); // 0xdd020e25\\n    error NewBlockPeriodIsBelowMinimum(); // 0x6e6c9cac\\n    error ExceedValidatorLimit(); // 0x6df5ab76\\n    error TokenTransferFailed(); // 0x045c4b02\\n    error SameFeeChangeNotAllowed(); // 0xc81272f8\\n    error FeeIncreaseNotAllowed(); // 0x410a2b6c\\n    error NotAuthorized(); // 0xea8e4eb5\\n    error OperatorsListNotUnique(); // 0xa5a1ff5d\\n    error OperatorAlreadyExists(); // 0x289c9494\\n    error TargetModuleDoesNotExist(); // 0x8f9195fb\\n    error MaxValueExceeded(); // 0x91aa3017\\n    error FeeTooHigh(); // 0xcd4e6167\\n    error PublicKeysSharesLengthMismatch(); // 0x9ad467b8\\n    error IncorrectValidatorStateWithData(bytes publicKey); // 0x89307938\\n    error ValidatorAlreadyExistsWithData(bytes publicKey); // 0x388e7999\\n    error EmptyPublicKeysList(); // df83e679\\n\\n    // legacy errors\\n    error ValidatorAlreadyExists(); // 0x8d09a73e\\n    error IncorrectValidatorState(); // 0x2feda3c1\\n\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n    event BeaconUpgraded(address indexed beacon);\\n    event ClusterDeposited(\\n        address indexed owner,\\n        uint64[] operatorIds,\\n        uint256 value,\\n        Cluster cluster\\n    );\\n    event ClusterLiquidated(\\n        address indexed owner,\\n        uint64[] operatorIds,\\n        Cluster cluster\\n    );\\n    event ClusterReactivated(\\n        address indexed owner,\\n        uint64[] operatorIds,\\n        Cluster cluster\\n    );\\n    event ClusterWithdrawn(\\n        address indexed owner,\\n        uint64[] operatorIds,\\n        uint256 value,\\n        Cluster cluster\\n    );\\n    event DeclareOperatorFeePeriodUpdated(uint64 value);\\n    event ExecuteOperatorFeePeriodUpdated(uint64 value);\\n    event FeeRecipientAddressUpdated(\\n        address indexed owner,\\n        address recipientAddress\\n    );\\n    event Initialized(uint8 version);\\n    event LiquidationThresholdPeriodUpdated(uint64 value);\\n    event MinimumLiquidationCollateralUpdated(uint256 value);\\n    event NetworkEarningsWithdrawn(uint256 value, address recipient);\\n    event NetworkFeeUpdated(uint256 oldFee, uint256 newFee);\\n    event OperatorAdded(\\n        uint64 indexed operatorId,\\n        address indexed owner,\\n        bytes publicKey,\\n        uint256 fee\\n    );\\n    event OperatorFeeDeclarationCancelled(\\n        address indexed owner,\\n        uint64 indexed operatorId\\n    );\\n    event OperatorFeeDeclared(\\n        address indexed owner,\\n        uint64 indexed operatorId,\\n        uint256 blockNumber,\\n        uint256 fee\\n    );\\n    event OperatorFeeExecuted(\\n        address indexed owner,\\n        uint64 indexed operatorId,\\n        uint256 blockNumber,\\n        uint256 fee\\n    );\\n    event OperatorFeeIncreaseLimitUpdated(uint64 value);\\n    event OperatorMaximumFeeUpdated(uint64 maxFee);\\n    event OperatorRemoved(uint64 indexed operatorId);\\n    event OperatorWhitelistUpdated(\\n        uint64 indexed operatorId,\\n        address whitelisted\\n    );\\n    event OperatorWithdrawn(\\n        address indexed owner,\\n        uint64 indexed operatorId,\\n        uint256 value\\n    );\\n    event OwnershipTransferStarted(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n    event Upgraded(address indexed implementation);\\n    event ValidatorAdded(\\n        address indexed owner,\\n        uint64[] operatorIds,\\n        bytes publicKey,\\n        bytes shares,\\n        Cluster cluster\\n    );\\n    event ValidatorExited(\\n        address indexed owner,\\n        uint64[] operatorIds,\\n        bytes publicKey\\n    );\\n    event ValidatorRemoved(\\n        address indexed owner,\\n        uint64[] operatorIds,\\n        bytes publicKey,\\n        Cluster cluster\\n    );\\n\\n    fallback() external;\\n\\n    function acceptOwnership() external;\\n\\n    function cancelDeclaredOperatorFee(uint64 operatorId) external;\\n\\n    function declareOperatorFee(uint64 operatorId, uint256 fee) external;\\n\\n    function deposit(\\n        address clusterOwner,\\n        uint64[] memory operatorIds,\\n        uint256 amount,\\n        Cluster memory cluster\\n    ) external;\\n\\n    function executeOperatorFee(uint64 operatorId) external;\\n\\n    function exitValidator(bytes memory publicKey, uint64[] memory operatorIds)\\n        external;\\n\\n    function bulkExitValidator(\\n        bytes[] calldata publicKeys,\\n        uint64[] calldata operatorIds\\n    ) external;\\n\\n    function getVersion() external pure returns (string memory version);\\n\\n    function initialize(\\n        address token_,\\n        address ssvOperators_,\\n        address ssvClusters_,\\n        address ssvDAO_,\\n        address ssvViews_,\\n        uint64 minimumBlocksBeforeLiquidation_,\\n        uint256 minimumLiquidationCollateral_,\\n        uint32 validatorsPerOperatorLimit_,\\n        uint64 declareOperatorFeePeriod_,\\n        uint64 executeOperatorFeePeriod_,\\n        uint64 operatorMaxFeeIncrease_\\n    ) external;\\n\\n    function liquidate(\\n        address clusterOwner,\\n        uint64[] memory operatorIds,\\n        Cluster memory cluster\\n    ) external;\\n\\n    function owner() external view returns (address);\\n\\n    function pendingOwner() external view returns (address);\\n\\n    function proxiableUUID() external view returns (bytes32);\\n\\n    function reactivate(\\n        uint64[] memory operatorIds,\\n        uint256 amount,\\n        Cluster memory cluster\\n    ) external;\\n\\n    function reduceOperatorFee(uint64 operatorId, uint256 fee) external;\\n\\n    function registerOperator(bytes memory publicKey, uint256 fee)\\n        external\\n        returns (uint64 id);\\n\\n    function registerValidator(\\n        bytes memory publicKey,\\n        uint64[] memory operatorIds,\\n        bytes memory sharesData,\\n        uint256 amount,\\n        Cluster memory cluster\\n    ) external;\\n\\n    function bulkRegisterValidator(\\n        bytes[] calldata publicKeys,\\n        uint64[] calldata operatorIds,\\n        bytes[] calldata sharesData,\\n        uint256 amount,\\n        Cluster memory cluster\\n    ) external;\\n\\n    function removeOperator(uint64 operatorId) external;\\n\\n    function removeValidator(\\n        bytes memory publicKey,\\n        uint64[] memory operatorIds,\\n        Cluster memory cluster\\n    ) external;\\n\\n    function bulkRemoveValidator(\\n        bytes[] calldata publicKeys,\\n        uint64[] calldata operatorIds,\\n        Cluster memory cluster\\n    ) external;\\n\\n    function renounceOwnership() external;\\n\\n    function setFeeRecipientAddress(address recipientAddress) external;\\n\\n    function setOperatorWhitelist(uint64 operatorId, address whitelisted)\\n        external;\\n\\n    function transferOwnership(address newOwner) external;\\n\\n    function updateDeclareOperatorFeePeriod(uint64 timeInSeconds) external;\\n\\n    function updateExecuteOperatorFeePeriod(uint64 timeInSeconds) external;\\n\\n    function updateLiquidationThresholdPeriod(uint64 blocks) external;\\n\\n    function updateMaximumOperatorFee(uint64 maxFee) external;\\n\\n    function updateMinimumLiquidationCollateral(uint256 amount) external;\\n\\n    function updateModule(uint8 moduleId, address moduleAddress) external;\\n\\n    function updateNetworkFee(uint256 fee) external;\\n\\n    function updateOperatorFeeIncreaseLimit(uint64 percentage) external;\\n\\n    function upgradeTo(address newImplementation) external;\\n\\n    function upgradeToAndCall(address newImplementation, bytes memory data)\\n        external\\n        payable;\\n\\n    function withdraw(\\n        uint64[] memory operatorIds,\\n        uint256 amount,\\n        Cluster memory cluster\\n    ) external;\\n\\n    function withdrawAllOperatorEarnings(uint64 operatorId) external;\\n\\n    function withdrawNetworkEarnings(uint256 amount) external;\\n\\n    function withdrawOperatorEarnings(uint64 operatorId, uint256 amount)\\n        external;\\n}\\n\",\"keccak256\":\"0xbd86cb74702aebc5b53c8fc738a2e3ad1b410583460617be84b22ce922af12a7\",\"license\":\"MIT\"},\"contracts/interfaces/IWETH9.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IWETH9 {\\n    event Approval(address indexed src, address indexed guy, uint256 wad);\\n    event Deposit(address indexed dst, uint256 wad);\\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\\n    event Withdrawal(address indexed src, uint256 wad);\\n\\n    function allowance(address, address) external view returns (uint256);\\n\\n    function approve(address guy, uint256 wad) external returns (bool);\\n\\n    function balanceOf(address) external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function deposit() external payable;\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function transfer(address dst, uint256 wad) external returns (bool);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 wad\\n    ) external returns (bool);\\n\\n    function withdraw(uint256 wad) external;\\n}\\n\",\"keccak256\":\"0x05b7dce6c24d3cd4e48b5c6346d86e5e40ecc3291bcdf3f3ef091c98fc826519\",\"license\":\"MIT\"},\"contracts/strategies/NativeStaking/CompoundingStakingView.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport { CompoundingValidatorManager } from \\\"./CompoundingValidatorManager.sol\\\";\\n\\n/**\\n * @title Viewing contract for the Compounding Staking Strategy.\\n * @author Origin Protocol Inc\\n */\\ncontract CompoundingStakingStrategyView {\\n    /// @notice The address of the Compounding Staking Strategy contract\\n    CompoundingValidatorManager public immutable stakingStrategy;\\n\\n    constructor(address _stakingStrategy) {\\n        stakingStrategy = CompoundingValidatorManager(_stakingStrategy);\\n    }\\n\\n    struct ValidatorView {\\n        bytes32 pubKeyHash;\\n        uint64 index;\\n        CompoundingValidatorManager.ValidatorState state;\\n    }\\n\\n    struct DepositView {\\n        uint256 depositID;\\n        bytes32 pubKeyHash;\\n        uint64 amountGwei;\\n        uint64 slot;\\n        uint256 withdrawableEpoch;\\n    }\\n\\n    /// @notice Returns the strategy's active validators.\\n    /// These are the ones that have been verified and have a non-zero balance.\\n    /// @return validators An array of `ValidatorView` containing the public key hash, validator index and state.\\n    function getVerifiedValidators()\\n        external\\n        view\\n        returns (ValidatorView[] memory validators)\\n    {\\n        uint256 validatorCount = stakingStrategy.verifiedValidatorsLength();\\n        validators = new ValidatorView[](validatorCount);\\n        for (uint256 i = 0; i < validatorCount; ++i) {\\n            bytes32 pubKeyHash = stakingStrategy.verifiedValidators(i);\\n            (\\n                CompoundingValidatorManager.ValidatorState state,\\n                uint64 index\\n            ) = stakingStrategy.validator(pubKeyHash);\\n            validators[i] = ValidatorView({\\n                pubKeyHash: pubKeyHash,\\n                index: index,\\n                state: state\\n            });\\n        }\\n    }\\n\\n    /// @notice Returns the deposits that are still to be verified.\\n    /// These may or may not have been processed by the beacon chain.\\n    /// @return pendingDeposits An array of `DepositView` containing the deposit ID, public key hash,\\n    /// amount in Gwei and the slot of the deposit.\\n    function getPendingDeposits()\\n        external\\n        view\\n        returns (DepositView[] memory pendingDeposits)\\n    {\\n        uint256 depositsCount = stakingStrategy.depositListLength();\\n        pendingDeposits = new DepositView[](depositsCount);\\n        for (uint256 i = 0; i < depositsCount; ++i) {\\n            (\\n                bytes32 pubKeyHash,\\n                uint64 amountGwei,\\n                uint64 slot,\\n                ,\\n                ,\\n                uint256 withdrawableEpoch\\n            ) = stakingStrategy.deposits(stakingStrategy.depositList(i));\\n            pendingDeposits[i] = DepositView({\\n                depositID: stakingStrategy.depositList(i),\\n                pubKeyHash: pubKeyHash,\\n                amountGwei: amountGwei,\\n                slot: slot,\\n                withdrawableEpoch: withdrawableEpoch\\n            });\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa291502fd2adfb2378ad70325ded8d2f52809347c91af4b30c33541559656bf3\",\"license\":\"BUSL-1.1\"},\"contracts/strategies/NativeStaking/CompoundingValidatorManager.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { SafeCast } from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport { Math } from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { Governable } from \\\"../../governance/Governable.sol\\\";\\nimport { IDepositContract } from \\\"../../interfaces/IDepositContract.sol\\\";\\nimport { IWETH9 } from \\\"../../interfaces/IWETH9.sol\\\";\\nimport { ISSVNetwork, Cluster } from \\\"../../interfaces/ISSVNetwork.sol\\\";\\nimport { BeaconRoots } from \\\"../../beacon/BeaconRoots.sol\\\";\\nimport { PartialWithdrawal } from \\\"../../beacon/PartialWithdrawal.sol\\\";\\nimport { IBeaconProofs } from \\\"../../interfaces/IBeaconProofs.sol\\\";\\n\\n/**\\n * @title Validator lifecycle management contract\\n * @notice This contract implements all the required functionality to\\n * register, deposit, withdraw, exit and remove validators.\\n * @author Origin Protocol Inc\\n */\\nabstract contract CompoundingValidatorManager is Governable {\\n    using SafeERC20 for IERC20;\\n\\n    /// @dev The amount of ETH in wei that is required for a deposit to a new validator.\\n    /// Initially this is 32 ETH, but will be reduced to 1 ETH after P2P's APIs have been updated\\n    /// to support deposits of 1 ETH.\\n    uint256 internal constant DEPOSIT_AMOUNT_WEI = 32 ether;\\n    /// @dev The maximum number of deposits that are waiting to be verified as processed on the beacon chain.\\n    uint256 internal constant MAX_DEPOSITS = 12;\\n    /// @dev The maximum number of validators that can be verified.\\n    uint256 internal constant MAX_VERIFIED_VALIDATORS = 48;\\n    /// @dev The default withdrawable epoch value on the Beacon chain.\\n    /// A value in the far future means the validator is not exiting.\\n    uint64 internal constant FAR_FUTURE_EPOCH = type(uint64).max;\\n    /// @dev The number of seconds between each beacon chain slot.\\n    uint64 internal constant SLOT_DURATION = 12;\\n    /// @dev The number of slots in each beacon chain epoch.\\n    uint64 internal constant SLOTS_PER_EPOCH = 32;\\n    /// @dev Minimum time in seconds to allow snapped balances to be verified.\\n    /// Set to 1 epoch as the pending deposits only changes every epoch.\\n    /// That's also enough time to generate the proofs and call `verifyBalances`.\\n    uint64 internal constant SNAP_BALANCES_DELAY =\\n        SLOTS_PER_EPOCH * SLOT_DURATION;\\n\\n    /// @notice The address of the Wrapped ETH (WETH) token contract\\n    address public immutable WETH;\\n    /// @notice The address of the beacon chain deposit contract\\n    address public immutable BEACON_CHAIN_DEPOSIT_CONTRACT;\\n    /// @notice The address of the SSV Network contract used to interface with\\n    address public immutable SSV_NETWORK;\\n    /// @notice Address of the OETH Vault proxy contract\\n    address public immutable VAULT_ADDRESS;\\n    /// @notice Address of the Beacon Proofs contract that verifies beacon chain data\\n    address public immutable BEACON_PROOFS;\\n    /// @notice The timestamp of the Beacon chain genesis.\\n    /// @dev this is different on Testnets like Hoodi so is set at deployment time.\\n    uint64 public immutable BEACON_GENESIS_TIMESTAMP;\\n\\n    /// @notice Address of the registrator - allowed to register, withdraw, exit and remove validators\\n    address public validatorRegistrator;\\n\\n    /// Deposit data for new compounding validators.\\n    enum DepositStatus {\\n        UNKNOWN, // default value\\n        PENDING, // deposit is pending and waiting to be  verified\\n        VERIFIED // deposit has been verified and is ready to be staked\\n    }\\n\\n    /// @param pubKeyHash Hash of validator's public key using the Beacon Chain's format\\n    /// @param amountWei Amount of ETH in wei that has been deposited to the beacon chain deposit contract\\n    /// @param blockNumber Block number when the deposit was made\\n    /// @param depositIndex The index of the deposit in the list of active deposits\\n    /// @param status The status of the deposit, either PENDING or VERIFIED\\n    struct DepositData {\\n        bytes32 pubKeyHash;\\n        uint64 amountGwei;\\n        uint64 slot;\\n        uint32 depositIndex;\\n        DepositStatus status;\\n        uint64 withdrawableEpoch;\\n    }\\n    /// @notice Restricts to only one deposit to an unverified validator at a time.\\n    /// This is to limit front-running attacks of deposits to the beacon chain contract.\\n    bool public firstDeposit;\\n    /// @notice Unique identifier of the next validator deposit.\\n    uint128 public nextDepositID;\\n    /// @notice Mapping of the deposit ID to the deposit data\\n    mapping(uint256 => DepositData) public deposits;\\n    /// @notice List of strategy deposit IDs to a validator.\\n    /// The list can be for deposits waiting to be verified as processed on the beacon chain,\\n    /// or deposits that have been verified to an exiting validator and is now waiting for the\\n    /// validator's balance to be swept.\\n    /// The list may not be ordered by time of deposit.\\n    /// Removed deposits will move the last deposit to the removed index.\\n    uint256[] public depositList;\\n\\n    // Validator data\\n    enum ValidatorState {\\n        NON_REGISTERED, // validator is not registered on the SSV network\\n        REGISTERED, // validator is registered on the SSV network\\n        STAKED, // validator has funds staked\\n        VERIFIED, // validator has been verified to exist on the beacon chain\\n        EXITING, // The validator has been requested to exit or has been verified as forced exit\\n        EXITED, // The validator has been verified to have a zero balance\\n        REMOVED, // validator has funds withdrawn to the EigenPod and is removed from the SSV\\n        INVALID // The validator has been front-run and the withdrawal address is not this strategy\\n    }\\n\\n    struct ValidatorData {\\n        ValidatorState state;\\n        uint64 index; // The index of the validator on the beacon chain\\n    }\\n    /// @notice List of validator public key hashes that have been verified to exist on the beacon chain.\\n    /// These have had a deposit processed and the validator's balance increased.\\n    /// Validators will be removed from this list when its verified they have a zero balance.\\n    bytes32[] public verifiedValidators;\\n    /// @notice Mapping of the hash of the validator's public key to the validator state and index.\\n    /// Uses the Beacon chain hashing for BLSPubkey which is sha256(abi.encodePacked(validator.pubkey, bytes16(0)))\\n    mapping(bytes32 => ValidatorData) public validator;\\n\\n    /// @param timestamp Timestamp of the snapshot\\n    /// @param ethBalance The balance of ETH in the strategy contract at the snapshot\\n    struct Balances {\\n        uint64 timestamp;\\n        uint128 ethBalance;\\n    }\\n    /// @notice Mapping of the block root to the balances at that slot\\n    mapping(bytes32 => Balances) public snappedBalances;\\n    /// @notice The timestamp of the last snapshot taken\\n    uint64 public lastSnapTimestamp;\\n    /// @notice The last verified ETH balance of the strategy\\n    uint128 public lastVerifiedEthBalance;\\n\\n    /// @dev This contract receives WETH as the deposit asset, but unlike other strategies doesn't immediately\\n    /// deposit it to an underlying platform. Rather a special privilege account stakes it to the validators.\\n    /// For that reason calling WETH.balanceOf(this) in a deposit function can contain WETH that has just been\\n    /// deposited and also WETH that has previously been deposited. To keep a correct count we need to keep track\\n    /// of WETH that has already been accounted for.\\n    /// This value represents the amount of WETH balance of this contract that has already been accounted for by the\\n    /// deposit events.\\n    /// It is important to note that this variable is not concerned with WETH that is a result of full/partial\\n    /// withdrawal of the validators. It is strictly concerned with WETH that has been deposited and is waiting to\\n    /// be staked.\\n    uint256 public depositedWethAccountedFor;\\n\\n    // For future use\\n    uint256[50] private __gap;\\n\\n    event RegistratorChanged(address indexed newAddress);\\n    event StakingMonitorChanged(address indexed newAddress);\\n    event FirstDepositReset();\\n    event SSVValidatorRegistered(\\n        bytes32 indexed pubKeyHash,\\n        uint64[] operatorIds\\n    );\\n    event SSVValidatorRemoved(bytes32 indexed pubKeyHash, uint64[] operatorIds);\\n    event ETHStaked(\\n        bytes32 indexed pubKeyHash,\\n        uint256 indexed depositID,\\n        bytes pubKey,\\n        uint256 amountWei\\n    );\\n    event ValidatorVerified(\\n        bytes32 indexed pubKeyHash,\\n        uint64 indexed validatorIndex\\n    );\\n    event ValidatorInvalid(bytes32 indexed pubKeyHash);\\n    event DepositVerified(uint256 indexed depositID, uint256 amountWei);\\n    event DepositToValidatorExiting(\\n        uint256 indexed depositID,\\n        uint256 amountWei,\\n        uint64 withdrawableEpoch\\n    );\\n    event DepositValidatorExited(uint256 indexed depositID, uint256 amountWei);\\n    event ValidatorWithdraw(bytes32 indexed pubKeyHash, uint256 amountWei);\\n    event BalancesSnapped(bytes32 indexed blockRoot, uint256 ethBalance);\\n    event BalancesVerified(\\n        uint64 indexed timestamp,\\n        uint256 totalDepositsWei,\\n        uint256 totalValidatorBalance,\\n        uint256 ethBalance\\n    );\\n\\n    /// @dev Throws if called by any account other than the Registrator\\n    modifier onlyRegistrator() {\\n        require(msg.sender == validatorRegistrator, \\\"Not Registrator\\\");\\n        _;\\n    }\\n\\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\\n    /// @param _vaultAddress Address of the Vault\\n    /// @param _beaconChainDepositContract Address of the beacon chain deposit contract\\n    /// @param _ssvNetwork Address of the SSV Network contract\\n    /// @param _beaconProofs Address of the Beacon Proofs contract that verifies beacon chain data\\n    /// @param _beaconGenesisTimestamp The timestamp of the Beacon chain's genesis.\\n    constructor(\\n        address _wethAddress,\\n        address _vaultAddress,\\n        address _beaconChainDepositContract,\\n        address _ssvNetwork,\\n        address _beaconProofs,\\n        uint64 _beaconGenesisTimestamp\\n    ) {\\n        WETH = _wethAddress;\\n        BEACON_CHAIN_DEPOSIT_CONTRACT = _beaconChainDepositContract;\\n        SSV_NETWORK = _ssvNetwork;\\n        VAULT_ADDRESS = _vaultAddress;\\n        BEACON_PROOFS = _beaconProofs;\\n        BEACON_GENESIS_TIMESTAMP = _beaconGenesisTimestamp;\\n\\n        require(\\n            block.timestamp > _beaconGenesisTimestamp,\\n            \\\"Invalid genesis timestamp\\\"\\n        );\\n    }\\n\\n    /**\\n     *\\n     *             Admin Functions\\n     *\\n     */\\n\\n    /// @notice Set the address of the registrator which can register, exit and remove validators\\n    function setRegistrator(address _address) external onlyGovernor {\\n        validatorRegistrator = _address;\\n        emit RegistratorChanged(_address);\\n    }\\n\\n    /// @notice Reset the `firstDeposit` flag to false so deposits to unverified validators can be made again.\\n    function resetFirstDeposit() external onlyGovernor {\\n        require(firstDeposit, \\\"No first deposit\\\");\\n\\n        firstDeposit = false;\\n\\n        emit FirstDepositReset();\\n    }\\n\\n    /**\\n     *\\n     *             Validator Management\\n     *\\n     */\\n\\n    /// @notice Registers a single validator in a SSV Cluster.\\n    /// Only the Registrator can call this function.\\n    /// @param publicKey The public key of the validator\\n    /// @param operatorIds The operator IDs of the SSV Cluster\\n    /// @param sharesData The shares data for the validator\\n    /// @param ssvAmount The amount of SSV tokens to be deposited to the SSV cluster\\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\\n    // slither-disable-start reentrancy-no-eth\\n    function registerSsvValidator(\\n        bytes calldata publicKey,\\n        uint64[] calldata operatorIds,\\n        bytes calldata sharesData,\\n        uint256 ssvAmount,\\n        Cluster calldata cluster\\n    ) external onlyRegistrator {\\n        // Hash the public key using the Beacon Chain's format\\n        bytes32 pubKeyHash = _hashPubKey(publicKey);\\n        // Check each public key has not already been used\\n        require(\\n            validator[pubKeyHash].state == ValidatorState.NON_REGISTERED,\\n            \\\"Validator already registered\\\"\\n        );\\n\\n        // Store the validator state as registered\\n        validator[pubKeyHash].state = ValidatorState.REGISTERED;\\n\\n        ISSVNetwork(SSV_NETWORK).registerValidator(\\n            publicKey,\\n            operatorIds,\\n            sharesData,\\n            ssvAmount,\\n            cluster\\n        );\\n\\n        emit SSVValidatorRegistered(pubKeyHash, operatorIds);\\n    }\\n\\n    // slither-disable-end reentrancy-no-eth\\n\\n    struct ValidatorStakeData {\\n        bytes pubkey;\\n        bytes signature;\\n        bytes32 depositDataRoot;\\n    }\\n\\n    /// @notice Stakes WETH in this strategy to a compounding validator.\\n    /// Does not convert any ETH sitting in this strategy to WETH.\\n    /// @param validatorStakeData validator data needed to stake.\\n    /// The `ValidatorStakeData` struct contains the pubkey, signature and depositDataRoot.\\n    /// Only the registrator can call this function.\\n    /// @param depositAmountGwei The amount of WETH to stake to the validator in Gwei.\\n    // slither-disable-start reentrancy-eth\\n    function stakeEth(\\n        ValidatorStakeData calldata validatorStakeData,\\n        uint64 depositAmountGwei\\n    ) external onlyRegistrator {\\n        uint256 depositAmountWei = uint256(depositAmountGwei) * 1 gwei;\\n        // Check there is enough WETH from the deposits sitting in this strategy contract\\n        // There could be ETH from withdrawals but we'll ignore that. If it's really needed\\n        // the ETH can be withdrawn and then deposited back to the strategy.\\n        require(\\n            depositAmountWei <= IWETH9(WETH).balanceOf(address(this)),\\n            \\\"Insufficient WETH\\\"\\n        );\\n        require(depositList.length < MAX_DEPOSITS, \\\"Max deposits\\\");\\n\\n        // Convert required ETH from WETH and do the necessary accounting\\n        _convertWethToEth(depositAmountWei);\\n\\n        // Hash the public key using the Beacon Chain's hashing for BLSPubkey\\n        bytes32 pubKeyHash = _hashPubKey(validatorStakeData.pubkey);\\n        ValidatorState currentState = validator[pubKeyHash].state;\\n        // Can only stake to a validator has have been registered or verified.\\n        // Can not stake to a validator that has been staked but not yet verified.\\n        require(\\n            (currentState == ValidatorState.REGISTERED ||\\n                currentState == ValidatorState.VERIFIED),\\n            \\\"Not registered or verified\\\"\\n        );\\n        require(depositAmountWei >= 1 ether, \\\"Deposit too small\\\");\\n        if (currentState == ValidatorState.REGISTERED) {\\n            // Can only have one pending deposit to an unverified validator at a time.\\n            // This is to limit front-running deposit attacks to a single deposit.\\n            // The exiting deposit needs to be verified before another deposit can be made.\\n            // If there was a front-running attack, the validator needs to be verified as invalid\\n            // and the Governor calls `resetFirstDeposit` to set `firstDeposit` to false.\\n            require(!firstDeposit, \\\"Existing first deposit\\\");\\n            // Limits the amount of ETH that can be at risk from a front-running deposit attack.\\n            require(\\n                depositAmountWei == DEPOSIT_AMOUNT_WEI,\\n                \\\"Invalid first deposit amount\\\"\\n            );\\n            // Limits the number of validator balance proofs to verifyBalances\\n            require(\\n                verifiedValidators.length + 1 < MAX_VERIFIED_VALIDATORS,\\n                \\\"Max validators\\\"\\n            );\\n\\n            // Flag a deposit to an unverified validator so only no other deposits can be made\\n            // to an unverified validator.\\n            firstDeposit = true;\\n        }\\n\\n        /* 0x02 to indicate that withdrawal credentials are for a compounding validator\\n         * that was introduced with the Pectra upgrade.\\n         * bytes11(0) to fill up the required zeros\\n         * remaining bytes20 are for the address\\n         */\\n        bytes memory withdrawalCredentials = abi.encodePacked(\\n            bytes1(0x02),\\n            bytes11(0),\\n            address(this)\\n        );\\n\\n        // Deposit to the Beacon Chain deposit contract.\\n        // This will create a deposit in the beacon chain's pending deposit queue.\\n        IDepositContract(BEACON_CHAIN_DEPOSIT_CONTRACT).deposit{\\n            value: depositAmountWei\\n        }(\\n            validatorStakeData.pubkey,\\n            withdrawalCredentials,\\n            validatorStakeData.signature,\\n            validatorStakeData.depositDataRoot\\n        );\\n\\n        //// Update contract storage\\n        // Store the validator state if needed\\n        if (currentState == ValidatorState.REGISTERED) {\\n            validator[pubKeyHash].state = ValidatorState.STAKED;\\n        }\\n\\n        /// After the Pectra upgrade the validators have a new restriction when proposing\\n        /// blocks. The timestamps are at strict intervals of 12 seconds from the genesis block\\n        /// forward. Each slot is created at strict 12 second intervals and those slots can\\n        /// either have blocks attached to them or not. This way using the block.timestamp\\n        /// the slot number can easily be calculated.\\n        uint64 depositSlot = (SafeCast.toUint64(block.timestamp) -\\n            BEACON_GENESIS_TIMESTAMP) / SLOT_DURATION;\\n\\n        // Store the deposit data for verifyDeposit and verifyBalances\\n        uint256 depositID = nextDepositID++;\\n        deposits[depositID] = DepositData({\\n            pubKeyHash: pubKeyHash,\\n            amountGwei: depositAmountGwei,\\n            slot: depositSlot,\\n            depositIndex: SafeCast.toUint32(depositList.length),\\n            status: DepositStatus.PENDING,\\n            withdrawableEpoch: FAR_FUTURE_EPOCH\\n        });\\n        depositList.push(depositID);\\n\\n        emit ETHStaked(\\n            pubKeyHash,\\n            depositID,\\n            validatorStakeData.pubkey,\\n            depositAmountWei\\n        );\\n    }\\n\\n    // slither-disable-end reentrancy-eth\\n\\n    /// @notice Request a full or partial withdrawal from a validator.\\n    /// A zero amount will trigger a full withdrawal.\\n    /// If the remaining balance is < 32 ETH then only the amount in excess of 32 ETH will be withdrawn.\\n    /// Only the Registrator can call this function.\\n    /// 1 wei of value should be sent with the tx to pay for the withdrawal request fee.\\n    /// If no value sent, 1 wei will be taken from the strategy's ETH balance if it has any.\\n    /// If no ETH balance, the tx will revert.\\n    /// @param publicKey The public key of the validator\\n    /// @param amountGwei The amount of ETH to be withdrawn from the validator in Gwei.\\n    /// A zero amount will trigger a full withdrawal.\\n    // slither-disable-start reentrancy-no-eth\\n    function validatorWithdrawal(bytes calldata publicKey, uint64 amountGwei)\\n        external\\n        payable\\n        onlyRegistrator\\n    {\\n        // Hash the public key using the Beacon Chain's format\\n        bytes32 pubKeyHash = _hashPubKey(publicKey);\\n        ValidatorState currentState = validator[pubKeyHash].state;\\n        require(\\n            currentState == ValidatorState.VERIFIED,\\n            \\\"Validator not verified\\\"\\n        );\\n\\n        PartialWithdrawal.request(publicKey, amountGwei);\\n\\n        // If a full withdrawal (validator exit)\\n        if (amountGwei == 0) {\\n            // Store the validator state as exiting so no more deposits can be made to it.\\n            validator[pubKeyHash].state = ValidatorState.EXITING;\\n        }\\n\\n        // Do not remove from the list of verified validators.\\n        // This is done in the verifyBalances function once the validator's balance has been verified to be zero.\\n        // The validator state will be set to EXITED in the verifyBalances function.\\n\\n        emit ValidatorWithdraw(pubKeyHash, uint256(amountGwei) * 1 gwei);\\n    }\\n\\n    // slither-disable-end reentrancy-no-eth\\n\\n    /// @notice Remove the validator from the SSV Cluster after:\\n    /// - the validator has been exited from `validatorWithdrawal` or slashed\\n    /// - the validator has incorrectly registered and can not be staked to\\n    /// - the initial deposit was front-run and the withdrawal address is not this strategy's address.\\n    /// Make sure `validatorWithdrawal` is called with a zero amount and the validator has exited the Beacon chain.\\n    /// If removed before the validator has exited the beacon chain will result in the validator being slashed.\\n    /// Only the registrator can call this function.\\n    /// @param publicKey The public key of the validator\\n    /// @param operatorIds The operator IDs of the SSV Cluster\\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\\n    // slither-disable-start reentrancy-no-eth\\n    function removeSsvValidator(\\n        bytes calldata publicKey,\\n        uint64[] calldata operatorIds,\\n        Cluster calldata cluster\\n    ) external onlyRegistrator {\\n        // Hash the public key using the Beacon Chain's format\\n        bytes32 pubKeyHash = _hashPubKey(publicKey);\\n        ValidatorState currentState = validator[pubKeyHash].state;\\n        // Can remove SSV validators that were incorrectly registered and can not be deposited to.\\n        require(\\n            currentState == ValidatorState.REGISTERED ||\\n                currentState == ValidatorState.EXITED ||\\n                currentState == ValidatorState.INVALID,\\n            \\\"Validator not regd or exited\\\"\\n        );\\n\\n        ISSVNetwork(SSV_NETWORK).removeValidator(\\n            publicKey,\\n            operatorIds,\\n            cluster\\n        );\\n\\n        validator[pubKeyHash].state = ValidatorState.REMOVED;\\n\\n        emit SSVValidatorRemoved(pubKeyHash, operatorIds);\\n    }\\n\\n    /**\\n     *\\n     *             SSV Management\\n     *\\n     */\\n\\n    // slither-disable-end reentrancy-no-eth\\n\\n    /// `depositSSV` has been removed as `deposit` on the SSVNetwork contract can be called directly\\n    /// by the Strategist which is already holding SSV tokens.\\n\\n    /// @notice Withdraws excess SSV Tokens from the SSV Network contract which was used to pay the SSV Operators.\\n    /// @dev A SSV cluster is defined by the SSVOwnerAddress and the set of operatorIds.\\n    /// @param operatorIds The operator IDs of the SSV Cluster\\n    /// @param ssvAmount The amount of SSV tokens to be withdrawn from the SSV cluster\\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\\n    function withdrawSSV(\\n        uint64[] memory operatorIds,\\n        uint256 ssvAmount,\\n        Cluster memory cluster\\n    ) external onlyGovernor {\\n        ISSVNetwork(SSV_NETWORK).withdraw(operatorIds, ssvAmount, cluster);\\n    }\\n\\n    /**\\n     *\\n     *             Beacon Chain Proofs\\n     *\\n     */\\n\\n    /// @notice Verifies a validator's index to its public key.\\n    /// Adds to the list of verified validators if the validator's withdrawal address is this strategy's address.\\n    /// Marks the validator as invalid and removes the deposit if the withdrawal address is not this strategy's address.\\n    /// @param nextBlockTimestamp The timestamp of the execution layer block after the beacon chain slot\\n    /// we are verifying.\\n    /// The next one is needed as the Beacon Oracle returns the parent beacon block root for a block timestamp,\\n    /// which is the beacon block root of the previous block.\\n    /// @param validatorIndex The index of the validator on the beacon chain.\\n    /// @param pubKeyHash The hash of the validator's public key using the Beacon Chain's format\\n    /// @param withdrawalAddress The withdrawal address of the validator which should be this strategy's address.\\n    /// If the withdrawal address is not this strategy's address, the initial deposit was front-run\\n    /// and the validator is marked as invalid.\\n    /// @param validatorPubKeyProof The merkle proof for the validator public key to the beacon block root.\\n    /// This is 53 witness hashes of 32 bytes each concatenated together starting from the leaf node.\\n    /// BeaconBlock.state.validators[validatorIndex].pubkey\\n    function verifyValidator(\\n        uint64 nextBlockTimestamp,\\n        uint64 validatorIndex,\\n        bytes32 pubKeyHash,\\n        address withdrawalAddress,\\n        bytes calldata validatorPubKeyProof\\n    ) external {\\n        require(\\n            validator[pubKeyHash].state == ValidatorState.STAKED,\\n            \\\"Validator not staked\\\"\\n        );\\n\\n        // Get the beacon block root of the slot we are verifying the validator in.\\n        // The parent beacon block root of the next block is the beacon block root of the slot we are verifying.\\n        bytes32 blockRoot = BeaconRoots.parentBlockRoot(nextBlockTimestamp);\\n\\n        // Verify the validator index is for the validator with the given public key.\\n        // Also verify the validator's withdrawal credential points to the `withdrawalAddress`.\\n        IBeaconProofs(BEACON_PROOFS).verifyValidator(\\n            blockRoot,\\n            pubKeyHash,\\n            validatorPubKeyProof,\\n            validatorIndex,\\n            withdrawalAddress\\n        );\\n\\n        // If the initial deposit was front-run and the withdrawal address is not this strategy\\n        if (withdrawalAddress != address(this)) {\\n            validator[pubKeyHash] = ValidatorData({\\n                state: ValidatorState.INVALID,\\n                index: validatorIndex\\n            });\\n\\n            // Find and remove the deposit as the funds can not be recovered\\n            uint256 depositCount = depositList.length;\\n            for (uint256 i = 0; i < depositCount; i++) {\\n                DepositData memory deposit = deposits[depositList[i]];\\n                if (deposit.pubKeyHash == pubKeyHash) {\\n                    _removeDeposit(depositList[i], deposit);\\n                    break;\\n                }\\n            }\\n\\n            // Leave the `firstDeposit` flag as true so no more deposits to unverified validators can be made.\\n            // The Governor has to reset the `firstDeposit` to false before another deposit to\\n            // an unverified validator can be made.\\n            // The Governor can set a new `validatorRegistrator` if they suspect it has been compromised.\\n\\n            emit ValidatorInvalid(pubKeyHash);\\n            return;\\n        }\\n\\n        // Store the validator state as verified\\n        validator[pubKeyHash] = ValidatorData({\\n            state: ValidatorState.VERIFIED,\\n            index: validatorIndex\\n        });\\n\\n        // Add the new validator to the list of verified validators\\n        verifiedValidators.push(pubKeyHash);\\n\\n        // Reset the firstDeposit flag as the first deposit to an unverified validator has been verified.\\n        firstDeposit = false;\\n\\n        emit ValidatorVerified(pubKeyHash, validatorIndex);\\n    }\\n\\n    struct FirstPendingDepositProofData {\\n        uint64 slot;\\n        uint64 validatorIndex;\\n        bytes32 pubKeyHash;\\n        bytes pendingDepositPubKeyProof;\\n        bytes withdrawableEpochProof;\\n        bytes validatorPubKeyProof;\\n    }\\n\\n    struct DepositValidatorProofData {\\n        uint64 withdrawableEpoch;\\n        bytes withdrawableEpochProof;\\n    }\\n\\n    /// @notice Verifies a deposit on the execution layer has been processed by the beacon chain.\\n    /// This means the accounting of the strategy's ETH moves from a pending deposit to a validator balance.\\n    ///\\n    /// Important: this function has a limitation where the `verificationSlot` that is passed by the off-chain\\n    /// verifier requires a slot immediately after it to propose a block otherwise the `BeaconRoots.parentBlockRoot`\\n    /// will fail. This shouldn't be a problem, since by the current behaviour of beacon chain only 1%-3% slots\\n    /// don't propose a block.\\n    /// @param depositID The deposit ID emitted in `ETHStaked` from the `stakeEth` function.\\n    /// @param depositProcessedSlot Any slot on or after the strategy's deposit was processed on the beacon chain.\\n    /// Can not be a slot with pending deposits with the same slot as the deposit being verified.\\n    /// Can not be a slot before a missed slot as the Beacon Root contract will have the parent block root\\n    /// set for the next block timestamp in 12 seconds time.\\n    /// @param firstDepositValidatorCreatedSlot The slot on or after when the validator of the first pending deposit\\n    /// was created on the beacon chain. This is used to verify the validator has not exited.\\n    // slither-disable-start reentrancy-no-eth\\n    function verifyDeposit(\\n        uint256 depositID,\\n        uint64 depositProcessedSlot,\\n        uint64 firstDepositValidatorCreatedSlot,\\n        FirstPendingDepositProofData calldata firstPendingDeposit,\\n        DepositValidatorProofData calldata strategyValidatorData\\n    ) external {\\n        // Load into memory the previously saved deposit data\\n        DepositData memory deposit = deposits[depositID];\\n        ValidatorData memory strategyValidator = validator[deposit.pubKeyHash];\\n        require(deposit.status == DepositStatus.PENDING, \\\"Deposit not pending\\\");\\n        require(\\n            strategyValidator.state == ValidatorState.VERIFIED,\\n            \\\"Validator not verified\\\"\\n        );\\n        // The verification slot must be after the deposit's slot.\\n        // This is needed for when the deposit queue is empty.\\n        require(deposit.slot < depositProcessedSlot, \\\"Slot not after deposit\\\");\\n        require(\\n            depositProcessedSlot <= firstDepositValidatorCreatedSlot,\\n            \\\"Invalid verification slots\\\"\\n        );\\n\\n        // Get the parent beacon block root of the next block which is the block root of the deposit verification slot.\\n        // This will revert if the slot after the verification slot was missed.\\n        bytes32 depositBlockRoot = BeaconRoots.parentBlockRoot(\\n            _calcNextBlockTimestamp(depositProcessedSlot)\\n        );\\n\\n        // Verify the slot of the first pending deposit matches the beacon chain\\n        bool isDepositQueueEmpty = IBeaconProofs(BEACON_PROOFS)\\n            .verifyFirstPendingDeposit(\\n                depositBlockRoot,\\n                firstPendingDeposit.slot,\\n                firstPendingDeposit.pubKeyHash,\\n                firstPendingDeposit.pendingDepositPubKeyProof\\n            );\\n\\n        // If the deposit queue is not empty\\n        if (!isDepositQueueEmpty) {\\n            // Get the parent beacon block root of the next block which is\\n            // the block root of the validator verification slot.\\n            // This will revert if the slot after the verification slot was missed.\\n            bytes32 validatorBlockRoot = BeaconRoots.parentBlockRoot(\\n                _calcNextBlockTimestamp(firstDepositValidatorCreatedSlot)\\n            );\\n\\n            // Verify the validator of the first pending deposit is not exiting.\\n            // If it is exiting we can't be sure this deposit has not been postponed in the deposit queue.\\n            // Hence we can not verify if the strategy's deposit has been processed or not.\\n            IBeaconProofs(BEACON_PROOFS).verifyValidatorWithdrawable(\\n                validatorBlockRoot,\\n                firstPendingDeposit.validatorIndex,\\n                firstPendingDeposit.pubKeyHash,\\n                FAR_FUTURE_EPOCH,\\n                firstPendingDeposit.withdrawableEpochProof,\\n                firstPendingDeposit.validatorPubKeyProof\\n            );\\n        }\\n\\n        // Verify the withdrawableEpoch on the validator of the strategy's deposit\\n        IBeaconProofs(BEACON_PROOFS).verifyValidatorWithdrawable(\\n            depositBlockRoot,\\n            strategyValidator.index,\\n            strategyValidatorData.withdrawableEpoch,\\n            strategyValidatorData.withdrawableEpochProof\\n        );\\n\\n        // If the validator is exiting because it has been slashed\\n        if (strategyValidatorData.withdrawableEpoch != FAR_FUTURE_EPOCH) {\\n            // Store the exit epoch in the deposit data\\n            deposit.withdrawableEpoch = strategyValidatorData.withdrawableEpoch;\\n\\n            emit DepositToValidatorExiting(\\n                depositID,\\n                uint256(deposit.amountGwei) * 1 gwei,\\n                strategyValidatorData.withdrawableEpoch\\n            );\\n\\n            validator[deposit.pubKeyHash].state = ValidatorState.EXITING;\\n\\n            // Leave the deposit status as PENDING\\n            return;\\n        }\\n\\n        // solhint-disable max-line-length\\n        // Check the deposit slot is before the first pending deposit's slot on the beacon chain.\\n        // If this is not true then we can't guarantee the deposit has been processed by the beacon chain.\\n        // The deposit's slot can not be the same slot as the first pending deposit as there could be\\n        // many deposits in the same block, hence have the same pending deposit slot.\\n        // If the deposit queue is empty then our deposit must have been processed on the beacon chain.\\n        // The deposit slot can be zero for validators consolidating to a compounding validator or 0x01 validator\\n        // being promoted to a compounding one. Reference:\\n        // - [switch_to_compounding_validator](https://ethereum.github.io/consensus-specs/specs/electra/beacon-chain/#new-switch_to_compounding_validator\\n        // - [queue_excess_active_balance](https://ethereum.github.io/consensus-specs/specs/electra/beacon-chain/#new-queue_excess_active_balance)\\n        // - [process_consolidation_request](https://ethereum.github.io/consensus-specs/specs/electra/beacon-chain/#new-process_consolidation_request)\\n        // We can not guarantee that the deposit has been processed in that case.\\n        // solhint-enable max-line-length\\n        require(\\n            deposit.slot < firstPendingDeposit.slot || isDepositQueueEmpty,\\n            \\\"Deposit likely not processed\\\"\\n        );\\n\\n        // Remove the deposit now it has been verified as processed on the beacon chain.\\n        _removeDeposit(depositID, deposit);\\n\\n        emit DepositVerified(depositID, uint256(deposit.amountGwei) * 1 gwei);\\n    }\\n\\n    function _removeDeposit(uint256 depositID, DepositData memory deposit)\\n        internal\\n    {\\n        // After verifying the proof, update the contract storage\\n        deposits[depositID].status = DepositStatus.VERIFIED;\\n        // Move the last deposit to the index of the verified deposit\\n        uint256 lastDeposit = depositList[depositList.length - 1];\\n        depositList[deposit.depositIndex] = lastDeposit;\\n        deposits[lastDeposit].depositIndex = deposit.depositIndex;\\n        // Delete the last deposit from the list\\n        depositList.pop();\\n    }\\n\\n    /// @dev Calculates the timestamp of the next execution block from the given slot.\\n    /// @param slot The beacon chain slot number used for merkle proof verification.\\n    function _calcNextBlockTimestamp(uint64 slot)\\n        internal\\n        view\\n        returns (uint64)\\n    {\\n        // Calculate the next block timestamp from the slot.\\n        return SLOT_DURATION * slot + BEACON_GENESIS_TIMESTAMP + SLOT_DURATION;\\n    }\\n\\n    // slither-disable-end reentrancy-no-eth\\n\\n    /// @notice Stores the current ETH balance at the current block and beacon block root\\n    ///         of the slot that is associated with the previous block.\\n    ///\\n    /// When snapping / verifying balance it is of a high importance that there is no\\n    /// miss-match in respect to ETH that is held by the contract and balances that are\\n    /// verified on the validators.\\n    ///\\n    /// First some context on the beacon-chain block building behaviour. Relevant parts of\\n    /// constructing a block on the beacon chain consist of:\\n    ///  - process_withdrawals: ETH is deducted from the validator's balance\\n    ///  - process_execution_payload: immediately after the previous step executing all the\\n    ///    transactions\\n    ///  - apply the withdrawals: adding ETH to the recipient which is the withdrawal address\\n    ///    contained in the withdrawal credentials of the exited validators\\n    ///\\n    /// That means that balance increases which are part of the post-block execution state are\\n    /// done within the block, but the transaction that are contained within that block can not\\n    /// see / interact with the balance from the exited validators. Only transactions in the\\n    /// next block can do that.\\n    ///\\n    /// When snap balances is performed the state of the chain is snapped across 2 separate\\n    /// chain states:\\n    ///  - ETH balance of the contract is recorded on block X -> and corresponding slot Y\\n    ///  - beacon chain block root is recorded of block X - 1 -> and corresponding slot Y - 1\\n    ///    given there were no missed slots. It could also be Y - 2, Y - 3 depending on how\\n    ///    many slots have not managed to propose a block. For the sake of simplicity this slot\\n    ///    will be referred to as Y - 1 as it makes no difference in the argument\\n    ///\\n    /// Given these 2 separate chain states it is paramount that verify balances can not experience\\n    /// miss-counting ETH or much more dangerous double counting of the ETH.\\n    ///\\n    /// When verifyBalances is called it is performed on the current block Z where Z > X. Verify\\n    /// balances adds up all the ETH (omitting WETH) controlled by this contract:\\n    ///  - ETH balance in the contract on block X\\n    ///  - ETH balance in Deposits on block Z that haven't been yet processed in slot Y - 1\\n    ///  - ETH balance in validators that are active in slot Y - 1\\n    ///  - skips the ETH balance in validators that have withdrawn in slot Y - 1 (or sooner)\\n    ///    and have their balance visible to transactions in slot Y and corresponding block X\\n    ///    (or sooner)\\n    ///\\n    /// Lets verify the correctness of ETH accounting given the above described behaviour.\\n    ///\\n    /// *ETH balance in the contract on block X*\\n    ///\\n    /// This is an ETH balance of the contract on a non current X block. Any ETH leaving the\\n    /// contract as a result of a withdrawal subtracts from the ETH accounted for on block X\\n    /// if `verifyBalances` has already been called. It also invalidates a `snapBalances` in\\n    /// case `verifyBalances` has not been called yet. Not performing this would result in not\\n    /// accounting for the withdrawn ETH that has happened anywhere in the block interval [X + 1, Z].\\n    ///\\n    /// Similarly to withdrawals any `stakeEth` deposits to the deposit contract adds to the ETH\\n    /// accounted for since the last `verifyBalances` has been called. And it invalidates the\\n    /// `snapBalances` in case `verifyBalances` hasn't been yet called. Not performing this\\n    /// would result in double counting the `stakedEth` since it would be present once in the\\n    /// snapped contract balance and the second time in deposit storage variables.\\n    ///\\n    /// This behaviour is correct.\\n    ///\\n    /// *ETH balance in Deposits on block Z that haven't been yet processed in slot Y - 1*\\n    ///\\n    /// The contract sums up all the ETH that has been deposited to the Beacon chain deposit\\n    /// contract at block Z. The execution layer doesn't have direct access to the state of\\n    /// deposits on the beacon chain. And if it is to sum up all the ETH that is marked to be\\n    /// deposited it needs to be sure to not double count ETH that is in deposits (storage vars)\\n    /// and could also be part of the validator balances. It does that by verifying that at\\n    /// slot Y - 1 none of the deposits visible on block Z have been processed. Meaning since\\n    /// the last snap till now all are still in queue. Which ensures they can not be part of\\n    /// the validator balances in later steps.\\n    ///\\n    /// This behaviour is correct.\\n    ///\\n    /// *ETH balance in validators that are active in slot Y - 1*\\n    ///\\n    /// The contract is verifying none of the deposits on Y - 1 slot have been processed and\\n    /// for that reason it checks the validator balances in the same slot. Ensuring accounting\\n    /// correctness.\\n    ///\\n    /// This behaviour is correct.\\n    ///\\n    /// *The withdrawn validators*\\n    ///\\n    /// The withdrawn validators could have their balances deducted in any slot before slot\\n    /// Y - 1 and the execution layer sees the balance increase in the subsequent slot. Lets\\n    /// look at the \\\"worst case scenario\\\" where the validator withdrawal is processed in the\\n    /// slot Y - 1 (snapped slot) and see their balance increase (in execution layer) in slot\\n    /// Y -> block X. The ETH balance on the contract is snapped at block X meaning that\\n    /// even if the validator exits at the latest possible time it is paramount that the ETH\\n    /// balance on the execution layer is recorded in the next block. Correctly accounting\\n    /// for the withdrawn ETH.\\n    ///\\n    /// Worth mentioning if the validator exit is processed by the slot Y and balance increase\\n    /// seen on the execution layer on block X + 1 the withdrawal is ignored by both the\\n    /// validator balance verification as well as execution layer contract balance snap.\\n    ///\\n    /// This behaviour is correct.\\n    ///\\n    /// The validator balances on the beacon chain can then be proved with `verifyBalances`.\\n    function snapBalances() external {\\n        uint64 currentTimestamp = SafeCast.toUint64(block.timestamp);\\n        require(\\n            lastSnapTimestamp + SNAP_BALANCES_DELAY < currentTimestamp,\\n            \\\"Snap too soon\\\"\\n        );\\n\\n        bytes32 blockRoot = BeaconRoots.parentBlockRoot(currentTimestamp);\\n        // Get the current ETH balance\\n        uint256 ethBalance = address(this).balance;\\n\\n        // Store the balances in the mapping\\n        snappedBalances[blockRoot] = Balances({\\n            timestamp: currentTimestamp,\\n            ethBalance: SafeCast.toUint128(ethBalance)\\n        });\\n\\n        // Store the snapped timestamp\\n        lastSnapTimestamp = currentTimestamp;\\n\\n        emit BalancesSnapped(blockRoot, ethBalance);\\n    }\\n\\n    // A struct is used to avoid stack too deep errors\\n    struct BalanceProofs {\\n        // BeaconBlock.state.balances\\n        bytes32 balancesContainerRoot;\\n        bytes balancesContainerProof;\\n        // BeaconBlock.state.balances[validatorIndex]\\n        bytes32[] validatorBalanceLeaves;\\n        bytes[] validatorBalanceProofs;\\n    }\\n\\n    /// @notice Verifies the balances of all active validators on the beacon chain\\n    /// and checks no pending deposits have been processed by the beacon chain.\\n    /// @param snapBlockRoot The beacon block root emitted from `snapBalance` in `BalancesSnapped`.\\n    /// @param balanceProofs a `BalanceProofs` struct containing the following:\\n    /// balancesContainerRoot - the merkle root of the balances container\\n    /// balancesContainerProof - The merkle proof for the balances container to the beacon block root.\\n    ///   This is 9 witness hashes of 32 bytes each concatenated together starting from the leaf node.\\n    /// validatorBalanceLeaves - Array of leaf nodes containing the validator balance with three other balances.\\n    /// validatorBalanceProofs -  Array of merkle proofs for the validator balance to the Balances container root.\\n    ///   This is 39 witness hashes of 32 bytes each concatenated together starting from the leaf node.\\n    // slither-disable-start reentrancy-no-eth\\n    function verifyBalances(\\n        bytes32 snapBlockRoot,\\n        uint64 validatorVerificationBlockTimestamp,\\n        FirstPendingDepositProofData calldata firstPendingDeposit,\\n        BalanceProofs calldata balanceProofs\\n    ) external {\\n        // Load previously snapped balances for the given block root\\n        Balances memory balancesMem = snappedBalances[snapBlockRoot];\\n        // Check the balances are the latest\\n        require(lastSnapTimestamp > 0, \\\"No snapped balances\\\");\\n        require(balancesMem.timestamp == lastSnapTimestamp, \\\"Stale snap\\\");\\n\\n        uint256 verifiedValidatorsCount = verifiedValidators.length;\\n        uint256 totalValidatorBalance = 0;\\n\\n        // If there are no verified validators then we can skip the balance verification\\n        if (verifiedValidatorsCount > 0) {\\n            require(\\n                balanceProofs.validatorBalanceProofs.length ==\\n                    verifiedValidatorsCount,\\n                \\\"Invalid balance proofs\\\"\\n            );\\n            require(\\n                balanceProofs.validatorBalanceLeaves.length ==\\n                    verifiedValidatorsCount,\\n                \\\"Invalid balance leaves\\\"\\n            );\\n            // verify beaconBlock.state.balances root to beacon block root\\n            IBeaconProofs(BEACON_PROOFS).verifyBalancesContainer(\\n                snapBlockRoot,\\n                balanceProofs.balancesContainerRoot,\\n                balanceProofs.balancesContainerProof\\n            );\\n\\n            // for each validator in reserve order so we can pop off exited validators at the end\\n            for (uint256 i = verifiedValidatorsCount; i > 0; ) {\\n                --i;\\n                // verify validator's balance in beaconBlock.state.balances to the\\n                // beaconBlock.state.balances container root\\n                uint256 validatorBalanceGwei = IBeaconProofs(BEACON_PROOFS)\\n                    .verifyValidatorBalance(\\n                        balanceProofs.balancesContainerRoot,\\n                        balanceProofs.validatorBalanceLeaves[i],\\n                        balanceProofs.validatorBalanceProofs[i],\\n                        validator[verifiedValidators[i]].index\\n                    );\\n\\n                // If the validator balance is zero\\n                if (validatorBalanceGwei == 0) {\\n                    // Store the validator state as exited\\n                    // This could have been in VERIFIED or EXITING state\\n                    validator[verifiedValidators[i]].state = ValidatorState\\n                        .EXITED;\\n\\n                    // Remove the validator with a zero balance from the list of verified validators\\n\\n                    // Reduce the count of verified validators which is the last index before the pop removes it.\\n                    verifiedValidatorsCount -= 1;\\n\\n                    // Move the last validator that has already been verified to the current index.\\n                    // There's an extra SSTORE if i is the last active validator but that's fine,\\n                    // It's not a common case and the code is simpler this way.\\n                    verifiedValidators[i] = verifiedValidators[\\n                        verifiedValidatorsCount\\n                    ];\\n                    // Delete the last validator from the list\\n                    verifiedValidators.pop();\\n\\n                    // The validator balance is zero so not need to add to totalValidatorBalance\\n                    continue;\\n                }\\n\\n                // convert Gwei balance to Wei and add to the total validator balance\\n                totalValidatorBalance += validatorBalanceGwei * 1 gwei;\\n            }\\n        }\\n\\n        uint256 depositsCount = depositList.length;\\n        uint256 totalDepositsWei = 0;\\n\\n        // If there are no deposits then we can skip the deposit verification.\\n        // This section is after the validator balance verifications so an exited validator will be marked\\n        // as EXITED before the deposits are verified. If there was a deposit to an exited validator\\n        // then the deposit can only be removed once the validator is fully exited.\\n        if (depositsCount > 0) {\\n            // Verify the slot of the first pending deposit matches the beacon chain\\n            bool isDepositQueueEmpty = IBeaconProofs(BEACON_PROOFS)\\n                .verifyFirstPendingDeposit(\\n                    snapBlockRoot,\\n                    firstPendingDeposit.slot,\\n                    firstPendingDeposit.pubKeyHash,\\n                    firstPendingDeposit.pendingDepositPubKeyProof\\n                );\\n\\n            // If there are no deposits in the beacon chain queue then our deposits must have been processed.\\n            // If the deposits have been processed, each deposit will need to be verified with `verifyDeposit`\\n            require(!isDepositQueueEmpty, \\\"Deposits have been processed\\\");\\n\\n            // The verification of the validator the first pending deposit is for must be on or after when\\n            // `snapBalances` was called.\\n            require(\\n                balancesMem.timestamp <= validatorVerificationBlockTimestamp,\\n                \\\"Invalid validator timestamp\\\"\\n            );\\n\\n            // Verify the validator of the first pending deposit is not exiting by checking\\n            // the withdrawable epoch is far into the future.\\n            // If it is exiting we can't be sure this deposit has not been postponed in the deposit queue.\\n            // Hence we can not verify if the strategy's deposit has been processed or not.\\n            IBeaconProofs(BEACON_PROOFS).verifyValidatorWithdrawable(\\n                // Get the parent beacon block root of the next block which is\\n                // the block root of the validator verification slot.\\n                // This will revert if the slot after the verification slot was missed.\\n                BeaconRoots.parentBlockRoot(\\n                    validatorVerificationBlockTimestamp\\n                ),\\n                firstPendingDeposit.validatorIndex,\\n                firstPendingDeposit.pubKeyHash,\\n                // Validator is not exiting\\n                FAR_FUTURE_EPOCH,\\n                firstPendingDeposit.withdrawableEpochProof,\\n                firstPendingDeposit.validatorPubKeyProof\\n            );\\n\\n            // solhint-disable max-line-length\\n            // If a validator is converted from a sweeping validator to a compounding validator, any balance in excess\\n            // of the min 32 ETH is put in the pending deposit queue. Reference:\\n            // - [switch_to_compounding_validator](https://ethereum.github.io/consensus-specs/specs/electra/beacon-chain/#new-switch_to_compounding_validator\\n            // - [queue_excess_active_balance](https://ethereum.github.io/consensus-specs/specs/electra/beacon-chain/#new-queue_excess_active_balance)\\n            // - [process_consolidation_request](https://ethereum.github.io/consensus-specs/specs/electra/beacon-chain/#new-process_consolidation_request)\\n            // This will have a slot value of zero unfortunately.\\n            // We can not prove the strategy's deposits are still pending with a zero slot value so revert the tx.\\n            // Another snapBalances will need to be taken that does not have consolidation deposits at the front of the\\n            // beacon chain deposit queue.\\n            // solhint-enable max-line-length\\n            require(\\n                firstPendingDeposit.slot > 0,\\n                \\\"Invalid first pending deposit\\\"\\n            );\\n\\n            // Calculate the epoch at the time of the snapBalances\\n            uint64 verificationEpoch = (SafeCast.toUint64(\\n                balancesMem.timestamp\\n            ) - BEACON_GENESIS_TIMESTAMP) / (SLOT_DURATION * SLOTS_PER_EPOCH);\\n\\n            // For each staking strategy's deposits\\n            for (uint256 i = 0; i < depositsCount; ++i) {\\n                uint256 depositID = depositList[i];\\n                DepositData memory depositData = deposits[depositID];\\n\\n                // Check the stored deposit is still waiting to be processed on the beacon chain.\\n                // That is, the first pending deposit slot is before the slot of the staking strategy's deposit.\\n                // If the deposit has been processed, it will need to be verified with `verifyDeposit`.\\n                // OR the deposit is to an exiting validator so check it is still not withdrawable.\\n                // If the validator is not withdrawable, then the deposit can not have been processed yet.\\n                // If the validator is now withdrawable, then the deposit may have been processed. The strategy\\n                // now has to wait until the validator's balance is verified to be zero.\\n                // OR the validator has exited and the deposit is now verified as processed.\\n                require(\\n                    firstPendingDeposit.slot < depositData.slot ||\\n                        (verificationEpoch < depositData.withdrawableEpoch &&\\n                            depositData.withdrawableEpoch !=\\n                            FAR_FUTURE_EPOCH) ||\\n                        validator[depositData.pubKeyHash].state ==\\n                        ValidatorState.EXITED,\\n                    \\\"Deposit likely processed\\\"\\n                );\\n\\n                // Convert the deposit amount from Gwei to Wei and add to the total\\n                totalDepositsWei += uint256(depositData.amountGwei) * 1 gwei;\\n\\n                // Remove the deposit if the validator has exited.\\n                if (\\n                    validator[depositData.pubKeyHash].state ==\\n                    ValidatorState.EXITED\\n                ) {\\n                    _removeDeposit(depositID, depositData);\\n\\n                    emit DepositValidatorExited(\\n                        depositID,\\n                        uint256(depositData.amountGwei) * 1 gwei\\n                    );\\n                }\\n            }\\n        }\\n\\n        // Store the verified balance in storage\\n        lastVerifiedEthBalance = SafeCast.toUint128(\\n            totalDepositsWei + totalValidatorBalance + balancesMem.ethBalance\\n        );\\n        // Reset the last snap timestamp so a new snapBalances has to be made\\n        lastSnapTimestamp = 0;\\n\\n        emit BalancesVerified(\\n            balancesMem.timestamp,\\n            totalDepositsWei,\\n            totalValidatorBalance,\\n            balancesMem.ethBalance\\n        );\\n    }\\n\\n    // slither-disable-end reentrancy-no-eth\\n\\n    /// @notice Hash a validator public key using the Beacon Chain's format\\n    function _hashPubKey(bytes memory pubKey) internal pure returns (bytes32) {\\n        require(pubKey.length == 48, \\\"Invalid public key length\\\");\\n        return sha256(abi.encodePacked(pubKey, bytes16(0)));\\n    }\\n\\n    /**\\n     *\\n     *         WETH and ETH Accounting\\n     *\\n     */\\n\\n    /// @dev Called when WETH is transferred out of the strategy so\\n    /// the strategy knows how much WETH it has on deposit.\\n    /// This is so it can emit the correct amount in the Deposit event in depositAll().\\n    function _transferWeth(uint256 _amount, address _recipient) internal {\\n        IERC20(WETH).safeTransfer(_recipient, _amount);\\n\\n        // The min is required as more WETH can be withdrawn than deposited\\n        // as the strategy earns consensus and execution rewards.\\n        uint256 deductAmount = Math.min(_amount, depositedWethAccountedFor);\\n        depositedWethAccountedFor -= deductAmount;\\n\\n        // No change in ETH balance so no need to snapshot the balances\\n    }\\n\\n    /// @dev Converts ETH to WETH and updates the accounting.\\n    /// @param _ethAmount The amount of ETH in wei.\\n    function _convertEthToWeth(uint256 _ethAmount) internal {\\n        // slither-disable-next-line arbitrary-send-eth\\n        IWETH9(WETH).deposit{ value: _ethAmount }();\\n\\n        depositedWethAccountedFor += _ethAmount;\\n\\n        // Store the reduced ETH balance.\\n        // The ETH balance in this strategy contract can be more than the last verified ETH balance\\n        // due to partial withdrawals or full exits being processed by the beacon chain since the last snapBalances.\\n        // It can also happen from execution rewards (MEV) or ETH donations.\\n        lastVerifiedEthBalance -= SafeCast.toUint128(\\n            Math.min(uint256(lastVerifiedEthBalance), _ethAmount)\\n        );\\n\\n        // The ETH balance was decreased to WETH so we need to invalidate the last balances snap.\\n        lastSnapTimestamp = 0;\\n    }\\n\\n    /// @dev Converts WETH to ETH and updates the accounting.\\n    /// @param _wethAmount The amount of WETH in wei.\\n    function _convertWethToEth(uint256 _wethAmount) internal {\\n        IWETH9(WETH).withdraw(_wethAmount);\\n\\n        uint256 deductAmount = Math.min(_wethAmount, depositedWethAccountedFor);\\n        depositedWethAccountedFor -= deductAmount;\\n\\n        // Store the increased ETH balance\\n        lastVerifiedEthBalance += SafeCast.toUint128(_wethAmount);\\n\\n        // The ETH balance was increased from WETH so we need to invalidate the last balances snap.\\n        lastSnapTimestamp = 0;\\n    }\\n\\n    /**\\n     *\\n     *             View Functions\\n     *\\n     */\\n\\n    /// @notice Returns the number of deposits waiting to be verified as processed on the beacon chain,\\n    /// or deposits that have been verified to an exiting validator and is now waiting for the\\n    /// validator's balance to be swept.\\n    function depositListLength() external view returns (uint256) {\\n        return depositList.length;\\n    }\\n\\n    /// @notice Returns the number of verified validators.\\n    function verifiedValidatorsLength() external view returns (uint256) {\\n        return verifiedValidators.length;\\n    }\\n}\\n\",\"keccak256\":\"0xf190f380916aaef1bee329bf26a708f3718f1c3f87117d2a392feddc00efd7c2\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b5060405161099138038061099183398101604081905261002f91610040565b6001600160a01b0316608052610070565b60006020828403121561005257600080fd5b81516001600160a01b038116811461006957600080fd5b9392505050565b6080516108d76100ba60003960008181604b0152818160ba015281816101ce01528181610248015281816103440152818161044e0152818161047d015261058a01526108d76000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c80632e4aee1f146100465780635e1c519b1461008a578063d1699c261461009f575b600080fd5b61006d7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020015b60405180910390f35b6100926100b4565b6040516100819190610688565b6100a761033e565b604051610081919061070b565b606060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663d79e40326040518163ffffffff1660e01b8152600401602060405180830381865afa158015610116573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061013a9190610787565b90508067ffffffffffffffff811115610155576101556107a0565b6040519080825280602002602001820160405280156101a757816020015b61019460408051606081018252600080825260208201819052909182015290565b8152602001906001900390816101735790505b50915060005b8181101561033957604051630ef9985560e01b8152600481018290526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690630ef9985590602401602060405180830381865afa15801561021d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102419190610787565b90506000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166398245f1b846040518263ffffffff1660e01b815260040161029491815260200190565b6040805180830381865afa1580156102b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102d491906107d3565b9150915060405180606001604052808481526020018267ffffffffffffffff16815260200183600781111561030b5761030b610672565b8152508685815181106103205761032061080c565b60200260200101819052505050508060010190506101ad565b505090565b606060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316634896b31a6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156103a0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103c49190610787565b90508067ffffffffffffffff8111156103df576103df6107a0565b60405190808252806020026020018201604052801561043857816020015b6040805160a0810182526000808252602080830182905292820181905260608201819052608082015282526000199092019101816103fd5790505b50915060005b81811015610339576000806000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b02c43d07f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b8ec6678886040518263ffffffff1660e01b81526004016104c991815260200190565b602060405180830381865afa1580156104e6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061050a9190610787565b6040518263ffffffff1660e01b815260040161052891815260200190565b60c060405180830381865afa158015610545573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105699190610822565b67ffffffffffffffff16955050509350935093506040518060a001604052807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b8ec6678886040518263ffffffff1660e01b81526004016105d691815260200190565b602060405180830381865afa1580156105f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106179190610787565b81526020018581526020018467ffffffffffffffff1681526020018367ffffffffffffffff168152602001828152508786815181106106585761065861080c565b60200260200101819052505050505080600101905061043e565b634e487b7160e01b600052602160045260246000fd5b602080825282518282018190526000918401906040840190835b818110156107005783518051845260208082015167ffffffffffffffff169085015260400151600881106106e657634e487b7160e01b600052602160045260246000fd5b6040840152602093909301926060909201916001016106a2565b509095945050505050565b602080825282518282018190526000918401906040840190835b81811015610700578351805184526020810151602085015267ffffffffffffffff604082015116604085015267ffffffffffffffff6060820151166060850152608081015160808501525060a083019250602084019350600181019050610725565b60006020828403121561079957600080fd5b5051919050565b634e487b7160e01b600052604160045260246000fd5b805167ffffffffffffffff811681146107ce57600080fd5b919050565b600080604083850312156107e657600080fd5b8251600881106107f557600080fd5b9150610803602084016107b6565b90509250929050565b634e487b7160e01b600052603260045260246000fd5b60008060008060008060c0878903121561083b57600080fd5b8651955061084b602088016107b6565b9450610859604088016107b6565b9350606087015163ffffffff8116811461087257600080fd5b60808801519093506003811061088757600080fd5b915061089560a088016107b6565b9050929550929550929556fea2646970667358221220b66db0bfafe8ca64b4b2d898b3f8529d9f89c4798781e96df855edc4ea42333964736f6c634300081c0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c80632e4aee1f146100465780635e1c519b1461008a578063d1699c261461009f575b600080fd5b61006d7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020015b60405180910390f35b6100926100b4565b6040516100819190610688565b6100a761033e565b604051610081919061070b565b606060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663d79e40326040518163ffffffff1660e01b8152600401602060405180830381865afa158015610116573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061013a9190610787565b90508067ffffffffffffffff811115610155576101556107a0565b6040519080825280602002602001820160405280156101a757816020015b61019460408051606081018252600080825260208201819052909182015290565b8152602001906001900390816101735790505b50915060005b8181101561033957604051630ef9985560e01b8152600481018290526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690630ef9985590602401602060405180830381865afa15801561021d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102419190610787565b90506000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166398245f1b846040518263ffffffff1660e01b815260040161029491815260200190565b6040805180830381865afa1580156102b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102d491906107d3565b9150915060405180606001604052808481526020018267ffffffffffffffff16815260200183600781111561030b5761030b610672565b8152508685815181106103205761032061080c565b60200260200101819052505050508060010190506101ad565b505090565b606060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316634896b31a6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156103a0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103c49190610787565b90508067ffffffffffffffff8111156103df576103df6107a0565b60405190808252806020026020018201604052801561043857816020015b6040805160a0810182526000808252602080830182905292820181905260608201819052608082015282526000199092019101816103fd5790505b50915060005b81811015610339576000806000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b02c43d07f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b8ec6678886040518263ffffffff1660e01b81526004016104c991815260200190565b602060405180830381865afa1580156104e6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061050a9190610787565b6040518263ffffffff1660e01b815260040161052891815260200190565b60c060405180830381865afa158015610545573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105699190610822565b67ffffffffffffffff16955050509350935093506040518060a001604052807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b8ec6678886040518263ffffffff1660e01b81526004016105d691815260200190565b602060405180830381865afa1580156105f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106179190610787565b81526020018581526020018467ffffffffffffffff1681526020018367ffffffffffffffff168152602001828152508786815181106106585761065861080c565b60200260200101819052505050505080600101905061043e565b634e487b7160e01b600052602160045260246000fd5b602080825282518282018190526000918401906040840190835b818110156107005783518051845260208082015167ffffffffffffffff169085015260400151600881106106e657634e487b7160e01b600052602160045260246000fd5b6040840152602093909301926060909201916001016106a2565b509095945050505050565b602080825282518282018190526000918401906040840190835b81811015610700578351805184526020810151602085015267ffffffffffffffff604082015116604085015267ffffffffffffffff6060820151166060850152608081015160808501525060a083019250602084019350600181019050610725565b60006020828403121561079957600080fd5b5051919050565b634e487b7160e01b600052604160045260246000fd5b805167ffffffffffffffff811681146107ce57600080fd5b919050565b600080604083850312156107e657600080fd5b8251600881106107f557600080fd5b9150610803602084016107b6565b90509250929050565b634e487b7160e01b600052603260045260246000fd5b60008060008060008060c0878903121561083b57600080fd5b8651955061084b602088016107b6565b9450610859604088016107b6565b9350606087015163ffffffff8116811461087257600080fd5b60808801519093506003811061088757600080fd5b915061089560a088016107b6565b9050929550929550929556fea2646970667358221220b66db0bfafe8ca64b4b2d898b3f8529d9f89c4798781e96df855edc4ea42333964736f6c634300081c0033",
  "libraries": {},
  "devdoc": {
    "author": "Origin Protocol Inc",
    "kind": "dev",
    "methods": {
      "getPendingDeposits()": {
        "returns": {
          "pendingDeposits": "An array of `DepositView` containing the deposit ID, public key hash, amount in Gwei and the slot of the deposit."
        }
      },
      "getVerifiedValidators()": {
        "returns": {
          "validators": "An array of `ValidatorView` containing the public key hash, validator index and state."
        }
      }
    },
    "title": "Viewing contract for the Compounding Staking Strategy.",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getPendingDeposits()": {
        "notice": "Returns the deposits that are still to be verified. These may or may not have been processed by the beacon chain."
      },
      "getVerifiedValidators()": {
        "notice": "Returns the strategy's active validators. These are the ones that have been verified and have a non-zero balance."
      },
      "stakingStrategy()": {
        "notice": "The address of the Compounding Staking Strategy contract"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}