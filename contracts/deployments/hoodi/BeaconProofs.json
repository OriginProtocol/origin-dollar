{
  "address": "0x2828946cE2547E269Db3F1962B73A4ADBa5162A1",
  "abi": [
    {
      "inputs": [],
      "name": "InvalidProofLength",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "beaconBlockRoot",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "balancesContainerLeaf",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "balancesContainerProof",
          "type": "bytes"
        }
      ],
      "name": "verifyBalancesContainer",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "beaconBlockRoot",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "blockNumber",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "blockNumberProof",
          "type": "bytes"
        }
      ],
      "name": "verifyBlockNumber",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "beaconBlockRoot",
          "type": "bytes32"
        },
        {
          "internalType": "uint64",
          "name": "slot",
          "type": "uint64"
        },
        {
          "internalType": "bytes",
          "name": "firstPendingDepositSlotProof",
          "type": "bytes"
        }
      ],
      "name": "verifyFirstPendingDepositSlot",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "beaconBlockRoot",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "slot",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "slotProof",
          "type": "bytes"
        }
      ],
      "name": "verifySlot",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "root",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "validatorBalanceLeaf",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "balanceProof",
          "type": "bytes"
        },
        {
          "internalType": "uint64",
          "name": "validatorIndex",
          "type": "uint64"
        },
        {
          "internalType": "enum BeaconProofsLib.BalanceProofLevel",
          "name": "level",
          "type": "uint8"
        }
      ],
      "name": "verifyValidatorBalance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "validatorBalanceGwei",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "beaconBlockRoot",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "pubKeyHash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "validatorPubKeyProof",
          "type": "bytes"
        },
        {
          "internalType": "uint64",
          "name": "validatorIndex",
          "type": "uint64"
        },
        {
          "internalType": "address",
          "name": "withdrawalAddress",
          "type": "address"
        }
      ],
      "name": "verifyValidatorPubkey",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x71561965a136db82a4b251f3ce9b34ac709067a2d52f6075525207a744f46fe7",
  "receipt": {
    "to": null,
    "from": "0xf7749B41db006860cEc0650D18b8013d69C44Eeb",
    "contractAddress": "0x2828946cE2547E269Db3F1962B73A4ADBa5162A1",
    "transactionIndex": 14,
    "gasUsed": "664080",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x0d3768457ba048c204d218a325dbff4798ae4ae1bd00e5969828362170384ca5",
    "transactionHash": "0x71561965a136db82a4b251f3ce9b34ac709067a2d52f6075525207a744f46fe7",
    "logs": [],
    "blockNumber": 905473,
    "cumulativeGasUsed": "5125226",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "3de98f56666780054699342674f08b14",
  "metadata": "{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"InvalidProofLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"beaconBlockRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"balancesContainerLeaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"balancesContainerProof\",\"type\":\"bytes\"}],\"name\":\"verifyBalancesContainer\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"beaconBlockRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"blockNumberProof\",\"type\":\"bytes\"}],\"name\":\"verifyBlockNumber\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"beaconBlockRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"firstPendingDepositSlotProof\",\"type\":\"bytes\"}],\"name\":\"verifyFirstPendingDepositSlot\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"beaconBlockRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"slot\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"slotProof\",\"type\":\"bytes\"}],\"name\":\"verifySlot\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"validatorBalanceLeaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"balanceProof\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"validatorIndex\",\"type\":\"uint64\"},{\"internalType\":\"enum BeaconProofsLib.BalanceProofLevel\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"verifyValidatorBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorBalanceGwei\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"beaconBlockRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"pubKeyHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"validatorPubKeyProof\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"validatorIndex\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"withdrawalAddress\",\"type\":\"address\"}],\"name\":\"verifyValidatorPubkey\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"verifyBalancesContainer(bytes32,bytes32,bytes)\":{\"params\":{\"balancesContainerLeaf\":\"The leaf node containing the balances container\",\"balancesContainerProof\":\"The merkle proof for the balances container to the beacon block root. This is the witness hashes concatenated together starting from the leaf node.\",\"beaconBlockRoot\":\"The root of the beacon block\"}},\"verifyBlockNumber(bytes32,uint256,bytes)\":{\"params\":{\"beaconBlockRoot\":\"The root of the beacon block\",\"blockNumber\":\"The execution layer block number to verify\",\"blockNumberProof\":\"The merkle proof for the block number against the beacon block This is the witness hashes concatenated together starting from the leaf node.\"}},\"verifyFirstPendingDepositSlot(bytes32,uint64,bytes)\":{\"params\":{\"beaconBlockRoot\":\"The root of the beacon block\",\"firstPendingDepositSlotProof\":\"The merkle proof for the first pending deposit's slot against the beacon block root. This is the witness hashes concatenated together starting from the leaf node.\",\"slot\":\"The beacon chain slot to verify\"}},\"verifySlot(bytes32,uint256,bytes)\":{\"params\":{\"beaconBlockRoot\":\"The root of the beacon block\",\"slot\":\"The beacon chain slot to verify\",\"slotProof\":\"The merkle proof for the slot against the beacon block root. This is the witness hashes concatenated together starting from the leaf node.\"}},\"verifyValidatorBalance(bytes32,bytes32,bytes,uint64,uint8)\":{\"params\":{\"balanceProof\":\"The merkle proof for the validator balance against the root. This is the witness hashes concatenated together starting from the leaf node.\",\"level\":\"The level of the balance proof, either Container or BeaconBlock\",\"root\":\"The root of the Balances container or the beacon block root\",\"validatorBalanceLeaf\":\"The leaf node containing the validator balance with three other balances\",\"validatorIndex\":\"The validator index to verify the balance for\"},\"returns\":{\"validatorBalanceGwei\":\"The balance in Gwei of the validator at the given index\"}},\"verifyValidatorPubkey(bytes32,bytes32,bytes,uint64,address)\":{\"params\":{\"beaconBlockRoot\":\"The root of the beacon block\",\"pubKeyHash\":\"The beacon chain hash of the validator public key\",\"validatorIndex\":\"The validator index\",\"validatorPubKeyProof\":\"The merkle proof for the validator public key to the beacon block root. This is the witness hashes concatenated together starting from the leaf node.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"verifyBalancesContainer(bytes32,bytes32,bytes)\":{\"notice\":\"Verifies the balances container against the beacon block root BeaconBlock.state.balances\"},\"verifyBlockNumber(bytes32,uint256,bytes)\":{\"notice\":\"Verifies the block number to the the beacon block root BeaconBlock.body.executionPayload.blockNumber\"},\"verifyFirstPendingDepositSlot(bytes32,uint64,bytes)\":{\"notice\":\"Verifies the slot of the first pending deposit against the beacon block root BeaconBlock.state.PendingDeposits[0].slot\"},\"verifySlot(bytes32,uint256,bytes)\":{\"notice\":\"Verifies the slot number against the beacon block root. BeaconBlock.slot\"},\"verifyValidatorBalance(bytes32,bytes32,bytes,uint64,uint8)\":{\"notice\":\"Verifies the validator balance against the root of the Balances container or the beacon block root\"},\"verifyValidatorPubkey(bytes32,bytes32,bytes,uint64,address)\":{\"notice\":\"Verifies the validator public key against the beacon block root BeaconBlock.state.validators[validatorIndex].pubkey\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/beacon/BeaconProofs.sol\":\"BeaconProofs\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/beacon/BeaconProofs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport { BeaconProofsLib } from \\\"./BeaconProofsLib.sol\\\";\\n\\ncontract BeaconProofs {\\n    /// @notice Verifies the validator public key against the beacon block root\\n    /// BeaconBlock.state.validators[validatorIndex].pubkey\\n    /// @param beaconBlockRoot The root of the beacon block\\n    /// @param pubKeyHash The beacon chain hash of the validator public key\\n    /// @param validatorPubKeyProof The merkle proof for the validator public key to the beacon block root.\\n    /// This is the witness hashes concatenated together starting from the leaf node.\\n    /// @param validatorIndex The validator index\\n    function verifyValidatorPubkey(\\n        bytes32 beaconBlockRoot,\\n        bytes32 pubKeyHash,\\n        bytes calldata validatorPubKeyProof,\\n        uint64 validatorIndex,\\n        address withdrawalAddress\\n    ) external view {\\n        BeaconProofsLib.verifyValidatorPubkey(\\n            beaconBlockRoot,\\n            pubKeyHash,\\n            validatorPubKeyProof,\\n            validatorIndex,\\n            withdrawalAddress\\n        );\\n    }\\n\\n    /// @notice Verifies the balances container against the beacon block root\\n    /// BeaconBlock.state.balances\\n    /// @param beaconBlockRoot The root of the beacon block\\n    /// @param balancesContainerLeaf The leaf node containing the balances container\\n    /// @param balancesContainerProof The merkle proof for the balances container to the beacon block root.\\n    /// This is the witness hashes concatenated together starting from the leaf node.\\n    function verifyBalancesContainer(\\n        bytes32 beaconBlockRoot,\\n        bytes32 balancesContainerLeaf,\\n        bytes calldata balancesContainerProof\\n    ) external view {\\n        BeaconProofsLib.verifyBalancesContainer(\\n            beaconBlockRoot,\\n            balancesContainerLeaf,\\n            balancesContainerProof\\n        );\\n    }\\n\\n    /// @notice Verifies the validator balance against the root of the Balances container\\n    /// or the beacon block root\\n    /// @param root The root of the Balances container or the beacon block root\\n    /// @param validatorBalanceLeaf The leaf node containing the validator balance with three other balances\\n    /// @param balanceProof The merkle proof for the validator balance against the root.\\n    /// This is the witness hashes concatenated together starting from the leaf node.\\n    /// @param validatorIndex The validator index to verify the balance for\\n    /// @param level The level of the balance proof, either Container or BeaconBlock\\n    /// @return validatorBalanceGwei The balance in Gwei of the validator at the given index\\n    function verifyValidatorBalance(\\n        bytes32 root,\\n        bytes32 validatorBalanceLeaf,\\n        bytes calldata balanceProof,\\n        uint64 validatorIndex,\\n        BeaconProofsLib.BalanceProofLevel level\\n    ) external view returns (uint256 validatorBalanceGwei) {\\n        validatorBalanceGwei = BeaconProofsLib.verifyValidatorBalance(\\n            root,\\n            validatorBalanceLeaf,\\n            balanceProof,\\n            validatorIndex,\\n            level\\n        );\\n    }\\n\\n    /// @notice Verifies the slot of the first pending deposit against the beacon block root\\n    /// BeaconBlock.state.PendingDeposits[0].slot\\n    /// @param beaconBlockRoot The root of the beacon block\\n    /// @param slot The beacon chain slot to verify\\n    /// @param firstPendingDepositSlotProof The merkle proof for the first pending deposit's slot\\n    /// against the beacon block root.\\n    /// This is the witness hashes concatenated together starting from the leaf node.\\n    function verifyFirstPendingDepositSlot(\\n        bytes32 beaconBlockRoot,\\n        uint64 slot,\\n        bytes calldata firstPendingDepositSlotProof\\n    ) external view {\\n        BeaconProofsLib.verifyFirstPendingDepositSlot(\\n            beaconBlockRoot,\\n            slot,\\n            firstPendingDepositSlotProof\\n        );\\n    }\\n\\n    /// @notice Verifies the block number to the the beacon block root\\n    /// BeaconBlock.body.executionPayload.blockNumber\\n    /// @param beaconBlockRoot The root of the beacon block\\n    /// @param blockNumber The execution layer block number to verify\\n    /// @param blockNumberProof The merkle proof for the block number against the beacon block\\n    /// This is the witness hashes concatenated together starting from the leaf node.\\n    function verifyBlockNumber(\\n        bytes32 beaconBlockRoot,\\n        uint256 blockNumber,\\n        bytes calldata blockNumberProof\\n    ) external view {\\n        BeaconProofsLib.verifyBlockNumber(\\n            beaconBlockRoot,\\n            blockNumber,\\n            blockNumberProof\\n        );\\n    }\\n\\n    /// @notice Verifies the slot number against the beacon block root.\\n    /// BeaconBlock.slot\\n    /// @param beaconBlockRoot The root of the beacon block\\n    /// @param slot The beacon chain slot to verify\\n    /// @param slotProof The merkle proof for the slot against the beacon block root.\\n    /// This is the witness hashes concatenated together starting from the leaf node.\\n    function verifySlot(\\n        bytes32 beaconBlockRoot,\\n        uint256 slot,\\n        bytes calldata slotProof\\n    ) external view {\\n        BeaconProofsLib.verifySlot(beaconBlockRoot, slot, slotProof);\\n    }\\n}\\n\",\"keccak256\":\"0xf869d9e0f584284bdf1bd5d1d7192ee63ec814a8e5d276450745dcfe8b95bdf5\",\"license\":\"BUSL-1.1\"},\"contracts/beacon/BeaconProofsLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport { Merkle } from \\\"./Merkle.sol\\\";\\nimport { Endian } from \\\"./Endian.sol\\\";\\n\\nlibrary BeaconProofsLib {\\n    // Known generalized indices in the beacon block\\n    // BeaconBlock.slot\\n    uint256 internal constant SLOT_GENERALIZED_INDEX = 8;\\n    // BeaconBlock.state.PendingDeposits[0].slot\\n    uint256 internal constant FIRST_PENDING_DEPOSIT_SLOT_GENERALIZED_INDEX =\\n        1584842932228;\\n    // BeaconBlock.body.executionPayload.blockNumber\\n    uint256 internal constant BLOCK_NUMBER_GENERALIZED_INDEX = 6438;\\n    // BeaconBlock.state.validators\\n    uint256 internal constant VALIDATORS_CONTAINER_GENERALIZED_INDEX = 715;\\n    // BeaconBlock.state.balances\\n    uint256 internal constant BALANCES_CONTAINER_GENERALIZED_INDEX = 716;\\n\\n    // Beacon Container Tree Heights\\n    uint256 internal constant BALANCES_HEIGHT = 39;\\n    uint256 internal constant VALIDATORS_HEIGHT = 41;\\n    uint256 internal constant VALIDATOR_HEIGHT = 3;\\n\\n    /// @notice Fields in the Validator container for phase 0\\n    /// See https://ethereum.github.io/consensus-specs/specs/phase0/beacon-chain/#validator\\n    uint256 internal constant VALIDATOR_PUBKEY_INDEX = 0;\\n\\n    enum BalanceProofLevel {\\n        Container,\\n        BeaconBlock\\n    }\\n\\n    /// @notice Verifies the validator public key against the beacon block root\\n    /// BeaconBlock.state.validators[validatorIndex].pubkey\\n    /// @param beaconBlockRoot The root of the beacon block\\n    /// @param pubKeyHash The beacon chain hash of the validator public key\\n    /// @param validatorPubKeyProof The merkle proof for the validator public key to the beacon block root.\\n    /// This is the witness hashes concatenated together starting from the leaf node.\\n    /// @param validatorIndex The validator index\\n    /// @param withdrawalAddress The withdrawal address used in the validator's withdrawal credentials\\n    function verifyValidatorPubkey(\\n        bytes32 beaconBlockRoot,\\n        bytes32 pubKeyHash,\\n        bytes calldata validatorPubKeyProof,\\n        uint64 validatorIndex,\\n        address withdrawalAddress\\n    ) internal view {\\n        // BeaconBlock.state.validators[validatorIndex].pubkey\\n        uint256 generalizedIndex = concatGenIndices(\\n            VALIDATORS_CONTAINER_GENERALIZED_INDEX,\\n            VALIDATORS_HEIGHT,\\n            validatorIndex\\n        );\\n        generalizedIndex = concatGenIndices(\\n            generalizedIndex,\\n            VALIDATOR_HEIGHT,\\n            VALIDATOR_PUBKEY_INDEX\\n        );\\n\\n        // Get the withdrawal address from the first witness in the pubkey merkle proof.\\n        address withdrawalAddressFromProof;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // The first 32 bytes of the proof is the withdrawal credential so load it into memory.\\n            calldatacopy(0, validatorPubKeyProof.offset, 32)\\n            // Cast the 32 bytes in memory to an address which is the last 20 bytes.\\n            withdrawalAddressFromProof := mload(0)\\n        }\\n        require(\\n            withdrawalAddressFromProof == withdrawalAddress,\\n            \\\"Invalid withdrawal address\\\"\\n        );\\n\\n        require(\\n            Merkle.verifyInclusionSha256({\\n                proof: validatorPubKeyProof,\\n                root: beaconBlockRoot,\\n                leaf: pubKeyHash,\\n                index: generalizedIndex\\n            }),\\n            \\\"Invalid validator pubkey proof\\\"\\n        );\\n    }\\n\\n    /// @notice Verifies the balances container against the beacon block root\\n    /// BeaconBlock.state.balances\\n    /// @param beaconBlockRoot The root of the beacon block\\n    /// @param balancesContainerLeaf The leaf node containing the balances container\\n    /// @param balancesContainerProof The merkle proof for the balances container to the beacon block root.\\n    /// This is the witness hashes concatenated together starting from the leaf node.\\n    function verifyBalancesContainer(\\n        bytes32 beaconBlockRoot,\\n        bytes32 balancesContainerLeaf,\\n        bytes calldata balancesContainerProof\\n    ) internal view {\\n        // BeaconBlock.state.balances\\n        require(\\n            Merkle.verifyInclusionSha256({\\n                proof: balancesContainerProof,\\n                root: beaconBlockRoot,\\n                leaf: balancesContainerLeaf,\\n                index: BALANCES_CONTAINER_GENERALIZED_INDEX\\n            }),\\n            \\\"Invalid balance container proof\\\"\\n        );\\n    }\\n\\n    /// @notice Verifies the validator balance against the root of the Balances container\\n    /// or the beacon block root\\n    /// @param root The root of the Balances container or the beacon block root\\n    /// @param validatorBalanceLeaf The leaf node containing the validator balance with three other balances\\n    /// @param balanceProof The merkle proof for the validator balance against the root.\\n    /// This is the witness hashes concatenated together starting from the leaf node.\\n    /// @param validatorIndex The validator index to verify the balance for\\n    /// @param level The level of the balance proof, either Container or BeaconBlock\\n    /// @return validatorBalanceGwei The balance in Gwei of the validator at the given index\\n    function verifyValidatorBalance(\\n        bytes32 root,\\n        bytes32 validatorBalanceLeaf,\\n        bytes calldata balanceProof,\\n        uint64 validatorIndex,\\n        BalanceProofLevel level\\n    ) internal view returns (uint256 validatorBalanceGwei) {\\n        // Four balances are stored in each leaf so the validator index is divided by 4\\n        uint64 balanceIndex = validatorIndex / 4;\\n\\n        // slither-disable-next-line uninitialized-local\\n        uint256 generalizedIndex;\\n        if (level == BalanceProofLevel.Container) {\\n            // Get the index within the balances container, not the Beacon Block\\n            // BeaconBlock.state.balances[balanceIndex]\\n            generalizedIndex = concatGenIndices(\\n                1,\\n                BALANCES_HEIGHT,\\n                balanceIndex\\n            );\\n        }\\n\\n        if (level == BalanceProofLevel.BeaconBlock) {\\n            generalizedIndex = concatGenIndices(\\n                BALANCES_CONTAINER_GENERALIZED_INDEX,\\n                BALANCES_HEIGHT,\\n                balanceIndex\\n            );\\n        }\\n\\n        validatorBalanceGwei = balanceAtIndex(\\n            validatorBalanceLeaf,\\n            validatorIndex\\n        );\\n\\n        require(\\n            Merkle.verifyInclusionSha256({\\n                proof: balanceProof,\\n                root: root,\\n                leaf: validatorBalanceLeaf,\\n                index: generalizedIndex\\n            }),\\n            \\\"Invalid balance proof\\\"\\n        );\\n    }\\n\\n    /// @notice Verifies the slot of the first pending deposit against the beacon block root\\n    /// BeaconBlock.state.PendingDeposits[0].slot\\n    /// @param beaconBlockRoot The root of the beacon block\\n    /// @param slot The beacon chain slot to verify\\n    /// @param firstPendingDepositSlotProof The merkle proof for the first pending deposit's slot\\n    /// against the beacon block root.\\n    /// This is the witness hashes concatenated together starting from the leaf node.\\n    function verifyFirstPendingDepositSlot(\\n        bytes32 beaconBlockRoot,\\n        uint64 slot,\\n        bytes calldata firstPendingDepositSlotProof\\n    ) internal view {\\n        // Convert uint64 slot number to a little endian bytes32\\n        bytes32 slotLeaf = Endian.toLittleEndianUint64(slot);\\n\\n        require(\\n            Merkle.verifyInclusionSha256({\\n                proof: firstPendingDepositSlotProof,\\n                root: beaconBlockRoot,\\n                leaf: slotLeaf,\\n                index: FIRST_PENDING_DEPOSIT_SLOT_GENERALIZED_INDEX\\n            }),\\n            \\\"Invalid pending deposit proof\\\"\\n        );\\n    }\\n\\n    /// @notice Verifies the block number to the the beacon block root\\n    /// BeaconBlock.body.executionPayload.blockNumber\\n    /// @param beaconBlockRoot The root of the beacon block\\n    /// @param blockNumber The execution layer block number to verify\\n    /// @param blockNumberProof The merkle proof for the block number against the beacon block\\n    /// This is the witness hashes concatenated together starting from the leaf node.\\n    function verifyBlockNumber(\\n        bytes32 beaconBlockRoot,\\n        uint256 blockNumber,\\n        bytes calldata blockNumberProof\\n    ) internal view {\\n        // Convert uint64 block number to a little endian bytes32\\n        bytes32 blockNumberLeaf = Endian.toLittleEndianUint64(\\n            uint64(blockNumber)\\n        );\\n        require(\\n            Merkle.verifyInclusionSha256({\\n                proof: blockNumberProof,\\n                root: beaconBlockRoot,\\n                leaf: blockNumberLeaf,\\n                index: BLOCK_NUMBER_GENERALIZED_INDEX\\n            }),\\n            \\\"Invalid block number proof\\\"\\n        );\\n    }\\n\\n    /// @notice Verifies the slot number against the beacon block root.\\n    /// BeaconBlock.slot\\n    /// @param beaconBlockRoot The root of the beacon block\\n    /// @param slot The beacon chain slot to verify\\n    /// @param slotProof The merkle proof for the slot against the beacon block root.\\n    /// This is the witness hashes concatenated together starting from the leaf node.\\n    function verifySlot(\\n        bytes32 beaconBlockRoot,\\n        uint256 slot,\\n        bytes calldata slotProof\\n    ) internal view {\\n        require(\\n            Merkle.verifyInclusionSha256({\\n                proof: slotProof,\\n                root: beaconBlockRoot,\\n                leaf: Endian.toLittleEndianUint64(uint64(slot)),\\n                index: SLOT_GENERALIZED_INDEX\\n            }),\\n            \\\"Invalid slot number proof\\\"\\n        );\\n    }\\n\\n    ////////////////////////////////////////////////////\\n    ///       Internal Helper Functions\\n    ////////////////////////////////////////////////////\\n\\n    function balanceAtIndex(bytes32 validatorBalanceLeaf, uint64 validatorIndex)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 bitShiftAmount = (validatorIndex % 4) * 64;\\n        return\\n            Endian.fromLittleEndianUint64(\\n                bytes32((uint256(validatorBalanceLeaf) << bitShiftAmount))\\n            );\\n    }\\n\\n    /// @notice Concatenates two beacon chain generalized indices into one.\\n    /// @param genIndex The first generalized index or 1 if calculating for a single container.\\n    /// @param height The merkle tree height of the second container. eg 39 for balances, 41 for validators.\\n    /// @param index The index within the second container. eg the validator index.\\n    /// @return genIndex The concatenated generalized index.\\n    function concatGenIndices(\\n        uint256 genIndex,\\n        uint256 height,\\n        uint256 index\\n    ) internal pure returns (uint256) {\\n        return (genIndex << height) | index;\\n    }\\n}\\n\",\"keccak256\":\"0x2cdd350db8a5964fd876c9fc5c5ed1c9a43432d77a5f2454fd80862f92bacf9c\",\"license\":\"BUSL-1.1\"},\"contracts/beacon/Endian.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary Endian {\\n    /**\\n     * @notice Converts a little endian-formatted uint64 to a big endian-formatted uint64\\n     * @param lenum little endian-formatted uint64 input, provided as 'bytes32' type\\n     * @return n The big endian-formatted uint64\\n     * @dev Note that the input is formatted as a 'bytes32' type (i.e. 256 bits),\\n     * but it is immediately truncated to a uint64 (i.e. 64 bits)\\n     * through a right-shift/shr operation.\\n     */\\n    function fromLittleEndianUint64(bytes32 lenum)\\n        internal\\n        pure\\n        returns (uint64 n)\\n    {\\n        // the number needs to be stored in little-endian encoding (ie in bytes 0-8)\\n        n = uint64(uint256(lenum >> 192));\\n        // forgefmt: disable-next-item\\n        return\\n            (n >> 56) |\\n            ((0x00FF000000000000 & n) >> 40) |\\n            ((0x0000FF0000000000 & n) >> 24) |\\n            ((0x000000FF00000000 & n) >> 8) |\\n            ((0x00000000FF000000 & n) << 8) |\\n            ((0x0000000000FF0000 & n) << 24) |\\n            ((0x000000000000FF00 & n) << 40) |\\n            ((0x00000000000000FF & n) << 56);\\n    }\\n\\n    function toLittleEndianUint64(uint64 benum)\\n        internal\\n        pure\\n        returns (bytes32 n)\\n    {\\n        // Convert to little-endian by reversing byte order\\n        uint64 reversed = (benum >> 56) |\\n            ((0x00FF000000000000 & benum) >> 40) |\\n            ((0x0000FF0000000000 & benum) >> 24) |\\n            ((0x000000FF00000000 & benum) >> 8) |\\n            ((0x00000000FF000000 & benum) << 8) |\\n            ((0x0000000000FF0000 & benum) << 24) |\\n            ((0x000000000000FF00 & benum) << 40) |\\n            ((0x00000000000000FF & benum) << 56);\\n\\n        // Store the little-endian uint64 in the least significant 64 bits of bytes32\\n        n = bytes32(uint256(reversed));\\n        // Shift to most significant bits\\n        n = n << 192;\\n    }\\n}\\n\",\"keccak256\":\"0xd1184c7f56025b694bc4dfe20b610ed208b973eb9040d4084708c39511a42c68\",\"license\":\"MIT\"},\"contracts/beacon/Merkle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Adapted from OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary Merkle {\\n    error InvalidProofLength();\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. The tree is built assuming `leaf` is\\n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\\n     *\\n     * Note this is for a Merkle tree using the sha256 hash function\\n     */\\n    function verifyInclusionSha256(\\n        bytes memory proof,\\n        bytes32 root,\\n        bytes32 leaf,\\n        uint256 index\\n    ) internal view returns (bool) {\\n        return processInclusionProofSha256(proof, leaf, index) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. The tree is built assuming `leaf` is\\n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\\n     *\\n     * _Available since v4.4._\\n     *\\n     * Note this is for a Merkle tree using the sha256 hash function\\n     */\\n    function processInclusionProofSha256(\\n        bytes memory proof,\\n        bytes32 leaf,\\n        uint256 index\\n    ) internal view returns (bytes32) {\\n        require(\\n            proof.length != 0 && proof.length % 32 == 0,\\n            InvalidProofLength()\\n        );\\n        bytes32[1] memory computedHash = [leaf];\\n        for (uint256 i = 32; i <= proof.length; i += 32) {\\n            if (index % 2 == 0) {\\n                // if ith bit of index is 0, then computedHash is a left sibling\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    mstore(0x00, mload(computedHash))\\n                    mstore(0x20, mload(add(proof, i)))\\n                    if iszero(\\n                        staticcall(\\n                            sub(gas(), 2000),\\n                            2,\\n                            0x00,\\n                            0x40,\\n                            computedHash,\\n                            0x20\\n                        )\\n                    ) {\\n                        revert(0, 0)\\n                    }\\n                    index := div(index, 2)\\n                }\\n            } else {\\n                // if ith bit of index is 1, then computedHash is a right sibling\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    mstore(0x00, mload(add(proof, i)))\\n                    mstore(0x20, mload(computedHash))\\n                    if iszero(\\n                        staticcall(\\n                            sub(gas(), 2000),\\n                            2,\\n                            0x00,\\n                            0x40,\\n                            computedHash,\\n                            0x20\\n                        )\\n                    ) {\\n                        revert(0, 0)\\n                    }\\n                    index := div(index, 2)\\n                }\\n            }\\n        }\\n        return computedHash[0];\\n    }\\n}\\n\",\"keccak256\":\"0x01e60fb19fe4439b27c4b7fa6e7fc68892b2affa3c4ef8769fa24ad3d20e2273\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080604052348015600f57600080fd5b50610b118061001f6000396000f3fe608060405234801561001057600080fd5b50600436106100625760003560e01c806311aec4c114610067578063431c729b1461008c57806391ad640d146100a1578063b41cc546146100b4578063e915f067146100c7578063ec52a221146100da575b600080fd5b61007a610075366004610864565b6100ed565b60405190815260200160405180910390f35b61009f61009a3660046108e2565b610108565b005b61009f6100af36600461093b565b61011a565b61009f6100c236600461093b565b610126565b61009f6100d5366004610975565b610132565b61009f6100e836600461093b565b610148565b60006100fd878787878787610154565b979650505050505050565b61011484848484610264565b50505050565b6101148484848461030e565b610114848484846103a0565b61014086868686868661043f565b505050505050565b6101148484848461055c565b600080610162600485610a19565b905060008084600181111561017957610179610a47565b0361019157506001600160401b038116648000000000175b60018460018111156101a5576101a5610a47565b036101bf57506001600160401b0381166601660000000000175b6101c988866105f5565b925061020f87878080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508d92508c9150859050610695565b6102585760405162461bcd60e51b815260206004820152601560248201527424b73b30b634b2103130b630b731b290383937b7b360591b60448201526064015b60405180910390fd5b50509695505050505050565b600061026f846106ad565b90506102bb83838080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250899250859150650171000000049050610695565b6103075760405162461bcd60e51b815260206004820152601d60248201527f496e76616c69642070656e64696e67206465706f7369742070726f6f66000000604482015260640161024f565b5050505050565b61035482828080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508892508791506102cc9050610695565b6101145760405162461bcd60e51b815260206004820152601f60248201527f496e76616c69642062616c616e636520636f6e7461696e65722070726f6f6600604482015260640161024f565b60006103ab846106ad565b90506103f383838080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508992508591506119269050610695565b6103075760405162461bcd60e51b815260206004820152601a60248201527f496e76616c696420626c6f636b206e756d6265722070726f6f66000000000000604482015260640161024f565b6001600160401b03821666059600000000001760031b600060208682376000519050826001600160a01b0316816001600160a01b0316146104c25760405162461bcd60e51b815260206004820152601a60248201527f496e76616c6964207769746864726177616c2061646472657373000000000000604482015260640161024f565b61050686868080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508c92508b9150869050610695565b6105525760405162461bcd60e51b815260206004820152601e60248201527f496e76616c69642076616c696461746f72207075626b65792070726f6f660000604482015260640161024f565b5050505050505050565b6105a982828080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508892506105a291508790506106ad565b6008610695565b6101145760405162461bcd60e51b815260206004820152601960248201527f496e76616c696420736c6f74206e756d6265722070726f6f6600000000000000604482015260640161024f565b600080610603600484610a5d565b61060e906040610a8b565b6001600160401b0316905061068284821b60f881901c60e882901c61ff00161760d882901c62ff0000161760c882901c63ff000000161764ff0000000060b883901c161765ff000000000060a883901c161766ff000000000000609883901c161760ff60381b60889290921c919091161790565b6001600160401b03169150505b92915050565b6000836106a3868585610723565b1495945050505050565b603881811c60ff16602883811c61ff001691909117601884811c62ff00001691909117600885811c63ff000000169190911764ff000000009186901b919091161765ff00000000009185901b919091161766ff0000000000009184901b919091161760ff60381b9290911b919091161760c01b90565b600083516000141580156107425750602084516107409190610ab4565b155b61075f576040516313717da960e21b815260040160405180910390fd5b604080516020808201909252848152905b855181116107f657610783600285610ab4565b6000036107b9578151600052808601516020526020826040600060026107d05a03fa6107ae57600080fd5b6002840493506107e4565b8086015160005281516020526020826040600060026107d05a03fa6107dd57600080fd5b6002840493505b6107ef602082610ac8565b9050610770565b5051949350505050565b60008083601f84011261081257600080fd5b5081356001600160401b0381111561082957600080fd5b60208301915083602082850101111561084157600080fd5b9250929050565b80356001600160401b038116811461085f57600080fd5b919050565b60008060008060008060a0878903121561087d57600080fd5b863595506020870135945060408701356001600160401b038111156108a157600080fd5b6108ad89828a01610800565b90955093506108c0905060608801610848565b91506080870135600281106108d457600080fd5b809150509295509295509295565b600080600080606085870312156108f857600080fd5b8435935061090860208601610848565b925060408501356001600160401b0381111561092357600080fd5b61092f87828801610800565b95989497509550505050565b6000806000806060858703121561095157600080fd5b843593506020850135925060408501356001600160401b0381111561092357600080fd5b60008060008060008060a0878903121561098e57600080fd5b863595506020870135945060408701356001600160401b038111156109b257600080fd5b6109be89828a01610800565b90955093506109d1905060608801610848565b915060808701356001600160a01b03811681146108d457600080fd5b634e487b7160e01b600052601260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b60006001600160401b03831680610a3257610a326109ed565b806001600160401b0384160491505092915050565b634e487b7160e01b600052602160045260246000fd5b60006001600160401b03831680610a7657610a766109ed565b806001600160401b0384160691505092915050565b6001600160401b038181168382160290811690818114610aad57610aad610a03565b5092915050565b600082610ac357610ac36109ed565b500690565b8082018082111561068f5761068f610a0356fea2646970667358221220f1c53953b16f8cec59af4c531299c78299a48101d2779a178033042d22db9e1664736f6c634300081c0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100625760003560e01c806311aec4c114610067578063431c729b1461008c57806391ad640d146100a1578063b41cc546146100b4578063e915f067146100c7578063ec52a221146100da575b600080fd5b61007a610075366004610864565b6100ed565b60405190815260200160405180910390f35b61009f61009a3660046108e2565b610108565b005b61009f6100af36600461093b565b61011a565b61009f6100c236600461093b565b610126565b61009f6100d5366004610975565b610132565b61009f6100e836600461093b565b610148565b60006100fd878787878787610154565b979650505050505050565b61011484848484610264565b50505050565b6101148484848461030e565b610114848484846103a0565b61014086868686868661043f565b505050505050565b6101148484848461055c565b600080610162600485610a19565b905060008084600181111561017957610179610a47565b0361019157506001600160401b038116648000000000175b60018460018111156101a5576101a5610a47565b036101bf57506001600160401b0381166601660000000000175b6101c988866105f5565b925061020f87878080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508d92508c9150859050610695565b6102585760405162461bcd60e51b815260206004820152601560248201527424b73b30b634b2103130b630b731b290383937b7b360591b60448201526064015b60405180910390fd5b50509695505050505050565b600061026f846106ad565b90506102bb83838080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250899250859150650171000000049050610695565b6103075760405162461bcd60e51b815260206004820152601d60248201527f496e76616c69642070656e64696e67206465706f7369742070726f6f66000000604482015260640161024f565b5050505050565b61035482828080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508892508791506102cc9050610695565b6101145760405162461bcd60e51b815260206004820152601f60248201527f496e76616c69642062616c616e636520636f6e7461696e65722070726f6f6600604482015260640161024f565b60006103ab846106ad565b90506103f383838080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508992508591506119269050610695565b6103075760405162461bcd60e51b815260206004820152601a60248201527f496e76616c696420626c6f636b206e756d6265722070726f6f66000000000000604482015260640161024f565b6001600160401b03821666059600000000001760031b600060208682376000519050826001600160a01b0316816001600160a01b0316146104c25760405162461bcd60e51b815260206004820152601a60248201527f496e76616c6964207769746864726177616c2061646472657373000000000000604482015260640161024f565b61050686868080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508c92508b9150869050610695565b6105525760405162461bcd60e51b815260206004820152601e60248201527f496e76616c69642076616c696461746f72207075626b65792070726f6f660000604482015260640161024f565b5050505050505050565b6105a982828080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508892506105a291508790506106ad565b6008610695565b6101145760405162461bcd60e51b815260206004820152601960248201527f496e76616c696420736c6f74206e756d6265722070726f6f6600000000000000604482015260640161024f565b600080610603600484610a5d565b61060e906040610a8b565b6001600160401b0316905061068284821b60f881901c60e882901c61ff00161760d882901c62ff0000161760c882901c63ff000000161764ff0000000060b883901c161765ff000000000060a883901c161766ff000000000000609883901c161760ff60381b60889290921c919091161790565b6001600160401b03169150505b92915050565b6000836106a3868585610723565b1495945050505050565b603881811c60ff16602883811c61ff001691909117601884811c62ff00001691909117600885811c63ff000000169190911764ff000000009186901b919091161765ff00000000009185901b919091161766ff0000000000009184901b919091161760ff60381b9290911b919091161760c01b90565b600083516000141580156107425750602084516107409190610ab4565b155b61075f576040516313717da960e21b815260040160405180910390fd5b604080516020808201909252848152905b855181116107f657610783600285610ab4565b6000036107b9578151600052808601516020526020826040600060026107d05a03fa6107ae57600080fd5b6002840493506107e4565b8086015160005281516020526020826040600060026107d05a03fa6107dd57600080fd5b6002840493505b6107ef602082610ac8565b9050610770565b5051949350505050565b60008083601f84011261081257600080fd5b5081356001600160401b0381111561082957600080fd5b60208301915083602082850101111561084157600080fd5b9250929050565b80356001600160401b038116811461085f57600080fd5b919050565b60008060008060008060a0878903121561087d57600080fd5b863595506020870135945060408701356001600160401b038111156108a157600080fd5b6108ad89828a01610800565b90955093506108c0905060608801610848565b91506080870135600281106108d457600080fd5b809150509295509295509295565b600080600080606085870312156108f857600080fd5b8435935061090860208601610848565b925060408501356001600160401b0381111561092357600080fd5b61092f87828801610800565b95989497509550505050565b6000806000806060858703121561095157600080fd5b843593506020850135925060408501356001600160401b0381111561092357600080fd5b60008060008060008060a0878903121561098e57600080fd5b863595506020870135945060408701356001600160401b038111156109b257600080fd5b6109be89828a01610800565b90955093506109d1905060608801610848565b915060808701356001600160a01b03811681146108d457600080fd5b634e487b7160e01b600052601260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b60006001600160401b03831680610a3257610a326109ed565b806001600160401b0384160491505092915050565b634e487b7160e01b600052602160045260246000fd5b60006001600160401b03831680610a7657610a766109ed565b806001600160401b0384160691505092915050565b6001600160401b038181168382160290811690818114610aad57610aad610a03565b5092915050565b600082610ac357610ac36109ed565b500690565b8082018082111561068f5761068f610a0356fea2646970667358221220f1c53953b16f8cec59af4c531299c78299a48101d2779a178033042d22db9e1664736f6c634300081c0033",
  "libraries": {},
  "devdoc": {
    "kind": "dev",
    "methods": {
      "verifyBalancesContainer(bytes32,bytes32,bytes)": {
        "params": {
          "balancesContainerLeaf": "The leaf node containing the balances container",
          "balancesContainerProof": "The merkle proof for the balances container to the beacon block root. This is the witness hashes concatenated together starting from the leaf node.",
          "beaconBlockRoot": "The root of the beacon block"
        }
      },
      "verifyBlockNumber(bytes32,uint256,bytes)": {
        "params": {
          "beaconBlockRoot": "The root of the beacon block",
          "blockNumber": "The execution layer block number to verify",
          "blockNumberProof": "The merkle proof for the block number against the beacon block This is the witness hashes concatenated together starting from the leaf node."
        }
      },
      "verifyFirstPendingDepositSlot(bytes32,uint64,bytes)": {
        "params": {
          "beaconBlockRoot": "The root of the beacon block",
          "firstPendingDepositSlotProof": "The merkle proof for the first pending deposit's slot against the beacon block root. This is the witness hashes concatenated together starting from the leaf node.",
          "slot": "The beacon chain slot to verify"
        }
      },
      "verifySlot(bytes32,uint256,bytes)": {
        "params": {
          "beaconBlockRoot": "The root of the beacon block",
          "slot": "The beacon chain slot to verify",
          "slotProof": "The merkle proof for the slot against the beacon block root. This is the witness hashes concatenated together starting from the leaf node."
        }
      },
      "verifyValidatorBalance(bytes32,bytes32,bytes,uint64,uint8)": {
        "params": {
          "balanceProof": "The merkle proof for the validator balance against the root. This is the witness hashes concatenated together starting from the leaf node.",
          "level": "The level of the balance proof, either Container or BeaconBlock",
          "root": "The root of the Balances container or the beacon block root",
          "validatorBalanceLeaf": "The leaf node containing the validator balance with three other balances",
          "validatorIndex": "The validator index to verify the balance for"
        },
        "returns": {
          "validatorBalanceGwei": "The balance in Gwei of the validator at the given index"
        }
      },
      "verifyValidatorPubkey(bytes32,bytes32,bytes,uint64,address)": {
        "params": {
          "beaconBlockRoot": "The root of the beacon block",
          "pubKeyHash": "The beacon chain hash of the validator public key",
          "validatorIndex": "The validator index",
          "validatorPubKeyProof": "The merkle proof for the validator public key to the beacon block root. This is the witness hashes concatenated together starting from the leaf node."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "verifyBalancesContainer(bytes32,bytes32,bytes)": {
        "notice": "Verifies the balances container against the beacon block root BeaconBlock.state.balances"
      },
      "verifyBlockNumber(bytes32,uint256,bytes)": {
        "notice": "Verifies the block number to the the beacon block root BeaconBlock.body.executionPayload.blockNumber"
      },
      "verifyFirstPendingDepositSlot(bytes32,uint64,bytes)": {
        "notice": "Verifies the slot of the first pending deposit against the beacon block root BeaconBlock.state.PendingDeposits[0].slot"
      },
      "verifySlot(bytes32,uint256,bytes)": {
        "notice": "Verifies the slot number against the beacon block root. BeaconBlock.slot"
      },
      "verifyValidatorBalance(bytes32,bytes32,bytes,uint64,uint8)": {
        "notice": "Verifies the validator balance against the root of the Balances container or the beacon block root"
      },
      "verifyValidatorPubkey(bytes32,bytes32,bytes,uint64,address)": {
        "notice": "Verifies the validator public key against the beacon block root BeaconBlock.state.validators[validatorIndex].pubkey"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}