{
  "language": "Solidity",
  "sources": {
    "contracts/beacon/BeaconProofs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { BeaconProofsLib } from \"./BeaconProofsLib.sol\";\n\n/**\n * @title Verifies merkle proofs of beacon chain data.\n * @author Origin Protocol Inc\n */\ncontract BeaconProofs {\n    /// @notice Verifies the validator public key to the beacon block root\n    /// BeaconBlock.state.validators[validatorIndex].pubkey\n    /// @param beaconBlockRoot The root of the beacon block\n    /// @param pubKeyHash Hash of validator's public key using the Beacon Chain's format\n    /// @param validatorPubKeyProof The merkle proof for the validator public key to the beacon block root.\n    /// This is 53 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    /// @param validatorIndex The validator index\n    /// @param withdrawalAddress The withdrawal address used in the validator's withdrawal credentials\n    function verifyValidatorPubkey(\n        bytes32 beaconBlockRoot,\n        bytes32 pubKeyHash,\n        bytes calldata validatorPubKeyProof,\n        uint64 validatorIndex,\n        address withdrawalAddress\n    ) external view {\n        BeaconProofsLib.verifyValidatorPubkey(\n            beaconBlockRoot,\n            pubKeyHash,\n            validatorPubKeyProof,\n            validatorIndex,\n            withdrawalAddress\n        );\n    }\n\n    /// @notice Verifies the balances container to the beacon block root\n    /// BeaconBlock.state.balances\n    /// @param beaconBlockRoot The root of the beacon block\n    /// @param balancesContainerRoot The merkle root of the the balances container\n    /// @param balancesContainerProof The merkle proof for the balances container to the beacon block root.\n    /// This is 9 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    function verifyBalancesContainer(\n        bytes32 beaconBlockRoot,\n        bytes32 balancesContainerRoot,\n        bytes calldata balancesContainerProof\n    ) external view {\n        BeaconProofsLib.verifyBalancesContainer(\n            beaconBlockRoot,\n            balancesContainerRoot,\n            balancesContainerProof\n        );\n    }\n\n    /// @notice Verifies the validator balance to the root of the Balances container.\n    /// @param balancesContainerRoot The merkle root of the Balances container.\n    /// @param validatorBalanceLeaf The leaf node containing the validator balance with three other balances.\n    /// @param balanceProof The merkle proof for the validator balance to the Balances container root.\n    /// This is 39 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    /// @param validatorIndex The validator index to verify the balance for\n    /// @return validatorBalanceGwei The balance in Gwei of the validator at the given index\n    function verifyValidatorBalance(\n        bytes32 balancesContainerRoot,\n        bytes32 validatorBalanceLeaf,\n        bytes calldata balanceProof,\n        uint64 validatorIndex\n    ) external view returns (uint256 validatorBalanceGwei) {\n        validatorBalanceGwei = BeaconProofsLib.verifyValidatorBalance(\n            balancesContainerRoot,\n            validatorBalanceLeaf,\n            balanceProof,\n            validatorIndex\n        );\n    }\n\n    /// @notice If the deposit queue is not empty,\n    /// verify the slot of the first pending deposit to the beacon block root\n    /// BeaconBlock.state.PendingDeposits[0].slot\n    /// If the deposit queue is empty, verify the root of the first pending deposit is empty\n    /// BeaconBlock.state.PendingDeposits[0]\n    /// @param beaconBlockRoot The root of the beacon block\n    /// @param slot The beacon chain slot of the first deposit in the beacon chain's deposit queue.\n    /// Can be anything if the deposit queue is empty, but zero would be a good choice.\n    /// @param firstPendingDepositSlotProof The merkle proof to the beacon block root. Can be either:\n    /// - 40 witness hashes for BeaconBlock.state.PendingDeposits[0].slot when the deposit queue is not empty.\n    /// - 37 witness hashes for BeaconBlock.state.PendingDeposits[0] when the deposit queue is empty.\n    /// The 32 byte witness hashes are concatenated together starting from the leaf node.\n    /// @return isEmptyDepositQueue True if the deposit queue is empty, false otherwise\n    function verifyFirstPendingDepositSlot(\n        bytes32 beaconBlockRoot,\n        uint64 slot,\n        bytes calldata firstPendingDepositSlotProof\n    ) external view returns (bool isEmptyDepositQueue) {\n        isEmptyDepositQueue = BeaconProofsLib.verifyFirstPendingDepositSlot(\n            beaconBlockRoot,\n            slot,\n            firstPendingDepositSlotProof\n        );\n    }\n}\n"
    },
    "contracts/beacon/BeaconProofsLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Merkle } from \"./Merkle.sol\";\nimport { Endian } from \"./Endian.sol\";\n\n/**\n * @title Library to verify merkle proofs of beacon chain data.\n * @author Origin Protocol Inc\n */\nlibrary BeaconProofsLib {\n    // Known generalized indices in the beacon block\n    /// @dev BeaconBlock.slot\n    uint256 internal constant SLOT_GENERALIZED_INDEX = 8;\n    /// @dev BeaconBlock.state.PendingDeposits[0]\n    uint256 internal constant FIRST_PENDING_DEPOSIT_GENERALIZED_INDEX =\n        198105366528;\n    /// @dev BeaconBlock.state.PendingDeposits[0].slot\n    uint256 internal constant FIRST_PENDING_DEPOSIT_SLOT_GENERALIZED_INDEX =\n        1584842932228;\n    /// @dev BeaconBlock.body.executionPayload.blockNumber\n    uint256 internal constant BLOCK_NUMBER_GENERALIZED_INDEX = 6438;\n    /// @dev BeaconBlock.state.validators\n    uint256 internal constant VALIDATORS_CONTAINER_GENERALIZED_INDEX = 715;\n    /// @dev BeaconBlock.state.balances\n    uint256 internal constant BALANCES_CONTAINER_GENERALIZED_INDEX = 716;\n\n    /// @dev Number of bytes in the proof to the first pending deposit.\n    /// 37 witness hashes of 32 bytes each concatenated together.\n    /// BeaconBlock.state.PendingDeposits[0]\n    uint256 internal constant FIRST_PENDING_DEPOSIT_PROOF_LENGTH = 37 * 32;\n    /// @dev Number of bytes in the proof to the slot of the first pending deposit.\n    /// 40 witness hashes of 32 bytes each concatenated together.\n    /// BeaconBlock.state.PendingDeposits[0].slot\n    uint256 internal constant FIRST_PENDING_DEPOSIT_SLOT_PROOF_LENGTH = 40 * 32;\n\n    /// @dev Merkle height of the Balances container\n    /// BeaconBlock.state.balances\n    uint256 internal constant BALANCES_HEIGHT = 39;\n    /// @dev Merkle height of the Validators container\n    /// BeaconBlock.state.validators\n    uint256 internal constant VALIDATORS_HEIGHT = 41;\n    /// @dev Merkle height of the Validator container\n    /// BeaconBlock.state.validators[validatorIndex]\n    uint256 internal constant VALIDATOR_HEIGHT = 3;\n\n    /// @dev Position of the pubkey field in the Validator container.\n    /// BeaconBlock.state.validators[validatorIndex].pubkey\n    uint256 internal constant VALIDATOR_PUBKEY_INDEX = 0;\n\n    /// @notice Verifies the validator public key to the beacon block root\n    /// BeaconBlock.state.validators[validatorIndex].pubkey\n    /// @param beaconBlockRoot The root of the beacon block\n    /// @param pubKeyHash Hash of validator's public key using the Beacon Chain's format\n    /// @param validatorPubKeyProof The merkle proof for the validator public key to the beacon block root.\n    /// This is 53 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    /// @param validatorIndex The validator index\n    /// @param withdrawalAddress The withdrawal address used in the validator's withdrawal credentials\n    function verifyValidatorPubkey(\n        bytes32 beaconBlockRoot,\n        bytes32 pubKeyHash,\n        bytes calldata validatorPubKeyProof,\n        uint64 validatorIndex,\n        address withdrawalAddress\n    ) internal view {\n        require(beaconBlockRoot != bytes32(0), \"Invalid block root\");\n        require(\n            // 53 * 32 bytes = 1696 bytes\n            validatorPubKeyProof.length == 1696,\n            \"Invalid proof length\"\n        );\n\n        // BeaconBlock.state.validators[validatorIndex]\n        uint256 generalizedIndex = concatGenIndices(\n            VALIDATORS_CONTAINER_GENERALIZED_INDEX,\n            VALIDATORS_HEIGHT,\n            validatorIndex\n        );\n        // BeaconBlock.state.validators[validatorIndex].pubkey\n        generalizedIndex = concatGenIndices(\n            generalizedIndex,\n            VALIDATOR_HEIGHT,\n            VALIDATOR_PUBKEY_INDEX\n        );\n\n        // Get the withdrawal address from the first witness in the pubkey merkle proof.\n        address withdrawalAddressFromProof;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // The first 32 bytes of the proof is the withdrawal credential so load it into memory.\n            calldatacopy(0, validatorPubKeyProof.offset, 32)\n            // Cast the 32 bytes in memory to an address which is the last 20 bytes.\n            withdrawalAddressFromProof := mload(0)\n        }\n        require(\n            withdrawalAddressFromProof == withdrawalAddress,\n            \"Invalid withdrawal address\"\n        );\n\n        require(\n            Merkle.verifyInclusionSha256({\n                proof: validatorPubKeyProof,\n                root: beaconBlockRoot,\n                leaf: pubKeyHash,\n                index: generalizedIndex\n            }),\n            \"Invalid validator pubkey proof\"\n        );\n    }\n\n    /// @notice Verifies the balances container to the beacon block root.\n    /// BeaconBlock.state.balances\n    /// @param beaconBlockRoot The root of the beacon block.\n    /// @param balancesContainerRoot The merkle root of the the balances container.\n    /// @param balancesContainerProof The merkle proof for the balances container to the beacon block root.\n    /// This is 9 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    function verifyBalancesContainer(\n        bytes32 beaconBlockRoot,\n        bytes32 balancesContainerRoot,\n        bytes calldata balancesContainerProof\n    ) internal view {\n        require(beaconBlockRoot != bytes32(0), \"Invalid block root\");\n        require(\n            // 9 * 32 bytes = 288 bytes\n            balancesContainerProof.length == 288,\n            \"Invalid proof length\"\n        );\n\n        // BeaconBlock.state.balances\n        require(\n            Merkle.verifyInclusionSha256({\n                proof: balancesContainerProof,\n                root: beaconBlockRoot,\n                leaf: balancesContainerRoot,\n                index: BALANCES_CONTAINER_GENERALIZED_INDEX\n            }),\n            \"Invalid balance container proof\"\n        );\n    }\n\n    /// @notice Verifies the validator balance to the root of the Balances container.\n    /// @param balancesContainerRoot The merkle root of the Balances container.\n    /// @param validatorBalanceLeaf The leaf node containing the validator balance with three other balances.\n    /// @param balanceProof The merkle proof for the validator balance to the Balances container root.\n    /// This is 39 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    /// @param validatorIndex The validator index to verify the balance for.\n    /// @return validatorBalanceGwei The balance in Gwei of the validator at the given index.\n    function verifyValidatorBalance(\n        bytes32 balancesContainerRoot,\n        bytes32 validatorBalanceLeaf,\n        bytes calldata balanceProof,\n        uint64 validatorIndex\n    ) internal view returns (uint256 validatorBalanceGwei) {\n        require(balancesContainerRoot != bytes32(0), \"Invalid container root\");\n        require(\n            // 39 * 32 bytes = 1248 bytes\n            balanceProof.length == 1248,\n            \"Invalid proof length\"\n        );\n\n        // Four balances are stored in each leaf so the validator index is divided by 4\n        uint64 balanceIndex = validatorIndex / 4;\n\n        // Get the index within the balances container, not the Beacon Block\n        // BeaconBlock.state.balances[balanceIndex]\n        uint256 generalizedIndex = concatGenIndices(\n            1,\n            BALANCES_HEIGHT,\n            balanceIndex\n        );\n\n        validatorBalanceGwei = balanceAtIndex(\n            validatorBalanceLeaf,\n            validatorIndex\n        );\n\n        require(\n            Merkle.verifyInclusionSha256({\n                proof: balanceProof,\n                root: balancesContainerRoot,\n                leaf: validatorBalanceLeaf,\n                index: generalizedIndex\n            }),\n            \"Invalid balance proof\"\n        );\n    }\n\n    /// @notice If the deposit queue is not empty,\n    /// verify the slot of the first pending deposit to the beacon block root\n    /// BeaconBlock.state.PendingDeposits[0].slot\n    /// If the deposit queue is empty, verify the root of the first pending deposit is empty\n    /// BeaconBlock.state.PendingDeposits[0]\n    /// @param beaconBlockRoot The root of the beacon block.\n    /// @param slot The beacon chain slot of the first deposit in the beacon chain's deposit queue.\n    /// Can be anything if the deposit queue is empty, but zero would be a good choice.\n    /// @param firstPendingDepositSlotProof The merkle proof to the beacon block root. Can be either:\n    /// - 40 witness hashes for BeaconBlock.state.PendingDeposits[0].slot when the deposit queue is not empty.\n    /// - 37 witness hashes for BeaconBlock.state.PendingDeposits[0] when the deposit queue is empty.\n    /// The 32 byte witness hashes are concatenated together starting from the leaf node.\n    /// @return isEmptyDepositQueue True if the deposit queue is empty, false otherwise.\n    function verifyFirstPendingDepositSlot(\n        bytes32 beaconBlockRoot,\n        uint64 slot,\n        bytes calldata firstPendingDepositSlotProof\n    ) internal view returns (bool isEmptyDepositQueue) {\n        require(beaconBlockRoot != bytes32(0), \"Invalid block root\");\n        require(\n            // 40 * 32 bytes = 1280 bytes\n            firstPendingDepositSlotProof.length == 1280 ||\n                // 37 * 32 bytes = 1184 bytes\n                firstPendingDepositSlotProof.length == 1184,\n            \"Invalid proof length\"\n        );\n\n        uint256 generalizedIndex;\n        bytes32 leaf;\n        // If the deposit queue is empty\n        if (\n            firstPendingDepositSlotProof.length ==\n            FIRST_PENDING_DEPOSIT_PROOF_LENGTH\n        ) {\n            isEmptyDepositQueue = true;\n            // use an empty leaf node as the root of the first pending deposit\n            // when the deposit queue is empty\n            leaf = bytes32(0);\n            // BeaconBlock.state.PendingDeposits[0]\n            generalizedIndex = FIRST_PENDING_DEPOSIT_GENERALIZED_INDEX;\n        } else if (\n            firstPendingDepositSlotProof.length ==\n            FIRST_PENDING_DEPOSIT_SLOT_PROOF_LENGTH\n        ) {\n            // Convert uint64 slot number to a little endian bytes32\n            leaf = Endian.toLittleEndianUint64(slot);\n            // BeaconBlock.state.PendingDeposits[0].slot\n            generalizedIndex = FIRST_PENDING_DEPOSIT_SLOT_GENERALIZED_INDEX;\n        } else {\n            revert(\"Invalid proof length\");\n        }\n\n        require(\n            Merkle.verifyInclusionSha256({\n                proof: firstPendingDepositSlotProof,\n                root: beaconBlockRoot,\n                leaf: leaf,\n                index: generalizedIndex\n            }),\n            \"Invalid pending deposit proof\"\n        );\n    }\n\n    ////////////////////////////////////////////////////\n    ///       Internal Helper Functions\n    ////////////////////////////////////////////////////\n\n    function balanceAtIndex(bytes32 validatorBalanceLeaf, uint64 validatorIndex)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 bitShiftAmount = (validatorIndex % 4) * 64;\n        return\n            Endian.fromLittleEndianUint64(\n                bytes32((uint256(validatorBalanceLeaf) << bitShiftAmount))\n            );\n    }\n\n    /// @notice Concatenates two beacon chain generalized indices into one.\n    /// @param genIndex The first generalized index or 1 if calculating for a single container.\n    /// @param height The merkle tree height of the second container. eg 39 for balances, 41 for validators.\n    /// @param index The index within the second container. eg the validator index.\n    /// @return genIndex The concatenated generalized index.\n    function concatGenIndices(\n        uint256 genIndex,\n        uint256 height,\n        uint256 index\n    ) internal pure returns (uint256) {\n        return (genIndex << height) | index;\n    }\n}\n"
    },
    "contracts/beacon/Endian.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Library to handle conversion between little-endian and big-endian formats.\n * @author Origin Protocol Inc\n */\nlibrary Endian {\n    /**\n     * @notice Converts a little endian-formatted uint64 to a big endian-formatted uint64\n     * @param lenum little endian-formatted uint64 input, provided as 'bytes32' type\n     * @return n The big endian-formatted uint64\n     * @dev Note that the input is formatted as a 'bytes32' type (i.e. 256 bits),\n     * but it is immediately truncated to a uint64 (i.e. 64 bits)\n     * through a right-shift/shr operation.\n     */\n    function fromLittleEndianUint64(bytes32 lenum)\n        internal\n        pure\n        returns (uint64 n)\n    {\n        // the number needs to be stored in little-endian encoding (ie in bytes 0-8)\n        n = uint64(uint256(lenum >> 192));\n        // forgefmt: disable-next-item\n        return\n            (n >> 56) |\n            ((0x00FF000000000000 & n) >> 40) |\n            ((0x0000FF0000000000 & n) >> 24) |\n            ((0x000000FF00000000 & n) >> 8) |\n            ((0x00000000FF000000 & n) << 8) |\n            ((0x0000000000FF0000 & n) << 24) |\n            ((0x000000000000FF00 & n) << 40) |\n            ((0x00000000000000FF & n) << 56);\n    }\n\n    function toLittleEndianUint64(uint64 benum)\n        internal\n        pure\n        returns (bytes32 n)\n    {\n        // Convert to little-endian by reversing byte order\n        uint64 reversed = (benum >> 56) |\n            ((0x00FF000000000000 & benum) >> 40) |\n            ((0x0000FF0000000000 & benum) >> 24) |\n            ((0x000000FF00000000 & benum) >> 8) |\n            ((0x00000000FF000000 & benum) << 8) |\n            ((0x0000000000FF0000 & benum) << 24) |\n            ((0x000000000000FF00 & benum) << 40) |\n            ((0x00000000000000FF & benum) << 56);\n\n        // Store the little-endian uint64 in the least significant 64 bits of bytes32\n        n = bytes32(uint256(reversed));\n        // Shift to most significant bits\n        n = n << 192;\n    }\n}\n"
    },
    "contracts/beacon/Merkle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Adapted from OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary Merkle {\n    error InvalidProofLength();\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is\n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     *\n     * Note this is for a Merkle tree using the sha256 hash function\n     */\n    function verifyInclusionSha256(\n        bytes memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        uint256 index\n    ) internal view returns (bool) {\n        return processInclusionProofSha256(proof, leaf, index) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is\n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     *\n     * _Available since v4.4._\n     *\n     * Note this is for a Merkle tree using the sha256 hash function\n     */\n    function processInclusionProofSha256(\n        bytes memory proof,\n        bytes32 leaf,\n        uint256 index\n    ) internal view returns (bytes32) {\n        require(\n            proof.length != 0 && proof.length % 32 == 0,\n            InvalidProofLength()\n        );\n        bytes32[1] memory computedHash = [leaf];\n        for (uint256 i = 32; i <= proof.length; i += 32) {\n            if (index % 2 == 0) {\n                // if ith bit of index is 0, then computedHash is a left sibling\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    mstore(0x00, mload(computedHash))\n                    mstore(0x20, mload(add(proof, i)))\n                    if iszero(\n                        staticcall(\n                            sub(gas(), 2000),\n                            2,\n                            0x00,\n                            0x40,\n                            computedHash,\n                            0x20\n                        )\n                    ) {\n                        revert(0, 0)\n                    }\n                    index := div(index, 2)\n                }\n            } else {\n                // if ith bit of index is 1, then computedHash is a right sibling\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    mstore(0x00, mload(add(proof, i)))\n                    mstore(0x20, mload(computedHash))\n                    if iszero(\n                        staticcall(\n                            sub(gas(), 2000),\n                            2,\n                            0x00,\n                            0x40,\n                            computedHash,\n                            0x20\n                        )\n                    ) {\n                        revert(0, 0)\n                    }\n                    index := div(index, 2)\n                }\n            }\n        }\n        return computedHash[0];\n    }\n}\n"
    },
    "contracts/mocks/MockBeaconProofs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { BeaconProofsLib } from \"../beacon/BeaconProofsLib.sol\";\nimport { BeaconProofs } from \"../beacon/BeaconProofs.sol\";\n\ncontract MockBeaconProofs is BeaconProofs {\n    function concatGenIndices(\n        uint256 index1,\n        uint256 height2,\n        uint256 index2\n    ) external pure returns (uint256 genIndex) {\n        return BeaconProofsLib.concatGenIndices(index1, height2, index2);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}