{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/beacon/BeaconRoots.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Library to retrieve beacon block roots.\n * @author Origin Protocol Inc\n */\nlibrary BeaconRoots {\n    /// @notice The address of beacon block roots oracle\n    /// See https://eips.ethereum.org/EIPS/eip-4788\n    address internal constant BEACON_ROOTS_ADDRESS =\n        0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02;\n\n    /// @notice Returns the beacon block root for the previous block.\n    /// This comes from the Beacon Roots contract defined in EIP-4788.\n    /// This will revert if the block is more than 8,191 blocks old as\n    /// that is the size of the beacon root's ring buffer.\n    /// @param timestamp The timestamp of the block for which to get the parent root.\n    /// @return parentRoot The parent block root for the given timestamp.\n    function parentBlockRoot(uint64 timestamp)\n        internal\n        view\n        returns (bytes32 parentRoot)\n    {\n        // Call the Beacon Roots contract to get the parent block root.\n        // This does not have a function signature, so we use a staticcall.\n        (bool success, bytes memory result) = BEACON_ROOTS_ADDRESS.staticcall(\n            abi.encode(timestamp)\n        );\n\n        require(success && result.length > 0, \"Invalid beacon timestamp\");\n        parentRoot = abi.decode(result, (bytes32));\n    }\n}\n"
    },
    "contracts/beacon/PartialWithdrawal.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Library to request full or partial withdrawals from validators on the beacon chain.\n * @author Origin Protocol Inc\n */\nlibrary PartialWithdrawal {\n    /// @notice The address where the withdrawal request is sent to\n    /// See https://eips.ethereum.org/EIPS/eip-7002\n    address internal constant WITHDRAWAL_REQUEST_ADDRESS =\n        0x00000961Ef480Eb55e80D19ad83579A64c007002;\n\n    function request(bytes calldata validatorPubKey, uint64 amount)\n        internal\n        returns (uint256 fee_)\n    {\n        require(validatorPubKey.length == 48, \"Invalid validator byte length\");\n        fee_ = fee();\n\n        // Call the Withdrawal Request contract with the validator public key\n        // and amount to be withdrawn packed together\n\n        // This is a general purpose EL to CL request:\n        // https://eips.ethereum.org/EIPS/eip-7685\n        (bool success, ) = WITHDRAWAL_REQUEST_ADDRESS.call{ value: fee_ }(\n            abi.encodePacked(validatorPubKey, amount)\n        );\n\n        require(success, \"Withdrawal request failed\");\n    }\n\n    function fee() internal view returns (uint256) {\n        // Get fee from the withdrawal request contract\n        (bool success, bytes memory result) = WITHDRAWAL_REQUEST_ADDRESS\n            .staticcall(\"\");\n\n        require(success && result.length > 0, \"Failed to get fee\");\n        return abi.decode(result, (uint256));\n    }\n}\n"
    },
    "contracts/governance/Governable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Base for contracts that are managed by the Origin Protocol's Governor.\n * @dev Copy of the openzeppelin Ownable.sol contract with nomenclature change\n *      from owner to governor and renounce methods removed. Does not use\n *      Context.sol like Ownable.sol does for simplification.\n * @author Origin Protocol Inc\n */\nabstract contract Governable {\n    // Storage position of the owner and pendingOwner of the contract\n    // keccak256(\"OUSD.governor\");\n    bytes32 private constant governorPosition =\n        0x7bea13895fa79d2831e0a9e28edede30099005a50d652d8957cf8a607ee6ca4a;\n\n    // keccak256(\"OUSD.pending.governor\");\n    bytes32 private constant pendingGovernorPosition =\n        0x44c4d30b2eaad5130ad70c3ba6972730566f3e6359ab83e800d905c61b1c51db;\n\n    // keccak256(\"OUSD.reentry.status\");\n    bytes32 private constant reentryStatusPosition =\n        0x53bf423e48ed90e97d02ab0ebab13b2a235a6bfbe9c321847d5c175333ac4535;\n\n    // See OpenZeppelin ReentrancyGuard implementation\n    uint256 constant _NOT_ENTERED = 1;\n    uint256 constant _ENTERED = 2;\n\n    event PendingGovernorshipTransfer(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    event GovernorshipTransferred(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    /**\n     * @notice Returns the address of the current Governor.\n     */\n    function governor() public view returns (address) {\n        return _governor();\n    }\n\n    /**\n     * @dev Returns the address of the current Governor.\n     */\n    function _governor() internal view returns (address governorOut) {\n        bytes32 position = governorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            governorOut := sload(position)\n        }\n    }\n\n    /**\n     * @dev Returns the address of the pending Governor.\n     */\n    function _pendingGovernor()\n        internal\n        view\n        returns (address pendingGovernor)\n    {\n        bytes32 position = pendingGovernorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            pendingGovernor := sload(position)\n        }\n    }\n\n    /**\n     * @dev Throws if called by any account other than the Governor.\n     */\n    modifier onlyGovernor() {\n        require(isGovernor(), \"Caller is not the Governor\");\n        _;\n    }\n\n    /**\n     * @notice Returns true if the caller is the current Governor.\n     */\n    function isGovernor() public view returns (bool) {\n        return msg.sender == _governor();\n    }\n\n    function _setGovernor(address newGovernor) internal {\n        emit GovernorshipTransferred(_governor(), newGovernor);\n\n        bytes32 position = governorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, newGovernor)\n        }\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        bytes32 position = reentryStatusPosition;\n        uint256 _reentry_status;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _reentry_status := sload(position)\n        }\n\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_reentry_status != _ENTERED, \"Reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, _ENTERED)\n        }\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, _NOT_ENTERED)\n        }\n    }\n\n    function _setPendingGovernor(address newGovernor) internal {\n        bytes32 position = pendingGovernorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, newGovernor)\n        }\n    }\n\n    /**\n     * @notice Transfers Governance of the contract to a new account (`newGovernor`).\n     * Can only be called by the current Governor. Must be claimed for this to complete\n     * @param _newGovernor Address of the new Governor\n     */\n    function transferGovernance(address _newGovernor) external onlyGovernor {\n        _setPendingGovernor(_newGovernor);\n        emit PendingGovernorshipTransfer(_governor(), _newGovernor);\n    }\n\n    /**\n     * @notice Claim Governance of the contract to a new account (`newGovernor`).\n     * Can only be called by the new Governor.\n     */\n    function claimGovernance() external {\n        require(\n            msg.sender == _pendingGovernor(),\n            \"Only the pending Governor can complete the claim\"\n        );\n        _changeGovernor(msg.sender);\n    }\n\n    /**\n     * @dev Change Governance of the contract to a new account (`newGovernor`).\n     * @param _newGovernor Address of the new Governor\n     */\n    function _changeGovernor(address _newGovernor) internal {\n        require(_newGovernor != address(0), \"New Governor is address(0)\");\n        _setGovernor(_newGovernor);\n    }\n}\n"
    },
    "contracts/interfaces/IBasicToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBasicToken {\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IBeaconProofs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IBeaconProofs {\n    enum BalanceProofLevel {\n        Container,\n        BeaconBlock\n    }\n\n    function verifyValidatorPubkey(\n        bytes32 beaconBlockRoot,\n        bytes32 pubKeyHash,\n        bytes calldata validatorPubKeyProof,\n        uint64 validatorIndex,\n        address withdrawalAddress\n    ) external view;\n\n    function verifyBalancesContainer(\n        bytes32 beaconBlockRoot,\n        bytes32 balancesContainerLeaf,\n        bytes calldata balancesContainerProof\n    ) external view;\n\n    function verifyValidatorBalance(\n        bytes32 balancesContainerRoot,\n        bytes32 validatorBalanceLeaf,\n        bytes calldata balanceProof,\n        uint64 validatorIndex\n    ) external view returns (uint256 validatorBalance);\n\n    function verifyFirstPendingDepositSlot(\n        bytes32 beaconBlockRoot,\n        uint64 slot,\n        bytes calldata firstPendingDepositSlotProof\n    ) external view returns (bool isEmptyDepositQueue);\n\n    function verifyBlockNumber(\n        bytes32 beaconBlockRoot,\n        uint256 blockNumber,\n        bytes calldata blockNumberProof\n    ) external view;\n\n    function verifySlot(\n        bytes32 beaconBlockRoot,\n        uint256 slot,\n        bytes calldata slotProof\n    ) external view;\n\n    function balanceAtIndex(bytes32 validatorBalanceLeaf, uint64 validatorIndex)\n        external\n        pure\n        returns (uint256);\n\n    function concatGenIndices(\n        uint256 genIndex,\n        uint256 height,\n        uint256 index\n    ) external pure returns (uint256);\n}\n"
    },
    "contracts/interfaces/IDepositContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IDepositContract {\n    /// @notice A processed deposit event.\n    event DepositEvent(\n        bytes pubkey,\n        bytes withdrawal_credentials,\n        bytes amount,\n        bytes signature,\n        bytes index\n    );\n\n    /// @notice Submit a Phase 0 DepositData object.\n    /// @param pubkey A BLS12-381 public key.\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\n    /// @param signature A BLS12-381 signature.\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\n    /// Used as a protection against malformed input.\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawal_credentials,\n        bytes calldata signature,\n        bytes32 deposit_data_root\n    ) external payable;\n\n    /// @notice Query the current deposit root hash.\n    /// @return The deposit root hash.\n    function get_deposit_root() external view returns (bytes32);\n\n    /// @notice Query the current deposit count.\n    /// @return The deposit count encoded as a little endian 64-bit number.\n    function get_deposit_count() external view returns (bytes memory);\n}\n"
    },
    "contracts/interfaces/ISSVNetwork.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct Cluster {\n    uint32 validatorCount;\n    uint64 networkFeeIndex;\n    uint64 index;\n    bool active;\n    uint256 balance;\n}\n\ninterface ISSVNetwork {\n    /**********/\n    /* Errors */\n    /**********/\n\n    error CallerNotOwner(); // 0x5cd83192\n    error CallerNotWhitelisted(); // 0x8c6e5d71\n    error FeeTooLow(); // 0x732f9413\n    error FeeExceedsIncreaseLimit(); // 0x958065d9\n    error NoFeeDeclared(); // 0x1d226c30\n    error ApprovalNotWithinTimeframe(); // 0x97e4b518\n    error OperatorDoesNotExist(); // 0x961e3e8c\n    error InsufficientBalance(); // 0xf4d678b8\n    error ValidatorDoesNotExist(); // 0xe51315d2\n    error ClusterNotLiquidatable(); // 0x60300a8d\n    error InvalidPublicKeyLength(); // 0x637297a4\n    error InvalidOperatorIdsLength(); // 0x38186224\n    error ClusterAlreadyEnabled(); // 0x3babafd2\n    error ClusterIsLiquidated(); // 0x95a0cf33\n    error ClusterDoesNotExists(); // 0x185e2b16\n    error IncorrectClusterState(); // 0x12e04c87\n    error UnsortedOperatorsList(); // 0xdd020e25\n    error NewBlockPeriodIsBelowMinimum(); // 0x6e6c9cac\n    error ExceedValidatorLimit(); // 0x6df5ab76\n    error TokenTransferFailed(); // 0x045c4b02\n    error SameFeeChangeNotAllowed(); // 0xc81272f8\n    error FeeIncreaseNotAllowed(); // 0x410a2b6c\n    error NotAuthorized(); // 0xea8e4eb5\n    error OperatorsListNotUnique(); // 0xa5a1ff5d\n    error OperatorAlreadyExists(); // 0x289c9494\n    error TargetModuleDoesNotExist(); // 0x8f9195fb\n    error MaxValueExceeded(); // 0x91aa3017\n    error FeeTooHigh(); // 0xcd4e6167\n    error PublicKeysSharesLengthMismatch(); // 0x9ad467b8\n    error IncorrectValidatorStateWithData(bytes publicKey); // 0x89307938\n    error ValidatorAlreadyExistsWithData(bytes publicKey); // 0x388e7999\n    error EmptyPublicKeysList(); // df83e679\n\n    // legacy errors\n    error ValidatorAlreadyExists(); // 0x8d09a73e\n    error IncorrectValidatorState(); // 0x2feda3c1\n\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    event ClusterDeposited(\n        address indexed owner,\n        uint64[] operatorIds,\n        uint256 value,\n        Cluster cluster\n    );\n    event ClusterLiquidated(\n        address indexed owner,\n        uint64[] operatorIds,\n        Cluster cluster\n    );\n    event ClusterReactivated(\n        address indexed owner,\n        uint64[] operatorIds,\n        Cluster cluster\n    );\n    event ClusterWithdrawn(\n        address indexed owner,\n        uint64[] operatorIds,\n        uint256 value,\n        Cluster cluster\n    );\n    event DeclareOperatorFeePeriodUpdated(uint64 value);\n    event ExecuteOperatorFeePeriodUpdated(uint64 value);\n    event FeeRecipientAddressUpdated(\n        address indexed owner,\n        address recipientAddress\n    );\n    event Initialized(uint8 version);\n    event LiquidationThresholdPeriodUpdated(uint64 value);\n    event MinimumLiquidationCollateralUpdated(uint256 value);\n    event NetworkEarningsWithdrawn(uint256 value, address recipient);\n    event NetworkFeeUpdated(uint256 oldFee, uint256 newFee);\n    event OperatorAdded(\n        uint64 indexed operatorId,\n        address indexed owner,\n        bytes publicKey,\n        uint256 fee\n    );\n    event OperatorFeeDeclarationCancelled(\n        address indexed owner,\n        uint64 indexed operatorId\n    );\n    event OperatorFeeDeclared(\n        address indexed owner,\n        uint64 indexed operatorId,\n        uint256 blockNumber,\n        uint256 fee\n    );\n    event OperatorFeeExecuted(\n        address indexed owner,\n        uint64 indexed operatorId,\n        uint256 blockNumber,\n        uint256 fee\n    );\n    event OperatorFeeIncreaseLimitUpdated(uint64 value);\n    event OperatorMaximumFeeUpdated(uint64 maxFee);\n    event OperatorRemoved(uint64 indexed operatorId);\n    event OperatorWhitelistUpdated(\n        uint64 indexed operatorId,\n        address whitelisted\n    );\n    event OperatorWithdrawn(\n        address indexed owner,\n        uint64 indexed operatorId,\n        uint256 value\n    );\n    event OwnershipTransferStarted(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event Upgraded(address indexed implementation);\n    event ValidatorAdded(\n        address indexed owner,\n        uint64[] operatorIds,\n        bytes publicKey,\n        bytes shares,\n        Cluster cluster\n    );\n    event ValidatorExited(\n        address indexed owner,\n        uint64[] operatorIds,\n        bytes publicKey\n    );\n    event ValidatorRemoved(\n        address indexed owner,\n        uint64[] operatorIds,\n        bytes publicKey,\n        Cluster cluster\n    );\n\n    fallback() external;\n\n    function acceptOwnership() external;\n\n    function cancelDeclaredOperatorFee(uint64 operatorId) external;\n\n    function declareOperatorFee(uint64 operatorId, uint256 fee) external;\n\n    function deposit(\n        address clusterOwner,\n        uint64[] memory operatorIds,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function executeOperatorFee(uint64 operatorId) external;\n\n    function exitValidator(bytes memory publicKey, uint64[] memory operatorIds)\n        external;\n\n    function bulkExitValidator(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds\n    ) external;\n\n    function getVersion() external pure returns (string memory version);\n\n    function initialize(\n        address token_,\n        address ssvOperators_,\n        address ssvClusters_,\n        address ssvDAO_,\n        address ssvViews_,\n        uint64 minimumBlocksBeforeLiquidation_,\n        uint256 minimumLiquidationCollateral_,\n        uint32 validatorsPerOperatorLimit_,\n        uint64 declareOperatorFeePeriod_,\n        uint64 executeOperatorFeePeriod_,\n        uint64 operatorMaxFeeIncrease_\n    ) external;\n\n    function liquidate(\n        address clusterOwner,\n        uint64[] memory operatorIds,\n        Cluster memory cluster\n    ) external;\n\n    function owner() external view returns (address);\n\n    function pendingOwner() external view returns (address);\n\n    function proxiableUUID() external view returns (bytes32);\n\n    function reactivate(\n        uint64[] memory operatorIds,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function reduceOperatorFee(uint64 operatorId, uint256 fee) external;\n\n    function registerOperator(bytes memory publicKey, uint256 fee)\n        external\n        returns (uint64 id);\n\n    function registerValidator(\n        bytes memory publicKey,\n        uint64[] memory operatorIds,\n        bytes memory sharesData,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function bulkRegisterValidator(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds,\n        bytes[] calldata sharesData,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function removeOperator(uint64 operatorId) external;\n\n    function removeValidator(\n        bytes memory publicKey,\n        uint64[] memory operatorIds,\n        Cluster memory cluster\n    ) external;\n\n    function bulkRemoveValidator(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds,\n        Cluster memory cluster\n    ) external;\n\n    function renounceOwnership() external;\n\n    function setFeeRecipientAddress(address recipientAddress) external;\n\n    function setOperatorWhitelist(uint64 operatorId, address whitelisted)\n        external;\n\n    function transferOwnership(address newOwner) external;\n\n    function updateDeclareOperatorFeePeriod(uint64 timeInSeconds) external;\n\n    function updateExecuteOperatorFeePeriod(uint64 timeInSeconds) external;\n\n    function updateLiquidationThresholdPeriod(uint64 blocks) external;\n\n    function updateMaximumOperatorFee(uint64 maxFee) external;\n\n    function updateMinimumLiquidationCollateral(uint256 amount) external;\n\n    function updateModule(uint8 moduleId, address moduleAddress) external;\n\n    function updateNetworkFee(uint256 fee) external;\n\n    function updateOperatorFeeIncreaseLimit(uint64 percentage) external;\n\n    function upgradeTo(address newImplementation) external;\n\n    function upgradeToAndCall(address newImplementation, bytes memory data)\n        external\n        payable;\n\n    function withdraw(\n        uint64[] memory operatorIds,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function withdrawAllOperatorEarnings(uint64 operatorId) external;\n\n    function withdrawNetworkEarnings(uint256 amount) external;\n\n    function withdrawOperatorEarnings(uint64 operatorId, uint256 amount)\n        external;\n}\n"
    },
    "contracts/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Platform interface to integrate with lending platform like Compound, AAVE etc.\n */\ninterface IStrategy {\n    /**\n     * @dev Deposit the given asset to platform\n     * @param _asset asset address\n     * @param _amount Amount to deposit\n     */\n    function deposit(address _asset, uint256 _amount) external;\n\n    /**\n     * @dev Deposit the entire balance of all supported assets in the Strategy\n     *      to the platform\n     */\n    function depositAll() external;\n\n    /**\n     * @dev Withdraw given asset from Lending platform\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external;\n\n    /**\n     * @dev Liquidate all assets in strategy and return them to Vault.\n     */\n    function withdrawAll() external;\n\n    /**\n     * @dev Returns the current balance of the given asset.\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        returns (uint256 balance);\n\n    /**\n     * @dev Returns bool indicating whether strategy supports asset.\n     */\n    function supportsAsset(address _asset) external view returns (bool);\n\n    /**\n     * @dev Collect reward tokens from the Strategy.\n     */\n    function collectRewardTokens() external;\n\n    /**\n     * @dev The address array of the reward tokens for the Strategy.\n     */\n    function getRewardTokenAddresses() external view returns (address[] memory);\n\n    function harvesterAddress() external view returns (address);\n\n    function transferToken(address token, uint256 amount) external;\n\n    function setRewardTokenAddresses(address[] calldata _rewardTokenAddresses)\n        external;\n}\n"
    },
    "contracts/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { VaultStorage } from \"../vault/VaultStorage.sol\";\n\ninterface IVault {\n    // slither-disable-start constable-states\n\n    event AssetSupported(address _asset);\n    event AssetDefaultStrategyUpdated(address _asset, address _strategy);\n    event AssetAllocated(address _asset, address _strategy, uint256 _amount);\n    event StrategyApproved(address _addr);\n    event StrategyRemoved(address _addr);\n    event Mint(address _addr, uint256 _value);\n    event Redeem(address _addr, uint256 _value);\n    event CapitalPaused();\n    event CapitalUnpaused();\n    event RebasePaused();\n    event RebaseUnpaused();\n    event VaultBufferUpdated(uint256 _vaultBuffer);\n    event RedeemFeeUpdated(uint256 _redeemFeeBps);\n    event PriceProviderUpdated(address _priceProvider);\n    event AllocateThresholdUpdated(uint256 _threshold);\n    event RebaseThresholdUpdated(uint256 _threshold);\n    event StrategistUpdated(address _address);\n    event MaxSupplyDiffChanged(uint256 maxSupplyDiff);\n    event YieldDistribution(address _to, uint256 _yield, uint256 _fee);\n    event TrusteeFeeBpsChanged(uint256 _basis);\n    event TrusteeAddressChanged(address _address);\n    event SwapperChanged(address _address);\n    event SwapAllowedUndervalueChanged(uint256 _basis);\n    event SwapSlippageChanged(address _asset, uint256 _basis);\n    event Swapped(\n        address indexed _fromAsset,\n        address indexed _toAsset,\n        uint256 _fromAssetAmount,\n        uint256 _toAssetAmount\n    );\n    event StrategyAddedToMintWhitelist(address indexed strategy);\n    event StrategyRemovedFromMintWhitelist(address indexed strategy);\n    event DripperChanged(address indexed _dripper);\n    event WithdrawalRequested(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount,\n        uint256 _queued\n    );\n    event WithdrawalClaimed(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount\n    );\n    event WithdrawalClaimable(uint256 _claimable, uint256 _newClaimable);\n\n    // Governable.sol\n    function transferGovernance(address _newGovernor) external;\n\n    function claimGovernance() external;\n\n    function governor() external view returns (address);\n\n    function ADMIN_IMPLEMENTATION() external view returns (address);\n\n    // VaultAdmin.sol\n    function setPriceProvider(address _priceProvider) external;\n\n    function priceProvider() external view returns (address);\n\n    function setRedeemFeeBps(uint256 _redeemFeeBps) external;\n\n    function redeemFeeBps() external view returns (uint256);\n\n    function setVaultBuffer(uint256 _vaultBuffer) external;\n\n    function vaultBuffer() external view returns (uint256);\n\n    function setAutoAllocateThreshold(uint256 _threshold) external;\n\n    function autoAllocateThreshold() external view returns (uint256);\n\n    function setRebaseThreshold(uint256 _threshold) external;\n\n    function rebaseThreshold() external view returns (uint256);\n\n    function setStrategistAddr(address _address) external;\n\n    function strategistAddr() external view returns (address);\n\n    function setMaxSupplyDiff(uint256 _maxSupplyDiff) external;\n\n    function maxSupplyDiff() external view returns (uint256);\n\n    function setTrusteeAddress(address _address) external;\n\n    function trusteeAddress() external view returns (address);\n\n    function setTrusteeFeeBps(uint256 _basis) external;\n\n    function trusteeFeeBps() external view returns (uint256);\n\n    function ousdMetaStrategy() external view returns (address);\n\n    function setSwapper(address _swapperAddr) external;\n\n    function setSwapAllowedUndervalue(uint16 _percentageBps) external;\n\n    function setOracleSlippage(address _asset, uint16 _allowedOracleSlippageBps)\n        external;\n\n    function supportAsset(address _asset, uint8 _unitConversion) external;\n\n    function approveStrategy(address _addr) external;\n\n    function removeStrategy(address _addr) external;\n\n    function setAssetDefaultStrategy(address _asset, address _strategy)\n        external;\n\n    function assetDefaultStrategies(address _asset)\n        external\n        view\n        returns (address);\n\n    function pauseRebase() external;\n\n    function unpauseRebase() external;\n\n    function rebasePaused() external view returns (bool);\n\n    function pauseCapital() external;\n\n    function unpauseCapital() external;\n\n    function capitalPaused() external view returns (bool);\n\n    function transferToken(address _asset, uint256 _amount) external;\n\n    function priceUnitMint(address asset) external view returns (uint256);\n\n    function priceUnitRedeem(address asset) external view returns (uint256);\n\n    function withdrawAllFromStrategy(address _strategyAddr) external;\n\n    function withdrawAllFromStrategies() external;\n\n    function withdrawFromStrategy(\n        address _strategyFromAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external;\n\n    function depositToStrategy(\n        address _strategyToAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external;\n\n    // VaultCore.sol\n    function mint(\n        address _asset,\n        uint256 _amount,\n        uint256 _minimumOusdAmount\n    ) external;\n\n    function mintForStrategy(uint256 _amount) external;\n\n    function redeem(uint256 _amount, uint256 _minimumUnitAmount) external;\n\n    function burnForStrategy(uint256 _amount) external;\n\n    function allocate() external;\n\n    function rebase() external;\n\n    function swapCollateral(\n        address fromAsset,\n        address toAsset,\n        uint256 fromAssetAmount,\n        uint256 minToAssetAmount,\n        bytes calldata data\n    ) external returns (uint256 toAssetAmount);\n\n    function totalValue() external view returns (uint256 value);\n\n    function checkBalance(address _asset) external view returns (uint256);\n\n    function calculateRedeemOutputs(uint256 _amount)\n        external\n        view\n        returns (uint256[] memory);\n\n    function getAssetCount() external view returns (uint256);\n\n    function getAssetConfig(address _asset)\n        external\n        view\n        returns (VaultStorage.Asset memory config);\n\n    function getAllAssets() external view returns (address[] memory);\n\n    function getStrategyCount() external view returns (uint256);\n\n    function swapper() external view returns (address);\n\n    function allowedSwapUndervalue() external view returns (uint256);\n\n    function getAllStrategies() external view returns (address[] memory);\n\n    function isSupportedAsset(address _asset) external view returns (bool);\n\n    function netOusdMintForStrategyThreshold() external view returns (uint256);\n\n    function setOusdMetaStrategy(address _ousdMetaStrategy) external;\n\n    function setNetOusdMintForStrategyThreshold(uint256 _threshold) external;\n\n    function netOusdMintedForStrategy() external view returns (int256);\n\n    function setDripper(address _dripper) external;\n\n    function dripper() external view returns (address);\n\n    function weth() external view returns (address);\n\n    function cacheWETHAssetIndex() external;\n\n    function wethAssetIndex() external view returns (uint256);\n\n    function initialize(address, address) external;\n\n    function setAdminImpl(address) external;\n\n    function removeAsset(address _asset) external;\n\n    // These are OETH specific functions\n    function addWithdrawalQueueLiquidity() external;\n\n    function requestWithdrawal(uint256 _amount)\n        external\n        returns (uint256 requestId, uint256 queued);\n\n    function claimWithdrawal(uint256 requestId)\n        external\n        returns (uint256 amount);\n\n    function claimWithdrawals(uint256[] memory requestIds)\n        external\n        returns (uint256[] memory amounts, uint256 totalAmount);\n\n    function withdrawalQueueMetadata()\n        external\n        view\n        returns (VaultStorage.WithdrawalQueueMetadata memory);\n\n    function withdrawalRequests(uint256 requestId)\n        external\n        view\n        returns (VaultStorage.WithdrawalRequest memory);\n\n    // OETHb specific functions\n    function addStrategyToMintWhitelist(address strategyAddr) external;\n\n    function removeStrategyFromMintWhitelist(address strategyAddr) external;\n\n    function isMintWhitelistedStrategy(address strategyAddr)\n        external\n        view\n        returns (bool);\n\n    function withdrawalClaimDelay() external view returns (uint256);\n\n    function setWithdrawalClaimDelay(uint256 newDelay) external;\n\n    function lastRebase() external view returns (uint64);\n\n    function dripDuration() external view returns (uint64);\n\n    function setDripDuration(uint256 _dripDuration) external;\n\n    function rebasePerSecondMax() external view returns (uint64);\n\n    function setRebaseRateMax(uint256 yearlyApr) external;\n\n    function rebasePerSecondTarget() external view returns (uint64);\n\n    function previewYield() external view returns (uint256 yield);\n\n    // slither-disable-end constable-states\n}\n"
    },
    "contracts/interfaces/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWETH9 {\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    function allowance(address, address) external view returns (uint256);\n\n    function approve(address guy, uint256 wad) external returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function deposit() external payable;\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address dst, uint256 wad) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function withdraw(uint256 wad) external;\n}\n"
    },
    "contracts/strategies/NativeStaking/CompoundingStakingSSVStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { IWETH9 } from \"../../interfaces/IWETH9.sol\";\nimport { CompoundingValidatorManager } from \"./CompoundingValidatorManager.sol\";\n\n/// @title Compounding Staking SSV Strategy\n/// @notice Strategy to deploy funds into DVT validators powered by the SSV Network\n/// @author Origin Protocol Inc\n/// @dev This contract handles WETH and ETH and in some operations interchanges between the two. Any WETH that\n/// is on the contract across multiple blocks (and not just transitory within a transaction) is considered an\n/// asset. Meaning deposits increase the balance of the asset and withdrawal decrease it. As opposed to all\n/// our other strategies the WETH doesn't immediately get deposited into an underlying strategy and can be present\n/// across multiple blocks waiting to be unwrapped to ETH and staked to validators. This separation of WETH and ETH is\n/// required since the rewards (reward token) is also in ETH.\n///\n/// To simplify the accounting of WETH there is another difference in behavior compared to the other strategies.\n/// To withdraw WETH asset - exit message is posted to validators and the ETH hits this contract with multiple days\n/// delay. In order to simplify the WETH accounting upon detection of such an event the ValidatorAccountant\n/// immediately wraps ETH to WETH and sends it to the Vault.\n///\n/// On the other hand any ETH on the contract (across multiple blocks) is there either:\n///  - as a result of already accounted for consensus rewards\n///  - as a result of not yet accounted for consensus rewards\n///  - as a results of not yet accounted for full validator withdrawals (or validator slashes)\n///\n/// Even though the strategy assets and rewards are a very similar asset the consensus layer rewards and the\n/// execution layer rewards are considered rewards and those are dripped to the Vault over a configurable time\n/// interval and not immediately.\ncontract CompoundingStakingSSVStrategy is\n    CompoundingValidatorManager,\n    InitializableAbstractStrategy\n{\n    /// @notice SSV ERC20 token that serves as a payment for operating SSV validators\n    address public immutable SSV_TOKEN;\n\n    // For future use\n    uint256[50] private __gap;\n\n    /// @param _baseConfig Base strategy config with platformAddress (ERC-4626 Vault contract), eg sfrxETH or sDAI,\n    /// and vaultAddress (OToken Vault contract), eg VaultProxy or OETHVaultProxy\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\n    /// @param _ssvToken Address of the Erc20 SSV Token contract\n    /// @param _ssvNetwork Address of the SSV Network contract\n    /// @param _beaconChainDepositContract Address of the beacon chain deposit contract\n    /// @param _beaconProofs Address of the Beacon Proofs contract that verifies beacon chain data\n    /// @param _beaconGenesisTimestamp The timestamp of the Beacon chain's genesis.\n    constructor(\n        BaseStrategyConfig memory _baseConfig,\n        address _wethAddress,\n        address _ssvToken,\n        address _ssvNetwork,\n        address _beaconChainDepositContract,\n        address _beaconProofs,\n        uint64 _beaconGenesisTimestamp\n    )\n        InitializableAbstractStrategy(_baseConfig)\n        CompoundingValidatorManager(\n            _wethAddress,\n            _baseConfig.vaultAddress,\n            _beaconChainDepositContract,\n            _ssvNetwork,\n            _beaconProofs,\n            _beaconGenesisTimestamp\n        )\n    {\n        SSV_TOKEN = _ssvToken;\n    }\n\n    /// @notice Set up initial internal state including\n    /// 1. approving the SSVNetwork to transfer SSV tokens from this strategy contract\n    /// @param _rewardTokenAddresses Not used so empty array\n    /// @param _assets Not used so empty array\n    /// @param _pTokens Not used so empty array\n    function initialize(\n        address[] memory _rewardTokenAddresses,\n        address[] memory _assets,\n        address[] memory _pTokens\n    ) external onlyGovernor initializer {\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n\n        // Approves the SSV Network contract to transfer SSV tokens for deposits\n        IERC20(SSV_TOKEN).approve(SSV_NETWORK, type(uint256).max);\n    }\n\n    /// @notice Unlike other strategies, this does not deposit assets into the underlying platform.\n    /// It just checks the asset is WETH and emits the Deposit event.\n    /// To deposit WETH into validators, `registerSsvValidator` and `stakeEth` must be used.\n    /// @param _asset Address of the WETH token.\n    /// @param _amount Amount of WETH that was transferred to the strategy by the vault.\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        require(_asset == WETH, \"Unsupported asset\");\n        require(_amount > 0, \"Must deposit something\");\n\n        // Account for the new WETH\n        depositedWethAccountedFor += _amount;\n\n        emit Deposit(_asset, address(0), _amount);\n    }\n\n    /// @notice Unlike other strategies, this does not deposit assets into the underlying platform.\n    /// It just emits the Deposit event.\n    /// To deposit WETH into validators `registerSsvValidator` and `stakeEth` must be used.\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 wethBalance = IERC20(WETH).balanceOf(address(this));\n        uint256 newWeth = wethBalance - depositedWethAccountedFor;\n\n        if (newWeth > 0) {\n            // Account for the new WETH\n            depositedWethAccountedFor = wethBalance;\n\n            emit Deposit(WETH, address(0), newWeth);\n        }\n    }\n\n    /// @notice Withdraw ETH and WETH from this strategy contract.\n    /// @param _recipient Address to receive withdrawn assets\n    /// @param _asset WETH to withdraw\n    /// @param _amount Amount of WETH to withdraw\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_asset == WETH, \"Unsupported asset\");\n\n        _withdraw(_recipient, _asset, _amount, address(this).balance);\n    }\n\n    function _withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _withdrawAmount,\n        uint256 _ethBalance\n    ) internal {\n        require(_withdrawAmount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        // Convert any ETH from validator partial withdrawals, exits\n        // or execution rewards to WETH and do the necessary accounting.\n        if (_ethBalance > 0) _convertEthToWeth(_ethBalance);\n\n        // Transfer WETH to the recipient and do the necessary accounting.\n        _transferWeth(_withdrawAmount, _recipient);\n\n        emit Withdrawal(_asset, address(0), _withdrawAmount);\n    }\n\n    /// @notice Transfer all WETH deposits, ETH from validator withdrawals and ETH from\n    /// execution rewards in this strategy to the vault.\n    /// This does not withdraw from the validators. That has to be done separately with the\n    /// `validatorWithdrawal` operation.\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        uint256 ethBalance = address(this).balance;\n        uint256 withdrawAmount = IERC20(WETH).balanceOf(address(this)) +\n            ethBalance;\n\n        if (withdrawAmount > 0) {\n            _withdraw(vaultAddress, WETH, withdrawAmount, ethBalance);\n        }\n    }\n\n    /// @notice Accounts for all the assets managed by this strategy which includes:\n    /// 1. The current WETH in this strategy contract\n    /// 2. The last verified ETH balance, total deposits and total validator balances\n    /// @param _asset      Address of WETH asset.\n    /// @return balance    Total value in ETH\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == WETH, \"Unsupported asset\");\n\n        // Load the last verified balance from the storage\n        // and add to the latest WETH balance of this strategy.\n        balance =\n            lastVerifiedEthBalance +\n            IWETH9(WETH).balanceOf(address(this));\n    }\n\n    /// @notice Returns bool indicating whether asset is supported by the strategy.\n    /// @param _asset The address of the WETH token.\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == WETH;\n    }\n\n    /// @notice Approves the SSV Network contract to transfer SSV tokens for validator registration.\n    function safeApproveAllTokens() external override {\n        // Approves the SSV Network contract to transfer SSV tokens when validators are registered\n        IERC20(SSV_TOKEN).approve(SSV_NETWORK, type(uint256).max);\n    }\n\n    /**\n     * @notice We can accept ETH directly to this contract from anyone as it does not impact our accounting\n     * like it did in the legacy NativeStakingStrategy.\n     * The new ETH will be accounted for in `checkBalance` after the next snapBalances and verifyBalances txs.\n     */\n    receive() external payable {}\n\n    /***************************************\n                Internal functions\n    ****************************************/\n\n    /// @dev This strategy does not use a platform token like the old Aave and Compound strategies.\n    function _abstractSetPToken(address _asset, address) internal override {}\n\n    /// @dev Consensus rewards are compounded to the validator's balance instead of being\n    /// swept to this strategy contract.\n    /// Execution rewards from MEV and tx priority accumulate as ETH in this strategy contract.\n    /// Withdrawals from validators also accumulate as ETH in this strategy contract.\n    /// It's too complex to separate the rewards from withdrawals so this function is not implemented.\n    /// Besides, ETH rewards are not sent to the Dripper any more. The Vault can now regulate\n    /// the increase in assets.\n    function _collectRewardTokens() internal pure override {\n        revert(\"Unsupported function\");\n    }\n}\n"
    },
    "contracts/strategies/NativeStaking/CompoundingValidatorManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Governable } from \"../../governance/Governable.sol\";\nimport { IDepositContract } from \"../../interfaces/IDepositContract.sol\";\nimport { IWETH9 } from \"../../interfaces/IWETH9.sol\";\nimport { ISSVNetwork, Cluster } from \"../../interfaces/ISSVNetwork.sol\";\nimport { BeaconRoots } from \"../../beacon/BeaconRoots.sol\";\nimport { PartialWithdrawal } from \"../../beacon/PartialWithdrawal.sol\";\nimport { IBeaconProofs } from \"../../interfaces/IBeaconProofs.sol\";\n\nstruct ValidatorStakeData {\n    bytes pubkey;\n    bytes signature;\n    bytes32 depositDataRoot;\n}\n\n/**\n * @title Validator lifecycle management contract\n * @notice This contract implements all the required functionality to\n * register, deposit, withdraw, exit and remove validators.\n * @author Origin Protocol Inc\n */\nabstract contract CompoundingValidatorManager is Governable {\n    using SafeERC20 for IERC20;\n\n    /// @notice The amount of ETH in wei that is required for a deposit to a new validator.\n    /// Initially this is 32 ETH, but will be increased to 1 ETH after P2P's APIs have been updated\n    /// to support deposits of 1 ETH.\n    uint256 public constant DEPOSIT_AMOUNT_WEI = 32 ether;\n\n    /// @notice The address of the Wrapped ETH (WETH) token contract\n    address public immutable WETH;\n    /// @notice The address of the beacon chain deposit contract\n    address public immutable BEACON_CHAIN_DEPOSIT_CONTRACT;\n    /// @notice The address of the SSV Network contract used to interface with\n    address public immutable SSV_NETWORK;\n    /// @notice Address of the OETH Vault proxy contract\n    address public immutable VAULT_ADDRESS;\n    /// @notice Address of the Beacon Proofs contract that verifies beacon chain data\n    address public immutable BEACON_PROOFS;\n    /// @notice The timestamp of the Beacon chain genesis.\n    /// @dev this is different on Testnets like Hoodi so is set at deployment time.\n    uint64 public immutable BEACON_GENESIS_TIMESTAMP;\n\n    /// @notice Address of the registrator - allowed to register, withdraw, exit and remove validators\n    address public validatorRegistrator;\n\n    /// Deposit data for new compounding validators.\n\n    /// @param pubKeyHash Hash of validator's public key using the Beacon Chain's format\n    /// @param amountWei Amount of ETH in wei that has been deposited to the beacon chain deposit contract\n    /// @param blockNumber Block number when the deposit was made\n    /// @param depositIndex The index of the deposit in the list of active deposits\n    /// @param status The status of the deposit, either PENDING or PROVEN\n    struct DepositData {\n        bytes32 pubKeyHash;\n        uint64 amountGwei;\n        uint64 slot;\n        uint32 depositIndex;\n        DepositStatus status;\n    }\n    /// @notice Mapping of the root of a deposit (depositDataRoot) to its data\n    mapping(bytes32 => DepositData) public deposits;\n    /// @notice List of deposit roots that are still to be verified as processed on the beacon chain\n    bytes32[] public depositsRoots;\n\n    // Validator data\n\n    struct ValidatorData {\n        bytes32 pubKeyHash; // Hash of the validator's public key using the Beacon Chain's format\n        uint64 index; // The index of the validator on the beacon chain\n    }\n    /// @notice List of validator public key hashes and indexes that have been verified to exist on the beacon chain.\n    /// These have had a deposit processed and the validator's balance increased.\n    /// Validators will be removed from this list when its verified they have a zero balance.\n    ValidatorData[] internal verifiedValidators;\n    /// @notice State of the new compounding validators with a 0x02 withdrawal credential prefix.\n    /// Uses the Beacon chain hashing for BLSPubkey which is\n    /// sha256(abi.encodePacked(validator.pubkey, bytes16(0)))\n    mapping(bytes32 => VALIDATOR_STATE) public validatorState;\n\n    /// @param timestamp Timestamp of the snapshot\n    /// @param ethBalance The balance of ETH in the strategy contract at the snapshot\n    struct Balances {\n        uint64 timestamp;\n        uint128 ethBalance;\n    }\n    // TODO is it more efficient to use the block root rather than hashing it?\n    /// @notice Mapping of the block root to the balances at that slot\n    mapping(bytes32 => Balances) public snappedBalances;\n    uint64 public lastSnapTimestamp;\n    uint128 public lastVerifiedEthBalance;\n\n    /// @dev This contract receives WETH as the deposit asset, but unlike other strategies doesn't immediately\n    /// deposit it to an underlying platform. Rather a special privilege account stakes it to the validators.\n    /// For that reason calling WETH.balanceOf(this) in a deposit function can contain WETH that has just been\n    /// deposited and also WETH that has previously been deposited. To keep a correct count we need to keep track\n    /// of WETH that has already been accounted for.\n    /// This value represents the amount of WETH balance of this contract that has already been accounted for by the\n    /// deposit events.\n    /// It is important to note that this variable is not concerned with WETH that is a result of full/partial\n    /// withdrawal of the validators. It is strictly concerned with WETH that has been deposited and is waiting to\n    /// be staked.\n    uint256 public depositedWethAccountedFor;\n\n    // For future use\n    uint256[50] private __gap;\n\n    enum VALIDATOR_STATE {\n        NON_REGISTERED, // validator is not registered on the SSV network\n        REGISTERED, // validator is registered on the SSV network\n        STAKED, // validator has funds staked\n        VERIFIED, // validator has been verified to exist on the beacon chain\n        EXITED, // The validator has been verified to have a zero balance\n        REMOVED // validator has funds withdrawn to the EigenPod and is removed from the SSV\n    }\n    enum DepositStatus {\n        UNKNOWN, // default value\n        PENDING, // deposit is pending and waiting to be  verified\n        VERIFIED // deposit has been verified and is ready to be staked\n    }\n\n    event RegistratorChanged(address indexed newAddress);\n    event SourceStrategyAdded(address indexed strategy);\n    event SSVValidatorRegistered(\n        bytes32 indexed pubKeyHash,\n        uint64[] operatorIds\n    );\n    event SSVValidatorRemoved(bytes32 indexed pubKeyHash, uint64[] operatorIds);\n    event ETHStaked(\n        bytes32 indexed pubKeyHash,\n        bytes32 indexed depositDataRoot,\n        bytes pubKey,\n        uint256 amountWei\n    );\n    event ValidatorVerified(\n        bytes32 indexed pubKeyHash,\n        uint64 indexed validatorIndex\n    );\n    event DepositVerified(bytes32 indexed depositDataRoot, uint256 amountWei);\n    event ValidatorWithdraw(bytes32 indexed pubKeyHash, uint256 amountWei);\n    event BalancesSnapped(\n        uint256 indexed timestamp,\n        bytes32 indexed blockRoot,\n        uint256 ethBalance\n    );\n    event BalancesVerified(\n        uint64 indexed timestamp,\n        uint256 totalDepositsWei,\n        uint256 totalValidatorBalance,\n        uint256 wethBalance,\n        uint256 ethBalance\n    );\n\n    /// @dev Throws if called by any account other than the Registrator\n    modifier onlyRegistrator() {\n        require(msg.sender == validatorRegistrator, \"Not Registrator\");\n        _;\n    }\n\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\n    /// @param _vaultAddress Address of the Vault\n    /// @param _beaconChainDepositContract Address of the beacon chain deposit contract\n    /// @param _ssvNetwork Address of the SSV Network contract\n    /// @param _beaconProofs Address of the Beacon Proofs contract that verifies beacon chain data\n    /// @param _beaconGenesisTimestamp The timestamp of the Beacon chain's genesis.\n    constructor(\n        address _wethAddress,\n        address _vaultAddress,\n        address _beaconChainDepositContract,\n        address _ssvNetwork,\n        address _beaconProofs,\n        uint64 _beaconGenesisTimestamp\n    ) {\n        WETH = _wethAddress;\n        BEACON_CHAIN_DEPOSIT_CONTRACT = _beaconChainDepositContract;\n        SSV_NETWORK = _ssvNetwork;\n        VAULT_ADDRESS = _vaultAddress;\n        BEACON_PROOFS = _beaconProofs;\n        BEACON_GENESIS_TIMESTAMP = _beaconGenesisTimestamp;\n\n        require(\n            block.timestamp > _beaconGenesisTimestamp,\n            \"Invalid genesis timestamp\"\n        );\n    }\n\n    /***************************************\n                Admin Functions\n    ****************************************/\n\n    /// @notice Set the address of the registrator which can register, exit and remove validators\n    function setRegistrator(address _address) external onlyGovernor {\n        validatorRegistrator = _address;\n        emit RegistratorChanged(_address);\n    }\n\n    /***************************************`\n                Validator Management\n    ****************************************/\n\n    /// @notice Registers a single validator in a SSV Cluster.\n    /// Only the Registrator can call this function.\n    /// @param publicKey The public key of the validator\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param sharesData The shares data for the validator\n    /// @param ssvAmount The amount of SSV tokens to be deposited to the SSV cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    // slither-disable-start reentrancy-no-eth\n    function registerSsvValidator(\n        bytes calldata publicKey,\n        uint64[] calldata operatorIds,\n        bytes calldata sharesData,\n        uint256 ssvAmount,\n        Cluster calldata cluster\n    ) external onlyRegistrator {\n        // Hash the public key using the Beacon Chain's format\n        bytes32 pubKeyHash = _hashPubKey(publicKey);\n        // Check each public key has not already been used\n        require(\n            validatorState[pubKeyHash] == VALIDATOR_STATE.NON_REGISTERED,\n            \"Validator already registered\"\n        );\n\n        // Store the validator state as registered\n        validatorState[pubKeyHash] = VALIDATOR_STATE.REGISTERED;\n\n        ISSVNetwork(SSV_NETWORK).registerValidator(\n            publicKey,\n            operatorIds,\n            sharesData,\n            ssvAmount,\n            cluster\n        );\n\n        emit SSVValidatorRegistered(pubKeyHash, operatorIds);\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice Stakes WETH in this strategy to a compounding validator.\n    /// Does not convert any ETH sitting in this strategy to WETH.\n    /// @param validator validator data needed to stake.\n    /// The `ValidatorStakeData` struct contains the pubkey, signature and depositDataRoot.\n    /// Only the registrator can call this function.\n    /// @param depositAmountGwei The amount of WETH to stake to the validator in Gwei.\n    // slither-disable-start reentrancy-eth\n    function stakeEth(\n        ValidatorStakeData calldata validator,\n        uint64 depositAmountGwei\n    ) external onlyRegistrator {\n        uint256 depositAmountWei = uint256(depositAmountGwei) * 1 gwei;\n        // Check there is enough WETH from the deposits sitting in this strategy contract\n        // There could be ETH from withdrawals but we'll ignore that. If it's really needed\n        // the ETH can be withdrawn and then deposited back to the strategy.\n        require(\n            depositAmountWei <= IWETH9(WETH).balanceOf(address(this)),\n            \"Insufficient WETH\"\n        );\n\n        // Convert required ETH from WETH and do the necessary accounting\n        _convertWethToEth(depositAmountWei);\n\n        // Hash the public key using the Beacon Chain's hashing for BLSPubkey\n        bytes32 pubKeyHash = _hashPubKey(validator.pubkey);\n        VALIDATOR_STATE currentState = validatorState[pubKeyHash];\n        // Can only stake to a validator has have been registered or verified.\n        // Can not stake to a validator that has been staked but not yet verified.\n        require(\n            (currentState == VALIDATOR_STATE.REGISTERED ||\n                currentState == VALIDATOR_STATE.VERIFIED),\n            \"Not registered or verified\"\n        );\n        require(\n            currentState == VALIDATOR_STATE.VERIFIED ||\n                depositAmountWei == DEPOSIT_AMOUNT_WEI,\n            \"Invalid first deposit amount\"\n        );\n        require(depositAmountWei >= 1 ether, \"Deposit too small\");\n\n        /* 0x02 to indicate that withdrawal credentials are for a compounding validator\n         * that was introduced with the Pectra upgrade.\n         * bytes11(0) to fill up the required zeros\n         * remaining bytes20 are for the address\n         */\n        bytes memory withdrawalCredentials = abi.encodePacked(\n            bytes1(0x02),\n            bytes11(0),\n            address(this)\n        );\n\n        // Deposit to the Beacon Chain deposit contract.\n        // This will create a deposit in the beacon chain's pending deposit queue.\n        IDepositContract(BEACON_CHAIN_DEPOSIT_CONTRACT).deposit{\n            value: depositAmountWei\n        }(\n            validator.pubkey,\n            withdrawalCredentials,\n            validator.signature,\n            validator.depositDataRoot\n        );\n\n        //// Update contract storage\n        // Store the validator state if needed\n        if (currentState == VALIDATOR_STATE.REGISTERED) {\n            validatorState[pubKeyHash] = VALIDATOR_STATE.STAKED;\n        }\n\n        /// After the Pectra upgrade the validators have a new restriction when proposing\n        /// blocks. The timestamps are at strict intervals of 12 seconds from the genesis block\n        /// forward. Each slot is created at strict 12 second intervals and those slots can\n        /// either have blocks attached to them or not. This way using the block.timestamp\n        /// the slot number can easily be calculated.\n        uint64 depositSlot = (SafeCast.toUint64(block.timestamp) -\n            BEACON_GENESIS_TIMESTAMP) / 12;\n\n        // Store the deposit data for verifyDeposit and verifyBalances\n        deposits[validator.depositDataRoot] = DepositData({\n            pubKeyHash: pubKeyHash,\n            amountGwei: depositAmountGwei,\n            slot: depositSlot,\n            depositIndex: SafeCast.toUint32(depositsRoots.length),\n            status: DepositStatus.PENDING\n        });\n        depositsRoots.push(validator.depositDataRoot);\n\n        emit ETHStaked(\n            pubKeyHash,\n            validator.depositDataRoot,\n            validator.pubkey,\n            depositAmountWei\n        );\n    }\n\n    // slither-disable-end reentrancy-eth\n\n    /// @notice Request a full or partial withdrawal from a validator.\n    /// A zero amount will trigger a full withdrawal.\n    /// If the remaining balance is < 32 ETH then the request will fail.\n    /// Only the Registrator can call this function.\n    /// 1 wei of value should be sent with the tx to pay for the withdrawal request fee.\n    /// If no value sent, 1 wei will be taken from the strategy's ETH balance if it has any.\n    /// If no ETH balance, the tx will revert.\n    /// @param publicKey The public key of the validator\n    /// @param amountGwei The amount of ETH to be withdrawn from the validator in Gwei.\n    /// A zero amount will trigger a full withdrawal.\n    // slither-disable-start reentrancy-no-eth\n    function validatorWithdrawal(bytes calldata publicKey, uint64 amountGwei)\n        external\n        payable\n        onlyRegistrator\n    {\n        // Hash the public key using the Beacon Chain's format\n        bytes32 pubKeyHash = _hashPubKey(publicKey);\n        VALIDATOR_STATE currentState = validatorState[pubKeyHash];\n        require(\n            currentState == VALIDATOR_STATE.VERIFIED,\n            \"Validator not verified\"\n        );\n\n        PartialWithdrawal.request(publicKey, amountGwei);\n\n        // Do not remove from the list of verified validators.\n        // This is done in the verifyBalances function once the validator's balance has been verified to be zero.\n        // The validator state will be set to EXITED in the verifyBalances function.\n\n        emit ValidatorWithdraw(pubKeyHash, uint256(amountGwei) * 1 gwei);\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice Remove a sweeping validator from the SSV Cluster.\n    /// Make sure `exitSsvValidator` is called before and the validate has exited the Beacon chain.\n    /// If removed before the validator has exited the beacon chain will result in the validator being slashed.\n    /// Only the registrator can call this function.\n    /// @param publicKey The public key of the validator\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    // slither-disable-start reentrancy-no-eth\n    function removeSsvValidator(\n        bytes calldata publicKey,\n        uint64[] calldata operatorIds,\n        Cluster calldata cluster\n    ) external onlyRegistrator {\n        // Hash the public key using the Beacon Chain's format\n        bytes32 pubKeyHash = _hashPubKey(publicKey);\n        VALIDATOR_STATE currentState = validatorState[pubKeyHash];\n        // Can remove SSV validators that were incorrectly registered and can not be deposited to.\n        require(\n            currentState == VALIDATOR_STATE.EXITED ||\n                currentState == VALIDATOR_STATE.REGISTERED,\n            \"Validator not regd or exited\"\n        );\n\n        ISSVNetwork(SSV_NETWORK).removeValidator(\n            publicKey,\n            operatorIds,\n            cluster\n        );\n\n        validatorState[pubKeyHash] = VALIDATOR_STATE.REMOVED;\n\n        emit SSVValidatorRemoved(pubKeyHash, operatorIds);\n    }\n\n    /***************************************\n                SSV Management\n    ****************************************/\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// `depositSSV` has been removed as `deposit` on the SSVNetwork contract can be called directly\n    /// by the Strategist which is already holding SSV tokens.\n\n    /// @notice Withdraws excess SSV Tokens from the SSV Network contract which was used to pay the SSV Operators.\n    /// @dev A SSV cluster is defined by the SSVOwnerAddress and the set of operatorIds.\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param ssvAmount The amount of SSV tokens to be deposited to the SSV cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    function withdrawSSV(\n        uint64[] memory operatorIds,\n        uint256 ssvAmount,\n        Cluster memory cluster\n    ) external onlyGovernor {\n        ISSVNetwork(SSV_NETWORK).withdraw(operatorIds, ssvAmount, cluster);\n    }\n\n    /***************************************\n                Beacon Chain Proofs\n    ****************************************/\n\n    /// @notice Verifies a validator's index to its public key.\n    /// @param nextBlockTimestamp The timestamp of the execution layer block after the beacon chain slot\n    /// we are verifying.\n    /// The next one is needed as the Beacon Oracle returns the parent beacon block root for a block timestamp,\n    /// which is the beacon block root of the previous block.\n    /// @param validatorIndex The index of the validator on the beacon chain.\n    /// @param pubKeyHash The hash of the validator's public key using the Beacon Chain's format\n    /// @param validatorPubKeyProof The merkle proof for the validator public key to the beacon block root.\n    /// This is 53 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    /// BeaconBlock.state.validators[validatorIndex].pubkey\n    function verifyValidator(\n        uint64 nextBlockTimestamp,\n        uint64 validatorIndex,\n        bytes32 pubKeyHash,\n        bytes calldata validatorPubKeyProof\n    ) external {\n        require(\n            validatorState[pubKeyHash] == VALIDATOR_STATE.STAKED,\n            \"Validator not staked\"\n        );\n        // Get the beacon block root of the slot we are verifying the validator in.\n        // The parent beacon block root of the next block is the beacon block root of the slot we are verifying.\n        bytes32 blockRoot = BeaconRoots.parentBlockRoot(nextBlockTimestamp);\n\n        // Verify the validator index is for the validator with the given public key.\n        // Also verify the validator's withdrawal credential points to this strategy.\n        IBeaconProofs(BEACON_PROOFS).verifyValidatorPubkey(\n            blockRoot,\n            pubKeyHash,\n            validatorPubKeyProof,\n            validatorIndex,\n            address(this) // Withdrawal address is this strategy\n        );\n\n        // Store the validator state as verified\n        validatorState[pubKeyHash] = VALIDATOR_STATE.VERIFIED;\n\n        // Add the new validator to the list of verified validators\n        verifiedValidators.push(\n            ValidatorData({ pubKeyHash: pubKeyHash, index: validatorIndex })\n        );\n\n        emit ValidatorVerified(pubKeyHash, validatorIndex);\n    }\n\n    /// @notice Verifies a deposit on the execution layer has been processed by the beacon chain.\n    /// This means the accounting of the strategy's ETH moves from a pending deposit to a validator balance.\n    ///\n    /// Important: this function has a limitation where the `verificationSlot` that is passed by the off-chain\n    /// verifier requires a slot immediately after it to propose a block otherwise the `BeaconRoots.parentBlockRoot`\n    /// will fail. This shouldn't be a problem, since by the current behaviour of beacon chain only 1%-3% slots\n    /// don't propose a block.\n    /// @param depositDataRoot The root of the deposit data that was stored when\n    /// the deposit was made on the execution layer.\n    /// @param verificationSlot Any slot on or after the deposit was processed on the beacon chain.\n    /// Can not be a slot with pending deposits with the same slot as the deposit being verified.\n    /// Can not be a slot before a missed slot as the Beacon Root contract will have the parent block root\n    /// set for the next block timestamp in 12 seconds time.\n    /// @param firstPendingDepositSlot The slot of the first pending deposit in the beacon chain.\n    /// Can be anything if the deposit queue is empty, but zero is a good choice.\n    /// @param firstPendingDepositSlotProof The merkle proof to the beacon block root. Can be either:\n    /// - 40 witness hashes for BeaconBlock.state.PendingDeposits[0].slot when the deposit queue is not empty.\n    /// - 37 witness hashes for BeaconBlock.state.PendingDeposits[0] when the deposit queue is empty.\n    /// The 32 byte witness hashes are concatenated together starting from the leaf node.\n    // slither-disable-start reentrancy-no-eth\n    function verifyDeposit(\n        bytes32 depositDataRoot,\n        uint64 verificationSlot,\n        uint64 firstPendingDepositSlot,\n        bytes calldata firstPendingDepositSlotProof\n    ) external {\n        // Load into memory the previously saved deposit data\n        DepositData memory deposit = deposits[depositDataRoot];\n        require(deposit.status == DepositStatus.PENDING, \"Deposit not pending\");\n        require(\n            validatorState[deposit.pubKeyHash] == VALIDATOR_STATE.VERIFIED,\n            \"Validator not verified\"\n        );\n        // The verification slot must be after the deposit's slot.\n        // This is needed for when the deposit queue is empty.\n        require(deposit.slot < verificationSlot, \"Slot not after deposit\");\n\n        // Calculate the next block timestamp from the verification slot.\n        uint64 nextBlockTimestamp = 12 *\n            verificationSlot +\n            BEACON_GENESIS_TIMESTAMP +\n            // Add 12 seconds for the next block\n            12;\n        // Get the parent beacon block root of the next block which is the block root of the verification slot.\n        // This will revert if the slot after the verification slot was missed.\n        bytes32 blockRoot = BeaconRoots.parentBlockRoot(nextBlockTimestamp);\n\n        // Verify the slot of the first pending deposit matches the beacon chain\n        bool isDepositQueueEmpty = IBeaconProofs(BEACON_PROOFS)\n            .verifyFirstPendingDepositSlot(\n                blockRoot,\n                firstPendingDepositSlot,\n                firstPendingDepositSlotProof\n            );\n\n        // Check the deposit slot is before the first pending deposit's slot on the beacon chain.\n        // If this is not true then we can't guarantee the deposit has been processed by the beacon chain.\n        // The deposit's slot can not be the same slot as the first pending deposit as there could be\n        // many deposits in the same block, hence have the same pending deposit slot.\n        // If the deposit queue is empty then our deposit must have been processed on the beacon chain.\n        // The deposit slot can be zero for validators consolidating to a compounding validator. We can\n        // not guarantee that the deposit has been processed in that case.\n        require(\n            deposit.slot < firstPendingDepositSlot || isDepositQueueEmpty,\n            \"Deposit likely not processed\"\n        );\n\n        // After verifying the proof, update the contract storage\n        deposits[depositDataRoot].status = DepositStatus.VERIFIED;\n        // Move the last deposit to the index of the verified deposit\n        bytes32 lastDepositDataRoot = depositsRoots[depositsRoots.length - 1];\n        depositsRoots[deposit.depositIndex] = lastDepositDataRoot;\n        deposits[lastDepositDataRoot].depositIndex = deposit.depositIndex;\n        // Delete the last deposit from the list\n        depositsRoots.pop();\n\n        emit DepositVerified(\n            depositDataRoot,\n            uint256(deposit.amountGwei) * 1 gwei\n        );\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice Stores the current ETH balance at the current block and beacon block root\n    ///         of the slot that is associated with the previous block.\n    ///\n    /// When snapping / verifying balance it is of a high importance that there is no\n    /// miss-match in respect to ETH that is held by the contract and balances that are\n    /// verified on the validators.\n    ///\n    /// First some context on the beacon-chain block building behaviour. Relevant parts of\n    /// constructing a block on the beacon chain consist of:\n    ///  - process_withdrawals: ETH is deducted from the validator's balance\n    ///  - process_execution_payload: immediately after the previous step executing all the\n    ///    transactions\n    ///  - apply the withdrawals: adding ETH to the recipient which is the withdrawal address\n    ///    contained in the withdrawal credentials of the exited validators\n    ///\n    /// That means that balance increases which are part of the post-block execution state are\n    /// done within the block, but the transaction that are contained within that block can not\n    /// see / interact with the balance from the exited validators. Only transactions in the\n    /// next block can do that.\n    ///\n    /// When snap balances is performed the state of the chain is snapped across 2 separate\n    /// chain states:\n    ///  - ETH balance of the contract is recorded on block X -> and corresponding slot Y\n    ///  - beacon chain block root is recorded of block X - 1 -> and corresponding slot Y - 1\n    ///    given there were no missed slots. It could also be Y - 2, Y - 3 depending on how\n    ///    many slots have not managed to propose a block. For the sake of simplicity this slot\n    ///    will be referred to as Y - 1 as it makes no difference in the argument\n    ///\n    /// Given these 2 separate chain states it is paramount that verify balances can not experience\n    /// miss-counting ETH or much more dangerous double counting of the ETH.\n    ///\n    /// When verifyBalances is called it is performed on the current block Z where Z > X. Verify\n    /// balances adds up all the ETH (omitting WETH) controlled by this contract:\n    ///  - ETH balance in the contract on block X\n    ///  - ETH balance in Deposits on block Z that haven't been yet processed in slot Y - 1\n    ///  - ETH balance in validators that are active in slot Y - 1\n    ///  - skips the ETH balance in validators that have withdrawn in slot Y - 1 (or sooner)\n    ///    and have their balance visible to transactions in slot Y and corresponding block X\n    ///    (or sooner)\n    ///\n    /// Lets verify the correctness of ETH accounting given the above described behaviour.\n    ///\n    /// *ETH balance in the contract on block X*\n    ///\n    /// This is an ETH balance of the contract on a non current X block. Any ETH leaving the\n    /// contract as a result of a withdrawal subtracts from the ETH accounted for on block X\n    /// if `verifyBalances` has already been called. It also invalidates a `snapBalances` in\n    /// case `verifyBalances` has not been called yet. Not performing this would result in not\n    /// accounting for the withdrawn ETH that has happened anywhere in the block interval [X + 1, Z].\n    ///\n    /// Similarly to withdrawals any `stakeEth` deposits to the deposit contract adds to the ETH\n    /// accounted for since the last `verifyBalances` has been called. And it invalidates the\n    /// `snapBalances` in case `verifyBalances` hasn't been yet called. Not performing this\n    /// would result in double counting the `stakedEth` since it would be present once in the\n    /// snapped contract balance and the second time in deposit storage variables.\n    ///\n    /// This behaviour is correct.\n    ///\n    /// *ETH balance in Deposits on block Z that haven't been yet processed in slot Y - 1*\n    ///\n    /// The contract sums up all the ETH that has been deposited to the Beacon chain deposit\n    /// contract at block Z. The execution layer doesn't have direct access to the state of\n    /// deposits on the beacon chain. And if it is to sum up all the ETH that is marked to be\n    /// deposited it needs to be sure to not double count ETH that is in deposits (storage vars)\n    /// and could also be part of the validator balances. It does that by verifying that at\n    /// slot Y - 1 none of the deposits visible on block Z have been processed. Meaning since\n    /// the last snap till now all are still in queue. Which ensures they can not be part of\n    /// the validator balances in later steps.\n    ///\n    /// This behaviour is correct.\n    ///\n    /// *ETH balance in validators that are active in slot Y - 1*\n    ///\n    /// The contract is verifying none of the deposits on Y - 1 slot have been processed and\n    /// for that reason it checks the validator balances in the same slot. Ensuring accounting\n    /// correctness.\n    ///\n    /// This behaviour is correct.\n    ///\n    /// *The withdrawn validators*\n    ///\n    /// The withdrawn validators could have their balances deducted in any slot before slot\n    /// Y - 1 and the execution layer sees the balance increase in the subsequent slot. Lets\n    /// look at the \"worst case scenario\" where the validator withdrawal is processed in the\n    /// slot Y - 1 (snapped slot) and see their balance increase (in execution layer) in slot\n    /// Y -> block X. The ETH balance on the contract is snapped at block X meaning that\n    /// even if the validator exits at the latest possible time it is paramount that the ETH\n    /// balance on the execution layer is recorded in the next block. Correctly accounting\n    /// for the withdrawn ETH.\n    ///\n    /// Worth mentioning if the validator exit is processed by the slot Y and balance increase\n    /// seen on the execution layer on block X + 1 the withdrawal is ignored by both the\n    /// validator balance verification as well as execution layer contract balance snap.\n    ///\n    /// This behaviour is correct.\n    ///\n    /// The validator balances on the beacon chain can then be proved with `verifyBalances`.\n    /// Can only be called by the registrator.\n    function snapBalances() external onlyRegistrator {\n        _snapBalances();\n    }\n\n    function _snapBalances() internal {\n        bytes32 blockRoot = BeaconRoots.parentBlockRoot(\n            SafeCast.toUint64(block.timestamp)\n        );\n        // Get the current ETH balance\n        uint256 ethBalance = address(this).balance;\n\n        // Store the balances in the mapping\n        snappedBalances[blockRoot] = Balances({\n            timestamp: SafeCast.toUint64(block.timestamp),\n            ethBalance: SafeCast.toUint128(ethBalance)\n        });\n\n        // Store the snapped timestamp\n        lastSnapTimestamp = SafeCast.toUint64(block.timestamp);\n\n        emit BalancesSnapped(block.timestamp, blockRoot, ethBalance);\n    }\n\n    // A struct is used to avoid stack too deep errors\n    struct VerifyBalancesParams {\n        bytes32 blockRoot;\n        uint64 firstPendingDepositSlot;\n        // BeaconBlock.BeaconBlockBody.deposits[0].slot\n        bytes firstPendingDepositSlotProof;\n        // BeaconBlock.state.balances\n        bytes32 balancesContainerRoot;\n        bytes balancesContainerProof;\n        // BeaconBlock.state.balances[validatorIndex]\n        bytes32[] validatorBalanceLeaves;\n        bytes[] validatorBalanceProofs;\n    }\n\n    /// @notice Verifies the balances of all active validators on the beacon chain\n    /// and checks no pending deposits have been processed by the beacon chain.\n    /// @param params a `VerifyBalancesParams` struct containing the following:\n    /// blockRoot - the beacon block root emitted from `snapBalance` in `BalancesSnapped`\n    /// firstPendingDepositSlot - The beacon chain slot of the first deposit in the beacon chain's deposit queue.\n    ///   Can be anything if the deposit queue is empty, but zero would be a good choice.\n    /// firstPendingDepositSlotProof - The merkle proof to the beacon block root. Can be either:\n    ///   - 40 witness hashes for BeaconBlock.state.PendingDeposits[0].slot when the deposit queue is not empty.\n    ///   - 37 witness hashes for BeaconBlock.state.PendingDeposits[0] when the deposit queue is empty.\n    ///   The 32 byte witness hashes are concatenated together starting from the leaf node.\n    /// balancesContainerRoot - the merkle root of the balances container\n    /// balancesContainerProof - The merkle proof for the balances container to the beacon block root.\n    ///   This is 9 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    /// validatorBalanceLeaves - Array of leaf nodes containing the validator balance with three other balances.\n    /// validatorBalanceProofs -  Array of merkle proofs for the validator balance to the Balances container root.\n    ///   This is 39 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    // slither-disable-start reentrancy-no-eth\n    function verifyBalances(VerifyBalancesParams calldata params) external {\n        // Load previously snapped balances for the given block root\n        Balances memory balancesMem = snappedBalances[params.blockRoot];\n        // Check the balances are the latest\n        require(lastSnapTimestamp > 0, \"No snapped balances\");\n        require(balancesMem.timestamp == lastSnapTimestamp, \"Stale snap\");\n\n        uint256 depositsCount = depositsRoots.length;\n        uint256 totalDepositsWei = 0;\n\n        // If there are no deposits then we can skip the deposit verification\n        if (depositsCount > 0) {\n            // Verify the slot of the first pending deposit to the beacon block root\n            bool isEmptyDepositQueue = IBeaconProofs(BEACON_PROOFS)\n                .verifyFirstPendingDepositSlot(\n                    params.blockRoot,\n                    params.firstPendingDepositSlot,\n                    params.firstPendingDepositSlotProof\n                );\n\n            // If there are no deposits in the beacon chain queue then our deposits must have been processed.\n            // If the deposits have been processed, each deposit will need to be verified with `verifyDeposit`\n            require(!isEmptyDepositQueue, \"Deposits have been processed\");\n            // If a validator is converted from a sweeping validator to a compounding validator, any balance in excess\n            // of the min 32 ETH is put in the pending deposit queue. This will have a slot value of zero unfortunately.\n            // We can not prove the strategy's deposits are still pending with a zero slot value so revert the verification.\n            // Another snapBalances will need to be taken that does not have consolidation deposits at the front of the\n            // beacon chain deposit queue.\n            require(\n                params.firstPendingDepositSlot > 0,\n                \"Invalid first pending deposit\"\n            );\n\n            // For each staking strategy's deposits\n            for (uint256 i = 0; i < depositsCount; ++i) {\n                bytes32 depositDataRoot = depositsRoots[i];\n\n                // Check the stored deposit is still waiting to be processed on the beacon chain.\n                // That is, the first pending deposit slot is before the\n                // slot of the staking strategy's deposit.\n                // If the deposit has been processed, it will need to be verified with `verifyDeposit`\n                require(\n                    params.firstPendingDepositSlot <\n                        deposits[depositDataRoot].slot,\n                    \"Deposit has been processed\"\n                );\n\n                // Convert the deposit amount from Gwei to Wei and add to the total\n                totalDepositsWei +=\n                    uint256(deposits[depositDataRoot].amountGwei) *\n                    1 gwei;\n            }\n        }\n\n        uint256 verifiedValidatorsCount = verifiedValidators.length;\n        uint256 totalValidatorBalance = 0;\n\n        // If there are no verified validators then we can skip the balance verification\n        if (verifiedValidatorsCount > 0) {\n            require(\n                params.validatorBalanceProofs.length == verifiedValidatorsCount,\n                \"Invalid balance proofs\"\n            );\n            require(\n                params.validatorBalanceLeaves.length == verifiedValidatorsCount,\n                \"Invalid balance leaves\"\n            );\n            // verify beaconBlock.state.balances root to beacon block root\n            IBeaconProofs(BEACON_PROOFS).verifyBalancesContainer(\n                params.blockRoot,\n                params.balancesContainerRoot,\n                params.balancesContainerProof\n            );\n\n            // for each validator in reserve order so we can pop off exited validators at the end\n            for (uint256 i = verifiedValidatorsCount; i > 0; ) {\n                --i;\n                // verify validator's balance in beaconBlock.state.balances to the\n                // beaconBlock.state.balances container root\n                uint256 validatorBalanceGwei = IBeaconProofs(BEACON_PROOFS)\n                    .verifyValidatorBalance(\n                        params.balancesContainerRoot,\n                        params.validatorBalanceLeaves[i],\n                        params.validatorBalanceProofs[i],\n                        verifiedValidators[i].index\n                    );\n\n                // If the validator balance is zero\n                if (validatorBalanceGwei == 0) {\n                    // Store the validator state as exited\n                    validatorState[\n                        verifiedValidators[i].pubKeyHash\n                    ] = VALIDATOR_STATE.EXITED;\n\n                    // Remove the validator with a zero balance from the list of verified validators\n\n                    // Reduce the count of verified validators which is the last index before the pop removes it.\n                    verifiedValidatorsCount -= 1;\n\n                    // Move the last validator that has already been verified to the current index.\n                    // There's an extra SSTORE if i is the last active validator but that's fine,\n                    // It's not a common case and the code is simpler this way.\n                    verifiedValidators[i] = verifiedValidators[\n                        verifiedValidatorsCount\n                    ];\n                    // Delete the last validator from the list\n                    verifiedValidators.pop();\n\n                    // The validator balance is zero so not need to add to totalValidatorBalance\n                    continue;\n                }\n\n                // convert Gwei balance to Wei and add to the total validator balance\n                totalValidatorBalance += uint256(validatorBalanceGwei) * 1 gwei;\n            }\n        }\n\n        uint256 wethBalance = IWETH9(WETH).balanceOf(address(this));\n\n        // Store the verified balance in storage\n        lastVerifiedEthBalance = SafeCast.toUint128(\n            totalDepositsWei + totalValidatorBalance + balancesMem.ethBalance\n        );\n        // Reset the last snap timestamp so a new snapBalances has to be made\n        lastSnapTimestamp = 0;\n\n        emit BalancesVerified(\n            balancesMem.timestamp,\n            totalDepositsWei,\n            totalValidatorBalance,\n            wethBalance,\n            balancesMem.ethBalance\n        );\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice Hash a validator public key using the Beacon Chain's format\n    function _hashPubKey(bytes memory pubKey) internal pure returns (bytes32) {\n        return sha256(abi.encodePacked(pubKey, bytes16(0)));\n    }\n\n    /***************************************\n            WETH and ETH Accounting\n    ****************************************/\n\n    /// @dev Called when WETH is transferred out of the strategy so\n    /// the strategy knows how much WETH it has on deposit.\n    /// This is so it can emit the correct amount in the Deposit event in depositAll().\n    function _transferWeth(uint256 _amount, address _recipient) internal {\n        IERC20(WETH).safeTransfer(_recipient, _amount);\n\n        uint256 deductAmount = Math.min(_amount, depositedWethAccountedFor);\n        depositedWethAccountedFor -= deductAmount;\n\n        // No change in ETH balance so no need to snapshot the balances\n    }\n\n    /// @dev Converts ETH to WETH and updates the accounting.\n    /// @param _ethAmount The amount of ETH in wei.\n    function _convertEthToWeth(uint256 _ethAmount) internal {\n        // slither-disable-next-line arbitrary-send-eth\n        IWETH9(WETH).deposit{ value: _ethAmount }();\n\n        depositedWethAccountedFor += _ethAmount;\n\n        // Store the reduced ETH balance\n        if (lastVerifiedEthBalance > _ethAmount) {\n            lastVerifiedEthBalance -= SafeCast.toUint128(_ethAmount);\n        } else {\n            // This can happen if all ETH in the validators was withdrawn\n            // and there was more consensus rewards since the last balance verification.\n            // Or it can happen if ETH is donated to this strategy.\n            lastVerifiedEthBalance = 0;\n        }\n\n        // The ETH balance was increased from WETH so we need to invalidate the last balances snap.\n        lastSnapTimestamp = 0;\n    }\n\n    /// @dev Converts WETH to ETH and updates the accounting.\n    /// @param _wethAmount The amount of WETH in wei.\n    function _convertWethToEth(uint256 _wethAmount) internal {\n        IWETH9(WETH).withdraw(_wethAmount);\n\n        uint256 deductAmount = Math.min(_wethAmount, depositedWethAccountedFor);\n        depositedWethAccountedFor -= deductAmount;\n\n        // Store the increased ETH balance\n        lastVerifiedEthBalance += SafeCast.toUint128(_wethAmount);\n\n        // The ETH balance was decreased to WETH so we need to invalidate the last balances snap.\n        lastSnapTimestamp = 0;\n    }\n\n    /***************************************\n                View Functions\n    ****************************************/\n\n    /// @notice Returns the strategy's active validators.\n    /// These are the ones that have been verified and have a non-zero balance.\n    /// @return An array of `ValidatorData` containing the public key hash and validator index.\n    function getVerifiedValidators()\n        external\n        view\n        returns (ValidatorData[] memory)\n    {\n        return verifiedValidators;\n    }\n\n    struct DepositView {\n        bytes32 root;\n        bytes32 pubKeyHash;\n        uint64 amountGwei;\n        uint64 slot;\n    }\n\n    /// @notice Returns the deposits that are still to be verified.\n    /// These may or may not have been processed by the beacon chain.\n    /// @return pendingDeposits An array of `DepositView` containing the deposit root, public key hash,\n    /// amount in Gwei and the slot of the deposit.\n    function getPendingDeposits()\n        external\n        view\n        returns (DepositView[] memory pendingDeposits)\n    {\n        pendingDeposits = new DepositView[](depositsRoots.length);\n        for (uint256 i = 0; i < depositsRoots.length; ++i) {\n            DepositData memory deposit = deposits[depositsRoots[i]];\n            pendingDeposits[i] = DepositView({\n                root: depositsRoots[i],\n                pubKeyHash: deposit.pubKeyHash,\n                amountGwei: deposit.amountGwei,\n                slot: deposit.slot\n            });\n        }\n    }\n}\n"
    },
    "contracts/token/OUSD.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD Token Contract\n * @dev ERC20 compatible contract for OUSD\n * @dev Implements an elastic supply\n * @author Origin Protocol Inc\n */\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\ncontract OUSD is Governable {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n\n    /// @dev Event triggered when the supply changes\n    /// @param totalSupply Updated token total supply\n    /// @param rebasingCredits Updated token rebasing credits\n    /// @param rebasingCreditsPerToken Updated token rebasing credits per token\n    event TotalSupplyUpdatedHighres(\n        uint256 totalSupply,\n        uint256 rebasingCredits,\n        uint256 rebasingCreditsPerToken\n    );\n    /// @dev Event triggered when an account opts in for rebasing\n    /// @param account Address of the account\n    event AccountRebasingEnabled(address account);\n    /// @dev Event triggered when an account opts out of rebasing\n    /// @param account Address of the account\n    event AccountRebasingDisabled(address account);\n    /// @dev Emitted when `value` tokens are moved from one account `from` to\n    ///      another `to`.\n    /// @param from Address of the account tokens are moved from\n    /// @param to Address of the account tokens are moved to\n    /// @param value Amount of tokens transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set by\n    ///      a call to {approve}. `value` is the new allowance.\n    /// @param owner Address of the owner approving allowance\n    /// @param spender Address of the spender allowance is granted to\n    /// @param value Amount of tokens spender can transfer\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    /// @dev Yield resulting from {changeSupply} that a `source` account would\n    ///      receive is directed to `target` account.\n    /// @param source Address of the source forwarding the yield\n    /// @param target Address of the target receiving the yield\n    event YieldDelegated(address source, address target);\n    /// @dev Yield delegation from `source` account to the `target` account is\n    ///      suspended.\n    /// @param source Address of the source suspending yield forwarding\n    /// @param target Address of the target no longer receiving yield from `source`\n    ///        account\n    event YieldUndelegated(address source, address target);\n\n    enum RebaseOptions {\n        NotSet,\n        StdNonRebasing,\n        StdRebasing,\n        YieldDelegationSource,\n        YieldDelegationTarget\n    }\n\n    uint256[154] private _gap; // Slots to align with deployed contract\n    uint256 private constant MAX_SUPPLY = type(uint128).max;\n    /// @dev The amount of tokens in existence\n    uint256 public totalSupply;\n    mapping(address => mapping(address => uint256)) private allowances;\n    /// @dev The vault with privileges to execute {mint}, {burn}\n    ///     and {changeSupply}\n    address public vaultAddress;\n    mapping(address => uint256) internal creditBalances;\n    // the 2 storage variables below need trailing underscores to not name collide with public functions\n    uint256 private rebasingCredits_; // Sum of all rebasing credits (creditBalances for rebasing accounts)\n    uint256 private rebasingCreditsPerToken_;\n    /// @dev The amount of tokens that are not rebasing - receiving yield\n    uint256 public nonRebasingSupply;\n    mapping(address => uint256) internal alternativeCreditsPerToken;\n    /// @dev A map of all addresses and their respective RebaseOptions\n    mapping(address => RebaseOptions) public rebaseState;\n    mapping(address => uint256) private __deprecated_isUpgraded;\n    /// @dev A map of addresses that have yields forwarded to. This is an\n    ///      inverse mapping of {yieldFrom}\n    /// Key Account forwarding yield\n    /// Value Account receiving yield\n    mapping(address => address) public yieldTo;\n    /// @dev A map of addresses that are receiving the yield. This is an\n    ///      inverse mapping of {yieldTo}\n    /// Key Account receiving yield\n    /// Value Account forwarding yield\n    mapping(address => address) public yieldFrom;\n\n    uint256 private constant RESOLUTION_INCREASE = 1e9;\n    uint256[34] private __gap; // including below gap totals up to 200\n\n    /// @dev Verifies that the caller is the Governor or Strategist.\n    modifier onlyGovernorOrStrategist() {\n        require(\n            isGovernor() || msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    /// @dev Initializes the contract and sets necessary variables.\n    /// @param _vaultAddress Address of the vault contract\n    /// @param _initialCreditsPerToken The starting rebasing credits per token.\n    function initialize(address _vaultAddress, uint256 _initialCreditsPerToken)\n        external\n        onlyGovernor\n    {\n        require(_vaultAddress != address(0), \"Zero vault address\");\n        require(vaultAddress == address(0), \"Already initialized\");\n\n        rebasingCreditsPerToken_ = _initialCreditsPerToken;\n        vaultAddress = _vaultAddress;\n    }\n\n    /// @dev Returns the symbol of the token, a shorter version\n    ///      of the name.\n    function symbol() external pure virtual returns (string memory) {\n        return \"OUSD\";\n    }\n\n    /// @dev Returns the name of the token.\n    function name() external pure virtual returns (string memory) {\n        return \"Origin Dollar\";\n    }\n\n    /// @dev Returns the number of decimals used to get its user representation.\n    function decimals() external pure virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault contract\n     */\n    modifier onlyVault() {\n        require(vaultAddress == msg.sender, \"Caller is not the Vault\");\n        _;\n    }\n\n    /**\n     * @return High resolution rebasingCreditsPerToken\n     */\n    function rebasingCreditsPerTokenHighres() external view returns (uint256) {\n        return rebasingCreditsPerToken_;\n    }\n\n    /**\n     * @return Low resolution rebasingCreditsPerToken\n     */\n    function rebasingCreditsPerToken() external view returns (uint256) {\n        return rebasingCreditsPerToken_ / RESOLUTION_INCREASE;\n    }\n\n    /**\n     * @return High resolution total number of rebasing credits\n     */\n    function rebasingCreditsHighres() external view returns (uint256) {\n        return rebasingCredits_;\n    }\n\n    /**\n     * @return Low resolution total number of rebasing credits\n     */\n    function rebasingCredits() external view returns (uint256) {\n        return rebasingCredits_ / RESOLUTION_INCREASE;\n    }\n\n    /**\n     * @notice Gets the balance of the specified address.\n     * @param _account Address to query the balance of.\n     * @return A uint256 representing the amount of base units owned by the\n     *         specified address.\n     */\n    function balanceOf(address _account) public view returns (uint256) {\n        RebaseOptions state = rebaseState[_account];\n        if (state == RebaseOptions.YieldDelegationSource) {\n            // Saves a slot read when transferring to or from a yield delegating source\n            // since we know creditBalances equals the balance.\n            return creditBalances[_account];\n        }\n        uint256 baseBalance = (creditBalances[_account] * 1e18) /\n            _creditsPerToken(_account);\n        if (state == RebaseOptions.YieldDelegationTarget) {\n            // creditBalances of yieldFrom accounts equals token balances\n            return baseBalance - creditBalances[yieldFrom[_account]];\n        }\n        return baseBalance;\n    }\n\n    /**\n     * @notice Gets the credits balance of the specified address.\n     * @dev Backwards compatible with old low res credits per token.\n     * @param _account The address to query the balance of.\n     * @return (uint256, uint256) Credit balance and credits per token of the\n     *         address\n     */\n    function creditsBalanceOf(address _account)\n        external\n        view\n        returns (uint256, uint256)\n    {\n        uint256 cpt = _creditsPerToken(_account);\n        if (cpt == 1e27) {\n            // For a period before the resolution upgrade, we created all new\n            // contract accounts at high resolution. Since they are not changing\n            // as a result of this upgrade, we will return their true values\n            return (creditBalances[_account], cpt);\n        } else {\n            return (\n                creditBalances[_account] / RESOLUTION_INCREASE,\n                cpt / RESOLUTION_INCREASE\n            );\n        }\n    }\n\n    /**\n     * @notice Gets the credits balance of the specified address.\n     * @param _account The address to query the balance of.\n     * @return (uint256, uint256, bool) Credit balance, credits per token of the\n     *         address, and isUpgraded\n     */\n    function creditsBalanceOfHighres(address _account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        return (\n            creditBalances[_account],\n            _creditsPerToken(_account),\n            true // all accounts have their resolution \"upgraded\"\n        );\n    }\n\n    // Backwards compatible view\n    function nonRebasingCreditsPerToken(address _account)\n        external\n        view\n        returns (uint256)\n    {\n        return alternativeCreditsPerToken[_account];\n    }\n\n    /**\n     * @notice Transfer tokens to a specified address.\n     * @param _to the address to transfer to.\n     * @param _value the amount to be transferred.\n     * @return true on success.\n     */\n    function transfer(address _to, uint256 _value) external returns (bool) {\n        require(_to != address(0), \"Transfer to zero address\");\n\n        _executeTransfer(msg.sender, _to, _value);\n\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n     * @notice Transfer tokens from one address to another.\n     * @param _from The address you want to send tokens from.\n     * @param _to The address you want to transfer to.\n     * @param _value The amount of tokens to be transferred.\n     * @return true on success.\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool) {\n        require(_to != address(0), \"Transfer to zero address\");\n        uint256 userAllowance = allowances[_from][msg.sender];\n        require(_value <= userAllowance, \"Allowance exceeded\");\n\n        unchecked {\n            allowances[_from][msg.sender] = userAllowance - _value;\n        }\n\n        _executeTransfer(_from, _to, _value);\n\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function _executeTransfer(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal {\n        (\n            int256 fromRebasingCreditsDiff,\n            int256 fromNonRebasingSupplyDiff\n        ) = _adjustAccount(_from, -_value.toInt256());\n        (\n            int256 toRebasingCreditsDiff,\n            int256 toNonRebasingSupplyDiff\n        ) = _adjustAccount(_to, _value.toInt256());\n\n        _adjustGlobals(\n            fromRebasingCreditsDiff + toRebasingCreditsDiff,\n            fromNonRebasingSupplyDiff + toNonRebasingSupplyDiff\n        );\n    }\n\n    function _adjustAccount(address _account, int256 _balanceChange)\n        internal\n        returns (int256 rebasingCreditsDiff, int256 nonRebasingSupplyDiff)\n    {\n        RebaseOptions state = rebaseState[_account];\n        int256 currentBalance = balanceOf(_account).toInt256();\n        if (currentBalance + _balanceChange < 0) {\n            revert(\"Transfer amount exceeds balance\");\n        }\n        uint256 newBalance = (currentBalance + _balanceChange).toUint256();\n\n        if (state == RebaseOptions.YieldDelegationSource) {\n            address target = yieldTo[_account];\n            uint256 targetOldBalance = balanceOf(target);\n            uint256 targetNewCredits = _balanceToRebasingCredits(\n                targetOldBalance + newBalance\n            );\n            rebasingCreditsDiff =\n                targetNewCredits.toInt256() -\n                creditBalances[target].toInt256();\n\n            creditBalances[_account] = newBalance;\n            creditBalances[target] = targetNewCredits;\n        } else if (state == RebaseOptions.YieldDelegationTarget) {\n            uint256 newCredits = _balanceToRebasingCredits(\n                newBalance + creditBalances[yieldFrom[_account]]\n            );\n            rebasingCreditsDiff =\n                newCredits.toInt256() -\n                creditBalances[_account].toInt256();\n            creditBalances[_account] = newCredits;\n        } else {\n            _autoMigrate(_account);\n            uint256 alternativeCreditsPerTokenMem = alternativeCreditsPerToken[\n                _account\n            ];\n            if (alternativeCreditsPerTokenMem > 0) {\n                nonRebasingSupplyDiff = _balanceChange;\n                if (alternativeCreditsPerTokenMem != 1e18) {\n                    alternativeCreditsPerToken[_account] = 1e18;\n                }\n                creditBalances[_account] = newBalance;\n            } else {\n                uint256 newCredits = _balanceToRebasingCredits(newBalance);\n                rebasingCreditsDiff =\n                    newCredits.toInt256() -\n                    creditBalances[_account].toInt256();\n                creditBalances[_account] = newCredits;\n            }\n        }\n    }\n\n    function _adjustGlobals(\n        int256 _rebasingCreditsDiff,\n        int256 _nonRebasingSupplyDiff\n    ) internal {\n        if (_rebasingCreditsDiff != 0) {\n            rebasingCredits_ = (rebasingCredits_.toInt256() +\n                _rebasingCreditsDiff).toUint256();\n        }\n        if (_nonRebasingSupplyDiff != 0) {\n            nonRebasingSupply = (nonRebasingSupply.toInt256() +\n                _nonRebasingSupplyDiff).toUint256();\n        }\n    }\n\n    /**\n     * @notice Function to check the amount of tokens that _owner has allowed\n     *      to `_spender`.\n     * @param _owner The address which owns the funds.\n     * @param _spender The address which will spend the funds.\n     * @return The number of tokens still available for the _spender.\n     */\n    function allowance(address _owner, address _spender)\n        external\n        view\n        returns (uint256)\n    {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Approve the passed address to spend the specified amount of\n     *      tokens on behalf of msg.sender.\n     * @param _spender The address which will spend the funds.\n     * @param _value The amount of tokens to be spent.\n     * @return true on success.\n     */\n    function approve(address _spender, uint256 _value) external returns (bool) {\n        allowances[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * @notice Creates `_amount` tokens and assigns them to `_account`,\n     *     increasing the total supply.\n     */\n    function mint(address _account, uint256 _amount) external onlyVault {\n        require(_account != address(0), \"Mint to the zero address\");\n\n        // Account\n        (\n            int256 toRebasingCreditsDiff,\n            int256 toNonRebasingSupplyDiff\n        ) = _adjustAccount(_account, _amount.toInt256());\n        // Globals\n        _adjustGlobals(toRebasingCreditsDiff, toNonRebasingSupplyDiff);\n        totalSupply = totalSupply + _amount;\n\n        require(totalSupply < MAX_SUPPLY, \"Max supply\");\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    /**\n     * @notice Destroys `_amount` tokens from `_account`,\n     *     reducing the total supply.\n     */\n    function burn(address _account, uint256 _amount) external onlyVault {\n        require(_account != address(0), \"Burn from the zero address\");\n        if (_amount == 0) {\n            return;\n        }\n\n        // Account\n        (\n            int256 toRebasingCreditsDiff,\n            int256 toNonRebasingSupplyDiff\n        ) = _adjustAccount(_account, -_amount.toInt256());\n        // Globals\n        _adjustGlobals(toRebasingCreditsDiff, toNonRebasingSupplyDiff);\n        totalSupply = totalSupply - _amount;\n\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    /**\n     * @dev Get the credits per token for an account. Returns a fixed amount\n     *      if the account is non-rebasing.\n     * @param _account Address of the account.\n     */\n    function _creditsPerToken(address _account)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 alternativeCreditsPerTokenMem = alternativeCreditsPerToken[\n            _account\n        ];\n        if (alternativeCreditsPerTokenMem != 0) {\n            return alternativeCreditsPerTokenMem;\n        } else {\n            return rebasingCreditsPerToken_;\n        }\n    }\n\n    /**\n     * @dev Auto migrate contracts to be non rebasing,\n     *     unless they have opted into yield.\n     * @param _account Address of the account.\n     */\n    function _autoMigrate(address _account) internal {\n        uint256 codeLen = _account.code.length;\n        bool isEOA = (codeLen == 0) ||\n            (codeLen == 23 && bytes3(_account.code) == 0xef0100);\n        // In previous code versions, contracts would not have had their\n        // rebaseState[_account] set to RebaseOptions.NonRebasing when migrated\n        // therefore we check the actual accounting used on the account as well.\n        if (\n            (!isEOA) &&\n            rebaseState[_account] == RebaseOptions.NotSet &&\n            alternativeCreditsPerToken[_account] == 0\n        ) {\n            _rebaseOptOut(_account);\n        }\n    }\n\n    /**\n     * @dev Calculates credits from contract's global rebasingCreditsPerToken_, and\n     *      also balance that corresponds to those credits. The latter is important\n     *      when adjusting the contract's global nonRebasingSupply to circumvent any\n     *      possible rounding errors.\n     *\n     * @param _balance Balance of the account.\n     */\n    function _balanceToRebasingCredits(uint256 _balance)\n        internal\n        view\n        returns (uint256 rebasingCredits)\n    {\n        // Rounds up, because we need to ensure that accounts always have\n        // at least the balance that they should have.\n        // Note this should always be used on an absolute account value,\n        // not on a possibly negative diff, because then the rounding would be wrong.\n        return ((_balance) * rebasingCreditsPerToken_ + 1e18 - 1) / 1e18;\n    }\n\n    /**\n     * @notice The calling account will start receiving yield after a successful call.\n     * @param _account Address of the account.\n     */\n    function governanceRebaseOptIn(address _account) external onlyGovernor {\n        require(_account != address(0), \"Zero address not allowed\");\n        _rebaseOptIn(_account);\n    }\n\n    /**\n     * @notice The calling account will start receiving yield after a successful call.\n     */\n    function rebaseOptIn() external {\n        _rebaseOptIn(msg.sender);\n    }\n\n    function _rebaseOptIn(address _account) internal {\n        uint256 balance = balanceOf(_account);\n\n        // prettier-ignore\n        require(\n            alternativeCreditsPerToken[_account] > 0 ||\n                // Accounts may explicitly `rebaseOptIn` regardless of\n                // accounting if they have a 0 balance.\n                creditBalances[_account] == 0\n            ,\n            \"Account must be non-rebasing\"\n        );\n        RebaseOptions state = rebaseState[_account];\n        // prettier-ignore\n        require(\n            state == RebaseOptions.StdNonRebasing ||\n                state == RebaseOptions.NotSet,\n            \"Only standard non-rebasing accounts can opt in\"\n        );\n\n        uint256 newCredits = _balanceToRebasingCredits(balance);\n\n        // Account\n        rebaseState[_account] = RebaseOptions.StdRebasing;\n        alternativeCreditsPerToken[_account] = 0;\n        creditBalances[_account] = newCredits;\n        // Globals\n        _adjustGlobals(newCredits.toInt256(), -balance.toInt256());\n\n        emit AccountRebasingEnabled(_account);\n    }\n\n    /**\n     * @notice The calling account will no longer receive yield\n     */\n    function rebaseOptOut() external {\n        _rebaseOptOut(msg.sender);\n    }\n\n    function _rebaseOptOut(address _account) internal {\n        require(\n            alternativeCreditsPerToken[_account] == 0,\n            \"Account must be rebasing\"\n        );\n        RebaseOptions state = rebaseState[_account];\n        require(\n            state == RebaseOptions.StdRebasing || state == RebaseOptions.NotSet,\n            \"Only standard rebasing accounts can opt out\"\n        );\n\n        uint256 oldCredits = creditBalances[_account];\n        uint256 balance = balanceOf(_account);\n\n        // Account\n        rebaseState[_account] = RebaseOptions.StdNonRebasing;\n        alternativeCreditsPerToken[_account] = 1e18;\n        creditBalances[_account] = balance;\n        // Globals\n        _adjustGlobals(-oldCredits.toInt256(), balance.toInt256());\n\n        emit AccountRebasingDisabled(_account);\n    }\n\n    /**\n     * @notice Distribute yield to users. This changes the exchange rate\n     *  between \"credits\" and OUSD tokens to change rebasing user's balances.\n     * @param _newTotalSupply New total supply of OUSD.\n     */\n    function changeSupply(uint256 _newTotalSupply) external onlyVault {\n        require(totalSupply > 0, \"Cannot increase 0 supply\");\n\n        if (totalSupply == _newTotalSupply) {\n            emit TotalSupplyUpdatedHighres(\n                totalSupply,\n                rebasingCredits_,\n                rebasingCreditsPerToken_\n            );\n            return;\n        }\n\n        totalSupply = _newTotalSupply > MAX_SUPPLY\n            ? MAX_SUPPLY\n            : _newTotalSupply;\n\n        uint256 rebasingSupply = totalSupply - nonRebasingSupply;\n        // round up in the favour of the protocol\n        rebasingCreditsPerToken_ =\n            (rebasingCredits_ * 1e18 + rebasingSupply - 1) /\n            rebasingSupply;\n\n        require(rebasingCreditsPerToken_ > 0, \"Invalid change in supply\");\n\n        emit TotalSupplyUpdatedHighres(\n            totalSupply,\n            rebasingCredits_,\n            rebasingCreditsPerToken_\n        );\n    }\n\n    /*\n     * @notice Send the yield from one account to another account.\n     *         Each account keeps its own balances.\n     */\n    function delegateYield(address _from, address _to)\n        external\n        onlyGovernorOrStrategist\n    {\n        require(_from != address(0), \"Zero from address not allowed\");\n        require(_to != address(0), \"Zero to address not allowed\");\n\n        require(_from != _to, \"Cannot delegate to self\");\n        require(\n            yieldFrom[_to] == address(0) &&\n                yieldTo[_to] == address(0) &&\n                yieldFrom[_from] == address(0) &&\n                yieldTo[_from] == address(0),\n            \"Blocked by existing yield delegation\"\n        );\n        RebaseOptions stateFrom = rebaseState[_from];\n        RebaseOptions stateTo = rebaseState[_to];\n\n        require(\n            stateFrom == RebaseOptions.NotSet ||\n                stateFrom == RebaseOptions.StdNonRebasing ||\n                stateFrom == RebaseOptions.StdRebasing,\n            \"Invalid rebaseState from\"\n        );\n\n        require(\n            stateTo == RebaseOptions.NotSet ||\n                stateTo == RebaseOptions.StdNonRebasing ||\n                stateTo == RebaseOptions.StdRebasing,\n            \"Invalid rebaseState to\"\n        );\n\n        if (alternativeCreditsPerToken[_from] == 0) {\n            _rebaseOptOut(_from);\n        }\n        if (alternativeCreditsPerToken[_to] > 0) {\n            _rebaseOptIn(_to);\n        }\n\n        uint256 fromBalance = balanceOf(_from);\n        uint256 toBalance = balanceOf(_to);\n        uint256 oldToCredits = creditBalances[_to];\n        uint256 newToCredits = _balanceToRebasingCredits(\n            fromBalance + toBalance\n        );\n\n        // Set up the bidirectional links\n        yieldTo[_from] = _to;\n        yieldFrom[_to] = _from;\n\n        // Local\n        rebaseState[_from] = RebaseOptions.YieldDelegationSource;\n        alternativeCreditsPerToken[_from] = 1e18;\n        creditBalances[_from] = fromBalance;\n        rebaseState[_to] = RebaseOptions.YieldDelegationTarget;\n        creditBalances[_to] = newToCredits;\n\n        // Global\n        int256 creditsChange = newToCredits.toInt256() -\n            oldToCredits.toInt256();\n        _adjustGlobals(creditsChange, -(fromBalance).toInt256());\n        emit YieldDelegated(_from, _to);\n    }\n\n    /*\n     * @notice Stop sending the yield from one account to another account.\n     */\n    function undelegateYield(address _from) external onlyGovernorOrStrategist {\n        // Require a delegation, which will also ensure a valid delegation\n        require(yieldTo[_from] != address(0), \"Zero address not allowed\");\n\n        address to = yieldTo[_from];\n        uint256 fromBalance = balanceOf(_from);\n        uint256 toBalance = balanceOf(to);\n        uint256 oldToCredits = creditBalances[to];\n        uint256 newToCredits = _balanceToRebasingCredits(toBalance);\n\n        // Remove the bidirectional links\n        yieldFrom[to] = address(0);\n        yieldTo[_from] = address(0);\n\n        // Local\n        rebaseState[_from] = RebaseOptions.StdNonRebasing;\n        // alternativeCreditsPerToken[from] already 1e18 from `delegateYield()`\n        creditBalances[_from] = fromBalance;\n        rebaseState[to] = RebaseOptions.StdRebasing;\n        // alternativeCreditsPerToken[to] already 0 from `delegateYield()`\n        creditBalances[to] = newToCredits;\n\n        // Global\n        int256 creditsChange = newToCredits.toInt256() -\n            oldToCredits.toInt256();\n        _adjustGlobals(creditsChange, fromBalance.toInt256());\n        emit YieldUndelegated(_from, to);\n    }\n}\n"
    },
    "contracts/utils/Helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IBasicToken } from \"../interfaces/IBasicToken.sol\";\n\nlibrary Helpers {\n    /**\n     * @notice Fetch the `symbol()` from an ERC20 token\n     * @dev Grabs the `symbol()` from a contract\n     * @param _token Address of the ERC20 token\n     * @return string Symbol of the ERC20 token\n     */\n    function getSymbol(address _token) internal view returns (string memory) {\n        string memory symbol = IBasicToken(_token).symbol();\n        return symbol;\n    }\n\n    /**\n     * @notice Fetch the `decimals()` from an ERC20 token\n     * @dev Grabs the `decimals()` from a contract and fails if\n     *      the decimal value does not live within a certain range\n     * @param _token Address of the ERC20 token\n     * @return uint256 Decimals of the ERC20 token\n     */\n    function getDecimals(address _token) internal view returns (uint256) {\n        uint256 decimals = IBasicToken(_token).decimals();\n        require(\n            decimals >= 4 && decimals <= 18,\n            \"Token must have sufficient decimal places\"\n        );\n\n        return decimals;\n    }\n}\n"
    },
    "contracts/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Base contract any contracts that need to initialize state after deployment.\n * @author Origin Protocol Inc\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(\n            initializing || !initialized,\n            \"Initializable: contract is already initialized\"\n        );\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/utils/InitializableAbstractStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Base contract for vault strategies.\n * @author Origin Protocol Inc\n */\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\nabstract contract InitializableAbstractStrategy is Initializable, Governable {\n    using SafeERC20 for IERC20;\n\n    event PTokenAdded(address indexed _asset, address _pToken);\n    event PTokenRemoved(address indexed _asset, address _pToken);\n    event Deposit(address indexed _asset, address _pToken, uint256 _amount);\n    event Withdrawal(address indexed _asset, address _pToken, uint256 _amount);\n    event RewardTokenCollected(\n        address recipient,\n        address rewardToken,\n        uint256 amount\n    );\n    event RewardTokenAddressesUpdated(\n        address[] _oldAddresses,\n        address[] _newAddresses\n    );\n    event HarvesterAddressesUpdated(\n        address _oldHarvesterAddress,\n        address _newHarvesterAddress\n    );\n\n    /// @notice Address of the underlying platform\n    address public immutable platformAddress;\n    /// @notice Address of the OToken vault\n    address public immutable vaultAddress;\n\n    /// @dev Replaced with an immutable variable\n    // slither-disable-next-line constable-states\n    address private _deprecated_platformAddress;\n\n    /// @dev Replaced with an immutable\n    // slither-disable-next-line constable-states\n    address private _deprecated_vaultAddress;\n\n    /// @notice asset => pToken (Platform Specific Token Address)\n    mapping(address => address) public assetToPToken;\n\n    /// @notice Full list of all assets supported by the strategy\n    address[] internal assetsMapped;\n\n    // Deprecated: Reward token address\n    // slither-disable-next-line constable-states\n    address private _deprecated_rewardTokenAddress;\n\n    // Deprecated: now resides in Harvester's rewardTokenConfigs\n    // slither-disable-next-line constable-states\n    uint256 private _deprecated_rewardLiquidationThreshold;\n\n    /// @notice Address of the Harvester contract allowed to collect reward tokens\n    address public harvesterAddress;\n\n    /// @notice Address of the reward tokens. eg CRV, BAL, CVX, AURA\n    address[] public rewardTokenAddresses;\n\n    /* Reserved for future expansion. Used to be 100 storage slots\n     * and has decreased to accommodate:\n     * - harvesterAddress\n     * - rewardTokenAddresses\n     */\n    int256[98] private _reserved;\n\n    struct BaseStrategyConfig {\n        address platformAddress; // Address of the underlying platform\n        address vaultAddress; // Address of the OToken's Vault\n    }\n\n    /**\n     * @dev Verifies that the caller is the Governor or Strategist.\n     */\n    modifier onlyGovernorOrStrategist() {\n        require(\n            isGovernor() || msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    /**\n     * @param _config The platform and OToken vault addresses\n     */\n    constructor(BaseStrategyConfig memory _config) {\n        platformAddress = _config.platformAddress;\n        vaultAddress = _config.vaultAddress;\n    }\n\n    /**\n     * @dev Internal initialize function, to set up initial internal state\n     * @param _rewardTokenAddresses Address of reward token for platform\n     * @param _assets Addresses of initial supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function _initialize(\n        address[] memory _rewardTokenAddresses,\n        address[] memory _assets,\n        address[] memory _pTokens\n    ) internal {\n        rewardTokenAddresses = _rewardTokenAddresses;\n\n        uint256 assetCount = _assets.length;\n        require(assetCount == _pTokens.length, \"Invalid input arrays\");\n        for (uint256 i = 0; i < assetCount; ++i) {\n            _setPTokenAddress(_assets[i], _pTokens[i]);\n        }\n    }\n\n    /**\n     * @notice Collect accumulated reward token and send to Vault.\n     */\n    function collectRewardTokens() external virtual onlyHarvester nonReentrant {\n        _collectRewardTokens();\n    }\n\n    /**\n     * @dev Default implementation that transfers reward tokens to the Harvester\n     * Implementing strategies need to add custom logic to collect the rewards.\n     */\n    function _collectRewardTokens() internal virtual {\n        uint256 rewardTokenCount = rewardTokenAddresses.length;\n        for (uint256 i = 0; i < rewardTokenCount; ++i) {\n            IERC20 rewardToken = IERC20(rewardTokenAddresses[i]);\n            uint256 balance = rewardToken.balanceOf(address(this));\n            if (balance > 0) {\n                emit RewardTokenCollected(\n                    harvesterAddress,\n                    address(rewardToken),\n                    balance\n                );\n                rewardToken.safeTransfer(harvesterAddress, balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault.\n     */\n    modifier onlyVault() {\n        require(msg.sender == vaultAddress, \"Caller is not the Vault\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Harvester.\n     */\n    modifier onlyHarvester() {\n        require(msg.sender == harvesterAddress, \"Caller is not the Harvester\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault or Governor.\n     */\n    modifier onlyVaultOrGovernor() {\n        require(\n            msg.sender == vaultAddress || msg.sender == governor(),\n            \"Caller is not the Vault or Governor\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault, Governor, or Strategist.\n     */\n    modifier onlyVaultOrGovernorOrStrategist() {\n        require(\n            msg.sender == vaultAddress ||\n                msg.sender == governor() ||\n                msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Vault, Governor, or Strategist\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Set the reward token addresses. Any old addresses will be overwritten.\n     * @param _rewardTokenAddresses Array of reward token addresses\n     */\n    function setRewardTokenAddresses(address[] calldata _rewardTokenAddresses)\n        external\n        onlyGovernor\n    {\n        uint256 rewardTokenCount = _rewardTokenAddresses.length;\n        for (uint256 i = 0; i < rewardTokenCount; ++i) {\n            require(\n                _rewardTokenAddresses[i] != address(0),\n                \"Can not set an empty address as a reward token\"\n            );\n        }\n\n        emit RewardTokenAddressesUpdated(\n            rewardTokenAddresses,\n            _rewardTokenAddresses\n        );\n        rewardTokenAddresses = _rewardTokenAddresses;\n    }\n\n    /**\n     * @notice Get the reward token addresses.\n     * @return address[] the reward token addresses.\n     */\n    function getRewardTokenAddresses()\n        external\n        view\n        returns (address[] memory)\n    {\n        return rewardTokenAddresses;\n    }\n\n    /**\n     * @notice Provide support for asset by passing its pToken address.\n     *      This method can only be called by the system Governor\n     * @param _asset    Address for the asset\n     * @param _pToken   Address for the corresponding platform token\n     */\n    function setPTokenAddress(address _asset, address _pToken)\n        external\n        virtual\n        onlyGovernor\n    {\n        _setPTokenAddress(_asset, _pToken);\n    }\n\n    /**\n     * @notice Remove a supported asset by passing its index.\n     *      This method can only be called by the system Governor\n     * @param _assetIndex Index of the asset to be removed\n     */\n    function removePToken(uint256 _assetIndex) external virtual onlyGovernor {\n        require(_assetIndex < assetsMapped.length, \"Invalid index\");\n        address asset = assetsMapped[_assetIndex];\n        address pToken = assetToPToken[asset];\n\n        if (_assetIndex < assetsMapped.length - 1) {\n            assetsMapped[_assetIndex] = assetsMapped[assetsMapped.length - 1];\n        }\n        assetsMapped.pop();\n        assetToPToken[asset] = address(0);\n\n        emit PTokenRemoved(asset, pToken);\n    }\n\n    /**\n     * @notice Provide support for asset by passing its pToken address.\n     *      Add to internal mappings and execute the platform specific,\n     * abstract method `_abstractSetPToken`\n     * @param _asset    Address for the asset\n     * @param _pToken   Address for the corresponding platform token\n     */\n    function _setPTokenAddress(address _asset, address _pToken) internal {\n        require(assetToPToken[_asset] == address(0), \"pToken already set\");\n        require(\n            _asset != address(0) && _pToken != address(0),\n            \"Invalid addresses\"\n        );\n\n        assetToPToken[_asset] = _pToken;\n        assetsMapped.push(_asset);\n\n        emit PTokenAdded(_asset, _pToken);\n\n        _abstractSetPToken(_asset, _pToken);\n    }\n\n    /**\n     * @notice Transfer token to governor. Intended for recovering tokens stuck in\n     *      strategy contracts, i.e. mistaken sends.\n     * @param _asset Address for the asset\n     * @param _amount Amount of the asset to transfer\n     */\n    function transferToken(address _asset, uint256 _amount)\n        public\n        virtual\n        onlyGovernor\n    {\n        require(!supportsAsset(_asset), \"Cannot transfer supported asset\");\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /**\n     * @notice Set the Harvester contract that can collect rewards.\n     * @param _harvesterAddress Address of the harvester contract.\n     */\n    function setHarvesterAddress(address _harvesterAddress)\n        external\n        onlyGovernor\n    {\n        emit HarvesterAddressesUpdated(harvesterAddress, _harvesterAddress);\n        harvesterAddress = _harvesterAddress;\n    }\n\n    /***************************************\n                 Abstract\n    ****************************************/\n\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        virtual;\n\n    function safeApproveAllTokens() external virtual;\n\n    /**\n     * @notice Deposit an amount of assets into the platform\n     * @param _asset               Address for the asset\n     * @param _amount              Units of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount) external virtual;\n\n    /**\n     * @notice Deposit all supported assets in this strategy contract to the platform\n     */\n    function depositAll() external virtual;\n\n    /**\n     * @notice Withdraw an `amount` of assets from the platform and\n     * send to the `_recipient`.\n     * @param _recipient         Address to which the asset should be sent\n     * @param _asset             Address of the asset\n     * @param _amount            Units of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external virtual;\n\n    /**\n     * @notice Withdraw all supported assets from platform and\n     * sends to the OToken's Vault.\n     */\n    function withdrawAll() external virtual;\n\n    /**\n     * @notice Get the total asset value held in the platform.\n     *      This includes any interest that was generated since depositing.\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        virtual\n        returns (uint256 balance);\n\n    /**\n     * @notice Check if an asset is supported.\n     * @param _asset    Address of the asset\n     * @return bool     Whether asset is supported\n     */\n    function supportsAsset(address _asset) public view virtual returns (bool);\n}\n"
    },
    "contracts/vault/VaultStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OToken VaultStorage contract\n * @notice The VaultStorage contract defines the storage for the Vault contracts\n * @author Origin Protocol Inc\n */\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { OUSD } from \"../token/OUSD.sol\";\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport \"../utils/Helpers.sol\";\n\ncontract VaultStorage is Initializable, Governable {\n    using SafeERC20 for IERC20;\n\n    event AssetSupported(address _asset);\n    event AssetRemoved(address _asset);\n    event AssetDefaultStrategyUpdated(address _asset, address _strategy);\n    event AssetAllocated(address _asset, address _strategy, uint256 _amount);\n    event StrategyApproved(address _addr);\n    event StrategyRemoved(address _addr);\n    event Mint(address _addr, uint256 _value);\n    event Redeem(address _addr, uint256 _value);\n    event CapitalPaused();\n    event CapitalUnpaused();\n    event RebasePaused();\n    event RebaseUnpaused();\n    event VaultBufferUpdated(uint256 _vaultBuffer);\n    event OusdMetaStrategyUpdated(address _ousdMetaStrategy);\n    event RedeemFeeUpdated(uint256 _redeemFeeBps);\n    event PriceProviderUpdated(address _priceProvider);\n    event AllocateThresholdUpdated(uint256 _threshold);\n    event RebaseThresholdUpdated(uint256 _threshold);\n    event StrategistUpdated(address _address);\n    event MaxSupplyDiffChanged(uint256 maxSupplyDiff);\n    event YieldDistribution(address _to, uint256 _yield, uint256 _fee);\n    event TrusteeFeeBpsChanged(uint256 _basis);\n    event TrusteeAddressChanged(address _address);\n    event NetOusdMintForStrategyThresholdChanged(uint256 _threshold);\n    event SwapperChanged(address _address);\n    event SwapAllowedUndervalueChanged(uint256 _basis);\n    event SwapSlippageChanged(address _asset, uint256 _basis);\n    event Swapped(\n        address indexed _fromAsset,\n        address indexed _toAsset,\n        uint256 _fromAssetAmount,\n        uint256 _toAssetAmount\n    );\n    event StrategyAddedToMintWhitelist(address indexed strategy);\n    event StrategyRemovedFromMintWhitelist(address indexed strategy);\n    event RebasePerSecondMaxChanged(uint256 rebaseRatePerSecond);\n    event DripDurationChanged(uint256 dripDuration);\n    event WithdrawalRequested(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount,\n        uint256 _queued\n    );\n    event WithdrawalClaimed(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount\n    );\n    event WithdrawalClaimable(uint256 _claimable, uint256 _newClaimable);\n    event WithdrawalClaimDelayUpdated(uint256 _newDelay);\n\n    // Since we are proxy, all state should be uninitalized.\n    // Since this storage contract does not have logic directly on it\n    // we should not be checking for to see if these variables can be constant.\n    // slither-disable-start uninitialized-state\n    // slither-disable-start constable-states\n\n    // Assets supported by the Vault, i.e. Stablecoins\n    enum UnitConversion {\n        DECIMALS,\n        GETEXCHANGERATE\n    }\n    // Changed to fit into a single storage slot so the decimals needs to be recached\n    struct Asset {\n        // Note: OETHVaultCore doesn't use `isSupported` when minting,\n        // redeeming or checking balance of assets.\n        bool isSupported;\n        UnitConversion unitConversion;\n        uint8 decimals;\n        // Max allowed slippage from the Oracle price when swapping collateral assets in basis points.\n        // For example 40 == 0.4% slippage\n        uint16 allowedOracleSlippageBps;\n    }\n\n    /// @dev mapping of supported vault assets to their configuration\n    mapping(address => Asset) internal assets;\n    /// @dev list of all assets supported by the vault.\n    address[] internal allAssets;\n\n    // Strategies approved for use by the Vault\n    struct Strategy {\n        bool isSupported;\n        uint256 _deprecated; // Deprecated storage slot\n    }\n    /// @dev mapping of strategy contracts to their configuration\n    mapping(address => Strategy) public strategies;\n    /// @dev list of all vault strategies\n    address[] internal allStrategies;\n\n    /// @notice Address of the Oracle price provider contract\n    address public priceProvider;\n    /// @notice pause rebasing if true\n    bool public rebasePaused;\n    /// @notice pause operations that change the OToken supply.\n    /// eg mint, redeem, allocate, mint/burn for strategy\n    bool public capitalPaused;\n    /// @notice Redemption fee in basis points. eg 50 = 0.5%\n    uint256 public redeemFeeBps;\n    /// @notice Percentage of assets to keep in Vault to handle (most) withdrawals. 100% = 1e18.\n    uint256 public vaultBuffer;\n    /// @notice OToken mints over this amount automatically allocate funds. 18 decimals.\n    uint256 public autoAllocateThreshold;\n    /// @notice OToken mints over this amount automatically rebase. 18 decimals.\n    uint256 public rebaseThreshold;\n\n    /// @dev Address of the OToken token. eg OUSD or OETH.\n    OUSD public oUSD;\n\n    /// @dev Storage slot for the address of the VaultAdmin contract that is delegated to\n    // keccak256(\"OUSD.vault.governor.admin.impl\");\n    bytes32 public constant adminImplPosition =\n        0xa2bd3d3cf188a41358c8b401076eb59066b09dec5775650c0de4c55187d17bd9;\n\n    /// @dev Address of the contract responsible for post rebase syncs with AMMs\n    address private _deprecated_rebaseHooksAddr = address(0);\n\n    /// @dev Deprecated: Address of Uniswap\n    address private _deprecated_uniswapAddr = address(0);\n\n    /// @notice Address of the Strategist\n    address public strategistAddr = address(0);\n\n    /// @notice Mapping of asset address to the Strategy that they should automatically\n    // be allocated to\n    mapping(address => address) public assetDefaultStrategies;\n\n    /// @notice Max difference between total supply and total value of assets. 18 decimals.\n    uint256 public maxSupplyDiff;\n\n    /// @notice Trustee contract that can collect a percentage of yield\n    address public trusteeAddress;\n\n    /// @notice Amount of yield collected in basis points. eg 2000 = 20%\n    uint256 public trusteeFeeBps;\n\n    /// @dev Deprecated: Tokens that should be swapped for stablecoins\n    address[] private _deprecated_swapTokens;\n\n    uint256 constant MINT_MINIMUM_UNIT_PRICE = 0.998e18;\n\n    /// @notice Metapool strategy that is allowed to mint/burn OTokens without changing collateral\n\n    address public ousdMetaStrategy;\n\n    /// @notice How much OTokens are currently minted by the strategy\n    int256 public netOusdMintedForStrategy;\n\n    /// @notice How much net total OTokens are allowed to be minted by all strategies\n    uint256 public netOusdMintForStrategyThreshold;\n\n    uint256 constant MIN_UNIT_PRICE_DRIFT = 0.7e18;\n    uint256 constant MAX_UNIT_PRICE_DRIFT = 1.3e18;\n\n    /// @notice Collateral swap configuration.\n    /// @dev is packed into a single storage slot to save gas.\n    struct SwapConfig {\n        // Contract that swaps the vault's collateral assets\n        address swapper;\n        // Max allowed percentage the total value can drop below the total supply in basis points.\n        // For example 100 == 1%\n        uint16 allowedUndervalueBps;\n    }\n    SwapConfig internal swapConfig = SwapConfig(address(0), 0);\n\n    // List of strategies that can mint oTokens directly\n    // Used in OETHBaseVaultCore\n    mapping(address => bool) public isMintWhitelistedStrategy;\n\n    /// @notice Address of the Dripper contract that streams harvested rewards to the Vault\n    /// @dev The vault is proxied so needs to be set with setDripper against the proxy contract.\n    address private _deprecated_dripper;\n\n    /// Withdrawal Queue Storage /////\n\n    struct WithdrawalQueueMetadata {\n        // cumulative total of all withdrawal requests included the ones that have already been claimed\n        uint128 queued;\n        // cumulative total of all the requests that can be claimed including the ones that have already been claimed\n        uint128 claimable;\n        // total of all the requests that have been claimed\n        uint128 claimed;\n        // index of the next withdrawal request starting at 0\n        uint128 nextWithdrawalIndex;\n    }\n\n    /// @notice Global metadata for the withdrawal queue including:\n    /// queued - cumulative total of all withdrawal requests included the ones that have already been claimed\n    /// claimable - cumulative total of all the requests that can be claimed including the ones already claimed\n    /// claimed - total of all the requests that have been claimed\n    /// nextWithdrawalIndex - index of the next withdrawal request starting at 0\n    WithdrawalQueueMetadata public withdrawalQueueMetadata;\n\n    struct WithdrawalRequest {\n        address withdrawer;\n        bool claimed;\n        uint40 timestamp; // timestamp of the withdrawal request\n        // Amount of oTokens to redeem. eg OETH\n        uint128 amount;\n        // cumulative total of all withdrawal requests including this one.\n        // this request can be claimed when this queued amount is less than or equal to the queue's claimable amount.\n        uint128 queued;\n    }\n\n    /// @notice Mapping of withdrawal request indices to the user withdrawal request data\n    mapping(uint256 => WithdrawalRequest) public withdrawalRequests;\n\n    /// @notice Sets a minimum delay that is required to elapse between\n    ///     requesting async withdrawals and claiming the request.\n    ///     When set to 0 async withdrawals are disabled.\n    uint256 public withdrawalClaimDelay;\n\n    /// @notice Time in seconds that the vault last rebased yield.\n    uint64 public lastRebase;\n\n    /// @notice Automatic rebase yield calculations. In seconds. Set to 0 or 1 to disable.\n    uint64 public dripDuration;\n\n    /// @notice max rebase percentage per second\n    ///   Can be used to set maximum yield of the protocol,\n    ///   spreading out yield over time\n    uint64 public rebasePerSecondMax;\n\n    /// @notice target rebase rate limit, based on past rates and funds available.\n    uint64 public rebasePerSecondTarget;\n\n    uint256 internal constant MAX_REBASE = 0.02 ether;\n    uint256 internal constant MAX_REBASE_PER_SECOND =\n        uint256(0.05 ether) / 1 days;\n\n    // For future use\n    uint256[43] private __gap;\n\n    // slither-disable-end constable-states\n    // slither-disable-end uninitialized-state\n\n    /**\n     * @notice set the implementation for the admin, this needs to be in a base class else we cannot set it\n     * @param newImpl address of the implementation\n     */\n    function setAdminImpl(address newImpl) external onlyGovernor {\n        require(\n            Address.isContract(newImpl),\n            \"new implementation is not a contract\"\n        );\n        bytes32 position = adminImplPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, newImpl)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}