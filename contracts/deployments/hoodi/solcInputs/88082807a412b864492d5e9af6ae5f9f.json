{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/beacon/BeaconConsolidation.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Library to request validator consolidation on the beacon chain.\n * @author Origin Protocol Inc\n */\nlibrary BeaconConsolidation {\n    /// @notice The address the validator consolidation requests are sent\n    /// See https://eips.ethereum.org/EIPS/eip-7251\n    address internal constant CONSOLIDATION_REQUEST_ADDRESS =\n        0x0000BBdDc7CE488642fb579F8B00f3a590007251;\n\n    function request(bytes calldata source, bytes calldata target)\n        internal\n        returns (uint256 fee_)\n    {\n        require(source.length == 48, \"Invalid source byte length\");\n        require(target.length == 48, \"Invalid target byte length\");\n\n        fee_ = fee();\n\n        // Call the Consolidation Request contract with the public keys of the source and target\n        // validators packed together.\n        // This does not have a function signature, so we use a call\n        (bool success, ) = CONSOLIDATION_REQUEST_ADDRESS.call{ value: fee_ }(\n            abi.encodePacked(source, target)\n        );\n\n        require(success, \"Consolidation request failed\");\n    }\n\n    function fee() internal view returns (uint256) {\n        // Get fee from the consolidation request contract\n        (bool success, bytes memory result) = CONSOLIDATION_REQUEST_ADDRESS\n            .staticcall(\"\");\n\n        require(success && result.length > 0, \"Failed to get fee\");\n        return abi.decode(result, (uint256));\n    }\n}\n"
    },
    "contracts/beacon/BeaconRoots.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Library to retrieve beacon block roots.\n * @author Origin Protocol Inc\n */\nlibrary BeaconRoots {\n    /// @notice The address of beacon block roots oracle\n    /// See https://eips.ethereum.org/EIPS/eip-4788\n    address internal constant BEACON_ROOTS_ADDRESS =\n        0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02;\n\n    /// @notice Returns the beacon block root for the previous block.\n    /// This comes from the Beacon Roots contract defined in EIP-4788.\n    /// This will revert if the block is more than 8,191 blocks old as\n    /// that is the size of the beacon root's ring buffer.\n    /// @param timestamp The timestamp of the block for which to get the parent root.\n    /// @return parentRoot The parent block root for the given timestamp.\n    function parentBlockRoot(uint64 timestamp)\n        internal\n        view\n        returns (bytes32 parentRoot)\n    {\n        // Call the Beacon Roots contract to get the parent block root.\n        // This does not have a function signature, so we use a staticcall.\n        (bool success, bytes memory result) = BEACON_ROOTS_ADDRESS.staticcall(\n            abi.encode(timestamp)\n        );\n\n        require(success && result.length > 0, \"Invalid beacon timestamp\");\n        parentRoot = abi.decode(result, (bytes32));\n    }\n}\n"
    },
    "contracts/beacon/PartialWithdrawal.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Library to request full or partial withdrawals from validators on the beacon chain.\n * @author Origin Protocol Inc\n */\nlibrary PartialWithdrawal {\n    /// @notice The address where the withdrawal request is sent to\n    /// See https://eips.ethereum.org/EIPS/eip-7002\n    address internal constant WITHDRAWAL_REQUEST_ADDRESS =\n        0x00000961Ef480Eb55e80D19ad83579A64c007002;\n\n    /// @notice Requests a partial withdrawal for a given validator public key and amount.\n    /// @param validatorPubKey The public key of the validator to withdraw from\n    /// @param amount The amount of ETH to withdraw\n    function request(bytes calldata validatorPubKey, uint64 amount)\n        internal\n        returns (uint256 fee_)\n    {\n        require(validatorPubKey.length == 48, \"Invalid validator byte length\");\n        fee_ = fee();\n\n        // Call the Withdrawal Request contract with the validator public key\n        // and amount to be withdrawn packed together\n\n        // This is a general purpose EL to CL request:\n        // https://eips.ethereum.org/EIPS/eip-7685\n        (bool success, ) = WITHDRAWAL_REQUEST_ADDRESS.call{ value: fee_ }(\n            abi.encodePacked(validatorPubKey, amount)\n        );\n\n        require(success, \"Withdrawal request failed\");\n    }\n\n    /// @notice Gets fee for withdrawal requests contract on Beacon chain\n    function fee() internal view returns (uint256) {\n        // Get fee from the withdrawal request contract\n        (bool success, bytes memory result) = WITHDRAWAL_REQUEST_ADDRESS\n            .staticcall(\"\");\n\n        require(success && result.length > 0, \"Failed to get fee\");\n        return abi.decode(result, (uint256));\n    }\n}\n"
    },
    "contracts/governance/Governable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Base for contracts that are managed by the Origin Protocol's Governor.\n * @dev Copy of the openzeppelin Ownable.sol contract with nomenclature change\n *      from owner to governor and renounce methods removed. Does not use\n *      Context.sol like Ownable.sol does for simplification.\n * @author Origin Protocol Inc\n */\nabstract contract Governable {\n    // Storage position of the owner and pendingOwner of the contract\n    // keccak256(\"OUSD.governor\");\n    bytes32 private constant governorPosition =\n        0x7bea13895fa79d2831e0a9e28edede30099005a50d652d8957cf8a607ee6ca4a;\n\n    // keccak256(\"OUSD.pending.governor\");\n    bytes32 private constant pendingGovernorPosition =\n        0x44c4d30b2eaad5130ad70c3ba6972730566f3e6359ab83e800d905c61b1c51db;\n\n    // keccak256(\"OUSD.reentry.status\");\n    bytes32 private constant reentryStatusPosition =\n        0x53bf423e48ed90e97d02ab0ebab13b2a235a6bfbe9c321847d5c175333ac4535;\n\n    // See OpenZeppelin ReentrancyGuard implementation\n    uint256 constant _NOT_ENTERED = 1;\n    uint256 constant _ENTERED = 2;\n\n    event PendingGovernorshipTransfer(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    event GovernorshipTransferred(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    /**\n     * @notice Returns the address of the current Governor.\n     */\n    function governor() public view returns (address) {\n        return _governor();\n    }\n\n    /**\n     * @dev Returns the address of the current Governor.\n     */\n    function _governor() internal view returns (address governorOut) {\n        bytes32 position = governorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            governorOut := sload(position)\n        }\n    }\n\n    /**\n     * @dev Returns the address of the pending Governor.\n     */\n    function _pendingGovernor()\n        internal\n        view\n        returns (address pendingGovernor)\n    {\n        bytes32 position = pendingGovernorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            pendingGovernor := sload(position)\n        }\n    }\n\n    /**\n     * @dev Throws if called by any account other than the Governor.\n     */\n    modifier onlyGovernor() {\n        require(isGovernor(), \"Caller is not the Governor\");\n        _;\n    }\n\n    /**\n     * @notice Returns true if the caller is the current Governor.\n     */\n    function isGovernor() public view returns (bool) {\n        return msg.sender == _governor();\n    }\n\n    function _setGovernor(address newGovernor) internal {\n        emit GovernorshipTransferred(_governor(), newGovernor);\n\n        bytes32 position = governorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, newGovernor)\n        }\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        bytes32 position = reentryStatusPosition;\n        uint256 _reentry_status;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _reentry_status := sload(position)\n        }\n\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_reentry_status != _ENTERED, \"Reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, _ENTERED)\n        }\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, _NOT_ENTERED)\n        }\n    }\n\n    function _setPendingGovernor(address newGovernor) internal {\n        bytes32 position = pendingGovernorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, newGovernor)\n        }\n    }\n\n    /**\n     * @notice Transfers Governance of the contract to a new account (`newGovernor`).\n     * Can only be called by the current Governor. Must be claimed for this to complete\n     * @param _newGovernor Address of the new Governor\n     */\n    function transferGovernance(address _newGovernor) external onlyGovernor {\n        _setPendingGovernor(_newGovernor);\n        emit PendingGovernorshipTransfer(_governor(), _newGovernor);\n    }\n\n    /**\n     * @notice Claim Governance of the contract to a new account (`newGovernor`).\n     * Can only be called by the new Governor.\n     */\n    function claimGovernance() external {\n        require(\n            msg.sender == _pendingGovernor(),\n            \"Only the pending Governor can complete the claim\"\n        );\n        _changeGovernor(msg.sender);\n    }\n\n    /**\n     * @dev Change Governance of the contract to a new account (`newGovernor`).\n     * @param _newGovernor Address of the new Governor\n     */\n    function _changeGovernor(address _newGovernor) internal {\n        require(_newGovernor != address(0), \"New Governor is address(0)\");\n        _setGovernor(_newGovernor);\n    }\n}\n"
    },
    "contracts/interfaces/IBasicToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBasicToken {\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IBeaconProofs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IBeaconProofs {\n    function verifyValidator(\n        bytes32 beaconBlockRoot,\n        bytes32 pubKeyHash,\n        bytes calldata validatorPubKeyProof,\n        uint40 validatorIndex,\n        bytes32 withdrawalCredentials\n    ) external view;\n\n    function verifyValidatorWithdrawable(\n        bytes32 beaconBlockRoot,\n        uint40 validatorIndex,\n        uint64 withdrawableEpoch,\n        bytes calldata withdrawableEpochProof\n    ) external view;\n\n    function verifyBalancesContainer(\n        bytes32 beaconBlockRoot,\n        bytes32 balancesContainerLeaf,\n        bytes calldata balancesContainerProof\n    ) external view;\n\n    function verifyValidatorBalance(\n        bytes32 balancesContainerRoot,\n        bytes32 validatorBalanceLeaf,\n        bytes calldata balanceProof,\n        uint40 validatorIndex\n    ) external view returns (uint256 validatorBalance);\n\n    function verifyPendingDepositsContainer(\n        bytes32 beaconBlockRoot,\n        bytes32 pendingDepositsContainerRoot,\n        bytes calldata proof\n    ) external view;\n\n    function verifyPendingDeposit(\n        bytes32 pendingDepositsContainerRoot,\n        bytes32 pendingDepositRoot,\n        bytes calldata proof,\n        uint32 pendingDepositIndex\n    ) external view;\n\n    function verifyFirstPendingDeposit(\n        bytes32 beaconBlockRoot,\n        uint64 slot,\n        bytes calldata firstPendingDepositSlotProof\n    ) external view returns (bool isEmptyDepositQueue);\n\n    function merkleizePendingDeposit(\n        bytes32 pubKeyHash,\n        bytes calldata withdrawalCredentials,\n        uint64 amountGwei,\n        bytes calldata signature,\n        uint64 slot\n    ) external pure returns (bytes32 root);\n\n    function merkleizeSignature(bytes calldata signature)\n        external\n        pure\n        returns (bytes32 root);\n}\n"
    },
    "contracts/interfaces/IDepositContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IDepositContract {\n    /// @notice A processed deposit event.\n    event DepositEvent(\n        bytes pubkey,\n        bytes withdrawal_credentials,\n        bytes amount,\n        bytes signature,\n        bytes index\n    );\n\n    /// @notice Submit a Phase 0 DepositData object.\n    /// @param pubkey A BLS12-381 public key.\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\n    /// @param signature A BLS12-381 signature.\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\n    /// Used as a protection against malformed input.\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawal_credentials,\n        bytes calldata signature,\n        bytes32 deposit_data_root\n    ) external payable;\n\n    /// @notice Query the current deposit root hash.\n    /// @return The deposit root hash.\n    function get_deposit_root() external view returns (bytes32);\n\n    /// @notice Query the current deposit count.\n    /// @return The deposit count encoded as a little endian 64-bit number.\n    function get_deposit_count() external view returns (bytes memory);\n}\n"
    },
    "contracts/interfaces/ISSVNetwork.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct Cluster {\n    uint32 validatorCount;\n    uint64 networkFeeIndex;\n    uint64 index;\n    bool active;\n    uint256 balance;\n}\n\ninterface ISSVNetwork {\n    /**********/\n    /* Errors */\n    /**********/\n\n    error CallerNotOwner(); // 0x5cd83192\n    error CallerNotWhitelisted(); // 0x8c6e5d71\n    error FeeTooLow(); // 0x732f9413\n    error FeeExceedsIncreaseLimit(); // 0x958065d9\n    error NoFeeDeclared(); // 0x1d226c30\n    error ApprovalNotWithinTimeframe(); // 0x97e4b518\n    error OperatorDoesNotExist(); // 0x961e3e8c\n    error InsufficientBalance(); // 0xf4d678b8\n    error ValidatorDoesNotExist(); // 0xe51315d2\n    error ClusterNotLiquidatable(); // 0x60300a8d\n    error InvalidPublicKeyLength(); // 0x637297a4\n    error InvalidOperatorIdsLength(); // 0x38186224\n    error ClusterAlreadyEnabled(); // 0x3babafd2\n    error ClusterIsLiquidated(); // 0x95a0cf33\n    error ClusterDoesNotExists(); // 0x185e2b16\n    error IncorrectClusterState(); // 0x12e04c87\n    error UnsortedOperatorsList(); // 0xdd020e25\n    error NewBlockPeriodIsBelowMinimum(); // 0x6e6c9cac\n    error ExceedValidatorLimit(); // 0x6df5ab76\n    error TokenTransferFailed(); // 0x045c4b02\n    error SameFeeChangeNotAllowed(); // 0xc81272f8\n    error FeeIncreaseNotAllowed(); // 0x410a2b6c\n    error NotAuthorized(); // 0xea8e4eb5\n    error OperatorsListNotUnique(); // 0xa5a1ff5d\n    error OperatorAlreadyExists(); // 0x289c9494\n    error TargetModuleDoesNotExist(); // 0x8f9195fb\n    error MaxValueExceeded(); // 0x91aa3017\n    error FeeTooHigh(); // 0xcd4e6167\n    error PublicKeysSharesLengthMismatch(); // 0x9ad467b8\n    error IncorrectValidatorStateWithData(bytes publicKey); // 0x89307938\n    error ValidatorAlreadyExistsWithData(bytes publicKey); // 0x388e7999\n    error EmptyPublicKeysList(); // df83e679\n\n    // legacy errors\n    error ValidatorAlreadyExists(); // 0x8d09a73e\n    error IncorrectValidatorState(); // 0x2feda3c1\n\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    event ClusterDeposited(\n        address indexed owner,\n        uint64[] operatorIds,\n        uint256 value,\n        Cluster cluster\n    );\n    event ClusterLiquidated(\n        address indexed owner,\n        uint64[] operatorIds,\n        Cluster cluster\n    );\n    event ClusterReactivated(\n        address indexed owner,\n        uint64[] operatorIds,\n        Cluster cluster\n    );\n    event ClusterWithdrawn(\n        address indexed owner,\n        uint64[] operatorIds,\n        uint256 value,\n        Cluster cluster\n    );\n    event DeclareOperatorFeePeriodUpdated(uint64 value);\n    event ExecuteOperatorFeePeriodUpdated(uint64 value);\n    event FeeRecipientAddressUpdated(\n        address indexed owner,\n        address recipientAddress\n    );\n    event Initialized(uint8 version);\n    event LiquidationThresholdPeriodUpdated(uint64 value);\n    event MinimumLiquidationCollateralUpdated(uint256 value);\n    event NetworkEarningsWithdrawn(uint256 value, address recipient);\n    event NetworkFeeUpdated(uint256 oldFee, uint256 newFee);\n    event OperatorAdded(\n        uint64 indexed operatorId,\n        address indexed owner,\n        bytes publicKey,\n        uint256 fee\n    );\n    event OperatorFeeDeclarationCancelled(\n        address indexed owner,\n        uint64 indexed operatorId\n    );\n    event OperatorFeeDeclared(\n        address indexed owner,\n        uint64 indexed operatorId,\n        uint256 blockNumber,\n        uint256 fee\n    );\n    event OperatorFeeExecuted(\n        address indexed owner,\n        uint64 indexed operatorId,\n        uint256 blockNumber,\n        uint256 fee\n    );\n    event OperatorFeeIncreaseLimitUpdated(uint64 value);\n    event OperatorMaximumFeeUpdated(uint64 maxFee);\n    event OperatorRemoved(uint64 indexed operatorId);\n    event OperatorWhitelistUpdated(\n        uint64 indexed operatorId,\n        address whitelisted\n    );\n    event OperatorWithdrawn(\n        address indexed owner,\n        uint64 indexed operatorId,\n        uint256 value\n    );\n    event OwnershipTransferStarted(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event Upgraded(address indexed implementation);\n    event ValidatorAdded(\n        address indexed owner,\n        uint64[] operatorIds,\n        bytes publicKey,\n        bytes shares,\n        Cluster cluster\n    );\n    event ValidatorExited(\n        address indexed owner,\n        uint64[] operatorIds,\n        bytes publicKey\n    );\n    event ValidatorRemoved(\n        address indexed owner,\n        uint64[] operatorIds,\n        bytes publicKey,\n        Cluster cluster\n    );\n\n    fallback() external;\n\n    function acceptOwnership() external;\n\n    function cancelDeclaredOperatorFee(uint64 operatorId) external;\n\n    function declareOperatorFee(uint64 operatorId, uint256 fee) external;\n\n    function deposit(\n        address clusterOwner,\n        uint64[] memory operatorIds,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function executeOperatorFee(uint64 operatorId) external;\n\n    function exitValidator(bytes memory publicKey, uint64[] memory operatorIds)\n        external;\n\n    function bulkExitValidator(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds\n    ) external;\n\n    function getVersion() external pure returns (string memory version);\n\n    function initialize(\n        address token_,\n        address ssvOperators_,\n        address ssvClusters_,\n        address ssvDAO_,\n        address ssvViews_,\n        uint64 minimumBlocksBeforeLiquidation_,\n        uint256 minimumLiquidationCollateral_,\n        uint32 validatorsPerOperatorLimit_,\n        uint64 declareOperatorFeePeriod_,\n        uint64 executeOperatorFeePeriod_,\n        uint64 operatorMaxFeeIncrease_\n    ) external;\n\n    function liquidate(\n        address clusterOwner,\n        uint64[] memory operatorIds,\n        Cluster memory cluster\n    ) external;\n\n    function owner() external view returns (address);\n\n    function pendingOwner() external view returns (address);\n\n    function proxiableUUID() external view returns (bytes32);\n\n    function reactivate(\n        uint64[] memory operatorIds,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function reduceOperatorFee(uint64 operatorId, uint256 fee) external;\n\n    function registerOperator(bytes memory publicKey, uint256 fee)\n        external\n        returns (uint64 id);\n\n    function registerValidator(\n        bytes memory publicKey,\n        uint64[] memory operatorIds,\n        bytes memory sharesData,\n        Cluster memory cluster\n    ) external payable;\n\n    function bulkRegisterValidator(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds,\n        bytes[] calldata sharesData,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function migrateClusterToETH(\n        uint64[] calldata operatorIds,\n        Cluster memory cluster\n    ) external payable;\n\n    function removeOperator(uint64 operatorId) external;\n\n    function removeValidator(\n        bytes memory publicKey,\n        uint64[] memory operatorIds,\n        Cluster memory cluster\n    ) external;\n\n    function bulkRemoveValidator(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds,\n        Cluster memory cluster\n    ) external;\n\n    function renounceOwnership() external;\n\n    function setFeeRecipientAddress(address recipientAddress) external;\n\n    function setOperatorWhitelist(uint64 operatorId, address whitelisted)\n        external;\n\n    function transferOwnership(address newOwner) external;\n\n    function updateDeclareOperatorFeePeriod(uint64 timeInSeconds) external;\n\n    function updateExecuteOperatorFeePeriod(uint64 timeInSeconds) external;\n\n    function updateLiquidationThresholdPeriod(uint64 blocks) external;\n\n    function updateMaximumOperatorFee(uint64 maxFee) external;\n\n    function updateMinimumLiquidationCollateral(uint256 amount) external;\n\n    function updateModule(uint8 moduleId, address moduleAddress) external;\n\n    function updateNetworkFee(uint256 fee) external;\n\n    function updateOperatorFeeIncreaseLimit(uint64 percentage) external;\n\n    function upgradeTo(address newImplementation) external;\n\n    function upgradeToAndCall(address newImplementation, bytes memory data)\n        external\n        payable;\n\n    function withdraw(\n        uint64[] memory operatorIds,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function withdrawAllOperatorEarnings(uint64 operatorId) external;\n\n    function withdrawNetworkEarnings(uint256 amount) external;\n\n    function withdrawOperatorEarnings(uint64 operatorId, uint256 amount)\n        external;\n}\n"
    },
    "contracts/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Platform interface to integrate with lending platform like Compound, AAVE etc.\n */\ninterface IStrategy {\n    /**\n     * @dev Deposit the given asset to platform\n     * @param _asset asset address\n     * @param _amount Amount to deposit\n     */\n    function deposit(address _asset, uint256 _amount) external;\n\n    /**\n     * @dev Deposit the entire balance of all supported assets in the Strategy\n     *      to the platform\n     */\n    function depositAll() external;\n\n    /**\n     * @dev Withdraw given asset from Lending platform\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external;\n\n    /**\n     * @dev Liquidate all assets in strategy and return them to Vault.\n     */\n    function withdrawAll() external;\n\n    /**\n     * @dev Returns the current balance of the given asset.\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        returns (uint256 balance);\n\n    /**\n     * @dev Returns bool indicating whether strategy supports asset.\n     */\n    function supportsAsset(address _asset) external view returns (bool);\n\n    /**\n     * @dev Collect reward tokens from the Strategy.\n     */\n    function collectRewardTokens() external;\n\n    /**\n     * @dev The address array of the reward tokens for the Strategy.\n     */\n    function getRewardTokenAddresses() external view returns (address[] memory);\n\n    function harvesterAddress() external view returns (address);\n\n    function transferToken(address token, uint256 amount) external;\n\n    function setRewardTokenAddresses(address[] calldata _rewardTokenAddresses)\n        external;\n}\n"
    },
    "contracts/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { VaultStorage } from \"../vault/VaultStorage.sol\";\n\ninterface IVault {\n    // slither-disable-start constable-states\n\n    event AssetAllocated(address _asset, address _strategy, uint256 _amount);\n    event StrategyApproved(address _addr);\n    event StrategyRemoved(address _addr);\n    event Mint(address _addr, uint256 _value);\n    event Redeem(address _addr, uint256 _value);\n    event CapitalPaused();\n    event CapitalUnpaused();\n    event DefaultStrategyUpdated(address _strategy);\n    event RebasePaused();\n    event RebaseUnpaused();\n    event VaultBufferUpdated(uint256 _vaultBuffer);\n    event AllocateThresholdUpdated(uint256 _threshold);\n    event RebaseThresholdUpdated(uint256 _threshold);\n    event StrategistUpdated(address _address);\n    event MaxSupplyDiffChanged(uint256 maxSupplyDiff);\n    event YieldDistribution(address _to, uint256 _yield, uint256 _fee);\n    event TrusteeFeeBpsChanged(uint256 _basis);\n    event TrusteeAddressChanged(address _address);\n    event StrategyAddedToMintWhitelist(address indexed strategy);\n    event StrategyRemovedFromMintWhitelist(address indexed strategy);\n    event RebasePerSecondMaxChanged(uint256 rebaseRatePerSecond);\n    event DripDurationChanged(uint256 dripDuration);\n    event WithdrawalRequested(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount,\n        uint256 _queued\n    );\n    event WithdrawalClaimed(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount\n    );\n    event WithdrawalClaimable(uint256 _claimable, uint256 _newClaimable);\n    event WithdrawalClaimDelayUpdated(uint256 _newDelay);\n\n    // Governable.sol\n    function transferGovernance(address _newGovernor) external;\n\n    function claimGovernance() external;\n\n    function governor() external view returns (address);\n\n    // VaultAdmin.sol\n    function setVaultBuffer(uint256 _vaultBuffer) external;\n\n    function vaultBuffer() external view returns (uint256);\n\n    function setAutoAllocateThreshold(uint256 _threshold) external;\n\n    function autoAllocateThreshold() external view returns (uint256);\n\n    function setRebaseThreshold(uint256 _threshold) external;\n\n    function rebaseThreshold() external view returns (uint256);\n\n    function setStrategistAddr(address _address) external;\n\n    function strategistAddr() external view returns (address);\n\n    function setMaxSupplyDiff(uint256 _maxSupplyDiff) external;\n\n    function maxSupplyDiff() external view returns (uint256);\n\n    function setTrusteeAddress(address _address) external;\n\n    function trusteeAddress() external view returns (address);\n\n    function setTrusteeFeeBps(uint256 _basis) external;\n\n    function trusteeFeeBps() external view returns (uint256);\n\n    function approveStrategy(address _addr) external;\n\n    function removeStrategy(address _addr) external;\n\n    function setDefaultStrategy(address _strategy) external;\n\n    function defaultStrategy() external view returns (address);\n\n    function pauseRebase() external;\n\n    function unpauseRebase() external;\n\n    function rebasePaused() external view returns (bool);\n\n    function pauseCapital() external;\n\n    function unpauseCapital() external;\n\n    function capitalPaused() external view returns (bool);\n\n    function transferToken(address _asset, uint256 _amount) external;\n\n    function withdrawAllFromStrategy(address _strategyAddr) external;\n\n    function withdrawAllFromStrategies() external;\n\n    function withdrawFromStrategy(\n        address _strategyFromAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external;\n\n    function depositToStrategy(\n        address _strategyToAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external;\n\n    // VaultCore.sol\n    function mint(\n        address _asset,\n        uint256 _amount,\n        uint256 _minimumOusdAmount\n    ) external;\n\n    function mintForStrategy(uint256 _amount) external;\n\n    function redeem(uint256 _amount, uint256 _minimumUnitAmount) external;\n\n    function burnForStrategy(uint256 _amount) external;\n\n    function allocate() external;\n\n    function rebase() external;\n\n    function totalValue() external view returns (uint256 value);\n\n    function checkBalance(address _asset) external view returns (uint256);\n\n    /// @notice Deprecated: use calculateRedeemOutput\n    function calculateRedeemOutputs(uint256 _amount)\n        external\n        view\n        returns (uint256[] memory);\n\n    function calculateRedeemOutput(uint256 _amount)\n        external\n        view\n        returns (uint256);\n\n    function getAssetCount() external view returns (uint256);\n\n    function getAllAssets() external view returns (address[] memory);\n\n    function getStrategyCount() external view returns (uint256);\n\n    function getAllStrategies() external view returns (address[] memory);\n\n    /// @notice Deprecated.\n    function isSupportedAsset(address _asset) external view returns (bool);\n\n    function dripper() external view returns (address);\n\n    function asset() external view returns (address);\n\n    function initialize(address) external;\n\n    function addWithdrawalQueueLiquidity() external;\n\n    function requestWithdrawal(uint256 _amount)\n        external\n        returns (uint256 requestId, uint256 queued);\n\n    function claimWithdrawal(uint256 requestId)\n        external\n        returns (uint256 amount);\n\n    function claimWithdrawals(uint256[] memory requestIds)\n        external\n        returns (uint256[] memory amounts, uint256 totalAmount);\n\n    function withdrawalQueueMetadata()\n        external\n        view\n        returns (VaultStorage.WithdrawalQueueMetadata memory);\n\n    function withdrawalRequests(uint256 requestId)\n        external\n        view\n        returns (VaultStorage.WithdrawalRequest memory);\n\n    function addStrategyToMintWhitelist(address strategyAddr) external;\n\n    function removeStrategyFromMintWhitelist(address strategyAddr) external;\n\n    function isMintWhitelistedStrategy(address strategyAddr)\n        external\n        view\n        returns (bool);\n\n    function withdrawalClaimDelay() external view returns (uint256);\n\n    function setWithdrawalClaimDelay(uint256 newDelay) external;\n\n    function lastRebase() external view returns (uint64);\n\n    function dripDuration() external view returns (uint64);\n\n    function setDripDuration(uint256 _dripDuration) external;\n\n    function rebasePerSecondMax() external view returns (uint64);\n\n    function setRebaseRateMax(uint256 yearlyApr) external;\n\n    function rebasePerSecondTarget() external view returns (uint64);\n\n    function previewYield() external view returns (uint256 yield);\n\n    function weth() external view returns (address);\n\n    // slither-disable-end constable-states\n}\n"
    },
    "contracts/interfaces/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWETH9 {\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    function allowance(address, address) external view returns (uint256);\n\n    function approve(address guy, uint256 wad) external returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function deposit() external payable;\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address dst, uint256 wad) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function withdraw(uint256 wad) external;\n}\n"
    },
    "contracts/strategies/NativeStaking/CompoundingStakingSSVStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { IWETH9 } from \"../../interfaces/IWETH9.sol\";\nimport { CompoundingValidatorManager } from \"./CompoundingValidatorManager.sol\";\n\n/// @title Compounding Staking SSV Strategy\n/// @notice Strategy to deploy funds into DVT validators powered by the SSV Network\n/// @author Origin Protocol Inc\ncontract CompoundingStakingSSVStrategy is\n    CompoundingValidatorManager,\n    InitializableAbstractStrategy\n{\n    // For future use\n    uint256[50] private __gap;\n\n    /// @param _baseConfig Base strategy config with\n    ///   `platformAddress` not used so empty address\n    ///   `vaultAddress` the address of the OETH Vault contract\n    /// @param _wethAddress Address of the WETH Token contract\n    /// @param _ssvNetwork Address of the SSV Network contract\n    /// @param _beaconChainDepositContract Address of the beacon chain deposit contract\n    /// @param _beaconProofs Address of the Beacon Proofs contract that verifies beacon chain data\n    /// @param _beaconGenesisTimestamp The timestamp of the Beacon chain's genesis.\n    constructor(\n        BaseStrategyConfig memory _baseConfig,\n        address _wethAddress,\n        address _ssvNetwork,\n        address _beaconChainDepositContract,\n        address _beaconProofs,\n        uint64 _beaconGenesisTimestamp\n    )\n        InitializableAbstractStrategy(_baseConfig)\n        CompoundingValidatorManager(\n            _wethAddress,\n            _baseConfig.vaultAddress,\n            _beaconChainDepositContract,\n            _ssvNetwork,\n            _beaconProofs,\n            _beaconGenesisTimestamp\n        )\n    {\n        // Make sure nobody owns the implementation contract\n        _setGovernor(address(0));\n    }\n\n    /// @notice Set up initial internal state including\n    /// 1. approving the SSVNetwork to transfer SSV tokens from this strategy contract\n    /// @param _rewardTokenAddresses Not used so empty array\n    /// @param _assets Not used so empty array\n    /// @param _pTokens Not used so empty array\n    function initialize(\n        address[] memory _rewardTokenAddresses,\n        address[] memory _assets,\n        address[] memory _pTokens\n    ) external onlyGovernor initializer {\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n    }\n\n    /// @notice Unlike other strategies, this does not deposit assets into the underlying platform.\n    /// It just checks the asset is WETH and emits the Deposit event.\n    /// To deposit WETH into validators, `registerSsvValidator` and `stakeEth` must be used.\n    /// @param _asset Address of the WETH token.\n    /// @param _amount Amount of WETH that was transferred to the strategy by the vault.\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        require(_asset == WETH, \"Unsupported asset\");\n        require(_amount > 0, \"Must deposit something\");\n\n        // Account for the new WETH\n        depositedWethAccountedFor += _amount;\n\n        emit Deposit(_asset, address(0), _amount);\n    }\n\n    /// @notice Unlike other strategies, this does not deposit assets into the underlying platform.\n    /// It just emits the Deposit event.\n    /// To deposit WETH into validators `registerSsvValidator` and `stakeEth` must be used.\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 wethBalance = IERC20(WETH).balanceOf(address(this));\n        uint256 newWeth = wethBalance - depositedWethAccountedFor;\n\n        if (newWeth > 0) {\n            // Account for the new WETH\n            depositedWethAccountedFor = wethBalance;\n\n            emit Deposit(WETH, address(0), newWeth);\n        }\n    }\n\n    /// @notice Withdraw ETH and WETH from this strategy contract.\n    /// @param _recipient Address to receive withdrawn assets.\n    /// @param _asset Address of the WETH token.\n    /// @param _amount Amount of WETH to withdraw.\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override nonReentrant {\n        require(_asset == WETH, \"Unsupported asset\");\n        require(\n            msg.sender == vaultAddress || msg.sender == validatorRegistrator,\n            \"Caller not Vault or Registrator\"\n        );\n\n        _withdraw(_recipient, _amount, address(this).balance);\n    }\n\n    function _withdraw(\n        address _recipient,\n        uint256 _withdrawAmount,\n        uint256 _ethBalance\n    ) internal {\n        require(_withdrawAmount > 0, \"Must withdraw something\");\n        require(_recipient == vaultAddress, \"Recipient not Vault\");\n\n        // Convert any ETH from validator partial withdrawals, exits\n        // or execution rewards to WETH and do the necessary accounting.\n        if (_ethBalance > 0) _convertEthToWeth(_ethBalance);\n\n        // Transfer WETH to the recipient and do the necessary accounting.\n        _transferWeth(_withdrawAmount, _recipient);\n\n        emit Withdrawal(WETH, address(0), _withdrawAmount);\n    }\n\n    /// @notice Transfer all WETH deposits, ETH from validator withdrawals and ETH from\n    /// execution rewards in this strategy to the vault.\n    /// This does not withdraw from the validators. That has to be done separately with the\n    /// `validatorWithdrawal` operation.\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        uint256 ethBalance = address(this).balance;\n        uint256 withdrawAmount = IERC20(WETH).balanceOf(address(this)) +\n            ethBalance;\n\n        if (withdrawAmount > 0) {\n            _withdraw(vaultAddress, withdrawAmount, ethBalance);\n        }\n    }\n\n    /// @notice Accounts for all the assets managed by this strategy which includes:\n    /// 1. The current WETH in this strategy contract\n    /// 2. The last verified ETH balance, total deposits and total validator balances\n    /// @param _asset      Address of WETH asset.\n    /// @return balance    Total value in ETH\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == WETH, \"Unsupported asset\");\n\n        // Load the last verified balance from the storage\n        // and add to the latest WETH balance of this strategy.\n        balance =\n            lastVerifiedEthBalance +\n            IWETH9(WETH).balanceOf(address(this));\n    }\n\n    /// @notice Returns bool indicating whether asset is supported by the strategy.\n    /// @param _asset The address of the WETH token.\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == WETH;\n    }\n\n    /// @notice Does nothing but needed as this function is abstract on InitializableAbstractStrategy\n    /// @dev Use to be used to approve SSV tokens but that is no longer used by the SSV Network.\n    function safeApproveAllTokens() public override {}\n\n    /**\n     * @notice We can accept ETH directly to this contract from anyone as it does not impact our accounting\n     * like it did in the legacy NativeStakingStrategy.\n     * The new ETH will be accounted for in `checkBalance` after the next snapBalances and verifyBalances txs.\n     */\n    receive() external payable {}\n\n    /***************************************\n                Internal functions\n    ****************************************/\n\n    /// @notice is not supported for this strategy as there is no platform token.\n    function setPTokenAddress(address, address) external pure override {\n        revert(\"Unsupported function\");\n    }\n\n    /// @notice is not supported for this strategy as there is no platform token.\n    function removePToken(uint256) external pure override {\n        revert(\"Unsupported function\");\n    }\n\n    /// @dev This strategy does not use a platform token like the old Aave and Compound strategies.\n    function _abstractSetPToken(address _asset, address) internal override {}\n\n    /// @dev Consensus rewards are compounded to the validator's balance instead of being\n    /// swept to this strategy contract.\n    /// Execution rewards from MEV and tx priority accumulate as ETH in this strategy contract.\n    /// Withdrawals from validators also accumulate as ETH in this strategy contract.\n    /// It's too complex to separate the rewards from withdrawals so this function is not implemented.\n    /// Besides, ETH rewards are not sent to the Dripper any more. The Vault can now regulate\n    /// the increase in assets.\n    function _collectRewardTokens() internal pure override {\n        revert(\"Unsupported function\");\n    }\n}\n"
    },
    "contracts/strategies/NativeStaking/CompoundingValidatorManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { Governable } from \"../../governance/Governable.sol\";\nimport { IDepositContract } from \"../../interfaces/IDepositContract.sol\";\nimport { IWETH9 } from \"../../interfaces/IWETH9.sol\";\nimport { ISSVNetwork, Cluster } from \"../../interfaces/ISSVNetwork.sol\";\nimport { BeaconRoots } from \"../../beacon/BeaconRoots.sol\";\nimport { PartialWithdrawal } from \"../../beacon/PartialWithdrawal.sol\";\nimport { IBeaconProofs } from \"../../interfaces/IBeaconProofs.sol\";\n\n/**\n * @title Validator lifecycle management contract\n * @notice This contract implements all the required functionality to\n * register, deposit, withdraw, exit and remove validators.\n * @author Origin Protocol Inc\n */\nabstract contract CompoundingValidatorManager is Governable, Pausable {\n    using SafeERC20 for IERC20;\n\n    /// @dev The amount of ETH in wei that is required for a deposit to a new validator.\n    uint256 internal constant DEPOSIT_AMOUNT_WEI = 1 ether;\n    /// @dev Validator balances over this amount will eventually become active on the beacon chain.\n    /// Due to hysteresis, if the effective balance is 31 ETH, the actual balance\n    /// must rise to 32.25 ETH to trigger an effective balance update to 32 ETH.\n    /// https://eth2book.info/capella/part2/incentives/balances/#hysteresis\n    uint256 internal constant MIN_ACTIVATION_BALANCE_GWEI = 32.25 ether / 1e9;\n    /// @dev The maximum number of deposits that are waiting to be verified as processed on the beacon chain.\n    uint256 internal constant MAX_DEPOSITS = 32;\n    /// @dev The maximum number of validators that can be verified.\n    uint256 internal constant MAX_VERIFIED_VALIDATORS = 48;\n    /// @dev The default withdrawable epoch value on the Beacon chain.\n    /// A value in the far future means the validator is not exiting.\n    uint64 internal constant FAR_FUTURE_EPOCH = type(uint64).max;\n    /// @dev The number of seconds between each beacon chain slot.\n    uint64 internal constant SLOT_DURATION = 12;\n    /// @dev The number of slots in each beacon chain epoch.\n    uint64 internal constant SLOTS_PER_EPOCH = 32;\n    /// @dev Minimum time in seconds to allow snapped balances to be verified.\n    /// Set to 35 slots which is 3 slots more than 1 epoch (32 slots). Deposits get processed\n    /// once per epoch. This larger than 1 epoch delay should achieve that `snapBalances` sometimes\n    /// get called in the middle (or towards the end) of the epoch. Giving the off-chain script\n    /// sufficient time after the end of the epoch to prepare the proofs and call `verifyBalances`.\n    /// This is considering a malicious actor would keep calling `snapBalances` as frequent as possible\n    /// to disturb our operations.\n    uint64 internal constant SNAP_BALANCES_DELAY = 35 * SLOT_DURATION;\n\n    /// @notice The address of the Wrapped ETH (WETH) token contract\n    address internal immutable WETH;\n    /// @notice The address of the beacon chain deposit contract\n    address internal immutable BEACON_CHAIN_DEPOSIT_CONTRACT;\n    /// @notice The address of the SSV Network contract used to interface with\n    address internal immutable SSV_NETWORK;\n    /// @notice Address of the OETH Vault proxy contract\n    address internal immutable VAULT_ADDRESS;\n    /// @notice Address of the Beacon Proofs contract that verifies beacon chain data\n    address public immutable BEACON_PROOFS;\n    /// @notice The timestamp of the Beacon chain genesis.\n    /// @dev this is different on Testnets like Hoodi so is set at deployment time.\n    uint64 internal immutable BEACON_GENESIS_TIMESTAMP;\n\n    /// @notice Address of the registrator - allowed to register, withdraw, exit and remove validators\n    address public validatorRegistrator;\n\n    /// @notice Deposit data for new compounding validators.\n    /// @dev A `VERIFIED` deposit can mean 3 separate things:\n    ///      - a deposit has been processed by the beacon chain and shall be included in the\n    ///        balance of the next verifyBalances call\n    ///      - a deposit has been done to a slashed validator and has probably been recovered\n    ///        back to this strategy. Probably because we can not know for certain. This contract\n    ///        only detects when the validator has passed its withdrawal epoch. It is close to impossible\n    ///        to prove with Merkle Proofs that the postponed deposit this contract is responsible for\n    ///        creating is not present anymore in BeaconChain.state.pending_deposits. This in effect\n    ///        means that there might be a period where this contract thinks the deposit has been already\n    ///        returned as ETH balance before it happens. This will result in some days (or weeks)\n    ///        -> depending on the size of deposit queue of showing a deficit when calling `checkBalance`.\n    ///        As this only offsets the yield and doesn't cause a critical double-counting we are not addressing\n    ///        this issue.\n    ///      - A deposit has been done to the validator, but our deposit has been front run by a malicious\n    ///        actor. Funds in the deposit this contract makes are not recoverable.\n    enum DepositStatus {\n        UNKNOWN, // default value\n        PENDING, // deposit is pending and waiting to be  verified\n        VERIFIED // deposit has been verified\n    }\n\n    /// @param pubKeyHash Hash of validator's public key using the Beacon Chain's format\n    /// @param amountGwei Amount of ETH in gwei that has been deposited to the beacon chain deposit contract\n    /// @param slot The beacon chain slot number when the deposit has been made\n    /// @param depositIndex The index of the deposit in the list of active deposits\n    /// @param status The status of the deposit, either UNKNOWN, PENDING or VERIFIED\n    struct DepositData {\n        bytes32 pubKeyHash;\n        uint64 amountGwei;\n        uint64 slot;\n        uint32 depositIndex;\n        DepositStatus status;\n    }\n    /// @notice Restricts to only one deposit to an unverified validator at a time.\n    /// This is to limit front-running attacks of deposits to the beacon chain contract.\n    ///\n    /// @dev The value is set to true when a deposit to a new validator has been done that has\n    /// not yet be verified.\n    bool public firstDeposit;\n    /// @notice Mapping of the pending deposit roots to the deposit data\n    mapping(bytes32 => DepositData) public deposits;\n    /// @notice List of strategy deposit IDs to a validator.\n    /// The ID is the merkle root of the pending deposit data which is unique for each validator, amount and block.\n    /// Duplicate pending deposit roots are prevented so can be used as an identifier to each strategy deposit.\n    /// The list can be for deposits waiting to be verified as processed on the beacon chain,\n    /// or deposits that have been verified to an exiting validator and is now waiting for the\n    /// validator's balance to be swept.\n    /// The list may not be ordered by time of deposit.\n    /// Removed deposits will move the last deposit to the removed index.\n    bytes32[] public depositList;\n\n    enum ValidatorState {\n        NON_REGISTERED, // validator is not registered on the SSV network\n        REGISTERED, // validator is registered on the SSV network\n        STAKED, // validator has funds staked\n        VERIFIED, // validator has been verified to exist on the beacon chain\n        ACTIVE, // The validator balance is at least 32 ETH. The validator may not yet be active on the beacon chain.\n        EXITING, // The validator has been requested to exit\n        EXITED, // The validator has been verified to have a zero balance\n        REMOVED, // validator has funds withdrawn to this strategy contract and is removed from the SSV\n        INVALID // The validator has been front-run and the withdrawal address is not this strategy\n    }\n\n    // Validator data\n    struct ValidatorData {\n        ValidatorState state; // The state of the validator known to this contract\n        uint40 index; // The index of the validator on the beacon chain\n    }\n    /// @notice List of validator public key hashes that have been verified to exist on the beacon chain.\n    /// These have had a deposit processed and the validator's balance increased.\n    /// Validators will be removed from this list when its verified they have a zero balance.\n    bytes32[] public verifiedValidators;\n    /// @notice Mapping of the hash of the validator's public key to the validator state and index.\n    /// Uses the Beacon chain hashing for BLSPubkey which is sha256(abi.encodePacked(validator.pubkey, bytes16(0)))\n    mapping(bytes32 => ValidatorData) public validator;\n\n    /// @param blockRoot Beacon chain block root of the snapshot\n    /// @param timestamp Timestamp of the snapshot\n    /// @param ethBalance The balance of ETH in the strategy contract at the snapshot\n    struct Balances {\n        bytes32 blockRoot;\n        uint64 timestamp;\n        uint128 ethBalance;\n    }\n    /// @notice Mapping of the block root to the balances at that slot\n    Balances public snappedBalance;\n    /// @notice The last verified ETH balance of the strategy\n    uint256 public lastVerifiedEthBalance;\n\n    /// @dev This contract receives WETH as the deposit asset, but unlike other strategies doesn't immediately\n    /// deposit it to an underlying platform. Rather a special privilege account stakes it to the validators.\n    /// For that reason calling WETH.balanceOf(this) in a deposit function can contain WETH that has just been\n    /// deposited and also WETH that has previously been deposited. To keep a correct count we need to keep track\n    /// of WETH that has already been accounted for.\n    /// This value represents the amount of WETH balance of this contract that has already been accounted for by the\n    /// deposit events.\n    /// It is important to note that this variable is not concerned with WETH that is a result of full/partial\n    /// withdrawal of the validators. It is strictly concerned with WETH that has been deposited and is waiting to\n    /// be staked.\n    uint256 public depositedWethAccountedFor;\n\n    // For future use\n    uint256[41] private __gap;\n\n    event RegistratorChanged(address indexed newAddress);\n    event FirstDepositReset();\n    event SSVValidatorRegistered(\n        bytes32 indexed pubKeyHash,\n        uint64[] operatorIds\n    );\n    event SSVValidatorRemoved(bytes32 indexed pubKeyHash, uint64[] operatorIds);\n    event ETHStaked(\n        bytes32 indexed pubKeyHash,\n        bytes32 indexed pendingDepositRoot,\n        bytes pubKey,\n        uint256 amountWei\n    );\n    event ValidatorVerified(\n        bytes32 indexed pubKeyHash,\n        uint40 indexed validatorIndex\n    );\n    event ValidatorInvalid(bytes32 indexed pubKeyHash);\n    event DepositVerified(\n        bytes32 indexed pendingDepositRoot,\n        uint256 amountWei\n    );\n    event ValidatorWithdraw(bytes32 indexed pubKeyHash, uint256 amountWei);\n    event BalancesSnapped(bytes32 indexed blockRoot, uint256 ethBalance);\n    event BalancesVerified(\n        uint64 indexed timestamp,\n        uint256 totalDepositsWei,\n        uint256 totalValidatorBalance,\n        uint256 ethBalance\n    );\n\n    /// @dev Throws if called by any account other than the Registrator\n    modifier onlyRegistrator() {\n        _onlyRegistrator();\n        _;\n    }\n\n    /// @dev internal function used to reduce contract size\n    function _onlyRegistrator() internal view {\n        require(msg.sender == validatorRegistrator, \"Not Registrator\");\n    }\n\n    /// @dev Throws if called by any account other than the Registrator or Governor\n    modifier onlyRegistratorOrGovernor() {\n        require(\n            msg.sender == validatorRegistrator || isGovernor(),\n            \"Not Registrator or Governor\"\n        );\n        _;\n    }\n\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\n    /// @param _vaultAddress Address of the Vault\n    /// @param _beaconChainDepositContract Address of the beacon chain deposit contract\n    /// @param _ssvNetwork Address of the SSV Network contract\n    /// @param _beaconProofs Address of the Beacon Proofs contract that verifies beacon chain data\n    /// @param _beaconGenesisTimestamp The timestamp of the Beacon chain's genesis.\n    constructor(\n        address _wethAddress,\n        address _vaultAddress,\n        address _beaconChainDepositContract,\n        address _ssvNetwork,\n        address _beaconProofs,\n        uint64 _beaconGenesisTimestamp\n    ) {\n        WETH = _wethAddress;\n        BEACON_CHAIN_DEPOSIT_CONTRACT = _beaconChainDepositContract;\n        SSV_NETWORK = _ssvNetwork;\n        VAULT_ADDRESS = _vaultAddress;\n        BEACON_PROOFS = _beaconProofs;\n        BEACON_GENESIS_TIMESTAMP = _beaconGenesisTimestamp;\n\n        require(\n            block.timestamp > _beaconGenesisTimestamp,\n            \"Invalid genesis timestamp\"\n        );\n    }\n\n    /**\n     *\n     *             Admin Functions\n     *\n     */\n\n    /// @notice Set the address of the registrator which can register, exit and remove validators\n    function setRegistrator(address _address) external onlyGovernor {\n        validatorRegistrator = _address;\n        emit RegistratorChanged(_address);\n    }\n\n    /// @notice Reset the `firstDeposit` flag to false so deposits to unverified validators can be made again.\n    function resetFirstDeposit() external onlyGovernor {\n        require(firstDeposit, \"No first deposit\");\n\n        firstDeposit = false;\n\n        emit FirstDepositReset();\n    }\n\n    function pause() external onlyRegistratorOrGovernor {\n        _pause();\n    }\n\n    function unPause() external onlyGovernor {\n        _unpause();\n    }\n\n    /**\n     *\n     *             Validator Management\n     *\n     */\n\n    /// @notice Registers a single validator in a SSV Cluster.\n    /// Only the Registrator can call this function.\n    /// @param publicKey The public key of the validator\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param sharesData The shares data for the validator\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    // slither-disable-start reentrancy-no-eth\n    function registerSsvValidator(\n        bytes calldata publicKey,\n        uint64[] calldata operatorIds,\n        bytes calldata sharesData,\n        Cluster calldata cluster\n    ) external payable onlyRegistrator whenNotPaused {\n        // Hash the public key using the Beacon Chain's format\n        bytes32 pubKeyHash = _hashPubKey(publicKey);\n        // Check each public key has not already been used\n        require(\n            validator[pubKeyHash].state == ValidatorState.NON_REGISTERED,\n            \"Validator already registered\"\n        );\n\n        // Store the validator state as registered\n        validator[pubKeyHash].state = ValidatorState.REGISTERED;\n\n        ISSVNetwork(SSV_NETWORK).registerValidator{ value: msg.value }(\n            publicKey,\n            operatorIds,\n            sharesData,\n            cluster\n        );\n\n        emit SSVValidatorRegistered(pubKeyHash, operatorIds);\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    struct ValidatorStakeData {\n        bytes pubkey;\n        bytes signature;\n        bytes32 depositDataRoot;\n    }\n\n    /// @notice Stakes WETH in this strategy to a compounding validator.\n    /// The first deposit to a new validator, the amount must be 1 ETH.\n    /// Another deposit of at least 31 ETH is required for the validator to be activated.\n    /// This second deposit has to be done after the validator has been verified.\n    /// Does not convert any ETH sitting in this strategy to WETH.\n    /// There can not be two deposits to the same validator in the same block for the same amount.\n    /// Function is pausable so in case a run-away Registrator can be prevented from continuing\n    /// to deposit funds to slashed or undesired validators.\n    /// @param validatorStakeData validator data needed to stake.\n    /// The `ValidatorStakeData` struct contains the pubkey, signature and depositDataRoot.\n    /// Only the registrator can call this function.\n    /// @param depositAmountGwei The amount of WETH to stake to the validator in Gwei.\n    // slither-disable-start reentrancy-eth,reentrancy-no-eth\n    function stakeEth(\n        ValidatorStakeData calldata validatorStakeData,\n        uint64 depositAmountGwei\n    ) external onlyRegistrator whenNotPaused {\n        uint256 depositAmountWei = uint256(depositAmountGwei) * 1 gwei;\n        // Check there is enough WETH from the deposits sitting in this strategy contract\n        // There could be ETH from withdrawals but we'll ignore that. If it's really needed\n        // the ETH can be withdrawn and then deposited back to the strategy.\n        require(\n            depositAmountWei <= IWETH9(WETH).balanceOf(address(this)),\n            \"Insufficient WETH\"\n        );\n        require(depositList.length < MAX_DEPOSITS, \"Max deposits\");\n\n        // Convert required ETH from WETH and do the necessary accounting\n        _convertWethToEth(depositAmountWei);\n\n        // Hash the public key using the Beacon Chain's hashing for BLSPubkey\n        bytes32 pubKeyHash = _hashPubKey(validatorStakeData.pubkey);\n        ValidatorState currentState = validator[pubKeyHash].state;\n        // Can only stake to a validator that has been registered, verified or active.\n        // Can not stake to a validator that has been staked but not yet verified.\n        require(\n            (currentState == ValidatorState.REGISTERED ||\n                currentState == ValidatorState.VERIFIED ||\n                currentState == ValidatorState.ACTIVE),\n            \"Not registered or verified\"\n        );\n        require(depositAmountWei >= 1 ether, \"Deposit too small\");\n        if (currentState == ValidatorState.REGISTERED) {\n            // Can only have one pending deposit to an unverified validator at a time.\n            // This is to limit front-running deposit attacks to a single deposit.\n            // The exiting deposit needs to be verified before another deposit can be made.\n            // If there was a front-running attack, the validator needs to be verified as invalid\n            // and the Governor calls `resetFirstDeposit` to set `firstDeposit` to false.\n            require(!firstDeposit, \"Existing first deposit\");\n            // Limits the amount of ETH that can be at risk from a front-running deposit attack.\n            require(\n                depositAmountWei == DEPOSIT_AMOUNT_WEI,\n                \"Invalid first deposit amount\"\n            );\n            // Limits the number of validator balance proofs to verifyBalances\n            require(\n                verifiedValidators.length + 1 <= MAX_VERIFIED_VALIDATORS,\n                \"Max validators\"\n            );\n\n            // Flag a deposit to an unverified validator so no other deposits can be made\n            // to an unverified validator.\n            firstDeposit = true;\n            validator[pubKeyHash].state = ValidatorState.STAKED;\n        }\n\n        /* 0x02 to indicate that withdrawal credentials are for a compounding validator\n         * that was introduced with the Pectra upgrade.\n         * bytes11(0) to fill up the required zeros\n         * remaining bytes20 are for the address\n         */\n        bytes memory withdrawalCredentials = abi.encodePacked(\n            bytes1(0x02),\n            bytes11(0),\n            address(this)\n        );\n\n        /// After the Pectra upgrade the validators have a new restriction when proposing\n        /// blocks. The timestamps are at strict intervals of 12 seconds from the genesis block\n        /// forward. Each slot is created at strict 12 second intervals and those slots can\n        /// either have blocks attached to them or not. This way using the block.timestamp\n        /// the slot number can easily be calculated.\n        uint64 depositSlot = (SafeCast.toUint64(block.timestamp) -\n            BEACON_GENESIS_TIMESTAMP) / SLOT_DURATION;\n\n        // Calculate the merkle root of the beacon chain pending deposit data.\n        // This is used as the unique ID of the deposit.\n        bytes32 pendingDepositRoot = IBeaconProofs(BEACON_PROOFS)\n            .merkleizePendingDeposit(\n                pubKeyHash,\n                withdrawalCredentials,\n                depositAmountGwei,\n                validatorStakeData.signature,\n                depositSlot\n            );\n        require(\n            deposits[pendingDepositRoot].status == DepositStatus.UNKNOWN,\n            \"Duplicate deposit\"\n        );\n\n        // Store the deposit data for verifyDeposit and verifyBalances\n        deposits[pendingDepositRoot] = DepositData({\n            pubKeyHash: pubKeyHash,\n            amountGwei: depositAmountGwei,\n            slot: depositSlot,\n            depositIndex: SafeCast.toUint32(depositList.length),\n            status: DepositStatus.PENDING\n        });\n        depositList.push(pendingDepositRoot);\n\n        // Deposit to the Beacon Chain deposit contract.\n        // This will create a deposit in the beacon chain's pending deposit queue.\n        IDepositContract(BEACON_CHAIN_DEPOSIT_CONTRACT).deposit{\n            value: depositAmountWei\n        }(\n            validatorStakeData.pubkey,\n            withdrawalCredentials,\n            validatorStakeData.signature,\n            validatorStakeData.depositDataRoot\n        );\n\n        emit ETHStaked(\n            pubKeyHash,\n            pendingDepositRoot,\n            validatorStakeData.pubkey,\n            depositAmountWei\n        );\n    }\n\n    // slither-disable-end reentrancy-eth,reentrancy-no-eth\n\n    /// @notice Request a full or partial withdrawal from a validator.\n    /// A zero amount will trigger a full withdrawal.\n    /// If the remaining balance is < 32 ETH then only the amount in excess of 32 ETH will be withdrawn.\n    /// Only the Registrator can call this function.\n    /// 1 wei of value should be sent with the tx to pay for the withdrawal request fee.\n    /// If no value sent, 1 wei will be taken from the strategy's ETH balance if it has any.\n    /// If no ETH balance, the tx will revert.\n    /// @param publicKey The public key of the validator\n    /// @param amountGwei The amount of ETH to be withdrawn from the validator in Gwei.\n    /// A zero amount will trigger a full withdrawal.\n    // slither-disable-start reentrancy-no-eth\n    function validatorWithdrawal(bytes calldata publicKey, uint64 amountGwei)\n        external\n        payable\n        onlyRegistrator\n    {\n        // Hash the public key using the Beacon Chain's format\n        bytes32 pubKeyHash = _hashPubKey(publicKey);\n        ValidatorData memory validatorDataMem = validator[pubKeyHash];\n        // Validator full withdrawal could be denied due to multiple reasons:\n        //  - the validator has not been activated or active long enough\n        //    (current_epoch < activation_epoch + SHARD_COMMITTEE_PERIOD)\n        //  - the validator has pending balance to withdraw from a previous partial withdrawal request\n        //\n        // Meaning that the on-chain to beacon chain full withdrawal request could fail. Instead\n        // of adding complexity of verifying if a validator is eligible for a full exit, we allow\n        // multiple full withdrawal requests per validator.\n        require(\n            validatorDataMem.state == ValidatorState.ACTIVE ||\n                validatorDataMem.state == ValidatorState.EXITING,\n            \"Validator not active/exiting\"\n        );\n\n        // If a full withdrawal (validator exit)\n        if (amountGwei == 0) {\n            // For each staking strategy's deposits\n            uint256 depositsCount = depositList.length;\n            for (uint256 i = 0; i < depositsCount; ++i) {\n                bytes32 pendingDepositRoot = depositList[i];\n                // Check there is no pending deposits to the exiting validator\n                require(\n                    pubKeyHash != deposits[pendingDepositRoot].pubKeyHash,\n                    \"Pending deposit\"\n                );\n            }\n\n            // Store the validator state as exiting so no more deposits can be made to it.\n            // This may already be EXITING if the previous exit request failed. eg the validator\n            // was not active long enough.\n            validator[pubKeyHash].state = ValidatorState.EXITING;\n        }\n\n        // Do not remove from the list of verified validators.\n        // This is done in the verifyBalances function once the validator's balance has been verified to be zero.\n        // The validator state will be set to EXITED in the verifyBalances function.\n\n        PartialWithdrawal.request(publicKey, amountGwei);\n\n        emit ValidatorWithdraw(pubKeyHash, uint256(amountGwei) * 1 gwei);\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice Remove the validator from the SSV Cluster after:\n    /// - the validator has been exited from `validatorWithdrawal` or slashed\n    /// - the validator has incorrectly registered and can not be staked to\n    /// - the initial deposit was front-run and the withdrawal address is not this strategy's address.\n    /// Make sure `validatorWithdrawal` is called with a zero amount and the validator has exited the Beacon chain.\n    /// If removed before the validator has exited the beacon chain will result in the validator being slashed.\n    /// Only the registrator can call this function.\n    /// @param publicKey The public key of the validator\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    // slither-disable-start reentrancy-no-eth\n    function removeSsvValidator(\n        bytes calldata publicKey,\n        uint64[] calldata operatorIds,\n        Cluster calldata cluster\n    ) external onlyRegistrator {\n        // Hash the public key using the Beacon Chain's format\n        bytes32 pubKeyHash = _hashPubKey(publicKey);\n        ValidatorState currentState = validator[pubKeyHash].state;\n        // Can remove SSV validators that were incorrectly registered and can not be deposited to.\n        require(\n            currentState == ValidatorState.REGISTERED ||\n                currentState == ValidatorState.EXITED ||\n                currentState == ValidatorState.INVALID,\n            \"Validator not regd or exited\"\n        );\n\n        validator[pubKeyHash].state = ValidatorState.REMOVED;\n\n        ISSVNetwork(SSV_NETWORK).removeValidator(\n            publicKey,\n            operatorIds,\n            cluster\n        );\n\n        emit SSVValidatorRemoved(pubKeyHash, operatorIds);\n    }\n\n    /**\n     *\n     *             SSV Management\n     *\n     */\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice Migrate the SSV cluster to use ETH for payment instead of SSV tokens.\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    function migrateClusterToETH(\n        uint64[] memory operatorIds,\n        Cluster memory cluster\n    ) external onlyGovernor {\n        ISSVNetwork(SSV_NETWORK).migrateClusterToETH(operatorIds, cluster);\n    }\n\n    /**\n     *\n     *             Beacon Chain Proofs\n     *\n     */\n\n    /// @notice Verifies a validator's index to its public key.\n    /// Adds to the list of verified validators if the validator's withdrawal address is this strategy's address.\n    /// Marks the validator as invalid and removes the deposit if the withdrawal address is not this strategy's address.\n    /// @param nextBlockTimestamp The timestamp of the execution layer block after the beacon chain slot\n    /// we are verifying.\n    /// The next one is needed as the Beacon Oracle returns the parent beacon block root for a block timestamp,\n    /// which is the beacon block root of the previous block.\n    /// @param validatorIndex The index of the validator on the beacon chain.\n    /// @param pubKeyHash The hash of the validator's public key using the Beacon Chain's format\n    /// @param withdrawalCredentials contain the validator type and withdrawal address. These can be incorrect and/or\n    ///        malformed. In case of incorrect withdrawalCredentials the validator deposit has been front run\n    /// @param validatorPubKeyProof The merkle proof for the validator public key to the beacon block root.\n    /// This is 53 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    /// BeaconBlock.state.validators[validatorIndex].pubkey\n    function verifyValidator(\n        uint64 nextBlockTimestamp,\n        uint40 validatorIndex,\n        bytes32 pubKeyHash,\n        bytes32 withdrawalCredentials,\n        bytes calldata validatorPubKeyProof\n    ) external {\n        require(\n            validator[pubKeyHash].state == ValidatorState.STAKED,\n            \"Validator not staked\"\n        );\n\n        // Get the beacon block root of the slot we are verifying the validator in.\n        // The parent beacon block root of the next block is the beacon block root of the slot we are verifying.\n        bytes32 blockRoot = BeaconRoots.parentBlockRoot(nextBlockTimestamp);\n\n        // Verify the validator index is for the validator with the given public key.\n        // Also verify the validator's withdrawal credentials\n        IBeaconProofs(BEACON_PROOFS).verifyValidator(\n            blockRoot,\n            pubKeyHash,\n            validatorPubKeyProof,\n            validatorIndex,\n            withdrawalCredentials\n        );\n\n        // Store the validator state as verified\n        validator[pubKeyHash] = ValidatorData({\n            state: ValidatorState.VERIFIED,\n            index: validatorIndex\n        });\n\n        bytes32 expectedWithdrawalCredentials = bytes32(\n            abi.encodePacked(bytes1(0x02), bytes11(0), address(this))\n        );\n\n        // If the initial deposit was front-run and the withdrawal address is not this strategy\n        // or the validator type is not a compounding validator (0x02)\n        if (expectedWithdrawalCredentials != withdrawalCredentials) {\n            // override the validator state\n            validator[pubKeyHash].state = ValidatorState.INVALID;\n\n            // Find and remove the deposit as the funds can not be recovered\n            uint256 depositCount = depositList.length;\n            for (uint256 i = 0; i < depositCount; i++) {\n                DepositData memory deposit = deposits[depositList[i]];\n                if (deposit.pubKeyHash == pubKeyHash) {\n                    // next verifyBalances will correctly account for the loss of a front-run\n                    // deposit. Doing it here accounts for the loss as soon as possible\n                    lastVerifiedEthBalance -= Math.min(\n                        lastVerifiedEthBalance,\n                        uint256(deposit.amountGwei) * 1 gwei\n                    );\n                    _removeDeposit(depositList[i], deposit);\n                    break;\n                }\n            }\n\n            // Leave the `firstDeposit` flag as true so no more deposits to unverified validators can be made.\n            // The Governor has to reset the `firstDeposit` to false before another deposit to\n            // an unverified validator can be made.\n            // The Governor can set a new `validatorRegistrator` if they suspect it has been compromised.\n\n            emit ValidatorInvalid(pubKeyHash);\n            return;\n        }\n\n        // Add the new validator to the list of verified validators\n        verifiedValidators.push(pubKeyHash);\n\n        // Reset the firstDeposit flag as the first deposit to an unverified validator has been verified.\n        firstDeposit = false;\n\n        emit ValidatorVerified(pubKeyHash, validatorIndex);\n    }\n\n    struct FirstPendingDepositSlotProofData {\n        uint64 slot;\n        bytes proof;\n    }\n\n    struct StrategyValidatorProofData {\n        uint64 withdrawableEpoch;\n        bytes withdrawableEpochProof;\n    }\n\n    /// @notice Verifies a deposit on the execution layer has been processed by the beacon chain.\n    /// This means the accounting of the strategy's ETH moves from a pending deposit to a validator balance.\n    ///\n    /// Important: this function has a limitation where `depositProcessedSlot` that is passed by the off-chain\n    /// verifier requires a slot immediately after it to propose a block otherwise the `BeaconRoots.parentBlockRoot`\n    /// will fail. This shouldn't be a problem, since by the current behaviour of beacon chain only 1%-3% slots\n    /// don't propose a block.\n    /// @param pendingDepositRoot The unique identifier of the deposit emitted in `ETHStaked` from\n    /// the `stakeEth` function.\n    /// @param depositProcessedSlot Any slot on or after the strategy's deposit was processed on the beacon chain.\n    /// Can not be a slot with pending deposits with the same slot as the deposit being verified.\n    /// Can not be a slot before a missed slot as the Beacon Root contract will have the parent block root\n    /// set for the next block timestamp in 12 seconds time.\n    /// @param firstPendingDeposit a `FirstPendingDepositSlotProofData` struct containing:\n    /// - slot: The beacon chain slot of the first deposit in the beacon chain's deposit queue.\n    ///   Can be any non-zero value if the deposit queue is empty.\n    /// - proof: The merkle proof of the first pending deposit's slot to the beacon block root.\n    ///   Can be either:\n    ///   * 40 witness hashes for BeaconBlock.state.PendingDeposits[0].slot when the deposit queue is not empty.\n    ///   * 37 witness hashes for BeaconBlock.state.PendingDeposits[0] when the deposit queue is empty.\n    ///   The 32 byte witness hashes are concatenated together starting from the leaf node.\n    /// @param strategyValidatorData a `StrategyValidatorProofData` struct containing:\n    /// - withdrawableEpoch: The withdrawable epoch of the validator the strategy is depositing to.\n    /// - withdrawableEpochProof: The merkle proof for the withdrawable epoch of the validator the strategy\n    ///   is depositing to, to the beacon block root.\n    ///   This is 53 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    // slither-disable-start reentrancy-no-eth\n    function verifyDeposit(\n        bytes32 pendingDepositRoot,\n        uint64 depositProcessedSlot,\n        FirstPendingDepositSlotProofData calldata firstPendingDeposit,\n        StrategyValidatorProofData calldata strategyValidatorData\n    ) external {\n        // Load into memory the previously saved deposit data\n        DepositData memory deposit = deposits[pendingDepositRoot];\n        ValidatorData memory strategyValidator = validator[deposit.pubKeyHash];\n        require(deposit.status == DepositStatus.PENDING, \"Deposit not pending\");\n        require(firstPendingDeposit.slot != 0, \"Zero 1st pending deposit slot\");\n\n        // We should allow the verification of deposits for validators that have been marked as exiting\n        // to cover this situation:\n        //  - there are 2 pending deposits\n        //  - beacon chain has slashed the validator\n        //  - when verifyDeposit is called for the first deposit it sets the Validator state to EXITING\n        //  - verifyDeposit should allow a secondary call for the other deposit to a slashed validator\n        require(\n            strategyValidator.state == ValidatorState.VERIFIED ||\n                strategyValidator.state == ValidatorState.ACTIVE ||\n                strategyValidator.state == ValidatorState.EXITING,\n            \"Not verified/active/exiting\"\n        );\n        // The verification slot must be after the deposit's slot.\n        // This is needed for when the deposit queue is empty.\n        require(deposit.slot < depositProcessedSlot, \"Slot not after deposit\");\n\n        uint64 snapTimestamp = snappedBalance.timestamp;\n\n        // This check prevents an accounting error that can happen if:\n        //  - snapBalances are snapped at the time of T\n        //  - deposit is processed on the beacon chain after time T and before verifyBalances()\n        //  - verifyDeposit is called before verifyBalances which removes a deposit from depositList\n        //    and deposit balance from totalDepositsWei\n        //  - verifyBalances is called under-reporting the strategy's balance\n        require(\n            (_calcNextBlockTimestamp(depositProcessedSlot) <= snapTimestamp) ||\n                snapTimestamp == 0,\n            \"Deposit after balance snapshot\"\n        );\n\n        // Get the parent beacon block root of the next block which is the block root of the deposit verification slot.\n        // This will revert if the slot after the verification slot was missed.\n        bytes32 depositBlockRoot = BeaconRoots.parentBlockRoot(\n            _calcNextBlockTimestamp(depositProcessedSlot)\n        );\n\n        // Verify the slot of the first pending deposit matches the beacon chain\n        bool isDepositQueueEmpty = IBeaconProofs(BEACON_PROOFS)\n            .verifyFirstPendingDeposit(\n                depositBlockRoot,\n                firstPendingDeposit.slot,\n                firstPendingDeposit.proof\n            );\n\n        // Verify the withdrawableEpoch on the validator of the strategy's deposit\n        IBeaconProofs(BEACON_PROOFS).verifyValidatorWithdrawable(\n            depositBlockRoot,\n            strategyValidator.index,\n            strategyValidatorData.withdrawableEpoch,\n            strategyValidatorData.withdrawableEpochProof\n        );\n\n        uint64 firstPendingDepositEpoch = firstPendingDeposit.slot /\n            SLOTS_PER_EPOCH;\n\n        // If deposit queue is empty all deposits have certainly been processed. If not\n        // a validator can either be not exiting and no further checks are required.\n        // Or a validator is exiting then this function needs to make sure that the\n        // pending deposit to an exited validator has certainly been processed. The\n        // slot/epoch of first pending deposit is the one that contains the transaction\n        // where the deposit to the ETH Deposit Contract has been made.\n        //\n        // Once the firstPendingDepositEpoch becomes greater than the withdrawableEpoch of\n        // the slashed validator then the deposit has certainly been processed. When the beacon\n        // chain reaches the withdrawableEpoch of the validator the deposit will no longer be\n        // postponed. And any new deposits created (and present in the deposit queue)\n        // will have an equal or larger withdrawableEpoch.\n        require(\n            strategyValidatorData.withdrawableEpoch == FAR_FUTURE_EPOCH ||\n                strategyValidatorData.withdrawableEpoch <=\n                firstPendingDepositEpoch ||\n                isDepositQueueEmpty,\n            \"Exit Deposit likely not proc.\"\n        );\n\n        // solhint-disable max-line-length\n        // Check the deposit slot is before the first pending deposit's slot on the beacon chain.\n        // If this is not true then we can't guarantee the deposit has been processed by the beacon chain.\n        // The deposit's slot can not be the same slot as the first pending deposit as there could be\n        // many deposits in the same block, hence have the same pending deposit slot.\n        // If the deposit queue is empty then our deposit must have been processed on the beacon chain.\n        // The deposit slot can be zero for validators consolidating to a compounding validator or 0x01 validator\n        // being promoted to a compounding one. Reference:\n        // - [switch_to_compounding_validator](https://ethereum.github.io/consensus-specs/specs/electra/beacon-chain/#new-switch_to_compounding_validator\n        // - [queue_excess_active_balance](https://ethereum.github.io/consensus-specs/specs/electra/beacon-chain/#new-queue_excess_active_balance)\n        // - [process_consolidation_request](https://ethereum.github.io/consensus-specs/specs/electra/beacon-chain/#new-process_consolidation_request)\n        // We can not guarantee that the deposit has been processed in that case.\n        // solhint-enable max-line-length\n        require(\n            deposit.slot < firstPendingDeposit.slot || isDepositQueueEmpty,\n            \"Deposit likely not processed\"\n        );\n\n        // Remove the deposit now it has been verified as processed on the beacon chain.\n        _removeDeposit(pendingDepositRoot, deposit);\n\n        emit DepositVerified(\n            pendingDepositRoot,\n            uint256(deposit.amountGwei) * 1 gwei\n        );\n    }\n\n    function _removeDeposit(\n        bytes32 pendingDepositRoot,\n        DepositData memory deposit\n    ) internal {\n        // After verifying the proof, update the contract storage\n        deposits[pendingDepositRoot].status = DepositStatus.VERIFIED;\n        // Move the last deposit to the index of the verified deposit\n        bytes32 lastDeposit = depositList[depositList.length - 1];\n        depositList[deposit.depositIndex] = lastDeposit;\n        deposits[lastDeposit].depositIndex = deposit.depositIndex;\n        // Delete the last deposit from the list\n        depositList.pop();\n    }\n\n    /// @dev Calculates the timestamp of the next execution block from the given slot.\n    /// @param slot The beacon chain slot number used for merkle proof verification.\n    function _calcNextBlockTimestamp(uint64 slot)\n        internal\n        view\n        returns (uint64)\n    {\n        // Calculate the next block timestamp from the slot.\n        return SLOT_DURATION * slot + BEACON_GENESIS_TIMESTAMP + SLOT_DURATION;\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice Stores the current ETH balance at the current block and beacon block root\n    ///         of the slot that is associated with the previous block.\n    ///\n    /// When snapping / verifying balance it is of a high importance that there is no\n    /// miss-match in respect to ETH that is held by the contract and balances that are\n    /// verified on the validators.\n    ///\n    /// First some context on the beacon-chain block building behaviour. Relevant parts of\n    /// constructing a block on the beacon chain consist of:\n    ///  - process_withdrawals: ETH is deducted from the validator's balance\n    ///  - process_execution_payload: immediately after the previous step executing all the\n    ///    transactions\n    ///  - apply the withdrawals: adding ETH to the recipient which is the withdrawal address\n    ///    contained in the withdrawal credentials of the exited validators\n    ///\n    /// That means that balance increases which are part of the post-block execution state are\n    /// done within the block, but the transaction that are contained within that block can not\n    /// see / interact with the balance from the exited validators. Only transactions in the\n    /// next block can do that.\n    ///\n    /// When snap balances is performed the state of the chain is snapped across 2 separate\n    /// chain states:\n    ///  - ETH balance of the contract is recorded on block X -> and corresponding slot Y\n    ///  - beacon chain block root is recorded of block X - 1 -> and corresponding slot Y - 1\n    ///    given there were no missed slots. It could also be Y - 2, Y - 3 depending on how\n    ///    many slots have not managed to propose a block. For the sake of simplicity this slot\n    ///    will be referred to as Y - 1 as it makes no difference in the argument\n    ///\n    /// Given these 2 separate chain states it is paramount that verify balances can not experience\n    /// miss-counting ETH or much more dangerous double counting of the ETH.\n    ///\n    /// When verifyBalances is called it is performed on the current block Z where Z > X. Verify\n    /// balances adds up all the ETH (omitting WETH) controlled by this contract:\n    ///  - ETH balance in the contract on block X\n    ///  - ETH balance in Deposits on block Z that haven't been yet processed in slot Y - 1\n    ///  - ETH balance in validators that are active in slot Y - 1\n    ///  - skips the ETH balance in validators that have withdrawn in slot Y - 1 (or sooner)\n    ///    and have their balance visible to transactions in slot Y and corresponding block X\n    ///    (or sooner)\n    ///\n    /// Lets verify the correctness of ETH accounting given the above described behaviour.\n    ///\n    /// *ETH balance in the contract on block X*\n    ///\n    /// This is an ETH balance of the contract on a non current X block. Any ETH leaving the\n    /// contract as a result of a withdrawal subtracts from the ETH accounted for on block X\n    /// if `verifyBalances` has already been called. It also invalidates a `snapBalances` in\n    /// case `verifyBalances` has not been called yet. Not performing this would result in not\n    /// accounting for the withdrawn ETH that has happened anywhere in the block interval [X + 1, Z].\n    ///\n    /// Similarly to withdrawals any `stakeEth` deposits to the deposit contract adds to the ETH\n    /// accounted for since the last `verifyBalances` has been called. And it invalidates the\n    /// `snapBalances` in case `verifyBalances` hasn't been yet called. Not performing this\n    /// would result in double counting the `stakedEth` since it would be present once in the\n    /// snapped contract balance and the second time in deposit storage variables.\n    ///\n    /// This behaviour is correct.\n    ///\n    /// *ETH balance in Deposits on block Z that haven't been yet processed in slot Y - 1*\n    ///\n    /// The contract sums up all the ETH that has been deposited to the Beacon chain deposit\n    /// contract at block Z. The execution layer doesn't have direct access to the state of\n    /// deposits on the beacon chain. And if it is to sum up all the ETH that is marked to be\n    /// deposited it needs to be sure to not double count ETH that is in deposits (storage vars)\n    /// and could also be part of the validator balances. It does that by verifying that at\n    /// slot Y - 1 none of the deposits visible on block Z have been processed. Meaning since\n    /// the last snap till now all are still in queue. Which ensures they can not be part of\n    /// the validator balances in later steps.\n    ///\n    /// This behaviour is correct.\n    ///\n    /// *ETH balance in validators that are active in slot Y - 1*\n    ///\n    /// The contract is verifying none of the deposits on Y - 1 slot have been processed and\n    /// for that reason it checks the validator balances in the same slot. Ensuring accounting\n    /// correctness.\n    ///\n    /// This behaviour is correct.\n    ///\n    /// *The withdrawn validators*\n    ///\n    /// The withdrawn validators could have their balances deducted in any slot before slot\n    /// Y - 1 and the execution layer sees the balance increase in the subsequent slot. Lets\n    /// look at the \"worst case scenario\" where the validator withdrawal is processed in the\n    /// slot Y - 1 (snapped slot) and see their balance increase (in execution layer) in slot\n    /// Y -> block X. The ETH balance on the contract is snapped at block X meaning that\n    /// even if the validator exits at the latest possible time it is paramount that the ETH\n    /// balance on the execution layer is recorded in the next block. Correctly accounting\n    /// for the withdrawn ETH.\n    ///\n    /// Worth mentioning if the validator exit is processed by the slot Y and balance increase\n    /// seen on the execution layer on block X + 1 the withdrawal is ignored by both the\n    /// validator balance verification as well as execution layer contract balance snap.\n    ///\n    /// This behaviour is correct.\n    ///\n    /// The validator balances on the beacon chain can then be proved with `verifyBalances`.\n    function snapBalances() external onlyRegistrator {\n        uint64 currentTimestamp = SafeCast.toUint64(block.timestamp);\n        require(\n            snappedBalance.timestamp + SNAP_BALANCES_DELAY < currentTimestamp,\n            \"Snap too soon\"\n        );\n\n        bytes32 blockRoot = BeaconRoots.parentBlockRoot(currentTimestamp);\n        // Get the current ETH balance\n        uint256 ethBalance = address(this).balance;\n\n        // Store the snapped balance\n        snappedBalance = Balances({\n            blockRoot: blockRoot,\n            timestamp: currentTimestamp,\n            ethBalance: SafeCast.toUint128(ethBalance)\n        });\n\n        emit BalancesSnapped(blockRoot, ethBalance);\n    }\n\n    // A struct is used to avoid stack too deep errors\n    struct BalanceProofs {\n        // BeaconBlock.state.balances\n        bytes32 balancesContainerRoot;\n        bytes balancesContainerProof;\n        // BeaconBlock.state.balances[validatorIndex]\n        bytes32[] validatorBalanceLeaves;\n        bytes[] validatorBalanceProofs;\n    }\n\n    struct PendingDepositProofs {\n        bytes32 pendingDepositContainerRoot;\n        bytes pendingDepositContainerProof;\n        uint32[] pendingDepositIndexes;\n        bytes[] pendingDepositProofs;\n    }\n\n    /// @notice Verifies the balances of all active validators on the beacon chain\n    /// and checks each of the strategy's deposits are still to be processed by the beacon chain.\n    /// @param balanceProofs a `BalanceProofs` struct containing the following:\n    /// - balancesContainerRoot: The merkle root of the balances container\n    /// - balancesContainerProof: The merkle proof for the balances container to the beacon block root.\n    ///    This is 9 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    /// - validatorBalanceLeaves: Array of leaf nodes containing the validator balance with three other balances.\n    /// - validatorBalanceProofs: Array of merkle proofs for the validator balance to the Balances container root.\n    ///    This is 39 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    /// @param pendingDepositProofs a `PendingDepositProofs` struct containing the following:\n    /// - pendingDepositContainerRoot: The merkle root of the pending deposits list container\n    /// - pendingDepositContainerProof: The merkle proof from the pending deposits list container\n    ///     to the beacon block root.\n    ///    This is 9 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    /// - pendingDepositIndexes: Array of indexes in the pending deposits list container for each\n    ///    of the strategy's deposits.\n    /// - pendingDepositProofs: Array of merkle proofs for each strategy deposit in the\n    ///    beacon chain's pending deposit list container to the pending deposits list container root.\n    ///    These are 28 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    // slither-disable-start reentrancy-no-eth\n    function verifyBalances(\n        BalanceProofs calldata balanceProofs,\n        PendingDepositProofs calldata pendingDepositProofs\n    ) external onlyRegistrator {\n        // Load previously snapped balances for the given block root\n        Balances memory balancesMem = snappedBalance;\n        // Check the balances are the latest\n        require(balancesMem.timestamp > 0, \"No snapped balances\");\n\n        uint256 verifiedValidatorsCount = verifiedValidators.length;\n        uint256 totalValidatorBalance = 0;\n        uint256 depositsCount = depositList.length;\n\n        // If there are no verified validators then we can skip the balance verification\n        if (verifiedValidatorsCount > 0) {\n            require(\n                balanceProofs.validatorBalanceProofs.length ==\n                    verifiedValidatorsCount,\n                \"Invalid balance proofs\"\n            );\n            require(\n                balanceProofs.validatorBalanceLeaves.length ==\n                    verifiedValidatorsCount,\n                \"Invalid balance leaves\"\n            );\n            // verify beaconBlock.state.balances root to beacon block root\n            IBeaconProofs(BEACON_PROOFS).verifyBalancesContainer(\n                balancesMem.blockRoot,\n                balanceProofs.balancesContainerRoot,\n                balanceProofs.balancesContainerProof\n            );\n\n            bytes32[]\n                memory validatorHashesMem = _getPendingDepositValidatorHashes(\n                    depositsCount\n                );\n\n            // for each validator in reverse order so we can pop off exited validators at the end\n            for (uint256 i = verifiedValidatorsCount; i > 0; ) {\n                --i;\n                ValidatorData memory validatorDataMem = validator[\n                    verifiedValidators[i]\n                ];\n                // verify validator's balance in beaconBlock.state.balances to the\n                // beaconBlock.state.balances container root\n                uint256 validatorBalanceGwei = IBeaconProofs(BEACON_PROOFS)\n                    .verifyValidatorBalance(\n                        balanceProofs.balancesContainerRoot,\n                        balanceProofs.validatorBalanceLeaves[i],\n                        balanceProofs.validatorBalanceProofs[i],\n                        validatorDataMem.index\n                    );\n\n                // If the validator has exited and the balance is now zero\n                if (validatorBalanceGwei == 0) {\n                    // Check if there are any pending deposits to this validator\n                    bool depositPending = false;\n                    for (uint256 j = 0; j < validatorHashesMem.length; j++) {\n                        if (validatorHashesMem[j] == verifiedValidators[i]) {\n                            depositPending = true;\n                            break;\n                        }\n                    }\n\n                    // If validator has a pending deposit we can not remove due to\n                    // the following situation:\n                    //  - validator has a pending deposit\n                    //  - validator has been slashed\n                    //  - sweep cycle has withdrawn all ETH from the validator. Balance is 0\n                    //  - beacon chain has processed the deposit and set the validator balance\n                    //    to deposit amount\n                    //  - if validator is no longer in the list of verifiedValidators its\n                    //    balance will not be considered and be under-counted.\n                    if (!depositPending) {\n                        // Store the validator state as exited\n                        // This could have been in VERIFIED, ACTIVE or EXITING state\n                        validator[verifiedValidators[i]].state = ValidatorState\n                            .EXITED;\n\n                        // Remove the validator with a zero balance from the list of verified validators\n\n                        // Reduce the count of verified validators which is the last index before the pop removes it.\n                        verifiedValidatorsCount -= 1;\n\n                        // Move the last validator that has already been verified to the current index.\n                        // There's an extra SSTORE if i is the last active validator but that's fine,\n                        // It's not a common case and the code is simpler this way.\n                        verifiedValidators[i] = verifiedValidators[\n                            verifiedValidatorsCount\n                        ];\n                        // Delete the last validator from the list\n                        verifiedValidators.pop();\n                    }\n\n                    // The validator balance is zero so not need to add to totalValidatorBalance\n                    continue;\n                } else if (\n                    validatorDataMem.state == ValidatorState.VERIFIED &&\n                    validatorBalanceGwei > MIN_ACTIVATION_BALANCE_GWEI\n                ) {\n                    // Store the validator state as active. This does not necessarily mean the\n                    // validator is active on the beacon chain yet. It just means the validator has\n                    // enough balance that it can become active.\n                    validator[verifiedValidators[i]].state = ValidatorState\n                        .ACTIVE;\n                }\n\n                // convert Gwei balance to Wei and add to the total validator balance\n                totalValidatorBalance += validatorBalanceGwei * 1 gwei;\n            }\n        }\n\n        uint256 totalDepositsWei = 0;\n\n        // If there are no deposits then we can skip the deposit verification.\n        // This section is after the validator balance verifications so an exited validator will be marked\n        // as EXITED before the deposits are verified. If there was a deposit to an exited validator\n        // then the deposit can only be removed once the validator is fully exited.\n        // It is possible that validator fully exits and a postponed deposit to an exited validator increases\n        // its balance again. In such case the contract will erroneously consider a deposit applied before it\n        // has been applied on the beacon chain showing a smaller than real `totalValidatorBalance`.\n        if (depositsCount > 0) {\n            require(\n                pendingDepositProofs.pendingDepositProofs.length ==\n                    depositsCount,\n                \"Invalid deposit proofs\"\n            );\n            require(\n                pendingDepositProofs.pendingDepositIndexes.length ==\n                    depositsCount,\n                \"Invalid deposit indexes\"\n            );\n\n            // Verify from the root of the pending deposit list container to the beacon block root\n            IBeaconProofs(BEACON_PROOFS).verifyPendingDepositsContainer(\n                balancesMem.blockRoot,\n                pendingDepositProofs.pendingDepositContainerRoot,\n                pendingDepositProofs.pendingDepositContainerProof\n            );\n\n            // For each staking strategy's deposit.\n            for (uint256 i = 0; i < depositsCount; ++i) {\n                bytes32 pendingDepositRoot = depositList[i];\n\n                // Verify the strategy's deposit is still pending on the beacon chain.\n                IBeaconProofs(BEACON_PROOFS).verifyPendingDeposit(\n                    pendingDepositProofs.pendingDepositContainerRoot,\n                    pendingDepositRoot,\n                    pendingDepositProofs.pendingDepositProofs[i],\n                    pendingDepositProofs.pendingDepositIndexes[i]\n                );\n\n                // Convert the deposit amount from Gwei to Wei and add to the total\n                totalDepositsWei +=\n                    uint256(deposits[pendingDepositRoot].amountGwei) *\n                    1 gwei;\n            }\n        }\n\n        // Store the verified balance in storage\n        lastVerifiedEthBalance =\n            totalDepositsWei +\n            totalValidatorBalance +\n            balancesMem.ethBalance;\n        // Reset the last snap timestamp so a new snapBalances has to be made\n        snappedBalance.timestamp = 0;\n\n        emit BalancesVerified(\n            balancesMem.timestamp,\n            totalDepositsWei,\n            totalValidatorBalance,\n            balancesMem.ethBalance\n        );\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice get a list of all validator hashes present in the pending deposits\n    ///         list can have duplicate entries\n    function _getPendingDepositValidatorHashes(uint256 depositsCount)\n        internal\n        view\n        returns (bytes32[] memory validatorHashes)\n    {\n        validatorHashes = new bytes32[](depositsCount);\n        for (uint256 i = 0; i < depositsCount; i++) {\n            validatorHashes[i] = deposits[depositList[i]].pubKeyHash;\n        }\n    }\n\n    /// @notice Hash a validator public key using the Beacon Chain's format\n    function _hashPubKey(bytes memory pubKey) internal pure returns (bytes32) {\n        require(pubKey.length == 48, \"Invalid public key\");\n        return sha256(abi.encodePacked(pubKey, bytes16(0)));\n    }\n\n    /**\n     *\n     *         WETH and ETH Accounting\n     *\n     */\n\n    /// @dev Called when WETH is transferred out of the strategy so\n    /// the strategy knows how much WETH it has on deposit.\n    /// This is so it can emit the correct amount in the Deposit event in depositAll().\n    function _transferWeth(uint256 _amount, address _recipient) internal {\n        IERC20(WETH).safeTransfer(_recipient, _amount);\n\n        // The min is required as more WETH can be withdrawn than deposited\n        // as the strategy earns consensus and execution rewards.\n        uint256 deductAmount = Math.min(_amount, depositedWethAccountedFor);\n        depositedWethAccountedFor -= deductAmount;\n\n        // No change in ETH balance so no need to snapshot the balances\n    }\n\n    /// @dev Converts ETH to WETH and updates the accounting.\n    /// @param _ethAmount The amount of ETH in wei.\n    function _convertEthToWeth(uint256 _ethAmount) internal {\n        // slither-disable-next-line arbitrary-send-eth\n        IWETH9(WETH).deposit{ value: _ethAmount }();\n\n        depositedWethAccountedFor += _ethAmount;\n\n        // Store the reduced ETH balance.\n        // The ETH balance in this strategy contract can be more than the last verified ETH balance\n        // due to partial withdrawals or full exits being processed by the beacon chain since the last snapBalances.\n        // It can also happen from execution rewards (MEV) or ETH donations.\n        lastVerifiedEthBalance -= Math.min(lastVerifiedEthBalance, _ethAmount);\n\n        // The ETH balance was decreased to WETH so we need to invalidate the last balances snap.\n        snappedBalance.timestamp = 0;\n    }\n\n    /// @dev Converts WETH to ETH and updates the accounting.\n    /// @param _wethAmount The amount of WETH in wei.\n    function _convertWethToEth(uint256 _wethAmount) internal {\n        IWETH9(WETH).withdraw(_wethAmount);\n\n        uint256 deductAmount = Math.min(_wethAmount, depositedWethAccountedFor);\n        depositedWethAccountedFor -= deductAmount;\n\n        // Store the increased ETH balance\n        lastVerifiedEthBalance += _wethAmount;\n\n        // The ETH balance was increased from WETH so we need to invalidate the last balances snap.\n        snappedBalance.timestamp = 0;\n    }\n\n    /**\n     *\n     *             View Functions\n     *\n     */\n\n    /// @notice Returns the number of deposits waiting to be verified as processed on the beacon chain,\n    /// or deposits that have been verified to an exiting validator and is now waiting for the\n    /// validator's balance to be swept.\n    function depositListLength() external view returns (uint256) {\n        return depositList.length;\n    }\n\n    /// @notice Returns the number of verified validators.\n    function verifiedValidatorsLength() external view returns (uint256) {\n        return verifiedValidators.length;\n    }\n}\n"
    },
    "contracts/strategies/NativeStaking/ConsolidationController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { CompoundingStakingSSVStrategy, CompoundingValidatorManager } from \"./CompoundingStakingSSVStrategy.sol\";\nimport { ValidatorAccountant } from \"./ValidatorAccountant.sol\";\nimport { Cluster } from \"../../interfaces/ISSVNetwork.sol\";\n\n/// @title Consolidation Controller\n/// @notice Orchestrates the consolidation of validators from old Native Staking Strategies\n/// to the new Compounding Staking Strategy.\n/// @author Origin Protocol Inc\ncontract ConsolidationController is Ownable {\n    /// @dev Minimum time that must pass before a consolidation request can be processed.\n    /// 256 epochs * 32 slots/epoch * 12 seconds/slot = 98304 seconds (~27 hours)\n    /// The actual time can be a lot longer than this depending on the number of\n    /// requests in the beacon chain's pending consolidation queue.\n    uint256 internal constant MIN_CONSOLIDATION_PERIOD = 256 * 32 * 12;\n\n    /// @notice Address of the validator registrator account\n    address public immutable validatorRegistrator;\n    /// @dev The old Native Staking Strategy connected to the second SSV cluster\n    address internal immutable nativeStakingStrategy2;\n    /// @dev The old Native Staking Strategy connected to the third SSV cluster\n    address internal immutable nativeStakingStrategy3;\n    /// @dev The new Compounding Staking Strategy\n    CompoundingStakingSSVStrategy internal immutable targetStrategy;\n\n    /// @notice Number of validators being consolidated\n    uint64 public consolidationCount;\n    /// @notice Timestamp when the consolidation process was requested\n    uint64 public consolidationStartTimestamp;\n    /// @notice The address of the source Native Staking Strategy being consolidated from\n    address public sourceStrategy;\n    /// @notice The public key hash of the target validator on the new Compounding Staking Strategy\n    bytes32 public targetPubKeyHash;\n\n    /// @dev Throws if called by any account other than the Validator Registrator\n    modifier onlyRegistrator() {\n        require(\n            msg.sender == validatorRegistrator,\n            \"Caller is not the Registrator\"\n        );\n        _;\n    }\n\n    /// @param _owner The owner who can request, fail and confirm consolidations\n    /// @param _validatorRegistrator The validator registrator who does operations on the old staking strategy\n    constructor(\n        address _owner,\n        address _validatorRegistrator,\n        address _nativeStakingStrategy2,\n        address _nativeStakingStrategy3,\n        address _targetStrategy\n    ) {\n        _transferOwnership(_owner);\n\n        validatorRegistrator = _validatorRegistrator;\n        nativeStakingStrategy2 = _nativeStakingStrategy2;\n        nativeStakingStrategy3 = _nativeStakingStrategy3;\n        targetStrategy = CompoundingStakingSSVStrategy(\n            payable(_targetStrategy)\n        );\n    }\n\n    /**\n     * @notice Request consolidation of validators from an old Native Staking Strategy\n     * to the new Compounding Staking Strategy\n     * @param _sourceStrategy The address of the old Native Staking Strategy\n     * @param sourcePubKeys The public keys of the validators to be consolidated from the old Native Staking Strategy\n     * @param targetPubKey The public key of the target validator on the new Compounding Staking Strategy\n     */\n    function requestConsolidation(\n        address _sourceStrategy,\n        bytes[] calldata sourcePubKeys,\n        bytes calldata targetPubKey\n    ) external payable onlyOwner {\n        // Check no consolidations are already in progress\n        require(consolidationCount == 0, \"Consolidation in progress\");\n        // Check sourceStrategy is a valid old Native Staking Strategy\n        _checkSourceStrategy(_sourceStrategy);\n\n        // Check target validator is Active on the new Compounding Staking Strategy\n        bytes32 targetPubKeyHashMem = _hashPubKey(targetPubKey);\n        (CompoundingStakingSSVStrategy.ValidatorState state, ) = targetStrategy\n            .validator(targetPubKeyHashMem);\n        require(\n            state == CompoundingValidatorManager.ValidatorState.ACTIVE,\n            \"Target validator not active\"\n        );\n        // Check no pending deposits in the new target validator\n        require(\n            _hasPendingDeposit(targetPubKeyHashMem) == false,\n            \"Target has pending deposit\"\n        );\n\n        // Store the state at the start of the consolidation process\n        consolidationCount = SafeCast.toUint64(sourcePubKeys.length);\n        consolidationStartTimestamp = uint64(block.timestamp);\n        sourceStrategy = _sourceStrategy;\n        targetPubKeyHash = targetPubKeyHashMem;\n\n        // Call requestConsolidation on the old Native Staking Strategy\n        // to initiate the consolidations\n        ValidatorAccountant(_sourceStrategy).requestConsolidation{\n            value: msg.value\n        }(sourcePubKeys, targetPubKey);\n\n        // Snap the balances for the last time on the new Compounding Staking Strategy\n        // until the consolidations are confirmed\n        targetStrategy.snapBalances();\n\n        // No event emitted as ConsolidationRequested is emitted from the old Native Staking Strategy\n    }\n\n    /**\n     * @notice A consolidation request can fail to be processed on the beacon chain\n     * for various reasons. For example, the pending consolidation queue is full with 262,144 requests.\n     * Or the source validator has exited from a voluntary exit request.\n     * This reduces the consolidation count and changes the validator state back to STAKED.\n     * @param sourcePubKeys The public keys of the source validators that failed to be consolidated.\n     */\n    function failConsolidation(bytes[] calldata sourcePubKeys)\n        external\n        onlyOwner\n    {\n        // Check consolidations are in progress\n        require(consolidationCount > 0, \"No consolidation in progress\");\n        require(\n            sourcePubKeys.length <= consolidationCount,\n            \"Exceeds consolidation count\"\n        );\n\n        // Read into memory in case it gets reset in storage before\n        // the external call to the source strategy\n        address sourceStrategyMem = sourceStrategy;\n\n        // Store updated consolidation state\n        consolidationCount -= SafeCast.toUint64(sourcePubKeys.length);\n        if (consolidationCount == 0) {\n            // Reset the rest of the consolidation state\n            consolidationStartTimestamp = 0;\n            sourceStrategy = address(0);\n            targetPubKeyHash = bytes32(0);\n        }\n\n        ValidatorAccountant(sourceStrategyMem).failConsolidation(sourcePubKeys);\n\n        // No event emitted as ConsolidationFailed is emitted from the old Native Staking Strategy\n    }\n\n    /**\n     * @notice Confirm the consolidation of validators from an old Native Staking Strategy\n     * to the new Compounding Staking Strategy has been completed.\n     * @param balanceProofs a `BalanceProofs` struct containing the following:\n     * - balancesContainerRoot: The merkle root of the balances container\n     * - balancesContainerProof: The merkle proof for the balances container to the beacon block root.\n     *    This is 9 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n     * - validatorBalanceLeaves: Array of leaf nodes containing the validator balance with three other balances.\n     * - validatorBalanceProofs: Array of merkle proofs for the validator balance to the Balances container root.\n     *    This is 39 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n     * @param pendingDepositProofs a `PendingDepositProofs` struct containing the following:\n     * - pendingDepositContainerRoot: The merkle root of the pending deposits list container\n     * - pendingDepositContainerProof: The merkle proof from the pending deposits list container\n     *     to the beacon block root.\n     *    This is 9 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n     * - pendingDepositIndexes: Array of indexes in the pending deposits list container for each\n     *    of the strategy's deposits.\n     * - pendingDepositProofs: Array of merkle proofs for each strategy deposit in the\n     *    beacon chain's pending deposit list container to the pending deposits list container root.\n     *    These are 28 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n     */\n    function confirmConsolidation(\n        CompoundingValidatorManager.BalanceProofs calldata balanceProofs,\n        CompoundingValidatorManager.PendingDepositProofs\n            calldata pendingDepositProofs\n    ) external onlyOwner {\n        // Check consolidations are in progress\n        require(consolidationCount > 0, \"No consolidation in progress\");\n        // There a min time before a consolidation can be processed on the beacon chain\n        (, uint64 snappedTimestamp, ) = targetStrategy.snappedBalance();\n        require(\n            uint64(snappedTimestamp) >\n                consolidationStartTimestamp + MIN_CONSOLIDATION_PERIOD,\n            \"Source not withdrawable\"\n        );\n\n        // Load into memory as the storage is about to be reset.\n        // These are used in the external contract calls\n        address sourceStrategyMem = sourceStrategy;\n        uint256 consolidationCountMem = consolidationCount;\n\n        // Reset consolidation state before external calls\n        consolidationCount = 0;\n        consolidationStartTimestamp = 0;\n        sourceStrategy = address(0);\n        targetPubKeyHash = bytes32(0);\n\n        // Verify balances on the new Compounding Staking Strategy and update the strategy's balance\n        targetStrategy.verifyBalances(balanceProofs, pendingDepositProofs);\n\n        // Reduce the balance of the old Native Staking Strategy\n        ValidatorAccountant(sourceStrategyMem).confirmConsolidation(\n            consolidationCountMem\n        );\n\n        // No event emitted as ConsolidationConfirmed is emitted from the old Native Staking Strategy\n    }\n\n    /**\n     *\n     *   Functions that forward to the old Native Staking Strategy\n     *\n     */\n\n    /// @notice The validator registrator of the old Native Staking Strategy can call doAccounting\n    /// @param _sourceStrategy The address of the old Native Staking Strategy\n    /// @return accountingValid true if accounting was successful, false if fuse is blown\n    function doAccounting(address _sourceStrategy)\n        external\n        onlyRegistrator\n        returns (bool accountingValid)\n    {\n        // Check sourceStrategy is a valid old Native Staking Strategy\n        _checkSourceStrategy(_sourceStrategy);\n\n        return ValidatorAccountant(_sourceStrategy).doAccounting();\n    }\n\n    /**\n     * @notice Exit of source validators are allowed during the consolidation process\n     * as consolidated validators will be in EXITING state hence can not be consolidated after exit.\n     * Only callable by the validator registrator.\n     * @param _sourceStrategy The address of the old Native Staking Strategy\n     * @param publicKey The public key of the validator to exit which must have STAKED state.\n     * @param operatorIds The operator IDs for the source SSV cluster\n     */\n    function exitSsvValidator(\n        address _sourceStrategy,\n        bytes calldata publicKey,\n        uint64[] calldata operatorIds\n    ) external onlyRegistrator {\n        // Check sourceStrategy is a valid old Native Staking Strategy\n        _checkSourceStrategy(_sourceStrategy);\n\n        ValidatorAccountant(_sourceStrategy).exitSsvValidator(\n            publicKey,\n            operatorIds\n        );\n    }\n\n    /**\n     * @notice Removing source validators is not allowed during the consolidation process\n     * as consolidated validators will be in EXITING state hence can not be consolidated after removal.\n     * Only callable by the validator registrator.\n     * @param _sourceStrategy The address of the old Native Staking Strategy\n     * @param publicKey The public key of the validator to remove which must have EXITING or REGISTERED state.\n     * @param operatorIds The operator IDs for the source SSV cluster\n     * @param cluster The SSV cluster information for the source validator\n     */\n    function removeSsvValidator(\n        address _sourceStrategy,\n        bytes calldata publicKey,\n        uint64[] calldata operatorIds,\n        Cluster calldata cluster\n    ) external onlyRegistrator {\n        // Check sourceStrategy is a valid old Native Staking Strategy\n        _checkSourceStrategy(_sourceStrategy);\n        // Prevent removing a validator from the SSV cluster before the consolidation\n        // process has been completed.\n        // This prevents validators that have been exited rather than consolidated but that's ok.\n        // The exited validator can be removed after the consolidation process is complete.\n        require(consolidationCount == 0, \"Consolidation in progress\");\n\n        ValidatorAccountant(_sourceStrategy).removeSsvValidator(\n            publicKey,\n            operatorIds,\n            cluster\n        );\n    }\n\n    /**\n     *\n     *   Functions that forward to the new Compounding Staking Strategy\n     *\n     */\n\n    /// @notice Forwards to the new Compounding Staking Strategy.\n    /// Is only callable by the validator registrator when a consolidation is in progress.\n    /// Anyone can call when there are no consolidations in progress.\n    function snapBalances() external {\n        if (consolidationCount > 0 && msg.sender != validatorRegistrator) {\n            revert(\"Consolidation in progress\");\n        }\n\n        targetStrategy.snapBalances();\n    }\n\n    /**\n     * @notice Anyone can verify balances on the new Compounding Staking Strategy\n     * as long as there are no consolidations in progress.\n     * @param balanceProofs a `BalanceProofs` struct containing the following:\n     * - balancesContainerRoot: The merkle root of the balances container\n     * - balancesContainerProof: The merkle proof for the balances container to the beacon block root.\n     *    This is 9 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n     * - validatorBalanceLeaves: Array of leaf nodes containing the validator balance with three other balances.\n     * - validatorBalanceProofs: Array of merkle proofs for the validator balance to the Balances container root.\n     *    This is 39 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n     * @param pendingDepositProofs a `PendingDepositProofs` struct containing the following:\n     * - pendingDepositContainerRoot: The merkle root of the pending deposits list container\n     * - pendingDepositContainerProof: The merkle proof from the pending deposits list container\n     *     to the beacon block root.\n     *    This is 9 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n     * - pendingDepositIndexes: Array of indexes in the pending deposits list container for each\n     *    of the strategy's deposits.\n     * - pendingDepositProofs: Array of merkle proofs for each strategy deposit in the\n     *    beacon chain's pending deposit list container to the pending deposits list container root.\n     *    These are 28 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n     */\n    function verifyBalances(\n        CompoundingValidatorManager.BalanceProofs calldata balanceProofs,\n        CompoundingValidatorManager.PendingDepositProofs\n            calldata pendingDepositProofs\n    ) external {\n        (, uint64 snappedTimestamp, ) = targetStrategy.snappedBalance();\n        // Can not verify balances while consolidations are in progress\n        // but can if the snapped balance is the start of the consolidation process.\n        // That is, snappedTimestamp == consolidationStartTimestamp\n        if (\n            consolidationCount > 0 &&\n            snappedTimestamp != consolidationStartTimestamp\n        ) {\n            revert(\"Consolidation in progress\");\n        }\n\n        targetStrategy.verifyBalances(balanceProofs, pendingDepositProofs);\n    }\n\n    /// @notice Partial withdrawals are allowed during consolidation from the new Compounding Staking Strategy.\n    /// This includes partial withdrawals from the target validator.\n    // Full validator exits from any Compounding Staking Strategy validator are\n    /// not allowed during the migration period.\n    /// Only the registrator can call this function.\n    /// @param publicKey The public key of the validator\n    /// @param amountGwei The amount of ETH to be withdrawn from the validator in Gwei.\n    /// A zero amount is not allowed.\n    function validatorWithdrawal(bytes calldata publicKey, uint64 amountGwei)\n        external\n        payable\n        onlyRegistrator\n    {\n        // Prevent full exits from any new compounding validators.\n        // This includes when there is no consolidation in progress.\n        // This reduces the risk of an exit request being processed before a consolidation request\n        require(amountGwei > 0, \"No exit during migration\");\n        targetStrategy.validatorWithdrawal{ value: msg.value }(\n            publicKey,\n            amountGwei\n        );\n    }\n\n    /**\n     * @notice Deposits to Compounding Staking Strategy validators that are\n     * not the target of a consolidation are allowed.\n     * Only the registrator can call this function.\n     * @param validatorStakeData validator data needed to stake.\n     * The `ValidatorStakeData` struct contains the pubkey, signature and depositDataRoot.\n     * @param depositAmountGwei The amount of WETH to stake to the validator in Gwei.\n     */\n    function stakeEth(\n        CompoundingValidatorManager.ValidatorStakeData\n            calldata validatorStakeData,\n        uint64 depositAmountGwei\n    ) external onlyRegistrator {\n        require(\n            _hashPubKey(validatorStakeData.pubkey) != targetPubKeyHash,\n            \"Stake to consolidation target\"\n        );\n\n        targetStrategy.stakeEth(validatorStakeData, depositAmountGwei);\n    }\n\n    /// removeSsvValidator from the new Compounding Staking Strategy is not allowed until after\n    /// all the validators have been consolidated. This is done by restoring the validator registrator\n    /// back to the account used before the consolidation upgrades.\n\n    /**\n     *\n     *      Internal Functions\n     *\n     */\n\n    /// @dev Check if there are any pending deposits for a validator with a given public key hash.\n    /// Need to iterate over the target strategys `deposits`\n    /// @return True if there is at least one pending deposit for the validator\n    function _hasPendingDeposit(bytes32 _targetPubKeyHash)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 depositsCount = targetStrategy.depositListLength();\n        for (uint256 i = 0; i < depositsCount; ++i) {\n            (\n                bytes32 depositPubKeyHash,\n                ,\n                ,\n                ,\n                CompoundingValidatorManager.DepositStatus status\n            ) = targetStrategy.deposits(targetStrategy.depositList(i));\n            if (\n                depositPubKeyHash == _targetPubKeyHash &&\n                status == CompoundingValidatorManager.DepositStatus.PENDING\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// @dev Hash a validator public key using the Beacon Chain's format\n    /// @param pubKey The full validator public key\n    /// @return The hashed public key using the Beacon Chain's hashing for BLSPubkey\n    function _hashPubKey(bytes memory pubKey) internal pure returns (bytes32) {\n        require(pubKey.length == 48, \"Invalid public key\");\n        return sha256(abi.encodePacked(pubKey, bytes16(0)));\n    }\n\n    /// @dev Check source strategy is a valid old Native Staking Strategy\n    /// @param _sourceStrategy The address of the old Native Staking Strategy\n    function _checkSourceStrategy(address _sourceStrategy) internal view {\n        require(\n            _sourceStrategy == nativeStakingStrategy2 ||\n                _sourceStrategy == nativeStakingStrategy3,\n            \"Invalid source strategy\"\n        );\n    }\n}\n"
    },
    "contracts/strategies/NativeStaking/ValidatorAccountant.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ValidatorRegistrator } from \"./ValidatorRegistrator.sol\";\nimport { IWETH9 } from \"../../interfaces/IWETH9.sol\";\n\n/// @title Validator Accountant\n/// @notice Attributes the ETH swept from beacon chain validators to this strategy contract\n/// as either full or partial withdrawals. Partial withdrawals being consensus rewards.\n/// Full withdrawals are from exited validators.\n/// @author Origin Protocol Inc\nabstract contract ValidatorAccountant is ValidatorRegistrator {\n    /// @notice The minimum amount of blocks that need to pass between two calls to manuallyFixAccounting\n    uint256 public constant MIN_FIX_ACCOUNTING_CADENCE = 7200; // 1 day\n\n    /// @notice Keeps track of the total consensus rewards swept from the beacon chain\n    uint256 public consensusRewards;\n\n    /// @notice start of fuse interval\n    uint256 public fuseIntervalStart;\n    /// @notice end of fuse interval\n    uint256 public fuseIntervalEnd;\n    /// @notice last block number manuallyFixAccounting has been called\n    uint256 public lastFixAccountingBlockNumber;\n\n    uint256[49] private __gap;\n\n    event FuseIntervalUpdated(uint256 start, uint256 end);\n    event AccountingFullyWithdrawnValidator(\n        uint256 noOfValidators,\n        uint256 remainingValidators,\n        uint256 wethSentToVault\n    );\n    event AccountingValidatorSlashed(\n        uint256 remainingValidators,\n        uint256 wethSentToVault\n    );\n    event AccountingConsensusRewards(uint256 amount);\n\n    event AccountingManuallyFixed(\n        int256 validatorsDelta,\n        int256 consensusRewardsDelta,\n        uint256 wethToVault\n    );\n\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\n    /// @param _vaultAddress Address of the Vault\n    /// @param _beaconChainDepositContract Address of the beacon chain deposit contract\n    /// @param _ssvNetwork Address of the SSV Network contract\n    /// @param _maxValidators Maximum number of validators that can be registered in the strategy\n    constructor(\n        address _wethAddress,\n        address _vaultAddress,\n        address _beaconChainDepositContract,\n        address _ssvNetwork,\n        uint256 _maxValidators\n    )\n        ValidatorRegistrator(\n            _wethAddress,\n            _vaultAddress,\n            _beaconChainDepositContract,\n            _ssvNetwork,\n            _maxValidators\n        )\n    {}\n\n    /// @notice set fuse interval values\n    function setFuseInterval(\n        uint256 _fuseIntervalStart,\n        uint256 _fuseIntervalEnd\n    ) external onlyGovernor {\n        require(\n            _fuseIntervalStart < _fuseIntervalEnd &&\n                _fuseIntervalEnd < 32 ether &&\n                _fuseIntervalEnd - _fuseIntervalStart >= 4 ether,\n            \"Incorrect fuse interval\"\n        );\n\n        fuseIntervalStart = _fuseIntervalStart;\n        fuseIntervalEnd = _fuseIntervalEnd;\n\n        emit FuseIntervalUpdated(_fuseIntervalStart, _fuseIntervalEnd);\n    }\n\n    /* solhint-disable max-line-length */\n    /// This notion page offers a good explanation of how the accounting functions\n    /// https://www.notion.so/originprotocol/Limited-simplified-native-staking-accounting-67a217c8420d40678eb943b9da0ee77d\n    /// In short, after dividing by 32, if the ETH remaining on the contract falls between 0 and fuseIntervalStart,\n    /// the accounting function will treat that ETH as Beacon chain consensus rewards.\n    /// On the contrary, if after dividing by 32, the ETH remaining on the contract falls between fuseIntervalEnd and 32,\n    /// the accounting function will treat that as a validator slashing.\n    /// @notice Perform the accounting attributing beacon chain ETH to either full or partial withdrawals. Returns true when\n    /// accounting is valid and fuse isn't \"blown\". Returns false when fuse is blown.\n    /// @dev This function could in theory be permission-less but lets allow only the Registrator (Defender Action) to call it\n    /// for now.\n    /// @return accountingValid true if accounting was successful, false if fuse is blown\n    /* solhint-enable max-line-length */\n    function doAccounting()\n        external\n        onlyRegistrator\n        whenNotPaused\n        nonReentrant\n        returns (bool accountingValid)\n    {\n        // pause the accounting on failure\n        accountingValid = _doAccounting(true);\n    }\n\n    // slither-disable-start reentrancy-eth\n    function _doAccounting(bool pauseOnFail)\n        internal\n        returns (bool accountingValid)\n    {\n        if (address(this).balance < consensusRewards) {\n            return _failAccounting(pauseOnFail);\n        }\n\n        // Calculate all the new ETH that has been swept to the contract since the last accounting\n        uint256 newSweptETH = address(this).balance - consensusRewards;\n        accountingValid = true;\n\n        // send the ETH that is from fully withdrawn validators to the Vault\n        if (newSweptETH >= FULL_STAKE) {\n            uint256 fullyWithdrawnValidators;\n            // explicitly cast to uint256 as we want to round to a whole number of validators\n            fullyWithdrawnValidators = uint256(newSweptETH / FULL_STAKE);\n            activeDepositedValidators -= fullyWithdrawnValidators;\n\n            uint256 wethToVault = FULL_STAKE * fullyWithdrawnValidators;\n            IWETH9(WETH).deposit{ value: wethToVault }();\n            // slither-disable-next-line unchecked-transfer\n            IWETH9(WETH).transfer(VAULT_ADDRESS, wethToVault);\n            _wethWithdrawnToVault(wethToVault);\n\n            emit AccountingFullyWithdrawnValidator(\n                fullyWithdrawnValidators,\n                activeDepositedValidators,\n                wethToVault\n            );\n        }\n\n        uint256 ethRemaining = address(this).balance - consensusRewards;\n        // should be less than a whole validator stake\n        require(ethRemaining < FULL_STAKE, \"Unexpected accounting\");\n\n        // If no Beacon chain consensus rewards swept\n        if (ethRemaining == 0) {\n            // do nothing\n            return accountingValid;\n        } else if (ethRemaining < fuseIntervalStart) {\n            // Beacon chain consensus rewards swept (partial validator withdrawals)\n            // solhint-disable-next-line reentrancy\n            consensusRewards += ethRemaining;\n            emit AccountingConsensusRewards(ethRemaining);\n        } else if (ethRemaining > fuseIntervalEnd) {\n            // Beacon chain consensus rewards swept but also a slashed validator fully exited\n            IWETH9(WETH).deposit{ value: ethRemaining }();\n            // slither-disable-next-line unchecked-transfer\n            IWETH9(WETH).transfer(VAULT_ADDRESS, ethRemaining);\n            activeDepositedValidators -= 1;\n\n            _wethWithdrawnToVault(ethRemaining);\n\n            emit AccountingValidatorSlashed(\n                activeDepositedValidators,\n                ethRemaining\n            );\n        }\n        // Oh no... Fuse is blown. The Strategist needs to adjust the accounting values.\n        else {\n            return _failAccounting(pauseOnFail);\n        }\n    }\n\n    // slither-disable-end reentrancy-eth\n\n    /// @dev pause any further accounting if required and return false\n    function _failAccounting(bool pauseOnFail)\n        internal\n        returns (bool accountingValid)\n    {\n        // pause if not already\n        if (pauseOnFail) {\n            _pause();\n        }\n        // fail the accounting\n        accountingValid = false;\n    }\n\n    /// @notice Allow the Strategist to fix the accounting of this strategy and unpause.\n    /// @param _validatorsDelta adjust the active validators by up to plus three or minus three\n    /// @param _consensusRewardsDelta adjust the accounted for consensus rewards up or down\n    /// @param _ethToVaultAmount the amount of ETH that gets wrapped into WETH and sent to the Vault\n    /// @dev There is a case when a validator(s) gets slashed so much that the eth swept from\n    /// the beacon chain enters the fuse area and there are no consensus rewards on the contract\n    /// to \"dip into\"/use. To increase the amount of unaccounted ETH over the fuse end interval\n    /// we need to reduce the amount of active deposited validators and immediately send WETH\n    /// to the vault, so it doesn't interfere with further accounting.\n    function manuallyFixAccounting(\n        int256 _validatorsDelta,\n        int256 _consensusRewardsDelta,\n        uint256 _ethToVaultAmount\n    ) external onlyStrategist whenPaused nonReentrant {\n        require(\n            lastFixAccountingBlockNumber + MIN_FIX_ACCOUNTING_CADENCE <\n                block.number,\n            \"Fix accounting called too soon\"\n        );\n        require(\n            _validatorsDelta >= -3 &&\n                _validatorsDelta <= 3 &&\n                // new value must be positive\n                int256(activeDepositedValidators) + _validatorsDelta >= 0,\n            \"Invalid validatorsDelta\"\n        );\n        require(\n            _consensusRewardsDelta >= -332 ether &&\n                _consensusRewardsDelta <= 332 ether &&\n                // new value must be positive\n                int256(consensusRewards) + _consensusRewardsDelta >= 0,\n            \"Invalid consensusRewardsDelta\"\n        );\n        require(_ethToVaultAmount <= 32 ether * 3, \"Invalid wethToVaultAmount\");\n\n        activeDepositedValidators = uint256(\n            int256(activeDepositedValidators) + _validatorsDelta\n        );\n        consensusRewards = uint256(\n            int256(consensusRewards) + _consensusRewardsDelta\n        );\n        lastFixAccountingBlockNumber = block.number;\n        if (_ethToVaultAmount > 0) {\n            IWETH9(WETH).deposit{ value: _ethToVaultAmount }();\n            // slither-disable-next-line unchecked-transfer\n            IWETH9(WETH).transfer(VAULT_ADDRESS, _ethToVaultAmount);\n            _wethWithdrawnToVault(_ethToVaultAmount);\n        }\n\n        emit AccountingManuallyFixed(\n            _validatorsDelta,\n            _consensusRewardsDelta,\n            _ethToVaultAmount\n        );\n\n        // rerun the accounting to see if it has now been fixed.\n        // Do not pause the accounting on failure as it is already paused\n        require(_doAccounting(false), \"Fuse still blown\");\n\n        // unpause since doAccounting was successful\n        _unpause();\n    }\n\n    /***************************************\n                 Abstract\n    ****************************************/\n\n    /// @dev allows for NativeStakingSSVStrategy contract to emit the Withdrawal event\n    function _wethWithdrawnToVault(uint256 _amount) internal virtual;\n}\n"
    },
    "contracts/strategies/NativeStaking/ValidatorRegistrator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { Governable } from \"../../governance/Governable.sol\";\nimport { IDepositContract } from \"../../interfaces/IDepositContract.sol\";\nimport { IVault } from \"../../interfaces/IVault.sol\";\nimport { IWETH9 } from \"../../interfaces/IWETH9.sol\";\nimport { ISSVNetwork, Cluster } from \"../../interfaces/ISSVNetwork.sol\";\nimport { BeaconConsolidation } from \"../../beacon/BeaconConsolidation.sol\";\n\nstruct ValidatorStakeData {\n    bytes pubkey;\n    bytes signature;\n    bytes32 depositDataRoot;\n}\n\n/**\n * @title Registrator of the validators\n * @notice This contract implements all the required functionality to register, exit and remove validators.\n * @author Origin Protocol Inc\n */\nabstract contract ValidatorRegistrator is Governable, Pausable {\n    /// @notice The maximum amount of ETH that can be staked by a validator\n    /// @dev this can change in the future with EIP-7251, Increase the MAX_EFFECTIVE_BALANCE\n    uint256 public constant FULL_STAKE = 32 ether;\n\n    /// @notice The address of the Wrapped ETH (WETH) token contract\n    address public immutable WETH;\n    /// @notice The address of the beacon chain deposit contract\n    address public immutable BEACON_CHAIN_DEPOSIT_CONTRACT;\n    /// @notice The address of the SSV Network contract used to interface with\n    address public immutable SSV_NETWORK;\n    /// @notice Address of the OETH Vault proxy contract\n    address public immutable VAULT_ADDRESS;\n    /// @notice Maximum number of validators that can be registered in this strategy\n    uint256 public immutable MAX_VALIDATORS;\n\n    /// @notice Address of the registrator - allowed to register, exit and remove validators\n    address public validatorRegistrator;\n    /// @notice The number of validators that have 32 (!) ETH actively deposited. When a new deposit\n    /// to a validator happens this number increases, when a validator exit is detected this number\n    /// decreases.\n    uint256 public activeDepositedValidators;\n    /// @notice State of the validators keccak256(pubKey) => state\n    mapping(bytes32 => VALIDATOR_STATE) public validatorsStates;\n    /// @notice The account that is allowed to modify stakeETHThreshold and reset stakeETHTally\n    address public stakingMonitor;\n    /// @notice Amount of ETH that can be staked before staking on the contract is suspended\n    /// and the `stakingMonitor` needs to approve further staking by calling `resetStakeETHTally`\n    uint256 public stakeETHThreshold;\n    /// @notice Amount of ETH that has been staked since the `stakingMonitor` last called `resetStakeETHTally`.\n    /// This can not go above `stakeETHThreshold`.\n    uint256 public stakeETHTally;\n    // For future use\n    uint256[47] private __gap;\n\n    enum VALIDATOR_STATE {\n        NON_REGISTERED, // validator is not registered on the SSV network\n        REGISTERED, // validator is registered on the SSV network\n        STAKED, // validator has funds staked\n        EXITING, // exit message has been posted and validator is in the process of exiting\n        EXIT_COMPLETE // validator has funds withdrawn to the EigenPod and is removed from the SSV\n    }\n\n    event RegistratorChanged(address indexed newAddress);\n    event StakingMonitorChanged(address indexed newAddress);\n    event ETHStaked(bytes32 indexed pubKeyHash, bytes pubKey, uint256 amount);\n    event SSVValidatorRegistered(\n        bytes32 indexed pubKeyHash,\n        bytes pubKey,\n        uint64[] operatorIds\n    );\n    event SSVValidatorExitInitiated(\n        bytes32 indexed pubKeyHash,\n        bytes pubKey,\n        uint64[] operatorIds\n    );\n    event SSVValidatorExitCompleted(\n        bytes32 indexed pubKeyHash,\n        bytes pubKey,\n        uint64[] operatorIds\n    );\n    event ConsolidationRequested(\n        bytes[] sourcePubKeys,\n        bytes targetPubKey,\n        uint256 consolidationCount\n    );\n    event ConsolidationFailed(\n        bytes[] sourcePubKeys,\n        uint256 consolidationCount\n    );\n    event ConsolidationConfirmed(\n        uint256 consolidationCount,\n        uint256 activeDepositedValidators\n    );\n    event StakeETHThresholdChanged(uint256 amount);\n    event StakeETHTallyReset();\n\n    /// @dev Throws if called by any account other than the Registrator\n    modifier onlyRegistrator() {\n        require(\n            msg.sender == validatorRegistrator,\n            \"Caller is not the Registrator\"\n        );\n        _;\n    }\n\n    /// @dev Throws if called by any account other than the Staking monitor\n    modifier onlyStakingMonitor() {\n        require(msg.sender == stakingMonitor, \"Caller is not the Monitor\");\n        _;\n    }\n\n    /// @dev Throws if called by any account other than the Strategist\n    modifier onlyStrategist() {\n        require(\n            msg.sender == IVault(VAULT_ADDRESS).strategistAddr(),\n            \"Caller is not the Strategist\"\n        );\n        _;\n    }\n\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\n    /// @param _vaultAddress Address of the Vault\n    /// @param _beaconChainDepositContract Address of the beacon chain deposit contract\n    /// @param _ssvNetwork Address of the SSV Network contract\n    /// @param _maxValidators Maximum number of validators that can be registered in the strategy\n    constructor(\n        address _wethAddress,\n        address _vaultAddress,\n        address _beaconChainDepositContract,\n        address _ssvNetwork,\n        uint256 _maxValidators\n    ) {\n        WETH = _wethAddress;\n        BEACON_CHAIN_DEPOSIT_CONTRACT = _beaconChainDepositContract;\n        SSV_NETWORK = _ssvNetwork;\n        VAULT_ADDRESS = _vaultAddress;\n        MAX_VALIDATORS = _maxValidators;\n    }\n\n    /// @notice Set the address of the registrator which can register, exit and remove validators\n    function setRegistrator(address _address) external onlyGovernor {\n        validatorRegistrator = _address;\n        emit RegistratorChanged(_address);\n    }\n\n    /// @notice Set the address of the staking monitor that is allowed to reset stakeETHTally\n    function setStakingMonitor(address _address) external onlyGovernor {\n        stakingMonitor = _address;\n        emit StakingMonitorChanged(_address);\n    }\n\n    /// @notice Set the amount of ETH that can be staked before staking monitor\n    // needs to a approve further staking by resetting the stake ETH tally\n    function setStakeETHThreshold(uint256 _amount) external onlyGovernor {\n        stakeETHThreshold = _amount;\n        emit StakeETHThresholdChanged(_amount);\n    }\n\n    /// @notice Reset the stakeETHTally\n    function resetStakeETHTally() external onlyStakingMonitor {\n        stakeETHTally = 0;\n        emit StakeETHTallyReset();\n    }\n\n    /// @notice Stakes WETH to the node validators\n    /// @param validators A list of validator data needed to stake.\n    /// The `ValidatorStakeData` struct contains the pubkey, signature and depositDataRoot.\n    /// Only the registrator can call this function.\n    // slither-disable-start reentrancy-eth\n    function stakeEth(ValidatorStakeData[] calldata validators)\n        external\n        onlyRegistrator\n        whenNotPaused\n        nonReentrant\n    {\n        uint256 requiredETH = validators.length * FULL_STAKE;\n\n        // Check there is enough WETH from the deposits sitting in this strategy contract\n        require(\n            requiredETH <= IWETH9(WETH).balanceOf(address(this)),\n            \"Insufficient WETH\"\n        );\n        require(\n            activeDepositedValidators + validators.length <= MAX_VALIDATORS,\n            \"Max validators reached\"\n        );\n\n        require(\n            stakeETHTally + requiredETH <= stakeETHThreshold,\n            \"Staking ETH over threshold\"\n        );\n        stakeETHTally += requiredETH;\n\n        // Convert required ETH from WETH\n        IWETH9(WETH).withdraw(requiredETH);\n        _wethWithdrawn(requiredETH);\n\n        /* 0x01 to indicate that withdrawal credentials will contain an EOA address that the sweeping function\n         * can sweep funds to.\n         * bytes11(0) to fill up the required zeros\n         * remaining bytes20 are for the address\n         */\n        bytes memory withdrawalCredentials = abi.encodePacked(\n            bytes1(0x01),\n            bytes11(0),\n            address(this)\n        );\n\n        // For each validator\n        for (uint256 i = 0; i < validators.length; ++i) {\n            bytes32 pubKeyHash = keccak256(validators[i].pubkey);\n\n            require(\n                validatorsStates[pubKeyHash] == VALIDATOR_STATE.REGISTERED,\n                \"Validator not registered\"\n            );\n\n            IDepositContract(BEACON_CHAIN_DEPOSIT_CONTRACT).deposit{\n                value: FULL_STAKE\n            }(\n                validators[i].pubkey,\n                withdrawalCredentials,\n                validators[i].signature,\n                validators[i].depositDataRoot\n            );\n\n            validatorsStates[pubKeyHash] = VALIDATOR_STATE.STAKED;\n\n            emit ETHStaked(pubKeyHash, validators[i].pubkey, FULL_STAKE);\n        }\n        // save gas by changing this storage variable only once rather each time in the loop.\n        activeDepositedValidators += validators.length;\n    }\n\n    // slither-disable-end reentrancy-eth\n\n    /// @notice Registers a new validator in the SSV Cluster.\n    /// Only the registrator can call this function.\n    /// @param publicKeys The public keys of the validators\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param sharesData The shares data for each validator\n    /// @param ssvAmount The amount of SSV tokens to be deposited to the SSV cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    // slither-disable-start reentrancy-no-eth\n    function registerSsvValidators(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds,\n        bytes[] calldata sharesData,\n        uint256 ssvAmount,\n        Cluster calldata cluster\n    ) external onlyRegistrator whenNotPaused {\n        require(\n            publicKeys.length == sharesData.length,\n            \"Pubkey sharesData mismatch\"\n        );\n        // Check each public key has not already been used\n        bytes32 pubKeyHash;\n        VALIDATOR_STATE currentState;\n        for (uint256 i = 0; i < publicKeys.length; ++i) {\n            pubKeyHash = keccak256(publicKeys[i]);\n            currentState = validatorsStates[pubKeyHash];\n            require(\n                currentState == VALIDATOR_STATE.NON_REGISTERED,\n                \"Validator already registered\"\n            );\n\n            validatorsStates[pubKeyHash] = VALIDATOR_STATE.REGISTERED;\n\n            emit SSVValidatorRegistered(pubKeyHash, publicKeys[i], operatorIds);\n        }\n\n        ISSVNetwork(SSV_NETWORK).bulkRegisterValidator(\n            publicKeys,\n            operatorIds,\n            sharesData,\n            ssvAmount,\n            cluster\n        );\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice Exit a validator from the Beacon chain.\n    /// The staked ETH will eventually swept to this native staking strategy.\n    /// Only the registrator can call this function.\n    /// @param publicKey The public key of the validator\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    // slither-disable-start reentrancy-no-eth\n    function exitSsvValidator(\n        bytes calldata publicKey,\n        uint64[] calldata operatorIds\n    ) external onlyRegistrator whenNotPaused {\n        bytes32 pubKeyHash = keccak256(publicKey);\n        VALIDATOR_STATE currentState = validatorsStates[pubKeyHash];\n        require(currentState == VALIDATOR_STATE.STAKED, \"Validator not staked\");\n\n        ISSVNetwork(SSV_NETWORK).exitValidator(publicKey, operatorIds);\n\n        validatorsStates[pubKeyHash] = VALIDATOR_STATE.EXITING;\n\n        emit SSVValidatorExitInitiated(pubKeyHash, publicKey, operatorIds);\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice Remove a validator from the SSV Cluster.\n    /// Make sure `exitSsvValidator` is called before and the validate has exited the Beacon chain.\n    /// If removed before the validator has exited the beacon chain will result in the validator being slashed.\n    /// Only the registrator can call this function.\n    /// @param publicKey The public key of the validator\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    // slither-disable-start reentrancy-no-eth\n    function removeSsvValidator(\n        bytes calldata publicKey,\n        uint64[] calldata operatorIds,\n        Cluster calldata cluster\n    ) external onlyRegistrator whenNotPaused {\n        bytes32 pubKeyHash = keccak256(publicKey);\n        VALIDATOR_STATE currentState = validatorsStates[pubKeyHash];\n        // Can remove SSV validators that were incorrectly registered and can not be deposited to.\n        require(\n            currentState == VALIDATOR_STATE.EXITING ||\n                currentState == VALIDATOR_STATE.REGISTERED,\n            \"Validator not regd or exiting\"\n        );\n\n        ISSVNetwork(SSV_NETWORK).removeValidator(\n            publicKey,\n            operatorIds,\n            cluster\n        );\n\n        validatorsStates[pubKeyHash] = VALIDATOR_STATE.EXIT_COMPLETE;\n\n        emit SSVValidatorExitCompleted(pubKeyHash, publicKey, operatorIds);\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice Deposits more SSV Tokens to the SSV Network contract which is used to pay the SSV Operators.\n    /// @dev A SSV cluster is defined by the SSVOwnerAddress and the set of operatorIds.\n    /// uses \"onlyStrategist\" modifier so continuous front-running can't DOS our maintenance service\n    /// that tries to top up SSV tokens.\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param ssvAmount The amount of SSV tokens to be deposited to the SSV cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    function depositSSV(\n        uint64[] memory operatorIds,\n        uint256 ssvAmount,\n        Cluster memory cluster\n    ) external onlyStrategist {\n        ISSVNetwork(SSV_NETWORK).deposit(\n            address(this),\n            operatorIds,\n            ssvAmount,\n            cluster\n        );\n    }\n\n    /// @notice Withdraws excess SSV Tokens from the SSV Network contract which was used to pay the SSV Operators.\n    /// @dev A SSV cluster is defined by the SSVOwnerAddress and the set of operatorIds.\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param ssvAmount The amount of SSV tokens to be deposited to the SSV cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    function withdrawSSV(\n        uint64[] memory operatorIds,\n        uint256 ssvAmount,\n        Cluster memory cluster\n    ) external onlyGovernor {\n        ISSVNetwork(SSV_NETWORK).withdraw(operatorIds, ssvAmount, cluster);\n    }\n\n    /***************************************\n            Consolidation functions\n    ****************************************/\n\n    /**\n     * @notice Initiates the consolidation of multiple source sweeping validators to a single compounding validator.\n     * @dev The validator registrator should be set to the ConsolidationController contract which\n     * has checks against the target validator.\n     * @param sourcePubKeys The full public keys of the source validators to be consolidated.\n     * @param targetPubKey The full public key of the target validator to consolidate into.\n     */\n    function requestConsolidation(\n        bytes[] calldata sourcePubKeys,\n        bytes calldata targetPubKey\n    ) external payable nonReentrant whenNotPaused onlyRegistrator {\n        // Hash using the Native Staking Strategy's hashing method.\n        // This is different to the Beacon chain's method.\n        bytes32 targetPubKeyHash = keccak256(targetPubKey);\n        bytes32 sourcePubKeyHash;\n\n        // For each source validator\n        for (uint256 i = 0; i < sourcePubKeys.length; ++i) {\n            sourcePubKeyHash = keccak256(sourcePubKeys[i]);\n            require(sourcePubKeys[i].length == 48, \"Invalid source public key\");\n            require(sourcePubKeyHash != targetPubKeyHash, \"Self consolidation\");\n            require(\n                validatorsStates[sourcePubKeyHash] == VALIDATOR_STATE.STAKED,\n                \"Source validator not staked\"\n            );\n\n            // Store the state of the source validator as exiting so it can be removed\n            // after the consolidation is confirmed\n            validatorsStates[sourcePubKeyHash] = VALIDATOR_STATE.EXITING;\n\n            // Request consolidation from source to target validator\n            BeaconConsolidation.request(sourcePubKeys[i], targetPubKey);\n        }\n\n        emit ConsolidationRequested(\n            sourcePubKeys,\n            targetPubKey,\n            sourcePubKeys.length\n        );\n    }\n\n    /**\n     * @notice A consolidation request can fail to be processed on the beacon chain\n     * for various reasons. For example, the pending consolidation queue is full with 262,144 requests.\n     * This restores the validator states back to STAKED so they can be consolidated again or exited.\n     * @param sourcePubKeys The full public keys of the source validators that failed to be consolidated.\n     */\n    function failConsolidation(bytes[] calldata sourcePubKeys)\n        external\n        nonReentrant\n        whenNotPaused\n        onlyRegistrator\n    {\n        bytes32 sourcePubKeyHash;\n\n        // For each failed source validator\n        for (uint256 i = 0; i < sourcePubKeys.length; ++i) {\n            require(sourcePubKeys[i].length == 48, \"Invalid source public key\");\n            sourcePubKeyHash = keccak256(sourcePubKeys[i]);\n            require(\n                validatorsStates[sourcePubKeyHash] == VALIDATOR_STATE.EXITING,\n                \"Source validator not exiting\"\n            );\n\n            // Store the state of the source validator back to staked\n            validatorsStates[sourcePubKeyHash] = VALIDATOR_STATE.STAKED;\n        }\n\n        emit ConsolidationFailed(sourcePubKeys, sourcePubKeys.length);\n    }\n\n    /**\n     * @notice Confirms that a consolidation has completed successfully on the beacon chain.\n     * This reduces the number of active deposited validators managed by this strategy which\n     * reduces the strategy's balance.\n     * @param consolidationCount The number of source validators that were consolidated.\n     */\n    function confirmConsolidation(uint256 consolidationCount)\n        external\n        nonReentrant\n        whenNotPaused\n        onlyRegistrator\n    {\n        // Store the reduced number of active deposited validators\n        // managed by this strategy\n        activeDepositedValidators -= consolidationCount;\n\n        emit ConsolidationConfirmed(\n            consolidationCount,\n            activeDepositedValidators\n        );\n    }\n\n    /***************************************\n                 Abstract\n    ****************************************/\n\n    /// @dev Called when WETH is withdrawn from the strategy or staked to a validator so\n    /// the strategy knows how much WETH it has on deposit.\n    /// This is so it can emit the correct amount in the Deposit event in depositAll().\n    function _wethWithdrawn(uint256 _amount) internal virtual;\n}\n"
    },
    "contracts/token/OUSD.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD Token Contract\n * @dev ERC20 compatible contract for OUSD\n * @dev Implements an elastic supply\n * @author Origin Protocol Inc\n */\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\ncontract OUSD is Governable {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n\n    /// @dev Event triggered when the supply changes\n    /// @param totalSupply Updated token total supply\n    /// @param rebasingCredits Updated token rebasing credits\n    /// @param rebasingCreditsPerToken Updated token rebasing credits per token\n    event TotalSupplyUpdatedHighres(\n        uint256 totalSupply,\n        uint256 rebasingCredits,\n        uint256 rebasingCreditsPerToken\n    );\n    /// @dev Event triggered when an account opts in for rebasing\n    /// @param account Address of the account\n    event AccountRebasingEnabled(address account);\n    /// @dev Event triggered when an account opts out of rebasing\n    /// @param account Address of the account\n    event AccountRebasingDisabled(address account);\n    /// @dev Emitted when `value` tokens are moved from one account `from` to\n    ///      another `to`.\n    /// @param from Address of the account tokens are moved from\n    /// @param to Address of the account tokens are moved to\n    /// @param value Amount of tokens transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set by\n    ///      a call to {approve}. `value` is the new allowance.\n    /// @param owner Address of the owner approving allowance\n    /// @param spender Address of the spender allowance is granted to\n    /// @param value Amount of tokens spender can transfer\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    /// @dev Yield resulting from {changeSupply} that a `source` account would\n    ///      receive is directed to `target` account.\n    /// @param source Address of the source forwarding the yield\n    /// @param target Address of the target receiving the yield\n    event YieldDelegated(address source, address target);\n    /// @dev Yield delegation from `source` account to the `target` account is\n    ///      suspended.\n    /// @param source Address of the source suspending yield forwarding\n    /// @param target Address of the target no longer receiving yield from `source`\n    ///        account\n    event YieldUndelegated(address source, address target);\n\n    enum RebaseOptions {\n        NotSet,\n        StdNonRebasing,\n        StdRebasing,\n        YieldDelegationSource,\n        YieldDelegationTarget\n    }\n\n    uint256[154] private _gap; // Slots to align with deployed contract\n    uint256 private constant MAX_SUPPLY = type(uint128).max;\n    /// @dev The amount of tokens in existence\n    uint256 public totalSupply;\n    mapping(address => mapping(address => uint256)) private allowances;\n    /// @dev The vault with privileges to execute {mint}, {burn}\n    ///     and {changeSupply}\n    address public vaultAddress;\n    mapping(address => uint256) internal creditBalances;\n    // the 2 storage variables below need trailing underscores to not name collide with public functions\n    uint256 private rebasingCredits_; // Sum of all rebasing credits (creditBalances for rebasing accounts)\n    uint256 private rebasingCreditsPerToken_;\n    /// @dev The amount of tokens that are not rebasing - receiving yield\n    uint256 public nonRebasingSupply;\n    mapping(address => uint256) internal alternativeCreditsPerToken;\n    /// @dev A map of all addresses and their respective RebaseOptions\n    mapping(address => RebaseOptions) public rebaseState;\n    mapping(address => uint256) private __deprecated_isUpgraded;\n    /// @dev A map of addresses that have yields forwarded to. This is an\n    ///      inverse mapping of {yieldFrom}\n    /// Key Account forwarding yield\n    /// Value Account receiving yield\n    mapping(address => address) public yieldTo;\n    /// @dev A map of addresses that are receiving the yield. This is an\n    ///      inverse mapping of {yieldTo}\n    /// Key Account receiving yield\n    /// Value Account forwarding yield\n    mapping(address => address) public yieldFrom;\n\n    uint256 private constant RESOLUTION_INCREASE = 1e9;\n    uint256[34] private __gap; // including below gap totals up to 200\n\n    /// @dev Verifies that the caller is the Governor or Strategist.\n    modifier onlyGovernorOrStrategist() {\n        require(\n            isGovernor() || msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    /// @dev Initializes the contract and sets necessary variables.\n    /// @param _vaultAddress Address of the vault contract\n    /// @param _initialCreditsPerToken The starting rebasing credits per token.\n    function initialize(address _vaultAddress, uint256 _initialCreditsPerToken)\n        external\n        onlyGovernor\n    {\n        require(_vaultAddress != address(0), \"Zero vault address\");\n        require(vaultAddress == address(0), \"Already initialized\");\n\n        rebasingCreditsPerToken_ = _initialCreditsPerToken;\n        vaultAddress = _vaultAddress;\n    }\n\n    /// @dev Returns the symbol of the token, a shorter version\n    ///      of the name.\n    function symbol() external pure virtual returns (string memory) {\n        return \"OUSD\";\n    }\n\n    /// @dev Returns the name of the token.\n    function name() external pure virtual returns (string memory) {\n        return \"Origin Dollar\";\n    }\n\n    /// @dev Returns the number of decimals used to get its user representation.\n    function decimals() external pure virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault contract\n     */\n    modifier onlyVault() {\n        require(vaultAddress == msg.sender, \"Caller is not the Vault\");\n        _;\n    }\n\n    /**\n     * @return High resolution rebasingCreditsPerToken\n     */\n    function rebasingCreditsPerTokenHighres() external view returns (uint256) {\n        return rebasingCreditsPerToken_;\n    }\n\n    /**\n     * @return Low resolution rebasingCreditsPerToken\n     */\n    function rebasingCreditsPerToken() external view returns (uint256) {\n        return rebasingCreditsPerToken_ / RESOLUTION_INCREASE;\n    }\n\n    /**\n     * @return High resolution total number of rebasing credits\n     */\n    function rebasingCreditsHighres() external view returns (uint256) {\n        return rebasingCredits_;\n    }\n\n    /**\n     * @return Low resolution total number of rebasing credits\n     */\n    function rebasingCredits() external view returns (uint256) {\n        return rebasingCredits_ / RESOLUTION_INCREASE;\n    }\n\n    /**\n     * @notice Gets the balance of the specified address.\n     * @param _account Address to query the balance of.\n     * @return A uint256 representing the amount of base units owned by the\n     *         specified address.\n     */\n    function balanceOf(address _account) public view returns (uint256) {\n        RebaseOptions state = rebaseState[_account];\n        if (state == RebaseOptions.YieldDelegationSource) {\n            // Saves a slot read when transferring to or from a yield delegating source\n            // since we know creditBalances equals the balance.\n            return creditBalances[_account];\n        }\n        uint256 baseBalance = (creditBalances[_account] * 1e18) /\n            _creditsPerToken(_account);\n        if (state == RebaseOptions.YieldDelegationTarget) {\n            // creditBalances of yieldFrom accounts equals token balances\n            return baseBalance - creditBalances[yieldFrom[_account]];\n        }\n        return baseBalance;\n    }\n\n    /**\n     * @notice Gets the credits balance of the specified address.\n     * @dev Backwards compatible with old low res credits per token.\n     * @param _account The address to query the balance of.\n     * @return (uint256, uint256) Credit balance and credits per token of the\n     *         address\n     */\n    function creditsBalanceOf(address _account)\n        external\n        view\n        returns (uint256, uint256)\n    {\n        uint256 cpt = _creditsPerToken(_account);\n        if (cpt == 1e27) {\n            // For a period before the resolution upgrade, we created all new\n            // contract accounts at high resolution. Since they are not changing\n            // as a result of this upgrade, we will return their true values\n            return (creditBalances[_account], cpt);\n        } else {\n            return (\n                creditBalances[_account] / RESOLUTION_INCREASE,\n                cpt / RESOLUTION_INCREASE\n            );\n        }\n    }\n\n    /**\n     * @notice Gets the credits balance of the specified address.\n     * @param _account The address to query the balance of.\n     * @return (uint256, uint256, bool) Credit balance, credits per token of the\n     *         address, and isUpgraded\n     */\n    function creditsBalanceOfHighres(address _account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        return (\n            creditBalances[_account],\n            _creditsPerToken(_account),\n            true // all accounts have their resolution \"upgraded\"\n        );\n    }\n\n    // Backwards compatible view\n    function nonRebasingCreditsPerToken(address _account)\n        external\n        view\n        returns (uint256)\n    {\n        return alternativeCreditsPerToken[_account];\n    }\n\n    /**\n     * @notice Transfer tokens to a specified address.\n     * @param _to the address to transfer to.\n     * @param _value the amount to be transferred.\n     * @return true on success.\n     */\n    function transfer(address _to, uint256 _value) external returns (bool) {\n        require(_to != address(0), \"Transfer to zero address\");\n\n        _executeTransfer(msg.sender, _to, _value);\n\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n     * @notice Transfer tokens from one address to another.\n     * @param _from The address you want to send tokens from.\n     * @param _to The address you want to transfer to.\n     * @param _value The amount of tokens to be transferred.\n     * @return true on success.\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool) {\n        require(_to != address(0), \"Transfer to zero address\");\n        uint256 userAllowance = allowances[_from][msg.sender];\n        require(_value <= userAllowance, \"Allowance exceeded\");\n\n        unchecked {\n            allowances[_from][msg.sender] = userAllowance - _value;\n        }\n\n        _executeTransfer(_from, _to, _value);\n\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function _executeTransfer(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal {\n        (\n            int256 fromRebasingCreditsDiff,\n            int256 fromNonRebasingSupplyDiff\n        ) = _adjustAccount(_from, -_value.toInt256());\n        (\n            int256 toRebasingCreditsDiff,\n            int256 toNonRebasingSupplyDiff\n        ) = _adjustAccount(_to, _value.toInt256());\n\n        _adjustGlobals(\n            fromRebasingCreditsDiff + toRebasingCreditsDiff,\n            fromNonRebasingSupplyDiff + toNonRebasingSupplyDiff\n        );\n    }\n\n    function _adjustAccount(address _account, int256 _balanceChange)\n        internal\n        returns (int256 rebasingCreditsDiff, int256 nonRebasingSupplyDiff)\n    {\n        RebaseOptions state = rebaseState[_account];\n        int256 currentBalance = balanceOf(_account).toInt256();\n        if (currentBalance + _balanceChange < 0) {\n            revert(\"Transfer amount exceeds balance\");\n        }\n        uint256 newBalance = (currentBalance + _balanceChange).toUint256();\n\n        if (state == RebaseOptions.YieldDelegationSource) {\n            address target = yieldTo[_account];\n            uint256 targetOldBalance = balanceOf(target);\n            uint256 targetNewCredits = _balanceToRebasingCredits(\n                targetOldBalance + newBalance\n            );\n            rebasingCreditsDiff =\n                targetNewCredits.toInt256() -\n                creditBalances[target].toInt256();\n\n            creditBalances[_account] = newBalance;\n            creditBalances[target] = targetNewCredits;\n        } else if (state == RebaseOptions.YieldDelegationTarget) {\n            uint256 newCredits = _balanceToRebasingCredits(\n                newBalance + creditBalances[yieldFrom[_account]]\n            );\n            rebasingCreditsDiff =\n                newCredits.toInt256() -\n                creditBalances[_account].toInt256();\n            creditBalances[_account] = newCredits;\n        } else {\n            _autoMigrate(_account);\n            uint256 alternativeCreditsPerTokenMem = alternativeCreditsPerToken[\n                _account\n            ];\n            if (alternativeCreditsPerTokenMem > 0) {\n                nonRebasingSupplyDiff = _balanceChange;\n                if (alternativeCreditsPerTokenMem != 1e18) {\n                    alternativeCreditsPerToken[_account] = 1e18;\n                }\n                creditBalances[_account] = newBalance;\n            } else {\n                uint256 newCredits = _balanceToRebasingCredits(newBalance);\n                rebasingCreditsDiff =\n                    newCredits.toInt256() -\n                    creditBalances[_account].toInt256();\n                creditBalances[_account] = newCredits;\n            }\n        }\n    }\n\n    function _adjustGlobals(\n        int256 _rebasingCreditsDiff,\n        int256 _nonRebasingSupplyDiff\n    ) internal {\n        if (_rebasingCreditsDiff != 0) {\n            rebasingCredits_ = (rebasingCredits_.toInt256() +\n                _rebasingCreditsDiff).toUint256();\n        }\n        if (_nonRebasingSupplyDiff != 0) {\n            nonRebasingSupply = (nonRebasingSupply.toInt256() +\n                _nonRebasingSupplyDiff).toUint256();\n        }\n    }\n\n    /**\n     * @notice Function to check the amount of tokens that _owner has allowed\n     *      to `_spender`.\n     * @param _owner The address which owns the funds.\n     * @param _spender The address which will spend the funds.\n     * @return The number of tokens still available for the _spender.\n     */\n    function allowance(address _owner, address _spender)\n        external\n        view\n        returns (uint256)\n    {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Approve the passed address to spend the specified amount of\n     *      tokens on behalf of msg.sender.\n     * @param _spender The address which will spend the funds.\n     * @param _value The amount of tokens to be spent.\n     * @return true on success.\n     */\n    function approve(address _spender, uint256 _value) external returns (bool) {\n        allowances[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * @notice Creates `_amount` tokens and assigns them to `_account`,\n     *     increasing the total supply.\n     */\n    function mint(address _account, uint256 _amount) external onlyVault {\n        require(_account != address(0), \"Mint to the zero address\");\n\n        // Account\n        (\n            int256 toRebasingCreditsDiff,\n            int256 toNonRebasingSupplyDiff\n        ) = _adjustAccount(_account, _amount.toInt256());\n        // Globals\n        _adjustGlobals(toRebasingCreditsDiff, toNonRebasingSupplyDiff);\n        totalSupply = totalSupply + _amount;\n\n        require(totalSupply < MAX_SUPPLY, \"Max supply\");\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    /**\n     * @notice Destroys `_amount` tokens from `_account`,\n     *     reducing the total supply.\n     */\n    function burn(address _account, uint256 _amount) external onlyVault {\n        require(_account != address(0), \"Burn from the zero address\");\n        if (_amount == 0) {\n            return;\n        }\n\n        // Account\n        (\n            int256 toRebasingCreditsDiff,\n            int256 toNonRebasingSupplyDiff\n        ) = _adjustAccount(_account, -_amount.toInt256());\n        // Globals\n        _adjustGlobals(toRebasingCreditsDiff, toNonRebasingSupplyDiff);\n        totalSupply = totalSupply - _amount;\n\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    /**\n     * @dev Get the credits per token for an account. Returns a fixed amount\n     *      if the account is non-rebasing.\n     * @param _account Address of the account.\n     */\n    function _creditsPerToken(address _account)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 alternativeCreditsPerTokenMem = alternativeCreditsPerToken[\n            _account\n        ];\n        if (alternativeCreditsPerTokenMem != 0) {\n            return alternativeCreditsPerTokenMem;\n        } else {\n            return rebasingCreditsPerToken_;\n        }\n    }\n\n    /**\n     * @dev Auto migrate contracts to be non rebasing,\n     *     unless they have opted into yield.\n     * @param _account Address of the account.\n     */\n    function _autoMigrate(address _account) internal {\n        uint256 codeLen = _account.code.length;\n        bool isEOA = (codeLen == 0) ||\n            (codeLen == 23 && bytes3(_account.code) == 0xef0100);\n        // In previous code versions, contracts would not have had their\n        // rebaseState[_account] set to RebaseOptions.NonRebasing when migrated\n        // therefore we check the actual accounting used on the account as well.\n        if (\n            (!isEOA) &&\n            rebaseState[_account] == RebaseOptions.NotSet &&\n            alternativeCreditsPerToken[_account] == 0\n        ) {\n            _rebaseOptOut(_account);\n        }\n    }\n\n    /**\n     * @dev Calculates credits from contract's global rebasingCreditsPerToken_, and\n     *      also balance that corresponds to those credits. The latter is important\n     *      when adjusting the contract's global nonRebasingSupply to circumvent any\n     *      possible rounding errors.\n     *\n     * @param _balance Balance of the account.\n     */\n    function _balanceToRebasingCredits(uint256 _balance)\n        internal\n        view\n        returns (uint256 rebasingCredits)\n    {\n        // Rounds up, because we need to ensure that accounts always have\n        // at least the balance that they should have.\n        // Note this should always be used on an absolute account value,\n        // not on a possibly negative diff, because then the rounding would be wrong.\n        return ((_balance) * rebasingCreditsPerToken_ + 1e18 - 1) / 1e18;\n    }\n\n    /**\n     * @notice The calling account will start receiving yield after a successful call.\n     * @param _account Address of the account.\n     */\n    function governanceRebaseOptIn(address _account) external onlyGovernor {\n        require(_account != address(0), \"Zero address not allowed\");\n        _rebaseOptIn(_account);\n    }\n\n    /**\n     * @notice The calling account will start receiving yield after a successful call.\n     */\n    function rebaseOptIn() external {\n        _rebaseOptIn(msg.sender);\n    }\n\n    function _rebaseOptIn(address _account) internal {\n        uint256 balance = balanceOf(_account);\n\n        // prettier-ignore\n        require(\n            alternativeCreditsPerToken[_account] > 0 ||\n                // Accounts may explicitly `rebaseOptIn` regardless of\n                // accounting if they have a 0 balance.\n                creditBalances[_account] == 0\n            ,\n            \"Account must be non-rebasing\"\n        );\n        RebaseOptions state = rebaseState[_account];\n        // prettier-ignore\n        require(\n            state == RebaseOptions.StdNonRebasing ||\n                state == RebaseOptions.NotSet,\n            \"Only standard non-rebasing accounts can opt in\"\n        );\n\n        uint256 newCredits = _balanceToRebasingCredits(balance);\n\n        // Account\n        rebaseState[_account] = RebaseOptions.StdRebasing;\n        alternativeCreditsPerToken[_account] = 0;\n        creditBalances[_account] = newCredits;\n        // Globals\n        _adjustGlobals(newCredits.toInt256(), -balance.toInt256());\n\n        emit AccountRebasingEnabled(_account);\n    }\n\n    /**\n     * @notice The calling account will no longer receive yield\n     */\n    function rebaseOptOut() external {\n        _rebaseOptOut(msg.sender);\n    }\n\n    function _rebaseOptOut(address _account) internal {\n        require(\n            alternativeCreditsPerToken[_account] == 0,\n            \"Account must be rebasing\"\n        );\n        RebaseOptions state = rebaseState[_account];\n        require(\n            state == RebaseOptions.StdRebasing || state == RebaseOptions.NotSet,\n            \"Only standard rebasing accounts can opt out\"\n        );\n\n        uint256 oldCredits = creditBalances[_account];\n        uint256 balance = balanceOf(_account);\n\n        // Account\n        rebaseState[_account] = RebaseOptions.StdNonRebasing;\n        alternativeCreditsPerToken[_account] = 1e18;\n        creditBalances[_account] = balance;\n        // Globals\n        _adjustGlobals(-oldCredits.toInt256(), balance.toInt256());\n\n        emit AccountRebasingDisabled(_account);\n    }\n\n    /**\n     * @notice Distribute yield to users. This changes the exchange rate\n     *  between \"credits\" and OUSD tokens to change rebasing user's balances.\n     * @param _newTotalSupply New total supply of OUSD.\n     */\n    function changeSupply(uint256 _newTotalSupply) external onlyVault {\n        require(totalSupply > 0, \"Cannot increase 0 supply\");\n\n        if (totalSupply == _newTotalSupply) {\n            emit TotalSupplyUpdatedHighres(\n                totalSupply,\n                rebasingCredits_,\n                rebasingCreditsPerToken_\n            );\n            return;\n        }\n\n        totalSupply = _newTotalSupply > MAX_SUPPLY\n            ? MAX_SUPPLY\n            : _newTotalSupply;\n\n        uint256 rebasingSupply = totalSupply - nonRebasingSupply;\n        // round up in the favour of the protocol\n        rebasingCreditsPerToken_ =\n            (rebasingCredits_ * 1e18 + rebasingSupply - 1) /\n            rebasingSupply;\n\n        require(rebasingCreditsPerToken_ > 0, \"Invalid change in supply\");\n\n        emit TotalSupplyUpdatedHighres(\n            totalSupply,\n            rebasingCredits_,\n            rebasingCreditsPerToken_\n        );\n    }\n\n    /*\n     * @notice Send the yield from one account to another account.\n     *         Each account keeps its own balances.\n     */\n    function delegateYield(address _from, address _to)\n        external\n        onlyGovernorOrStrategist\n    {\n        require(_from != address(0), \"Zero from address not allowed\");\n        require(_to != address(0), \"Zero to address not allowed\");\n\n        require(_from != _to, \"Cannot delegate to self\");\n        require(\n            yieldFrom[_to] == address(0) &&\n                yieldTo[_to] == address(0) &&\n                yieldFrom[_from] == address(0) &&\n                yieldTo[_from] == address(0),\n            \"Blocked by existing yield delegation\"\n        );\n        RebaseOptions stateFrom = rebaseState[_from];\n        RebaseOptions stateTo = rebaseState[_to];\n\n        require(\n            stateFrom == RebaseOptions.NotSet ||\n                stateFrom == RebaseOptions.StdNonRebasing ||\n                stateFrom == RebaseOptions.StdRebasing,\n            \"Invalid rebaseState from\"\n        );\n\n        require(\n            stateTo == RebaseOptions.NotSet ||\n                stateTo == RebaseOptions.StdNonRebasing ||\n                stateTo == RebaseOptions.StdRebasing,\n            \"Invalid rebaseState to\"\n        );\n\n        if (alternativeCreditsPerToken[_from] == 0) {\n            _rebaseOptOut(_from);\n        }\n        if (alternativeCreditsPerToken[_to] > 0) {\n            _rebaseOptIn(_to);\n        }\n\n        uint256 fromBalance = balanceOf(_from);\n        uint256 toBalance = balanceOf(_to);\n        uint256 oldToCredits = creditBalances[_to];\n        uint256 newToCredits = _balanceToRebasingCredits(\n            fromBalance + toBalance\n        );\n\n        // Set up the bidirectional links\n        yieldTo[_from] = _to;\n        yieldFrom[_to] = _from;\n\n        // Local\n        rebaseState[_from] = RebaseOptions.YieldDelegationSource;\n        alternativeCreditsPerToken[_from] = 1e18;\n        creditBalances[_from] = fromBalance;\n        rebaseState[_to] = RebaseOptions.YieldDelegationTarget;\n        creditBalances[_to] = newToCredits;\n\n        // Global\n        int256 creditsChange = newToCredits.toInt256() -\n            oldToCredits.toInt256();\n        _adjustGlobals(creditsChange, -(fromBalance).toInt256());\n        emit YieldDelegated(_from, _to);\n    }\n\n    /*\n     * @notice Stop sending the yield from one account to another account.\n     */\n    function undelegateYield(address _from) external onlyGovernorOrStrategist {\n        // Require a delegation, which will also ensure a valid delegation\n        require(yieldTo[_from] != address(0), \"Zero address not allowed\");\n\n        address to = yieldTo[_from];\n        uint256 fromBalance = balanceOf(_from);\n        uint256 toBalance = balanceOf(to);\n        uint256 oldToCredits = creditBalances[to];\n        uint256 newToCredits = _balanceToRebasingCredits(toBalance);\n\n        // Remove the bidirectional links\n        yieldFrom[to] = address(0);\n        yieldTo[_from] = address(0);\n\n        // Local\n        rebaseState[_from] = RebaseOptions.StdNonRebasing;\n        // alternativeCreditsPerToken[from] already 1e18 from `delegateYield()`\n        creditBalances[_from] = fromBalance;\n        rebaseState[to] = RebaseOptions.StdRebasing;\n        // alternativeCreditsPerToken[to] already 0 from `delegateYield()`\n        creditBalances[to] = newToCredits;\n\n        // Global\n        int256 creditsChange = newToCredits.toInt256() -\n            oldToCredits.toInt256();\n        _adjustGlobals(creditsChange, fromBalance.toInt256());\n        emit YieldUndelegated(_from, to);\n    }\n}\n"
    },
    "contracts/utils/Helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IBasicToken } from \"../interfaces/IBasicToken.sol\";\n\nlibrary Helpers {\n    /**\n     * @notice Fetch the `symbol()` from an ERC20 token\n     * @dev Grabs the `symbol()` from a contract\n     * @param _token Address of the ERC20 token\n     * @return string Symbol of the ERC20 token\n     */\n    function getSymbol(address _token) internal view returns (string memory) {\n        string memory symbol = IBasicToken(_token).symbol();\n        return symbol;\n    }\n\n    /**\n     * @notice Fetch the `decimals()` from an ERC20 token\n     * @dev Grabs the `decimals()` from a contract and fails if\n     *      the decimal value does not live within a certain range\n     * @param _token Address of the ERC20 token\n     * @return uint256 Decimals of the ERC20 token\n     */\n    function getDecimals(address _token) internal view returns (uint256) {\n        uint256 decimals = IBasicToken(_token).decimals();\n        require(\n            decimals >= 4 && decimals <= 18,\n            \"Token must have sufficient decimal places\"\n        );\n\n        return decimals;\n    }\n}\n"
    },
    "contracts/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Base contract any contracts that need to initialize state after deployment.\n * @author Origin Protocol Inc\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(\n            initializing || !initialized,\n            \"Initializable: contract is already initialized\"\n        );\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/utils/InitializableAbstractStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Base contract for vault strategies.\n * @author Origin Protocol Inc\n */\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\nabstract contract InitializableAbstractStrategy is Initializable, Governable {\n    using SafeERC20 for IERC20;\n\n    event PTokenAdded(address indexed _asset, address _pToken);\n    event PTokenRemoved(address indexed _asset, address _pToken);\n    event Deposit(address indexed _asset, address _pToken, uint256 _amount);\n    event Withdrawal(address indexed _asset, address _pToken, uint256 _amount);\n    event RewardTokenCollected(\n        address recipient,\n        address rewardToken,\n        uint256 amount\n    );\n    event RewardTokenAddressesUpdated(\n        address[] _oldAddresses,\n        address[] _newAddresses\n    );\n    event HarvesterAddressesUpdated(\n        address _oldHarvesterAddress,\n        address _newHarvesterAddress\n    );\n\n    /// @notice Address of the underlying platform\n    address public immutable platformAddress;\n    /// @notice Address of the OToken vault\n    address public immutable vaultAddress;\n\n    /// @dev Replaced with an immutable variable\n    // slither-disable-next-line constable-states\n    address private _deprecated_platformAddress;\n\n    /// @dev Replaced with an immutable\n    // slither-disable-next-line constable-states\n    address private _deprecated_vaultAddress;\n\n    /// @notice asset => pToken (Platform Specific Token Address)\n    mapping(address => address) public assetToPToken;\n\n    /// @notice Full list of all assets supported by the strategy\n    address[] internal assetsMapped;\n\n    // Deprecated: Reward token address\n    // slither-disable-next-line constable-states\n    address private _deprecated_rewardTokenAddress;\n\n    // Deprecated: now resides in Harvester's rewardTokenConfigs\n    // slither-disable-next-line constable-states\n    uint256 private _deprecated_rewardLiquidationThreshold;\n\n    /// @notice Address of the Harvester contract allowed to collect reward tokens\n    address public harvesterAddress;\n\n    /// @notice Address of the reward tokens. eg CRV, BAL, CVX, AURA\n    address[] public rewardTokenAddresses;\n\n    /* Reserved for future expansion. Used to be 100 storage slots\n     * and has decreased to accommodate:\n     * - harvesterAddress\n     * - rewardTokenAddresses\n     */\n    int256[98] private _reserved;\n\n    struct BaseStrategyConfig {\n        address platformAddress; // Address of the underlying platform\n        address vaultAddress; // Address of the OToken's Vault\n    }\n\n    /**\n     * @dev Verifies that the caller is the Governor or Strategist.\n     */\n    modifier onlyGovernorOrStrategist() virtual {\n        require(\n            isGovernor() || msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    /**\n     * @param _config The platform and OToken vault addresses\n     */\n    constructor(BaseStrategyConfig memory _config) {\n        platformAddress = _config.platformAddress;\n        vaultAddress = _config.vaultAddress;\n    }\n\n    /**\n     * @dev Internal initialize function, to set up initial internal state\n     * @param _rewardTokenAddresses Address of reward token for platform\n     * @param _assets Addresses of initial supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function _initialize(\n        address[] memory _rewardTokenAddresses,\n        address[] memory _assets,\n        address[] memory _pTokens\n    ) internal {\n        rewardTokenAddresses = _rewardTokenAddresses;\n\n        uint256 assetCount = _assets.length;\n        require(assetCount == _pTokens.length, \"Invalid input arrays\");\n        for (uint256 i = 0; i < assetCount; ++i) {\n            _setPTokenAddress(_assets[i], _pTokens[i]);\n        }\n    }\n\n    /**\n     * @notice Collect accumulated reward token and send to Vault.\n     */\n    function collectRewardTokens() external virtual onlyHarvester nonReentrant {\n        _collectRewardTokens();\n    }\n\n    /**\n     * @dev Default implementation that transfers reward tokens to the Harvester\n     * Implementing strategies need to add custom logic to collect the rewards.\n     */\n    function _collectRewardTokens() internal virtual {\n        uint256 rewardTokenCount = rewardTokenAddresses.length;\n        for (uint256 i = 0; i < rewardTokenCount; ++i) {\n            IERC20 rewardToken = IERC20(rewardTokenAddresses[i]);\n            uint256 balance = rewardToken.balanceOf(address(this));\n            if (balance > 0) {\n                emit RewardTokenCollected(\n                    harvesterAddress,\n                    address(rewardToken),\n                    balance\n                );\n                rewardToken.safeTransfer(harvesterAddress, balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault.\n     */\n    modifier onlyVault() {\n        require(msg.sender == vaultAddress, \"Caller is not the Vault\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Harvester.\n     */\n    modifier onlyHarvester() {\n        require(msg.sender == harvesterAddress, \"Caller is not the Harvester\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault or Governor.\n     */\n    modifier onlyVaultOrGovernor() {\n        require(\n            msg.sender == vaultAddress || msg.sender == governor(),\n            \"Caller is not the Vault or Governor\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault, Governor, or Strategist.\n     */\n    modifier onlyVaultOrGovernorOrStrategist() {\n        require(\n            msg.sender == vaultAddress ||\n                msg.sender == governor() ||\n                msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Vault, Governor, or Strategist\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Set the reward token addresses. Any old addresses will be overwritten.\n     * @param _rewardTokenAddresses Array of reward token addresses\n     */\n    function setRewardTokenAddresses(address[] calldata _rewardTokenAddresses)\n        external\n        onlyGovernor\n    {\n        uint256 rewardTokenCount = _rewardTokenAddresses.length;\n        for (uint256 i = 0; i < rewardTokenCount; ++i) {\n            require(\n                _rewardTokenAddresses[i] != address(0),\n                \"Can not set an empty address as a reward token\"\n            );\n        }\n\n        emit RewardTokenAddressesUpdated(\n            rewardTokenAddresses,\n            _rewardTokenAddresses\n        );\n        rewardTokenAddresses = _rewardTokenAddresses;\n    }\n\n    /**\n     * @notice Get the reward token addresses.\n     * @return address[] the reward token addresses.\n     */\n    function getRewardTokenAddresses()\n        external\n        view\n        returns (address[] memory)\n    {\n        return rewardTokenAddresses;\n    }\n\n    /**\n     * @notice Provide support for asset by passing its pToken address.\n     *      This method can only be called by the system Governor\n     * @param _asset    Address for the asset\n     * @param _pToken   Address for the corresponding platform token\n     */\n    function setPTokenAddress(address _asset, address _pToken)\n        external\n        virtual\n        onlyGovernor\n    {\n        _setPTokenAddress(_asset, _pToken);\n    }\n\n    /**\n     * @notice Remove a supported asset by passing its index.\n     *      This method can only be called by the system Governor\n     * @param _assetIndex Index of the asset to be removed\n     */\n    function removePToken(uint256 _assetIndex) external virtual onlyGovernor {\n        require(_assetIndex < assetsMapped.length, \"Invalid index\");\n        address asset = assetsMapped[_assetIndex];\n        address pToken = assetToPToken[asset];\n\n        if (_assetIndex < assetsMapped.length - 1) {\n            assetsMapped[_assetIndex] = assetsMapped[assetsMapped.length - 1];\n        }\n        assetsMapped.pop();\n        assetToPToken[asset] = address(0);\n\n        emit PTokenRemoved(asset, pToken);\n    }\n\n    /**\n     * @notice Provide support for asset by passing its pToken address.\n     *      Add to internal mappings and execute the platform specific,\n     * abstract method `_abstractSetPToken`\n     * @param _asset    Address for the asset\n     * @param _pToken   Address for the corresponding platform token\n     */\n    function _setPTokenAddress(address _asset, address _pToken) internal {\n        require(assetToPToken[_asset] == address(0), \"pToken already set\");\n        require(\n            _asset != address(0) && _pToken != address(0),\n            \"Invalid addresses\"\n        );\n\n        assetToPToken[_asset] = _pToken;\n        assetsMapped.push(_asset);\n\n        emit PTokenAdded(_asset, _pToken);\n\n        _abstractSetPToken(_asset, _pToken);\n    }\n\n    /**\n     * @notice Transfer token to governor. Intended for recovering tokens stuck in\n     *      strategy contracts, i.e. mistaken sends.\n     * @param _asset Address for the asset\n     * @param _amount Amount of the asset to transfer\n     */\n    function transferToken(address _asset, uint256 _amount)\n        public\n        virtual\n        onlyGovernor\n    {\n        require(!supportsAsset(_asset), \"Cannot transfer supported asset\");\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /**\n     * @notice Set the Harvester contract that can collect rewards.\n     * @param _harvesterAddress Address of the harvester contract.\n     */\n    function setHarvesterAddress(address _harvesterAddress)\n        external\n        onlyGovernor\n    {\n        emit HarvesterAddressesUpdated(harvesterAddress, _harvesterAddress);\n        harvesterAddress = _harvesterAddress;\n    }\n\n    /***************************************\n                 Abstract\n    ****************************************/\n\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        virtual;\n\n    function safeApproveAllTokens() external virtual;\n\n    /**\n     * @notice Deposit an amount of assets into the platform\n     * @param _asset               Address for the asset\n     * @param _amount              Units of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount) external virtual;\n\n    /**\n     * @notice Deposit all supported assets in this strategy contract to the platform\n     */\n    function depositAll() external virtual;\n\n    /**\n     * @notice Withdraw an `amount` of assets from the platform and\n     * send to the `_recipient`.\n     * @param _recipient         Address to which the asset should be sent\n     * @param _asset             Address of the asset\n     * @param _amount            Units of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external virtual;\n\n    /**\n     * @notice Withdraw all supported assets from platform and\n     * sends to the OToken's Vault.\n     */\n    function withdrawAll() external virtual;\n\n    /**\n     * @notice Get the total asset value held in the platform.\n     *      This includes any interest that was generated since depositing.\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        virtual\n        returns (uint256 balance);\n\n    /**\n     * @notice Check if an asset is supported.\n     * @param _asset    Address of the asset\n     * @return bool     Whether asset is supported\n     */\n    function supportsAsset(address _asset) public view virtual returns (bool);\n}\n"
    },
    "contracts/vault/VaultStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OToken VaultStorage contract\n * @notice The VaultStorage contract defines the storage for the Vault contracts\n * @author Origin Protocol Inc\n */\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { OUSD } from \"../token/OUSD.sol\";\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport \"../utils/Helpers.sol\";\n\nabstract contract VaultStorage is Initializable, Governable {\n    using SafeERC20 for IERC20;\n\n    event AssetAllocated(address _asset, address _strategy, uint256 _amount);\n    event StrategyApproved(address _addr);\n    event StrategyRemoved(address _addr);\n    event Mint(address _addr, uint256 _value);\n    event Redeem(address _addr, uint256 _value);\n    event CapitalPaused();\n    event CapitalUnpaused();\n    event DefaultStrategyUpdated(address _strategy);\n    event RebasePaused();\n    event RebaseUnpaused();\n    event VaultBufferUpdated(uint256 _vaultBuffer);\n    event AllocateThresholdUpdated(uint256 _threshold);\n    event RebaseThresholdUpdated(uint256 _threshold);\n    event StrategistUpdated(address _address);\n    event MaxSupplyDiffChanged(uint256 maxSupplyDiff);\n    event YieldDistribution(address _to, uint256 _yield, uint256 _fee);\n    event TrusteeFeeBpsChanged(uint256 _basis);\n    event TrusteeAddressChanged(address _address);\n    event StrategyAddedToMintWhitelist(address indexed strategy);\n    event StrategyRemovedFromMintWhitelist(address indexed strategy);\n    event RebasePerSecondMaxChanged(uint256 rebaseRatePerSecond);\n    event DripDurationChanged(uint256 dripDuration);\n    event WithdrawalRequested(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount,\n        uint256 _queued\n    );\n    event WithdrawalClaimed(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount\n    );\n    event WithdrawalClaimable(uint256 _claimable, uint256 _newClaimable);\n    event WithdrawalClaimDelayUpdated(uint256 _newDelay);\n\n    // Since we are proxy, all state should be uninitalized.\n    // Since this storage contract does not have logic directly on it\n    // we should not be checking for to see if these variables can be constant.\n    // slither-disable-start uninitialized-state\n    // slither-disable-start constable-states\n\n    /// @dev mapping of supported vault assets to their configuration\n    uint256 private _deprecated_assets;\n    /// @dev list of all assets supported by the vault.\n    address[] private _deprecated_allAssets;\n\n    // Strategies approved for use by the Vault\n    struct Strategy {\n        bool isSupported;\n        uint256 _deprecated; // Deprecated storage slot\n    }\n    /// @dev mapping of strategy contracts to their configuration\n    mapping(address => Strategy) public strategies;\n    /// @dev list of all vault strategies\n    address[] internal allStrategies;\n\n    /// @notice Address of the Oracle price provider contract\n    address private _deprecated_priceProvider;\n    /// @notice pause rebasing if true\n    bool public rebasePaused;\n    /// @notice pause operations that change the OToken supply.\n    /// eg mint, redeem, allocate, mint/burn for strategy\n    bool public capitalPaused;\n    /// @notice Redemption fee in basis points. eg 50 = 0.5%\n    uint256 private _deprecated_redeemFeeBps;\n    /// @notice Percentage of assets to keep in Vault to handle (most) withdrawals. 100% = 1e18.\n    uint256 public vaultBuffer;\n    /// @notice OToken mints over this amount automatically allocate funds. 18 decimals.\n    uint256 public autoAllocateThreshold;\n    /// @notice OToken mints over this amount automatically rebase. 18 decimals.\n    uint256 public rebaseThreshold;\n\n    /// @dev Address of the OToken token. eg OUSD or OETH.\n    OUSD public oToken;\n\n    /// @dev Address of the contract responsible for post rebase syncs with AMMs\n    address private _deprecated_rebaseHooksAddr = address(0);\n\n    /// @dev Deprecated: Address of Uniswap\n    address private _deprecated_uniswapAddr = address(0);\n\n    /// @notice Address of the Strategist\n    address public strategistAddr = address(0);\n\n    /// @notice Mapping of asset address to the Strategy that they should automatically\n    // be allocated to\n    uint256 private _deprecated_assetDefaultStrategies;\n\n    /// @notice Max difference between total supply and total value of assets. 18 decimals.\n    uint256 public maxSupplyDiff;\n\n    /// @notice Trustee contract that can collect a percentage of yield\n    address public trusteeAddress;\n\n    /// @notice Amount of yield collected in basis points. eg 2000 = 20%\n    uint256 public trusteeFeeBps;\n\n    /// @dev Deprecated: Tokens that should be swapped for stablecoins\n    address[] private _deprecated_swapTokens;\n\n    /// @notice Metapool strategy that is allowed to mint/burn OTokens without changing collateral\n\n    address private _deprecated_ousdMetaStrategy;\n\n    /// @notice How much OTokens are currently minted by the strategy\n    int256 private _deprecated_netOusdMintedForStrategy;\n\n    /// @notice How much net total OTokens are allowed to be minted by all strategies\n    uint256 private _deprecated_netOusdMintForStrategyThreshold;\n\n    uint256 private _deprecated_swapConfig;\n\n    // List of strategies that can mint oTokens directly\n    // Used in OETHBaseVaultCore\n    mapping(address => bool) public isMintWhitelistedStrategy;\n\n    /// @notice Address of the Dripper contract that streams harvested rewards to the Vault\n    /// @dev The vault is proxied so needs to be set with setDripper against the proxy contract.\n    address private _deprecated_dripper;\n\n    /// Withdrawal Queue Storage /////\n\n    struct WithdrawalQueueMetadata {\n        // cumulative total of all withdrawal requests included the ones that have already been claimed\n        uint128 queued;\n        // cumulative total of all the requests that can be claimed including the ones that have already been claimed\n        uint128 claimable;\n        // total of all the requests that have been claimed\n        uint128 claimed;\n        // index of the next withdrawal request starting at 0\n        uint128 nextWithdrawalIndex;\n    }\n\n    /// @notice Global metadata for the withdrawal queue including:\n    /// queued - cumulative total of all withdrawal requests included the ones that have already been claimed\n    /// claimable - cumulative total of all the requests that can be claimed including the ones already claimed\n    /// claimed - total of all the requests that have been claimed\n    /// nextWithdrawalIndex - index of the next withdrawal request starting at 0\n    WithdrawalQueueMetadata public withdrawalQueueMetadata;\n\n    struct WithdrawalRequest {\n        address withdrawer;\n        bool claimed;\n        uint40 timestamp; // timestamp of the withdrawal request\n        // Amount of oTokens to redeem. eg OETH\n        uint128 amount;\n        // cumulative total of all withdrawal requests including this one.\n        // this request can be claimed when this queued amount is less than or equal to the queue's claimable amount.\n        uint128 queued;\n    }\n\n    /// @notice Mapping of withdrawal request indices to the user withdrawal request data\n    mapping(uint256 => WithdrawalRequest) public withdrawalRequests;\n\n    /// @notice Sets a minimum delay that is required to elapse between\n    ///     requesting async withdrawals and claiming the request.\n    ///     When set to 0 async withdrawals are disabled.\n    uint256 public withdrawalClaimDelay;\n\n    /// @notice Time in seconds that the vault last rebased yield.\n    uint64 public lastRebase;\n\n    /// @notice Automatic rebase yield calculations. In seconds. Set to 0 or 1 to disable.\n    uint64 public dripDuration;\n\n    /// @notice max rebase percentage per second\n    ///   Can be used to set maximum yield of the protocol,\n    ///   spreading out yield over time\n    uint64 public rebasePerSecondMax;\n\n    /// @notice target rebase rate limit, based on past rates and funds available.\n    uint64 public rebasePerSecondTarget;\n\n    uint256 internal constant MAX_REBASE = 0.02 ether;\n    uint256 internal constant MAX_REBASE_PER_SECOND =\n        uint256(0.05 ether) / 1 days;\n\n    /// @notice Default strategy for asset\n    address public defaultStrategy;\n\n    // For future use\n    uint256[42] private __gap;\n\n    /// @notice Index of WETH asset in allAssets array\n    /// Legacy OETHVaultCore code, relocated here for vault consistency.\n    uint256 private _deprecated_wethAssetIndex;\n\n    /// @dev Address of the asset (eg. WETH or USDC)\n    address public immutable asset;\n    uint8 internal immutable assetDecimals;\n\n    // slither-disable-end constable-states\n    // slither-disable-end uninitialized-state\n\n    constructor(address _asset) {\n        uint8 _decimals = IERC20Metadata(_asset).decimals();\n        require(_decimals <= 18, \"invalid asset decimals\");\n        asset = _asset;\n        assetDecimals = _decimals;\n    }\n\n    /// @notice Deprecated: use `oToken()` instead.\n    function oUSD() external view returns (OUSD) {\n        return oToken;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}