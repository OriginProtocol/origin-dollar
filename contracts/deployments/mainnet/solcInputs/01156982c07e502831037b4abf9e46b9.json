{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/automation/AbstractSafeModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AccessControlEnumerable } from \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ISafe } from \"../interfaces/ISafe.sol\";\n\nabstract contract AbstractSafeModule is AccessControlEnumerable {\n    ISafe public immutable safeContract;\n\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n\n    modifier onlySafe() {\n        require(\n            msg.sender == address(safeContract),\n            \"Caller is not the safe contract\"\n        );\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(\n            hasRole(OPERATOR_ROLE, msg.sender),\n            \"Caller is not an operator\"\n        );\n        _;\n    }\n\n    constructor(address _safeContract) {\n        safeContract = ISafe(_safeContract);\n        _grantRole(DEFAULT_ADMIN_ROLE, address(safeContract));\n        _grantRole(OPERATOR_ROLE, address(safeContract));\n    }\n\n    /**\n     * @dev Helps recovering any tokens accidentally sent to this module.\n     * @param token Token to transfer. 0x0 to transfer Native token.\n     * @param amount Amount to transfer. 0 to transfer all balance.\n     */\n    function transferTokens(address token, uint256 amount) external onlySafe {\n        if (address(token) == address(0)) {\n            // Move ETH\n            amount = amount > 0 ? amount : address(this).balance;\n            payable(address(safeContract)).transfer(amount);\n            return;\n        }\n\n        // Move all balance if amount set to 0\n        amount = amount > 0 ? amount : IERC20(token).balanceOf(address(this));\n\n        // Transfer to Safe contract\n        // slither-disable-next-line unchecked-transfer unused-return\n        IERC20(token).transfer(address(safeContract), amount);\n    }\n\n    receive() external payable {\n        // Accept ETH to pay for bridge fees\n    }\n}\n"
    },
    "contracts/automation/CurvePoolBoosterBribesModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractSafeModule } from \"./AbstractSafeModule.sol\";\n\ninterface ICurvePoolBooster {\n    function manageTotalRewardAmount(\n        uint256 bridgeFee,\n        uint256 additionalGasLimit\n    ) external;\n\n    function manageNumberOfPeriods(\n        uint8 extraNumberOfPeriods,\n        uint256 bridgeFee,\n        uint256 additionalGasLimit\n    ) external;\n}\n\ncontract CurvePoolBoosterBribesModule is AbstractSafeModule {\n    address[] public POOLS;\n\n    event PoolBoosterAddressAdded(address pool);\n    event PoolBoosterAddressRemoved(address pool);\n\n    constructor(\n        address _safeContract,\n        address _operator,\n        address[] memory _pools\n    ) AbstractSafeModule(_safeContract) {\n        _grantRole(OPERATOR_ROLE, _operator);\n        _addPoolBoosterAddress(_pools);\n    }\n\n    function addPoolBoosterAddress(address[] memory pools)\n        external\n        onlyOperator\n    {\n        _addPoolBoosterAddress(pools);\n    }\n\n    function _addPoolBoosterAddress(address[] memory pools) internal {\n        for (uint256 i = 0; i < pools.length; i++) {\n            POOLS.push(pools[i]);\n            emit PoolBoosterAddressAdded(pools[i]);\n        }\n    }\n\n    function removePoolBoosterAddress(address[] calldata pools)\n        external\n        onlyOperator\n    {\n        for (uint256 i = 0; i < pools.length; i++) {\n            _removePoolBoosterAddress(pools[i]);\n        }\n    }\n\n    function _removePoolBoosterAddress(address pool) internal {\n        uint256 length = POOLS.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (POOLS[i] == pool) {\n                POOLS[i] = POOLS[length - 1];\n                POOLS.pop();\n                emit PoolBoosterAddressRemoved(pool);\n                break;\n            }\n        }\n    }\n\n    function manageBribes() external onlyOperator {\n        uint256 length = POOLS.length;\n        for (uint256 i = 0; i < length; i++) {\n            address poolBoosterAddress = POOLS[i];\n\n            // PoolBooster need to have a balance of at least 0.002 ether to operate\n            // 0.001 ether are used for the bridge fee\n            require(\n                poolBoosterAddress.balance > 0.002 ether,\n                \"Insufficient balance for bribes\"\n            );\n\n            require(\n                safeContract.execTransactionFromModule(\n                    poolBoosterAddress,\n                    0, // Value\n                    abi.encodeWithSelector(\n                        ICurvePoolBooster.manageNumberOfPeriods.selector,\n                        1, // extraNumberOfPeriods\n                        0.001 ether, // bridgeFee\n                        1000000 // additionalGasLimit\n                    ),\n                    0\n                ),\n                \"Manage number of periods failed\"\n            );\n\n            require(\n                safeContract.execTransactionFromModule(\n                    poolBoosterAddress,\n                    0, // Value\n                    abi.encodeWithSelector(\n                        ICurvePoolBooster.manageTotalRewardAmount.selector,\n                        0.001 ether, // bridgeFee\n                        1000000 // additionalGasLimit\n                    ),\n                    0\n                ),\n                \"Manage total reward failed\"\n            );\n        }\n    }\n}\n"
    },
    "contracts/governance/Governable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Base for contracts that are managed by the Origin Protocol's Governor.\n * @dev Copy of the openzeppelin Ownable.sol contract with nomenclature change\n *      from owner to governor and renounce methods removed. Does not use\n *      Context.sol like Ownable.sol does for simplification.\n * @author Origin Protocol Inc\n */\nabstract contract Governable {\n    // Storage position of the owner and pendingOwner of the contract\n    // keccak256(\"OUSD.governor\");\n    bytes32 private constant governorPosition =\n        0x7bea13895fa79d2831e0a9e28edede30099005a50d652d8957cf8a607ee6ca4a;\n\n    // keccak256(\"OUSD.pending.governor\");\n    bytes32 private constant pendingGovernorPosition =\n        0x44c4d30b2eaad5130ad70c3ba6972730566f3e6359ab83e800d905c61b1c51db;\n\n    // keccak256(\"OUSD.reentry.status\");\n    bytes32 private constant reentryStatusPosition =\n        0x53bf423e48ed90e97d02ab0ebab13b2a235a6bfbe9c321847d5c175333ac4535;\n\n    // See OpenZeppelin ReentrancyGuard implementation\n    uint256 constant _NOT_ENTERED = 1;\n    uint256 constant _ENTERED = 2;\n\n    event PendingGovernorshipTransfer(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    event GovernorshipTransferred(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    /**\n     * @notice Returns the address of the current Governor.\n     */\n    function governor() public view returns (address) {\n        return _governor();\n    }\n\n    /**\n     * @dev Returns the address of the current Governor.\n     */\n    function _governor() internal view returns (address governorOut) {\n        bytes32 position = governorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            governorOut := sload(position)\n        }\n    }\n\n    /**\n     * @dev Returns the address of the pending Governor.\n     */\n    function _pendingGovernor()\n        internal\n        view\n        returns (address pendingGovernor)\n    {\n        bytes32 position = pendingGovernorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            pendingGovernor := sload(position)\n        }\n    }\n\n    /**\n     * @dev Throws if called by any account other than the Governor.\n     */\n    modifier onlyGovernor() {\n        require(isGovernor(), \"Caller is not the Governor\");\n        _;\n    }\n\n    /**\n     * @notice Returns true if the caller is the current Governor.\n     */\n    function isGovernor() public view returns (bool) {\n        return msg.sender == _governor();\n    }\n\n    function _setGovernor(address newGovernor) internal {\n        emit GovernorshipTransferred(_governor(), newGovernor);\n\n        bytes32 position = governorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, newGovernor)\n        }\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        bytes32 position = reentryStatusPosition;\n        uint256 _reentry_status;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _reentry_status := sload(position)\n        }\n\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_reentry_status != _ENTERED, \"Reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, _ENTERED)\n        }\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, _NOT_ENTERED)\n        }\n    }\n\n    function _setPendingGovernor(address newGovernor) internal {\n        bytes32 position = pendingGovernorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, newGovernor)\n        }\n    }\n\n    /**\n     * @notice Transfers Governance of the contract to a new account (`newGovernor`).\n     * Can only be called by the current Governor. Must be claimed for this to complete\n     * @param _newGovernor Address of the new Governor\n     */\n    function transferGovernance(address _newGovernor) external onlyGovernor {\n        _setPendingGovernor(_newGovernor);\n        emit PendingGovernorshipTransfer(_governor(), _newGovernor);\n    }\n\n    /**\n     * @notice Claim Governance of the contract to a new account (`newGovernor`).\n     * Can only be called by the new Governor.\n     */\n    function claimGovernance() external {\n        require(\n            msg.sender == _pendingGovernor(),\n            \"Only the pending Governor can complete the claim\"\n        );\n        _changeGovernor(msg.sender);\n    }\n\n    /**\n     * @dev Change Governance of the contract to a new account (`newGovernor`).\n     * @param _newGovernor Address of the new Governor\n     */\n    function _changeGovernor(address _newGovernor) internal {\n        require(_newGovernor != address(0), \"New Governor is address(0)\");\n        _setGovernor(_newGovernor);\n    }\n}\n"
    },
    "contracts/governance/Strategizable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Governable } from \"./Governable.sol\";\n\ncontract Strategizable is Governable {\n    event StrategistUpdated(address _address);\n\n    // Address of strategist\n    address public strategistAddr;\n\n    // For future use\n    uint256[50] private __gap;\n\n    /**\n     * @dev Verifies that the caller is either Governor or Strategist.\n     */\n    modifier onlyGovernorOrStrategist() virtual {\n        require(\n            msg.sender == strategistAddr || isGovernor(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Set address of Strategist\n     * @param _address Address of Strategist\n     */\n    function setStrategistAddr(address _address) external onlyGovernor {\n        _setStrategistAddr(_address);\n    }\n\n    /**\n     * @dev Set address of Strategist\n     * @param _address Address of Strategist\n     */\n    function _setStrategistAddr(address _address) internal {\n        strategistAddr = _address;\n        emit StrategistUpdated(_address);\n    }\n}\n"
    },
    "contracts/interfaces/cctp/ICCTP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface ICCTPTokenMessenger {\n    function depositForBurn(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller,\n        uint256 maxFee,\n        uint32 minFinalityThreshold\n    ) external;\n\n    function depositForBurnWithHook(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller,\n        uint256 maxFee,\n        uint32 minFinalityThreshold,\n        bytes memory hookData\n    ) external;\n\n    function getMinFeeAmount(uint256 amount) external view returns (uint256);\n}\n\ninterface ICCTPMessageTransmitter {\n    function sendMessage(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        uint32 minFinalityThreshold,\n        bytes memory messageBody\n    ) external;\n\n    function receiveMessage(bytes calldata message, bytes calldata attestation)\n        external\n        returns (bool);\n}\n\ninterface IMessageHandlerV2 {\n    /**\n     * @notice Handles an incoming finalized message from an IReceiverV2\n     * @dev Finalized messages have finality threshold values greater than or equal to 2000\n     * @param sourceDomain The source domain of the message\n     * @param sender The sender of the message\n     * @param finalityThresholdExecuted the finality threshold at which the message was attested to\n     * @param messageBody The raw bytes of the message body\n     * @return success True, if successful; false, if not.\n     */\n    function handleReceiveFinalizedMessage(\n        uint32 sourceDomain,\n        bytes32 sender,\n        uint32 finalityThresholdExecuted,\n        bytes calldata messageBody\n    ) external returns (bool);\n\n    /**\n     * @notice Handles an incoming unfinalized message from an IReceiverV2\n     * @dev Unfinalized messages have finality threshold values less than 2000\n     * @param sourceDomain The source domain of the message\n     * @param sender The sender of the message\n     * @param finalityThresholdExecuted The finality threshold at which the message was attested to\n     * @param messageBody The raw bytes of the message body\n     * @return success True, if successful; false, if not.\n     */\n    function handleReceiveUnfinalizedMessage(\n        uint32 sourceDomain,\n        bytes32 sender,\n        uint32 finalityThresholdExecuted,\n        bytes calldata messageBody\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IBasicToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBasicToken {\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IMerkl.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IDistributor {\n    event Claimed(address indexed user, address indexed token, uint256 amount);\n\n    function claim(\n        address[] calldata users,\n        address[] calldata tokens,\n        uint256[] calldata amounts,\n        bytes32[][] calldata proofs\n    ) external;\n}\n"
    },
    "contracts/interfaces/ISafe.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface ISafe {\n    function execTransactionFromModule(\n        address,\n        uint256,\n        bytes memory,\n        uint8\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Platform interface to integrate with lending platform like Compound, AAVE etc.\n */\ninterface IStrategy {\n    /**\n     * @dev Deposit the given asset to platform\n     * @param _asset asset address\n     * @param _amount Amount to deposit\n     */\n    function deposit(address _asset, uint256 _amount) external;\n\n    /**\n     * @dev Deposit the entire balance of all supported assets in the Strategy\n     *      to the platform\n     */\n    function depositAll() external;\n\n    /**\n     * @dev Withdraw given asset from Lending platform\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external;\n\n    /**\n     * @dev Liquidate all assets in strategy and return them to Vault.\n     */\n    function withdrawAll() external;\n\n    /**\n     * @dev Returns the current balance of the given asset.\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        returns (uint256 balance);\n\n    /**\n     * @dev Returns bool indicating whether strategy supports asset.\n     */\n    function supportsAsset(address _asset) external view returns (bool);\n\n    /**\n     * @dev Collect reward tokens from the Strategy.\n     */\n    function collectRewardTokens() external;\n\n    /**\n     * @dev The address array of the reward tokens for the Strategy.\n     */\n    function getRewardTokenAddresses() external view returns (address[] memory);\n\n    function harvesterAddress() external view returns (address);\n\n    function transferToken(address token, uint256 amount) external;\n\n    function setRewardTokenAddresses(address[] calldata _rewardTokenAddresses)\n        external;\n}\n"
    },
    "contracts/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { VaultStorage } from \"../vault/VaultStorage.sol\";\n\ninterface IVault {\n    // slither-disable-start constable-states\n\n    event AssetSupported(address _asset);\n    event AssetDefaultStrategyUpdated(address _asset, address _strategy);\n    event AssetAllocated(address _asset, address _strategy, uint256 _amount);\n    event StrategyApproved(address _addr);\n    event StrategyRemoved(address _addr);\n    event Mint(address _addr, uint256 _value);\n    event Redeem(address _addr, uint256 _value);\n    event CapitalPaused();\n    event CapitalUnpaused();\n    event RebasePaused();\n    event RebaseUnpaused();\n    event VaultBufferUpdated(uint256 _vaultBuffer);\n    event RedeemFeeUpdated(uint256 _redeemFeeBps);\n    event PriceProviderUpdated(address _priceProvider);\n    event AllocateThresholdUpdated(uint256 _threshold);\n    event RebaseThresholdUpdated(uint256 _threshold);\n    event StrategistUpdated(address _address);\n    event MaxSupplyDiffChanged(uint256 maxSupplyDiff);\n    event YieldDistribution(address _to, uint256 _yield, uint256 _fee);\n    event TrusteeFeeBpsChanged(uint256 _basis);\n    event TrusteeAddressChanged(address _address);\n    event SwapperChanged(address _address);\n    event SwapAllowedUndervalueChanged(uint256 _basis);\n    event SwapSlippageChanged(address _asset, uint256 _basis);\n    event Swapped(\n        address indexed _fromAsset,\n        address indexed _toAsset,\n        uint256 _fromAssetAmount,\n        uint256 _toAssetAmount\n    );\n    event StrategyAddedToMintWhitelist(address indexed strategy);\n    event StrategyRemovedFromMintWhitelist(address indexed strategy);\n    event DripperChanged(address indexed _dripper);\n    event WithdrawalRequested(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount,\n        uint256 _queued\n    );\n    event WithdrawalClaimed(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount\n    );\n    event WithdrawalClaimable(uint256 _claimable, uint256 _newClaimable);\n\n    // Governable.sol\n    function transferGovernance(address _newGovernor) external;\n\n    function claimGovernance() external;\n\n    function governor() external view returns (address);\n\n    function ADMIN_IMPLEMENTATION() external view returns (address);\n\n    // VaultAdmin.sol\n    function setPriceProvider(address _priceProvider) external;\n\n    function priceProvider() external view returns (address);\n\n    function setRedeemFeeBps(uint256 _redeemFeeBps) external;\n\n    function redeemFeeBps() external view returns (uint256);\n\n    function setVaultBuffer(uint256 _vaultBuffer) external;\n\n    function vaultBuffer() external view returns (uint256);\n\n    function setAutoAllocateThreshold(uint256 _threshold) external;\n\n    function autoAllocateThreshold() external view returns (uint256);\n\n    function setRebaseThreshold(uint256 _threshold) external;\n\n    function rebaseThreshold() external view returns (uint256);\n\n    function setStrategistAddr(address _address) external;\n\n    function strategistAddr() external view returns (address);\n\n    function setMaxSupplyDiff(uint256 _maxSupplyDiff) external;\n\n    function maxSupplyDiff() external view returns (uint256);\n\n    function setTrusteeAddress(address _address) external;\n\n    function trusteeAddress() external view returns (address);\n\n    function setTrusteeFeeBps(uint256 _basis) external;\n\n    function trusteeFeeBps() external view returns (uint256);\n\n    function ousdMetaStrategy() external view returns (address);\n\n    function setSwapper(address _swapperAddr) external;\n\n    function setSwapAllowedUndervalue(uint16 _percentageBps) external;\n\n    function setOracleSlippage(address _asset, uint16 _allowedOracleSlippageBps)\n        external;\n\n    function supportAsset(address _asset, uint8 _unitConversion) external;\n\n    function approveStrategy(address _addr) external;\n\n    function removeStrategy(address _addr) external;\n\n    function setAssetDefaultStrategy(address _asset, address _strategy)\n        external;\n\n    function assetDefaultStrategies(address _asset)\n        external\n        view\n        returns (address);\n\n    function pauseRebase() external;\n\n    function unpauseRebase() external;\n\n    function rebasePaused() external view returns (bool);\n\n    function pauseCapital() external;\n\n    function unpauseCapital() external;\n\n    function capitalPaused() external view returns (bool);\n\n    function transferToken(address _asset, uint256 _amount) external;\n\n    function priceUnitMint(address asset) external view returns (uint256);\n\n    function priceUnitRedeem(address asset) external view returns (uint256);\n\n    function withdrawAllFromStrategy(address _strategyAddr) external;\n\n    function withdrawAllFromStrategies() external;\n\n    function withdrawFromStrategy(\n        address _strategyFromAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external;\n\n    function depositToStrategy(\n        address _strategyToAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external;\n\n    // VaultCore.sol\n    function mint(\n        address _asset,\n        uint256 _amount,\n        uint256 _minimumOusdAmount\n    ) external;\n\n    function mintForStrategy(uint256 _amount) external;\n\n    function redeem(uint256 _amount, uint256 _minimumUnitAmount) external;\n\n    function burnForStrategy(uint256 _amount) external;\n\n    function allocate() external;\n\n    function rebase() external;\n\n    function swapCollateral(\n        address fromAsset,\n        address toAsset,\n        uint256 fromAssetAmount,\n        uint256 minToAssetAmount,\n        bytes calldata data\n    ) external returns (uint256 toAssetAmount);\n\n    function totalValue() external view returns (uint256 value);\n\n    function checkBalance(address _asset) external view returns (uint256);\n\n    function calculateRedeemOutputs(uint256 _amount)\n        external\n        view\n        returns (uint256[] memory);\n\n    function getAssetCount() external view returns (uint256);\n\n    function getAssetConfig(address _asset)\n        external\n        view\n        returns (VaultStorage.Asset memory config);\n\n    function getAllAssets() external view returns (address[] memory);\n\n    function getStrategyCount() external view returns (uint256);\n\n    function swapper() external view returns (address);\n\n    function allowedSwapUndervalue() external view returns (uint256);\n\n    function getAllStrategies() external view returns (address[] memory);\n\n    function isSupportedAsset(address _asset) external view returns (bool);\n\n    function netOusdMintForStrategyThreshold() external view returns (uint256);\n\n    function setOusdMetaStrategy(address _ousdMetaStrategy) external;\n\n    function setNetOusdMintForStrategyThreshold(uint256 _threshold) external;\n\n    function netOusdMintedForStrategy() external view returns (int256);\n\n    function setDripper(address _dripper) external;\n\n    function dripper() external view returns (address);\n\n    function weth() external view returns (address);\n\n    function cacheWETHAssetIndex() external;\n\n    function wethAssetIndex() external view returns (uint256);\n\n    function initialize(address, address) external;\n\n    function setAdminImpl(address) external;\n\n    function removeAsset(address _asset) external;\n\n    // These are OETH specific functions\n    function addWithdrawalQueueLiquidity() external;\n\n    function requestWithdrawal(uint256 _amount)\n        external\n        returns (uint256 requestId, uint256 queued);\n\n    function claimWithdrawal(uint256 requestId)\n        external\n        returns (uint256 amount);\n\n    function claimWithdrawals(uint256[] memory requestIds)\n        external\n        returns (uint256[] memory amounts, uint256 totalAmount);\n\n    function withdrawalQueueMetadata()\n        external\n        view\n        returns (VaultStorage.WithdrawalQueueMetadata memory);\n\n    function withdrawalRequests(uint256 requestId)\n        external\n        view\n        returns (VaultStorage.WithdrawalRequest memory);\n\n    // OETHb specific functions\n    function addStrategyToMintWhitelist(address strategyAddr) external;\n\n    function removeStrategyFromMintWhitelist(address strategyAddr) external;\n\n    function isMintWhitelistedStrategy(address strategyAddr)\n        external\n        view\n        returns (bool);\n\n    function withdrawalClaimDelay() external view returns (uint256);\n\n    function setWithdrawalClaimDelay(uint256 newDelay) external;\n\n    function lastRebase() external view returns (uint64);\n\n    function dripDuration() external view returns (uint64);\n\n    function setDripDuration(uint256 _dripDuration) external;\n\n    function rebasePerSecondMax() external view returns (uint64);\n\n    function setRebaseRateMax(uint256 yearlyApr) external;\n\n    function rebasePerSecondTarget() external view returns (uint64);\n\n    function previewYield() external view returns (uint256 yield);\n\n    // slither-disable-end constable-states\n}\n"
    },
    "contracts/mocks/crosschain/CCTPMessageTransmitterMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ICCTPMessageTransmitter } from \"../../interfaces/cctp/ICCTP.sol\";\nimport { IERC20 } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { BytesHelper } from \"../../utils/BytesHelper.sol\";\nimport { AbstractCCTPIntegrator } from \"../../strategies/crosschain/AbstractCCTPIntegrator.sol\";\n\n/**\n * @title Mock conctract simulating the functionality of the CCTPTokenMessenger contract\n *        for the porposes of unit testing.\n * @author Origin Protocol Inc\n */\n\ncontract CCTPMessageTransmitterMock is ICCTPMessageTransmitter {\n    using BytesHelper for bytes;\n\n    IERC20 public usdc;\n    uint256 public nonce = 0;\n    // Sender index in the burn message v2\n    // Ref: https://github.com/circlefin/evm-cctp-contracts/blob/master/src/messages/v2/BurnMessageV2.sol\n    uint8 constant BURN_MESSAGE_V2_MESSAGE_SENDER_INDEX = 100;\n    uint8 constant BURN_MESSAGE_V2_HOOK_DATA_INDEX = 228;\n\n    uint16 public messageFinality = 2000;\n    address public messageSender;\n    uint32 public sourceDomain = 4294967295; // 0xFFFFFFFF\n\n    // Full message with header\n    struct Message {\n        uint32 version;\n        uint32 sourceDomain;\n        uint32 destinationDomain;\n        bytes32 recipient;\n        bytes32 messageHeaderRecipient;\n        bytes32 sender;\n        bytes32 destinationCaller;\n        uint32 minFinalityThreshold;\n        bool isTokenTransfer;\n        uint256 tokenAmount;\n        bytes messageBody;\n    }\n\n    Message[] public messages;\n    // map of encoded messages to the corresponding message structs\n    mapping(bytes32 => Message) public encodedMessages;\n\n    constructor(address _usdc) {\n        usdc = IERC20(_usdc);\n    }\n\n    // @dev for the porposes of unit tests queues the message to be mock-sent using\n    // the cctp bridge.\n    function sendMessage(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        uint32 minFinalityThreshold,\n        bytes memory messageBody\n    ) external virtual override {\n        bytes32 nonceHash = keccak256(abi.encodePacked(nonce));\n        nonce++;\n\n        // If destination is mainnet, source is base and vice versa\n        uint32 sourceDomain = destinationDomain == 0 ? 6 : 0;\n\n        Message memory message = Message({\n            version: 1,\n            sourceDomain: sourceDomain,\n            destinationDomain: destinationDomain,\n            recipient: recipient,\n            messageHeaderRecipient: recipient,\n            sender: bytes32(uint256(uint160(msg.sender))),\n            destinationCaller: destinationCaller,\n            minFinalityThreshold: minFinalityThreshold,\n            isTokenTransfer: false,\n            tokenAmount: 0,\n            messageBody: messageBody\n        });\n\n        messages.push(message);\n    }\n\n    // @dev for the porposes of unit tests queues the USDC burn/mint to be executed\n    // using the cctp bridge.\n    function sendTokenTransferMessage(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        uint32 minFinalityThreshold,\n        uint256 tokenAmount,\n        bytes memory messageBody\n    ) external {\n        bytes32 nonceHash = keccak256(abi.encodePacked(nonce));\n        nonce++;\n\n        // If destination is mainnet, source is base and vice versa\n        uint32 sourceDomain = destinationDomain == 0 ? 6 : 0;\n\n        Message memory message = Message({\n            version: 1,\n            sourceDomain: sourceDomain,\n            destinationDomain: destinationDomain,\n            recipient: recipient,\n            messageHeaderRecipient: recipient,\n            sender: bytes32(uint256(uint160(msg.sender))),\n            destinationCaller: destinationCaller,\n            minFinalityThreshold: minFinalityThreshold,\n            isTokenTransfer: true,\n            tokenAmount: tokenAmount,\n            messageBody: messageBody\n        });\n\n        messages.push(message);\n    }\n\n    function receiveMessage(bytes memory message, bytes memory attestation)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        Message memory storedMsg = encodedMessages[keccak256(message)];\n        AbstractCCTPIntegrator recipient = AbstractCCTPIntegrator(\n            address(uint160(uint256(storedMsg.recipient)))\n        );\n\n        bytes32 sender = storedMsg.sender;\n        bytes memory messageBody = storedMsg.messageBody;\n\n        // Credit USDC in this step as it is done in the live cctp contracts\n        if (storedMsg.isTokenTransfer) {\n            usdc.transfer(address(recipient), storedMsg.tokenAmount);\n            // override the sender with the one stored in the Burn message as the sender int he\n            // message header is the TokenMessenger.\n            sender = bytes32(\n                uint256(\n                    uint160(\n                        storedMsg.messageBody.extractAddress(\n                            BURN_MESSAGE_V2_MESSAGE_SENDER_INDEX\n                        )\n                    )\n                )\n            );\n            messageBody = storedMsg.messageBody.extractSlice(\n                BURN_MESSAGE_V2_HOOK_DATA_INDEX,\n                storedMsg.messageBody.length\n            );\n        } else {\n            bytes32 overrideSenderBytes = bytes32(\n                uint256(uint160(messageSender))\n            );\n            if (messageFinality >= 2000) {\n                recipient.handleReceiveFinalizedMessage(\n                    sourceDomain == 4294967295\n                        ? storedMsg.sourceDomain\n                        : sourceDomain,\n                    messageSender == address(0) ? sender : overrideSenderBytes,\n                    messageFinality,\n                    messageBody\n                );\n            } else {\n                recipient.handleReceiveUnfinalizedMessage(\n                    sourceDomain == 4294967295\n                        ? storedMsg.sourceDomain\n                        : sourceDomain,\n                    messageSender == address(0) ? sender : overrideSenderBytes,\n                    messageFinality,\n                    messageBody\n                );\n            }\n        }\n\n        return true;\n    }\n\n    function addMessage(Message memory storedMsg) external {\n        messages.push(storedMsg);\n    }\n\n    function _encodeMessageHeader(\n        uint32 version,\n        uint32 sourceDomain,\n        bytes32 sender,\n        bytes32 recipient,\n        bytes memory messageBody\n    ) internal pure returns (bytes memory) {\n        bytes memory header = abi.encodePacked(\n            version, // 0-3\n            sourceDomain, // 4-7\n            bytes32(0), // 8-39 destinationDomain\n            bytes4(0), // 40-43 nonce\n            sender, // 44-75 sender\n            recipient, // 76-107 recipient\n            bytes32(0), // other stuff\n            bytes8(0) // other stuff\n        );\n        return abi.encodePacked(header, messageBody);\n    }\n\n    function _removeFront() internal returns (Message memory) {\n        require(messages.length > 0, \"No messages\");\n        Message memory removed = messages[0];\n        // Shift array\n        for (uint256 i = 0; i < messages.length - 1; i++) {\n            messages[i] = messages[i + 1];\n        }\n        messages.pop();\n        return removed;\n    }\n\n    function _processMessage(Message memory storedMsg) internal {\n        bytes memory encodedMessage = _encodeMessageHeader(\n            storedMsg.version,\n            storedMsg.sourceDomain,\n            storedMsg.sender,\n            storedMsg.messageHeaderRecipient,\n            storedMsg.messageBody\n        );\n\n        encodedMessages[keccak256(encodedMessage)] = storedMsg;\n\n        address recipient = address(uint160(uint256(storedMsg.recipient)));\n\n        AbstractCCTPIntegrator(recipient).relay(encodedMessage, bytes(\"\"));\n    }\n\n    function _removeBack() internal returns (Message memory) {\n        require(messages.length > 0, \"No messages\");\n        Message memory last = messages[messages.length - 1];\n        messages.pop();\n        return last;\n    }\n\n    function messagesInQueue() external view returns (uint256) {\n        return messages.length;\n    }\n\n    function processFrontOverrideHeader(bytes4 customHeader) external {\n        Message memory storedMsg = _removeFront();\n\n        bytes memory modifiedBody = abi.encodePacked(\n            customHeader,\n            storedMsg.messageBody.extractSlice(4, storedMsg.messageBody.length)\n        );\n\n        storedMsg.messageBody = modifiedBody;\n\n        _processMessage(storedMsg);\n    }\n\n    function processFrontOverrideVersion(uint32 customVersion) external {\n        Message memory storedMsg = _removeFront();\n        storedMsg.version = customVersion;\n        _processMessage(storedMsg);\n    }\n\n    function processFrontOverrideSender(address customSender) external {\n        Message memory storedMsg = _removeFront();\n        storedMsg.sender = bytes32(uint256(uint160(customSender)));\n        _processMessage(storedMsg);\n    }\n\n    function processFrontOverrideRecipient(address customRecipient) external {\n        Message memory storedMsg = _removeFront();\n        storedMsg.messageHeaderRecipient = bytes32(\n            uint256(uint160(customRecipient))\n        );\n        _processMessage(storedMsg);\n    }\n\n    function processFront() external {\n        Message memory storedMsg = _removeFront();\n        _processMessage(storedMsg);\n    }\n\n    function processBack() external {\n        Message memory storedMsg = _removeBack();\n        _processMessage(storedMsg);\n    }\n\n    function getMessagesLength() external view returns (uint256) {\n        return messages.length;\n    }\n\n    function overrideMessageFinality(uint16 _finality) external {\n        messageFinality = _finality;\n    }\n\n    function overrideSender(address _sender) external {\n        messageSender = _sender;\n    }\n\n    function overrideSourceDomain(uint32 _sourceDomain) external {\n        sourceDomain = _sourceDomain;\n    }\n}\n"
    },
    "contracts/mocks/crosschain/CCTPMessageTransmitterMock2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IMessageHandlerV2 } from \"../../interfaces/cctp/ICCTP.sol\";\nimport { BytesHelper } from \"../../utils/BytesHelper.sol\";\nimport { CCTPMessageTransmitterMock } from \"./CCTPMessageTransmitterMock.sol\";\n\nuint8 constant SOURCE_DOMAIN_INDEX = 4;\nuint8 constant RECIPIENT_INDEX = 76;\nuint8 constant SENDER_INDEX = 44;\nuint8 constant MESSAGE_BODY_INDEX = 148;\n\n/**\n * @title Mock conctract simulating the functionality of the CCTPTokenMessenger contract\n *        for the porposes of unit testing.\n * @author Origin Protocol Inc\n */\n\ncontract CCTPMessageTransmitterMock2 is CCTPMessageTransmitterMock {\n    using BytesHelper for bytes;\n\n    address public cctpTokenMessenger;\n\n    event MessageReceivedInMockTransmitter(bytes message);\n    event MessageSent(bytes message);\n\n    constructor(address _usdc) CCTPMessageTransmitterMock(_usdc) {}\n\n    function setCCTPTokenMessenger(address _cctpTokenMessenger) external {\n        cctpTokenMessenger = _cctpTokenMessenger;\n    }\n\n    function sendMessage(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        uint32 minFinalityThreshold,\n        bytes memory messageBody\n    ) external virtual override {\n        bytes memory message = abi.encodePacked(\n            uint32(1), // version\n            uint32(destinationDomain == 0 ? 6 : 0), // source domain\n            uint32(destinationDomain), // destination domain\n            uint256(0),\n            bytes32(uint256(uint160(msg.sender))), // sender\n            recipient, // recipient\n            destinationCaller, // destination caller\n            minFinalityThreshold, // min finality threshold\n            uint32(0),\n            messageBody // message body\n        );\n        emit MessageSent(message);\n    }\n\n    function receiveMessage(bytes memory message, bytes memory attestation)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        uint32 sourceDomain = message.extractUint32(SOURCE_DOMAIN_INDEX);\n        address recipient = message.extractAddress(RECIPIENT_INDEX);\n        address sender = message.extractAddress(SENDER_INDEX);\n\n        bytes memory messageBody = message.extractSlice(\n            MESSAGE_BODY_INDEX,\n            message.length\n        );\n\n        bool isBurnMessage = recipient == cctpTokenMessenger;\n\n        if (isBurnMessage) {\n            // recipient = messageBody.extractAddress(BURN_MESSAGE_V2_RECIPIENT_INDEX);\n            // This step won't mint USDC, transfer it to the recipient address\n            // in your tests\n        } else {\n            IMessageHandlerV2(recipient).handleReceiveFinalizedMessage(\n                sourceDomain,\n                bytes32(uint256(uint160(sender))),\n                2000,\n                messageBody\n            );\n        }\n\n        // This step won't mint USDC, transfer it to the recipient address\n        // in your tests\n        emit MessageReceivedInMockTransmitter(message);\n\n        return true;\n    }\n}\n"
    },
    "contracts/mocks/crosschain/CCTPTokenMessengerMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ICCTPTokenMessenger } from \"../../interfaces/cctp/ICCTP.sol\";\nimport { CCTPMessageTransmitterMock } from \"./CCTPMessageTransmitterMock.sol\";\nimport { IERC20 } from \"../../utils/InitializableAbstractStrategy.sol\";\n\n/**\n * @title Mock conctract simulating the functionality of the CCTPTokenMessenger contract\n *        for the porposes of unit testing.\n * @author Origin Protocol Inc\n */\n\ncontract CCTPTokenMessengerMock is ICCTPTokenMessenger {\n    IERC20 public usdc;\n    CCTPMessageTransmitterMock public cctpMessageTransmitterMock;\n\n    constructor(address _usdc, address _cctpMessageTransmitterMock) {\n        usdc = IERC20(_usdc);\n        cctpMessageTransmitterMock = CCTPMessageTransmitterMock(\n            _cctpMessageTransmitterMock\n        );\n    }\n\n    function depositForBurn(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller,\n        uint256 maxFee,\n        uint32 minFinalityThreshold\n    ) external override {\n        revert(\"Not implemented\");\n    }\n\n    /**\n     * @dev mocks the depositForBurnWithHook function by sending the USDC to the CCTPMessageTransmitterMock\n     *      called by the AbstractCCTPIntegrator contract.\n     */\n    function depositForBurnWithHook(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller,\n        uint256 maxFee,\n        uint32 minFinalityThreshold,\n        bytes memory hookData\n    ) external override {\n        require(burnToken == address(usdc), \"Invalid burn token\");\n\n        usdc.transferFrom(msg.sender, address(this), maxFee);\n        uint256 destinationAmount = amount - maxFee;\n        usdc.transferFrom(\n            msg.sender,\n            address(cctpMessageTransmitterMock),\n            destinationAmount\n        );\n\n        bytes memory burnMessage = _encodeBurnMessageV2(\n            mintRecipient,\n            amount,\n            msg.sender,\n            maxFee,\n            maxFee,\n            hookData\n        );\n\n        cctpMessageTransmitterMock.sendTokenTransferMessage(\n            destinationDomain,\n            mintRecipient,\n            destinationCaller,\n            minFinalityThreshold,\n            destinationAmount,\n            burnMessage\n        );\n    }\n\n    function _encodeBurnMessageV2(\n        bytes32 mintRecipient,\n        uint256 amount,\n        address messageSender,\n        uint256 maxFee,\n        uint256 feeExecuted,\n        bytes memory hookData\n    ) internal view returns (bytes memory) {\n        bytes32 burnTokenBytes32 = bytes32(\n            abi.encodePacked(bytes12(0), bytes20(uint160(address(usdc))))\n        );\n        bytes32 messageSenderBytes32 = bytes32(\n            abi.encodePacked(bytes12(0), bytes20(uint160(messageSender)))\n        );\n        bytes32 expirationBlock = bytes32(0);\n\n        // Ref: https://developers.circle.com/cctp/technical-guide#message-body\n        return\n            abi.encodePacked(\n                uint32(1), // 0-3: version\n                burnTokenBytes32, // 4-35: burnToken (bytes32 left-padded address)\n                mintRecipient, // 36-67: mintRecipient (bytes32 left-padded address)\n                amount, // 68-99: uint256 amount\n                messageSenderBytes32, // 100-131: messageSender (bytes32 left-padded address)\n                maxFee, // 132-163: uint256 maxFee\n                feeExecuted, // 164-195: uint256 feeExecuted\n                expirationBlock, // 196-227: bytes32 expirationBlock\n                hookData // 228+: dynamic hookData\n            );\n    }\n\n    function getMinFeeAmount(uint256 amount)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return 0;\n    }\n}\n"
    },
    "contracts/strategies/crosschain/AbstractCCTPIntegrator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title AbstractCCTPIntegrator\n * @author Origin Protocol Inc\n *\n * @dev Abstract contract that contains all the logic used to integrate with CCTP.\n */\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"../../utils/InitializableAbstractStrategy.sol\";\n\nimport { ICCTPTokenMessenger, ICCTPMessageTransmitter, IMessageHandlerV2 } from \"../../interfaces/cctp/ICCTP.sol\";\n\nimport { CrossChainStrategyHelper } from \"./CrossChainStrategyHelper.sol\";\nimport { Governable } from \"../../governance/Governable.sol\";\nimport { BytesHelper } from \"../../utils/BytesHelper.sol\";\nimport \"../../utils/Helpers.sol\";\n\nabstract contract AbstractCCTPIntegrator is Governable, IMessageHandlerV2 {\n    using SafeERC20 for IERC20;\n\n    using BytesHelper for bytes;\n    using CrossChainStrategyHelper for bytes;\n\n    event CCTPMinFinalityThresholdSet(uint16 minFinalityThreshold);\n    event CCTPFeePremiumBpsSet(uint16 feePremiumBps);\n    event OperatorChanged(address operator);\n    event TokensBridged(\n        uint32 destinationDomain,\n        address peerStrategy,\n        address tokenAddress,\n        uint256 tokenAmount,\n        uint256 maxFee,\n        uint32 minFinalityThreshold,\n        bytes hookData\n    );\n    event MessageTransmitted(\n        uint32 destinationDomain,\n        address peerStrategy,\n        uint32 minFinalityThreshold,\n        bytes message\n    );\n\n    // Message body V2 fields\n    // Ref: https://developers.circle.com/cctp/technical-guide#message-body\n    // Ref: https://github.com/circlefin/evm-cctp-contracts/blob/master/src/messages/v2/BurnMessageV2.sol\n    uint8 private constant BURN_MESSAGE_V2_VERSION_INDEX = 0;\n    uint8 private constant BURN_MESSAGE_V2_RECIPIENT_INDEX = 36;\n    uint8 private constant BURN_MESSAGE_V2_AMOUNT_INDEX = 68;\n    uint8 private constant BURN_MESSAGE_V2_MESSAGE_SENDER_INDEX = 100;\n    uint8 private constant BURN_MESSAGE_V2_FEE_EXECUTED_INDEX = 164;\n    uint8 private constant BURN_MESSAGE_V2_HOOK_DATA_INDEX = 228;\n\n    /**\n     * @notice  Max transfer threshold imposed by the CCTP\n     *          Ref: https://developers.circle.com/cctp/evm-smart-contracts#depositforburn\n     * @dev     10M USDC limit applies to both standard and fast transfer modes. The fast transfer mode has\n     *          an additional limitation that is not present on-chain and Circle may alter that amount off-chain\n     *          at their preference. The amount available for fast transfer can be queried here:\n     *          https://iris-api.circle.com/v2/fastBurn/USDC/allowance .\n     *          If a fast transfer token transaction has been issued and there is not enough allowance for it\n     *          the off-chain Iris component will re-attempt the transaction and if it fails it will fallback\n     *          to a standard transfer. Reference section 4.3 in the whitepaper:\n     *          https://6778953.fs1.hubspotusercontent-na1.net/hubfs/6778953/PDFs/Whitepapers/CCTPV2_White_Paper.pdf\n     */\n    uint256 public constant MAX_TRANSFER_AMOUNT = 10_000_000 * 10**6; // 10M USDC\n\n    // CCTP contracts\n    // This implementation assumes that remote and local chains have these contracts\n    // deployed on the same addresses.\n    /// @notice CCTP message transmitter contract\n    ICCTPMessageTransmitter public immutable cctpMessageTransmitter;\n    /// @notice CCTP token messenger contract\n    ICCTPTokenMessenger public immutable cctpTokenMessenger;\n\n    /// @notice USDC address on local chain\n    address public immutable usdcToken;\n\n    /// @notice Domain ID of the chain from which messages are accepted\n    uint32 public immutable peerDomainID;\n\n    /// @notice Strategy address on other chain\n    address public immutable peerStrategy;\n\n    /**\n     * @notice Minimum finality threshold\n     *         Can be 1000 (safe, after 1 epoch) or 2000 (finalized, after 2 epochs).\n     *         Ref: https://developers.circle.com/cctp/technical-guide#finality-thresholds\n     * @dev    When configuring the contract for fast transfer we should check the available\n     *         allowance of USDC that can be bridged using fast mode:\n     *         wget https://iris-api.circle.com/v2/fastBurn/USDC/allowance\n     */\n    uint16 public minFinalityThreshold;\n\n    /// @notice Fee premium in basis points\n    uint16 public feePremiumBps;\n\n    /// @notice Nonce of the last known deposit or withdrawal\n    uint64 public lastTransferNonce;\n\n    /// @notice Operator address: Can relay CCTP messages\n    address public operator;\n\n    /// @notice Mapping of processed nonces\n    mapping(uint64 => bool) private nonceProcessed;\n\n    // For future use\n    uint256[48] private __gap;\n\n    modifier onlyCCTPMessageTransmitter() {\n        require(\n            msg.sender == address(cctpMessageTransmitter),\n            \"Caller is not CCTP transmitter\"\n        );\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(msg.sender == operator, \"Caller is not the Operator\");\n        _;\n    }\n\n    /**\n     * @notice Configuration for CCTP integration\n     * @param cctpTokenMessenger Address of the CCTP token messenger contract\n     * @param cctpMessageTransmitter Address of the CCTP message transmitter contract\n     * @param peerDomainID Domain ID of the chain from which messages are accepted.\n     *         0 for Ethereum, 6 for Base, etc.\n     *         Ref: https://developers.circle.com/cctp/cctp-supported-blockchains\n     * @param peerStrategy Address of the master or remote strategy on the other chain\n     * @param usdcToken USDC address on local chain\n     */\n    struct CCTPIntegrationConfig {\n        address cctpTokenMessenger;\n        address cctpMessageTransmitter;\n        uint32 peerDomainID;\n        address peerStrategy;\n        address usdcToken;\n    }\n\n    constructor(CCTPIntegrationConfig memory _config) {\n        require(_config.usdcToken != address(0), \"Invalid USDC address\");\n        require(\n            _config.cctpTokenMessenger != address(0),\n            \"Invalid CCTP config\"\n        );\n        require(\n            _config.cctpMessageTransmitter != address(0),\n            \"Invalid CCTP config\"\n        );\n        require(\n            _config.peerStrategy != address(0),\n            \"Invalid peer strategy address\"\n        );\n\n        cctpMessageTransmitter = ICCTPMessageTransmitter(\n            _config.cctpMessageTransmitter\n        );\n        cctpTokenMessenger = ICCTPTokenMessenger(_config.cctpTokenMessenger);\n\n        // Domain ID of the chain from which messages are accepted\n        peerDomainID = _config.peerDomainID;\n\n        // Strategy address on other chain, should\n        // always be same as the proxy of this strategy\n        peerStrategy = _config.peerStrategy;\n\n        // USDC address on local chain\n        usdcToken = _config.usdcToken;\n\n        // Just a sanity check to ensure the base token is USDC\n        uint256 _usdcTokenDecimals = Helpers.getDecimals(_config.usdcToken);\n        string memory _usdcTokenSymbol = Helpers.getSymbol(_config.usdcToken);\n        require(_usdcTokenDecimals == 6, \"Base token decimals must be 6\");\n        require(\n            keccak256(abi.encodePacked(_usdcTokenSymbol)) ==\n                keccak256(abi.encodePacked(\"USDC\")),\n            \"Token symbol must be USDC\"\n        );\n    }\n\n    /**\n     * @dev Initialize the implementation contract\n     * @param _operator Operator address\n     * @param _minFinalityThreshold Minimum finality threshold\n     * @param _feePremiumBps Fee premium in basis points\n     */\n    function _initialize(\n        address _operator,\n        uint16 _minFinalityThreshold,\n        uint16 _feePremiumBps\n    ) internal {\n        _setOperator(_operator);\n        _setMinFinalityThreshold(_minFinalityThreshold);\n        _setFeePremiumBps(_feePremiumBps);\n\n        // Nonce starts at 1, so assume nonce 0 as processed.\n        // NOTE: This will cause the deposit/withdraw to fail if the\n        // strategy is not initialized properly (which is expected).\n        nonceProcessed[0] = true;\n    }\n\n    /***************************************\n                    Settings\n    ****************************************/\n    /**\n     * @dev Set the operator address\n     * @param _operator Operator address\n     */\n    function setOperator(address _operator) external onlyGovernor {\n        _setOperator(_operator);\n    }\n\n    /**\n     * @dev Set the operator address\n     * @param _operator Operator address\n     */\n    function _setOperator(address _operator) internal {\n        operator = _operator;\n        emit OperatorChanged(_operator);\n    }\n\n    /**\n     * @dev Set the minimum finality threshold at which\n     *      the message is considered to be finalized to relay.\n     *      Only accepts a value of 1000 (Safe, after 1 epoch) or\n     *      2000 (Finalized, after 2 epochs).\n     * @param _minFinalityThreshold Minimum finality threshold\n     */\n    function setMinFinalityThreshold(uint16 _minFinalityThreshold)\n        external\n        onlyGovernor\n    {\n        _setMinFinalityThreshold(_minFinalityThreshold);\n    }\n\n    /**\n     * @dev Set the minimum finality threshold\n     * @param _minFinalityThreshold Minimum finality threshold\n     */\n    function _setMinFinalityThreshold(uint16 _minFinalityThreshold) internal {\n        // 1000 for fast transfer and 2000 for standard transfer\n        require(\n            _minFinalityThreshold == 1000 || _minFinalityThreshold == 2000,\n            \"Invalid threshold\"\n        );\n\n        minFinalityThreshold = _minFinalityThreshold;\n        emit CCTPMinFinalityThresholdSet(_minFinalityThreshold);\n    }\n\n    /**\n     * @dev Set the fee premium in basis points.\n     *      Cannot be higher than 30% (3000 basis points).\n     * @param _feePremiumBps Fee premium in basis points\n     */\n    function setFeePremiumBps(uint16 _feePremiumBps) external onlyGovernor {\n        _setFeePremiumBps(_feePremiumBps);\n    }\n\n    /**\n     * @dev Set the fee premium in basis points\n     *      Cannot be higher than 30% (3000 basis points).\n     *      Ref: https://developers.circle.com/cctp/technical-guide#fees\n     * @param _feePremiumBps Fee premium in basis points\n     */\n    function _setFeePremiumBps(uint16 _feePremiumBps) internal {\n        require(_feePremiumBps <= 3000, \"Fee premium too high\"); // 30%\n\n        feePremiumBps = _feePremiumBps;\n        emit CCTPFeePremiumBpsSet(_feePremiumBps);\n    }\n\n    /***************************************\n             CCTP message handling\n    ****************************************/\n\n    /**\n     * @dev Handles a finalized CCTP message\n     * @param sourceDomain Source domain of the message\n     * @param sender Sender of the message\n     * @param finalityThresholdExecuted Fidelity threshold executed\n     * @param messageBody Message body\n     */\n    function handleReceiveFinalizedMessage(\n        uint32 sourceDomain,\n        bytes32 sender,\n        uint32 finalityThresholdExecuted,\n        bytes memory messageBody\n    ) external override onlyCCTPMessageTransmitter returns (bool) {\n        // Make sure the finality threshold at execution is at least 2000\n        require(\n            finalityThresholdExecuted >= 2000,\n            \"Finality threshold too low\"\n        );\n\n        return _handleReceivedMessage(sourceDomain, sender, messageBody);\n    }\n\n    /**\n     * @dev Handles an unfinalized but safe CCTP message\n     * @param sourceDomain Source domain of the message\n     * @param sender Sender of the message\n     * @param finalityThresholdExecuted Fidelity threshold executed\n     * @param messageBody Message body\n     */\n    function handleReceiveUnfinalizedMessage(\n        uint32 sourceDomain,\n        bytes32 sender,\n        uint32 finalityThresholdExecuted,\n        bytes memory messageBody\n    ) external override onlyCCTPMessageTransmitter returns (bool) {\n        // Make sure the contract is configured to handle unfinalized messages\n        require(\n            minFinalityThreshold == 1000,\n            \"Unfinalized messages are not supported\"\n        );\n        // Make sure the finality threshold at execution is at least 1000\n        require(\n            finalityThresholdExecuted >= 1000,\n            \"Finality threshold too low\"\n        );\n\n        return _handleReceivedMessage(sourceDomain, sender, messageBody);\n    }\n\n    /**\n     * @dev Handles a CCTP message\n     * @param sourceDomain Source domain of the message\n     * @param sender Sender of the message\n     * @param messageBody Message body\n     */\n    function _handleReceivedMessage(\n        uint32 sourceDomain,\n        bytes32 sender,\n        bytes memory messageBody\n    ) internal returns (bool) {\n        require(sourceDomain == peerDomainID, \"Unknown Source Domain\");\n\n        // Extract address from bytes32 (CCTP stores addresses as right-padded bytes32)\n        address senderAddress = address(uint160(uint256(sender)));\n        require(senderAddress == peerStrategy, \"Unknown Sender\");\n\n        _onMessageReceived(messageBody);\n\n        return true;\n    }\n\n    /**\n     * @dev Sends tokens to the peer strategy using CCTP Token Messenger\n     * @param tokenAmount Amount of tokens to send\n     * @param hookData Hook data\n     */\n    function _sendTokens(uint256 tokenAmount, bytes memory hookData)\n        internal\n        virtual\n    {\n        // CCTP has a maximum transfer amount of 10M USDC per tx\n        require(tokenAmount <= MAX_TRANSFER_AMOUNT, \"Token amount too high\");\n\n        // Approve only what needs to be transferred\n        IERC20(usdcToken).safeApprove(address(cctpTokenMessenger), tokenAmount);\n\n        // Compute the max fee to be paid.\n        // Ref: https://developers.circle.com/cctp/evm-smart-contracts#getminfeeamount\n        // The right way to compute fees would be to use CCTP's getMinFeeAmount function.\n        // The issue is that the getMinFeeAmount is not present on v2.0 contracts, but is on\n        // v2.1. Some of CCTP's deployed contracts are v2.0, some are v2.1.\n        // We will only be using standard transfers and fee on those is 0 for now. If they\n        // ever start implementing fee for standard transfers or if we decide to use fast\n        // trasnfer, we can use feePremiumBps as a workaround.\n        uint256 maxFee = feePremiumBps > 0\n            ? (tokenAmount * feePremiumBps) / 10000\n            : 0;\n\n        // Send tokens to the peer strategy using CCTP Token Messenger\n        cctpTokenMessenger.depositForBurnWithHook(\n            tokenAmount,\n            peerDomainID,\n            bytes32(uint256(uint160(peerStrategy))),\n            address(usdcToken),\n            bytes32(uint256(uint160(peerStrategy))),\n            maxFee,\n            uint32(minFinalityThreshold),\n            hookData\n        );\n\n        emit TokensBridged(\n            peerDomainID,\n            peerStrategy,\n            usdcToken,\n            tokenAmount,\n            maxFee,\n            uint32(minFinalityThreshold),\n            hookData\n        );\n    }\n\n    /**\n     * @dev Sends a message to the peer strategy using CCTP Message Transmitter\n     * @param message Payload of the message to send\n     */\n    function _sendMessage(bytes memory message) internal virtual {\n        cctpMessageTransmitter.sendMessage(\n            peerDomainID,\n            bytes32(uint256(uint160(peerStrategy))),\n            bytes32(uint256(uint160(peerStrategy))),\n            uint32(minFinalityThreshold),\n            message\n        );\n\n        emit MessageTransmitted(\n            peerDomainID,\n            peerStrategy,\n            uint32(minFinalityThreshold),\n            message\n        );\n    }\n\n    /**\n     * @dev Receives a message from the peer strategy on the other chain,\n     *      does some basic checks and relays it to the local MessageTransmitterV2.\n     *      If the message is a burn message, it will also handle the hook data\n     *      and call the _onTokenReceived function.\n     * @param message Payload of the message to send\n     * @param attestation Attestation of the message\n     */\n    function relay(bytes memory message, bytes memory attestation)\n        external\n        onlyOperator\n    {\n        (\n            uint32 version,\n            uint32 sourceDomainID,\n            address sender,\n            address recipient,\n            bytes memory messageBody\n        ) = message.decodeMessageHeader();\n\n        // Ensure that it's a CCTP message\n        require(\n            version == CrossChainStrategyHelper.CCTP_MESSAGE_VERSION,\n            \"Invalid CCTP message version\"\n        );\n\n        // Ensure that the source domain is the peer domain\n        require(sourceDomainID == peerDomainID, \"Unknown Source Domain\");\n\n        // Ensure message body version\n        version = messageBody.extractUint32(BURN_MESSAGE_V2_VERSION_INDEX);\n\n        // NOTE: There's a possibility that the CCTP Token Messenger might\n        // send other types of messages in future, not just the burn message.\n        // If it ever comes to that, this shouldn't cause us any problems\n        // because it has to still go through the followign checks:\n        // - version check\n        // - message body length check\n        // - sender and recipient (which should be in the same slots and same as address(this))\n        // - hook data handling (which will revert even if all the above checks pass)\n        bool isBurnMessageV1 = sender == address(cctpTokenMessenger);\n\n        if (isBurnMessageV1) {\n            // Handle burn message\n            require(\n                version == 1 &&\n                    messageBody.length >= BURN_MESSAGE_V2_HOOK_DATA_INDEX,\n                \"Invalid burn message\"\n            );\n\n            // Address of caller of depositForBurn (or depositForBurnWithCaller) on source domain\n            sender = messageBody.extractAddress(\n                BURN_MESSAGE_V2_MESSAGE_SENDER_INDEX\n            );\n\n            recipient = messageBody.extractAddress(\n                BURN_MESSAGE_V2_RECIPIENT_INDEX\n            );\n        } else {\n            // We handle only Burn message or our custom messagee\n            require(\n                version == CrossChainStrategyHelper.ORIGIN_MESSAGE_VERSION,\n                \"Unsupported message version\"\n            );\n        }\n\n        // Ensure the recipient is this contract\n        // Both sender and recipient should be deployed to same address on both chains.\n        require(address(this) == recipient, \"Unexpected recipient address\");\n        require(sender == peerStrategy, \"Incorrect sender/recipient address\");\n\n        // Relay the message\n        // This step also mints USDC and transfers it to the recipient wallet\n        bool relaySuccess = cctpMessageTransmitter.receiveMessage(\n            message,\n            attestation\n        );\n        require(relaySuccess, \"Receive message failed\");\n\n        if (isBurnMessageV1) {\n            // Extract the hook data from the message body\n            bytes memory hookData = messageBody.extractSlice(\n                BURN_MESSAGE_V2_HOOK_DATA_INDEX,\n                messageBody.length\n            );\n\n            // Extract the token amount from the message body\n            uint256 tokenAmount = messageBody.extractUint256(\n                BURN_MESSAGE_V2_AMOUNT_INDEX\n            );\n\n            // Extract the fee executed from the message body\n            uint256 feeExecuted = messageBody.extractUint256(\n                BURN_MESSAGE_V2_FEE_EXECUTED_INDEX\n            );\n\n            // Call the _onTokenReceived function\n            _onTokenReceived(tokenAmount - feeExecuted, feeExecuted, hookData);\n        }\n    }\n\n    /***************************************\n                  Message utils\n    ****************************************/\n\n    /***************************************\n                  Nonce Handling\n    ****************************************/\n    /**\n     * @dev Checks if the last known transfer is pending.\n     *      Nonce starts at 1, so 0 is disregarded.\n     * @return True if a transfer is pending, false otherwise\n     */\n    function isTransferPending() public view returns (bool) {\n        return !nonceProcessed[lastTransferNonce];\n    }\n\n    /**\n     * @dev Checks if a given nonce is processed.\n     *      Nonce starts at 1, so 0 is disregarded.\n     * @param nonce Nonce to check\n     * @return True if the nonce is processed, false otherwise\n     */\n    function isNonceProcessed(uint64 nonce) public view returns (bool) {\n        return nonceProcessed[nonce];\n    }\n\n    /**\n     * @dev Marks a given nonce as processed.\n     *      Can only mark nonce as processed once. New nonce should\n     *      always be greater than the last known nonce. Also updates\n     *      the last known nonce.\n     * @param nonce Nonce to mark as processed\n     */\n    function _markNonceAsProcessed(uint64 nonce) internal {\n        uint64 lastNonce = lastTransferNonce;\n\n        // Can only mark latest nonce as processed\n        // Master strategy when receiving a message from the remote strategy\n        // will have lastNone == nonce, as the nonce is increase at the start\n        // of deposit / withdrawal flow.\n        // Remote strategy will have lastNonce < nonce, as a new nonce initiated\n        // from master will be greater than the last one.\n        require(nonce >= lastNonce, \"Nonce too low\");\n        // Can only mark nonce as processed once\n        require(!nonceProcessed[nonce], \"Nonce already processed\");\n\n        nonceProcessed[nonce] = true;\n\n        if (nonce != lastNonce) {\n            // Update last known nonce\n            lastTransferNonce = nonce;\n        }\n    }\n\n    /**\n     * @dev Gets the next nonce to use.\n     *      Nonce starts at 1, so 0 is disregarded.\n     *      Reverts if last nonce hasn't been processed yet.\n     * @return Next nonce\n     */\n    function _getNextNonce() internal returns (uint64) {\n        uint64 nonce = lastTransferNonce;\n\n        require(nonceProcessed[nonce], \"Pending token transfer\");\n\n        nonce = nonce + 1;\n        lastTransferNonce = nonce;\n\n        return nonce;\n    }\n\n    /***************************************\n             Inheritence overrides\n    ****************************************/\n\n    /**\n     * @dev Called when the USDC is received from the CCTP\n     * @param tokenAmount The actual amount of USDC received (amount sent - fee executed)\n     * @param feeExecuted The fee executed\n     * @param payload The payload of the message (hook data)\n     */\n    function _onTokenReceived(\n        uint256 tokenAmount,\n        uint256 feeExecuted,\n        bytes memory payload\n    ) internal virtual;\n\n    /**\n     * @dev Called when the message is received\n     * @param payload The payload of the message\n     */\n    function _onMessageReceived(bytes memory payload) internal virtual;\n}\n"
    },
    "contracts/strategies/crosschain/CrossChainMasterStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD Yearn V3 Master Strategy - the Mainnet part\n * @author Origin Protocol Inc\n *\n * @dev This strategy can only perform 1 deposit or withdrawal at a time. For that\n *      reason it shouldn't be configured as an asset default strategy.\n */\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { AbstractCCTPIntegrator } from \"./AbstractCCTPIntegrator.sol\";\nimport { CrossChainStrategyHelper } from \"./CrossChainStrategyHelper.sol\";\n\ncontract CrossChainMasterStrategy is\n    AbstractCCTPIntegrator,\n    InitializableAbstractStrategy\n{\n    using SafeERC20 for IERC20;\n    using CrossChainStrategyHelper for bytes;\n\n    /**\n     * @notice Remote strategy balance\n     * @dev    The remote balance is cached and might not reflect the actual\n     *         real-time balance of the remote strategy.\n     */\n    uint256 public remoteStrategyBalance;\n\n    /// @notice Amount that's bridged due to a pending Deposit process\n    ///         but with no acknowledgement from the remote strategy yet\n    uint256 public pendingAmount;\n\n    event RemoteStrategyBalanceUpdated(uint256 balance);\n    event WithdrawRequested(address indexed asset, uint256 amount);\n\n    /**\n     * @param _stratConfig The platform and OToken vault addresses\n     */\n    constructor(\n        BaseStrategyConfig memory _stratConfig,\n        CCTPIntegrationConfig memory _cctpConfig\n    )\n        InitializableAbstractStrategy(_stratConfig)\n        AbstractCCTPIntegrator(_cctpConfig)\n    {\n        require(\n            _stratConfig.platformAddress == address(0),\n            \"Invalid platform address\"\n        );\n        require(\n            _stratConfig.vaultAddress != address(0),\n            \"Invalid Vault address\"\n        );\n    }\n\n    /**\n     * @dev Initialize the strategy implementation\n     * @param _operator Address of the operator\n     * @param _minFinalityThreshold Minimum finality threshold\n     * @param _feePremiumBps Fee premium in basis points\n     */\n    function initialize(\n        address _operator,\n        uint16 _minFinalityThreshold,\n        uint16 _feePremiumBps\n    ) external virtual onlyGovernor initializer {\n        _initialize(_operator, _minFinalityThreshold, _feePremiumBps);\n\n        address[] memory rewardTokens = new address[](0);\n        address[] memory assets = new address[](0);\n        address[] memory pTokens = new address[](0);\n\n        InitializableAbstractStrategy._initialize(\n            rewardTokens,\n            assets,\n            pTokens\n        );\n    }\n\n    /// @inheritdoc InitializableAbstractStrategy\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /// @inheritdoc InitializableAbstractStrategy\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 balance = IERC20(usdcToken).balanceOf(address(this));\n        // Deposit if balance is greater than 1 USDC\n        if (balance >= 1e6) {\n            _deposit(usdcToken, balance);\n        }\n    }\n\n    /// @inheritdoc InitializableAbstractStrategy\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_recipient == vaultAddress, \"Only Vault can withdraw\");\n        _withdraw(_asset, _amount);\n    }\n\n    /// @inheritdoc InitializableAbstractStrategy\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        if (isTransferPending()) {\n            // Do nothing if there is a pending transfer\n            return;\n        }\n\n        // Withdraw everything in Remote strategy\n        uint256 _remoteBalance = remoteStrategyBalance;\n        if (_remoteBalance < 1e6) {\n            // Do nothing if there is less than 1 USDC in the Remote strategy\n            return;\n        }\n\n        _withdraw(\n            usdcToken,\n            _remoteBalance > MAX_TRANSFER_AMOUNT\n                ? MAX_TRANSFER_AMOUNT\n                : _remoteBalance\n        );\n    }\n\n    /**\n     * @notice Check the balance of the strategy that includes\n     *          the balance of the asset on this contract,\n     *          the amount of the asset being bridged,\n     *          and the balance reported by the Remote strategy.\n     * @param _asset Address of the asset to check\n     * @return balance Total balance of the asset\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == usdcToken, \"Unsupported asset\");\n\n        // USDC balance on this contract\n        // + USDC being bridged\n        // + USDC cached in the corresponding Remote part of this contract\n        return\n            IERC20(usdcToken).balanceOf(address(this)) +\n            pendingAmount +\n            remoteStrategyBalance;\n    }\n\n    /// @inheritdoc InitializableAbstractStrategy\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == usdcToken;\n    }\n\n    /// @inheritdoc InitializableAbstractStrategy\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {}\n\n    /// @inheritdoc InitializableAbstractStrategy\n    function _abstractSetPToken(address, address) internal override {}\n\n    /// @inheritdoc InitializableAbstractStrategy\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {}\n\n    /// @inheritdoc AbstractCCTPIntegrator\n    function _onMessageReceived(bytes memory payload) internal override {\n        if (\n            payload.getMessageType() ==\n            CrossChainStrategyHelper.BALANCE_CHECK_MESSAGE\n        ) {\n            // Received when Remote strategy checks the balance\n            _processBalanceCheckMessage(payload);\n            return;\n        }\n\n        revert(\"Unknown message type\");\n    }\n\n    /// @inheritdoc AbstractCCTPIntegrator\n    function _onTokenReceived(\n        uint256 tokenAmount,\n        // solhint-disable-next-line no-unused-vars\n        uint256 feeExecuted,\n        bytes memory payload\n    ) internal override {\n        uint64 _nonce = lastTransferNonce;\n\n        // Should be expecting an acknowledgement\n        require(!isNonceProcessed(_nonce), \"Nonce already processed\");\n\n        // Now relay to the regular flow\n        // NOTE: Calling _onMessageReceived would mean that we are bypassing a\n        // few checks that the regular flow does (like sourceDomainID check\n        // and sender check in `handleReceiveFinalizedMessage`). However,\n        // CCTPMessageRelayer relays the message first (which will go through\n        // all the checks) and not update balance and then finally calls this\n        // `_onTokenReceived` which will update the balance.\n        // So, if any of the checks fail during the first no-balance-update flow,\n        // this won't happen either, since the tx would revert.\n        _onMessageReceived(payload);\n\n        // Send any tokens in the contract to the Vault\n        uint256 usdcBalance = IERC20(usdcToken).balanceOf(address(this));\n        // Should always have enough tokens\n        require(usdcBalance >= tokenAmount, \"Insufficient balance\");\n        // Transfer all tokens to the Vault to not leave any dust\n        IERC20(usdcToken).safeTransfer(vaultAddress, usdcBalance);\n\n        // Emit withdrawal amount\n        emit Withdrawal(usdcToken, usdcToken, usdcBalance);\n    }\n\n    /**\n     * @dev Bridge and deposit asset into the remote strategy\n     * @param _asset Address of the asset to deposit\n     * @param depositAmount Amount of the asset to deposit\n     */\n    function _deposit(address _asset, uint256 depositAmount) internal virtual {\n        require(_asset == usdcToken, \"Unsupported asset\");\n        require(pendingAmount == 0, \"Unexpected pending amount\");\n        // Deposit at least 1 USDC\n        require(depositAmount >= 1e6, \"Deposit amount too small\");\n        require(\n            depositAmount <= MAX_TRANSFER_AMOUNT,\n            \"Deposit amount too high\"\n        );\n\n        // Get the next nonce\n        // Note: reverts if a transfer is pending\n        uint64 nonce = _getNextNonce();\n\n        // Set pending amount\n        pendingAmount = depositAmount;\n\n        // Build deposit message payload\n        bytes memory message = CrossChainStrategyHelper.encodeDepositMessage(\n            nonce,\n            depositAmount\n        );\n\n        // Send deposit message to the remote strategy\n        _sendTokens(depositAmount, message);\n\n        // Emit deposit event\n        emit Deposit(_asset, _asset, depositAmount);\n    }\n\n    /**\n     * @dev Send a withdraw request to the remote strategy\n     * @param _asset Address of the asset to withdraw\n     * @param _amount Amount of the asset to withdraw\n     */\n    function _withdraw(address _asset, uint256 _amount) internal virtual {\n        require(_asset == usdcToken, \"Unsupported asset\");\n        // Withdraw at least 1 USDC\n        require(_amount >= 1e6, \"Withdraw amount too small\");\n        require(\n            _amount <= remoteStrategyBalance,\n            \"Withdraw amount exceeds remote strategy balance\"\n        );\n        require(\n            _amount <= MAX_TRANSFER_AMOUNT,\n            \"Withdraw amount exceeds max transfer amount\"\n        );\n\n        // Get the next nonce\n        // Note: reverts if a transfer is pending\n        uint64 nonce = _getNextNonce();\n\n        // Build and send withdrawal message with payload\n        bytes memory message = CrossChainStrategyHelper.encodeWithdrawMessage(\n            nonce,\n            _amount\n        );\n        _sendMessage(message);\n\n        // Emit WithdrawRequested event here,\n        // Withdraw will be emitted in _onTokenReceived\n        emit WithdrawRequested(usdcToken, _amount);\n    }\n\n    /**\n     * @dev Process balance check:\n     *  - Confirms a deposit to the remote strategy\n     *  - Skips balance update if there's a pending withdrawal\n     *  - Updates the remote strategy balance\n     * @param message The message containing the nonce and balance\n     */\n    function _processBalanceCheckMessage(bytes memory message)\n        internal\n        virtual\n    {\n        // Decode the message\n        // When transferConfirmation is true, it means that the message is a result of a deposit or a withdrawal\n        // process.\n        (uint64 nonce, uint256 balance, bool transferConfirmation) = message\n            .decodeBalanceCheckMessage();\n        // Get the last cached nonce\n        uint64 _lastCachedNonce = lastTransferNonce;\n\n        if (nonce != _lastCachedNonce) {\n            // If nonce is not the last cached nonce, it is an outdated message\n            // Ignore it\n            return;\n        }\n\n        // A received message nonce not yet processed indicates there is a\n        // deposit or withdrawal in progress.\n        bool transferInProgress = isTransferPending();\n\n        if (transferInProgress) {\n            if (transferConfirmation) {\n                // Apply the effects of the deposit / withdrawal completion\n                _markNonceAsProcessed(nonce);\n                pendingAmount = 0;\n            } else {\n                // A balanceCheck arrived that is not part of the deposit / withdrawal process\n                // that has been generated on the Remote contract after the deposit / withdrawal which is\n                // still pending. This can happen when the CCTP bridge delivers the messages out of order.\n                // Ignore it, since the pending deposit / withdrawal must first be cofirmed.\n                return;\n            }\n        }\n\n        // At this point update the strategy balance the balanceCheck message is either:\n        // - a confirmation of a deposit / withdrawal\n        // - a message that updates balances when no deposit / withdrawal is in progress\n        remoteStrategyBalance = balance;\n        emit RemoteStrategyBalanceUpdated(balance);\n    }\n}\n"
    },
    "contracts/strategies/crosschain/CrossChainRemoteStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title CrossChainRemoteStrategy\n * @author Origin Protocol Inc\n *\n * @dev Part of the cross-chain strategy that lives on the remote chain.\n *      Handles deposits and withdrawals from the master strategy on peer chain\n *      and locally deposits the funds to a 4626 compatible vault.\n */\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { IERC4626 } from \"../../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { Generalized4626Strategy } from \"../Generalized4626Strategy.sol\";\nimport { AbstractCCTPIntegrator } from \"./AbstractCCTPIntegrator.sol\";\nimport { CrossChainStrategyHelper } from \"./CrossChainStrategyHelper.sol\";\nimport { InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { Strategizable } from \"../../governance/Strategizable.sol\";\n\ncontract CrossChainRemoteStrategy is\n    AbstractCCTPIntegrator,\n    Generalized4626Strategy,\n    Strategizable\n{\n    using SafeERC20 for IERC20;\n    using CrossChainStrategyHelper for bytes;\n\n    event DepositUnderlyingFailed(string reason);\n    event WithdrawalFailed(uint256 amountRequested, uint256 amountAvailable);\n    event WithdrawUnderlyingFailed(string reason);\n\n    modifier onlyOperatorOrStrategistOrGovernor() {\n        require(\n            msg.sender == operator ||\n                msg.sender == strategistAddr ||\n                isGovernor(),\n            \"Caller is not the Operator, Strategist or the Governor\"\n        );\n        _;\n    }\n\n    modifier onlyGovernorOrStrategist()\n        override(InitializableAbstractStrategy, Strategizable) {\n        require(\n            msg.sender == strategistAddr || isGovernor(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    constructor(\n        BaseStrategyConfig memory _baseConfig,\n        CCTPIntegrationConfig memory _cctpConfig\n    )\n        AbstractCCTPIntegrator(_cctpConfig)\n        Generalized4626Strategy(_baseConfig, _cctpConfig.usdcToken)\n    {\n        require(usdcToken == address(assetToken), \"Token mismatch\");\n        require(\n            _baseConfig.platformAddress != address(0),\n            \"Invalid platform address\"\n        );\n        // Vault address must always be address(0) for the remote strategy\n        require(\n            _baseConfig.vaultAddress == address(0),\n            \"Invalid vault address\"\n        );\n    }\n\n    /**\n     * @dev Initialize the strategy implementation\n     * @param _strategist Address of the strategist\n     * @param _operator Address of the operator\n     * @param _minFinalityThreshold Minimum finality threshold\n     * @param _feePremiumBps Fee premium in basis points\n     */\n    function initialize(\n        address _strategist,\n        address _operator,\n        uint16 _minFinalityThreshold,\n        uint16 _feePremiumBps\n    ) external virtual onlyGovernor initializer {\n        _initialize(_operator, _minFinalityThreshold, _feePremiumBps);\n        _setStrategistAddr(_strategist);\n\n        address[] memory rewardTokens = new address[](0);\n        address[] memory assets = new address[](1);\n        address[] memory pTokens = new address[](1);\n\n        assets[0] = address(usdcToken);\n        pTokens[0] = address(platformAddress);\n\n        InitializableAbstractStrategy._initialize(\n            rewardTokens,\n            assets,\n            pTokens\n        );\n    }\n\n    /// @inheritdoc Generalized4626Strategy\n    function deposit(address _asset, uint256 _amount)\n        external\n        virtual\n        override\n        onlyGovernorOrStrategist\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /// @inheritdoc Generalized4626Strategy\n    function depositAll()\n        external\n        virtual\n        override\n        onlyGovernorOrStrategist\n        nonReentrant\n    {\n        _deposit(usdcToken, IERC20(usdcToken).balanceOf(address(this)));\n    }\n\n    /// @inheritdoc Generalized4626Strategy\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external virtual override onlyGovernorOrStrategist nonReentrant {\n        _withdraw(_recipient, _asset, _amount);\n    }\n\n    /// @inheritdoc Generalized4626Strategy\n    function withdrawAll()\n        external\n        virtual\n        override\n        onlyGovernorOrStrategist\n        nonReentrant\n    {\n        IERC4626 platform = IERC4626(platformAddress);\n        _withdraw(\n            address(this),\n            usdcToken,\n            platform.previewRedeem(platform.balanceOf(address(this)))\n        );\n    }\n\n    /// @inheritdoc AbstractCCTPIntegrator\n    function _onMessageReceived(bytes memory payload) internal override {\n        uint32 messageType = payload.getMessageType();\n        if (messageType == CrossChainStrategyHelper.DEPOSIT_MESSAGE) {\n            // Received when Master strategy sends tokens to the remote strategy\n            // Do nothing because we receive acknowledgement with token transfer,\n            // so _onTokenReceived will handle it\n        } else if (messageType == CrossChainStrategyHelper.WITHDRAW_MESSAGE) {\n            // Received when Master strategy requests a withdrawal\n            _processWithdrawMessage(payload);\n        } else {\n            revert(\"Unknown message type\");\n        }\n    }\n\n    /**\n     * @dev Process deposit message from peer strategy\n     * @param tokenAmount Amount of tokens received\n     * @param feeExecuted Fee executed\n     * @param payload Payload of the message\n     */\n    function _processDepositMessage(\n        // solhint-disable-next-line no-unused-vars\n        uint256 tokenAmount,\n        // solhint-disable-next-line no-unused-vars\n        uint256 feeExecuted,\n        bytes memory payload\n    ) internal virtual {\n        (uint64 nonce, ) = payload.decodeDepositMessage();\n\n        // Replay protection is part of the _markNonceAsProcessed function\n        _markNonceAsProcessed(nonce);\n\n        // Deposit everything we got, not just what was bridged\n        uint256 balance = IERC20(usdcToken).balanceOf(address(this));\n\n        // Underlying call to deposit funds can fail. It mustn't affect the overall\n        // flow as confirmation message should still be sent.\n        if (balance >= 1e6) {\n            _deposit(usdcToken, balance);\n        }\n\n        // Send balance check message to the peer strategy\n        bytes memory message = CrossChainStrategyHelper\n            .encodeBalanceCheckMessage(\n                lastTransferNonce,\n                checkBalance(usdcToken),\n                true\n            );\n        _sendMessage(message);\n    }\n\n    /**\n     * @dev Deposit assets by converting them to shares\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal override {\n        // By design, this function should not revert. Otherwise, it'd\n        // not be able to process messages and might freeze the contracts\n        // state. However these two require statements would never fail\n        // in every function invoking this. The same kind of checks should\n        // be enforced in all the calling functions for these two and any\n        // other require statements added to this function.\n        require(_amount > 0, \"Must deposit something\");\n        require(_asset == address(usdcToken), \"Unexpected asset address\");\n\n        // This call can fail, and the failure doesn't need to bubble up to the _processDepositMessage function\n        // as the flow is not affected by the failure.\n\n        try IERC4626(platformAddress).deposit(_amount, address(this)) {\n            emit Deposit(_asset, address(shareToken), _amount);\n        } catch Error(string memory reason) {\n            emit DepositUnderlyingFailed(\n                string(abi.encodePacked(\"Deposit failed: \", reason))\n            );\n        } catch (bytes memory lowLevelData) {\n            emit DepositUnderlyingFailed(\n                string(\n                    abi.encodePacked(\n                        \"Deposit failed: low-level call failed with data \",\n                        lowLevelData\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Process withdrawal message from peer strategy\n     * @param payload Payload of the message\n     */\n    function _processWithdrawMessage(bytes memory payload) internal virtual {\n        (uint64 nonce, uint256 withdrawAmount) = payload\n            .decodeWithdrawMessage();\n\n        // Replay protection is part of the _markNonceAsProcessed function\n        _markNonceAsProcessed(nonce);\n\n        uint256 usdcBalance = IERC20(usdcToken).balanceOf(address(this));\n\n        if (usdcBalance < withdrawAmount) {\n            // Withdraw the missing funds from the remote strategy. This call can fail and\n            // the failure doesn't bubble up to the _processWithdrawMessage function\n            _withdraw(address(this), usdcToken, withdrawAmount - usdcBalance);\n\n            // Update the possible increase in the balance on the contract.\n            usdcBalance = IERC20(usdcToken).balanceOf(address(this));\n        }\n\n        // Check balance after withdrawal\n        uint256 strategyBalance = checkBalance(usdcToken);\n\n        // If there are some tokens to be sent AND the balance is sufficient\n        // to satisfy the withdrawal request then send the funds to the peer strategy.\n        // In case a direct withdraw(All) has previously been called\n        // there is a possibility of USDC funds remaining on the contract.\n        // A separate withdraw to extract or deposit to the Morpho vault needs to be\n        // initiated from the peer Master strategy to utilise USDC funds.\n        if (withdrawAmount >= 1e6 && usdcBalance >= withdrawAmount) {\n            // The new balance on the contract needs to have USDC subtracted from it as\n            // that will be withdrawn in the next step\n            bytes memory message = CrossChainStrategyHelper\n                .encodeBalanceCheckMessage(\n                    lastTransferNonce,\n                    strategyBalance - withdrawAmount,\n                    true\n                );\n            _sendTokens(withdrawAmount, message);\n        } else {\n            // Contract either:\n            // - only has small dust amount of USDC\n            // - doesn't have sufficient funds to satisfy the withdrawal request\n            // In both cases send the balance update message to the peer strategy.\n            bytes memory message = CrossChainStrategyHelper\n                .encodeBalanceCheckMessage(\n                    lastTransferNonce,\n                    strategyBalance,\n                    true\n                );\n            _sendMessage(message);\n            emit WithdrawalFailed(withdrawAmount, usdcBalance);\n        }\n    }\n\n    /**\n     * @dev Withdraw asset by burning shares\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function _withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) internal override {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient == address(this), \"Invalid recipient\");\n        require(_asset == address(usdcToken), \"Unexpected asset address\");\n\n        // This call can fail, and the failure doesn't need to bubble up to the _processWithdrawMessage function\n        // as the flow is not affected by the failure.\n        try\n            // slither-disable-next-line unused-return\n            IERC4626(platformAddress).withdraw(\n                _amount,\n                address(this),\n                address(this)\n            )\n        {\n            emit Withdrawal(_asset, address(shareToken), _amount);\n        } catch Error(string memory reason) {\n            emit WithdrawUnderlyingFailed(\n                string(abi.encodePacked(\"Withdrawal failed: \", reason))\n            );\n        } catch (bytes memory lowLevelData) {\n            emit WithdrawUnderlyingFailed(\n                string(\n                    abi.encodePacked(\n                        \"Withdrawal failed: low-level call failed with data \",\n                        lowLevelData\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Process token received message from peer strategy\n     * @param tokenAmount Amount of tokens received\n     * @param feeExecuted Fee executed\n     * @param payload Payload of the message\n     */\n    function _onTokenReceived(\n        uint256 tokenAmount,\n        uint256 feeExecuted,\n        bytes memory payload\n    ) internal override {\n        uint32 messageType = payload.getMessageType();\n\n        require(\n            messageType == CrossChainStrategyHelper.DEPOSIT_MESSAGE,\n            \"Invalid message type\"\n        );\n\n        _processDepositMessage(tokenAmount, feeExecuted, payload);\n    }\n\n    /**\n     * @dev Send balance update message to the peer strategy\n     */\n    function sendBalanceUpdate()\n        external\n        virtual\n        onlyOperatorOrStrategistOrGovernor\n    {\n        uint256 balance = checkBalance(usdcToken);\n        bytes memory message = CrossChainStrategyHelper\n            .encodeBalanceCheckMessage(lastTransferNonce, balance, false);\n        _sendMessage(message);\n    }\n\n    /**\n     * @notice Get the total asset value held in the platform and contract\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform and contract\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        require(_asset == usdcToken, \"Unexpected asset address\");\n        /**\n         * Balance of USDC on the contract is counted towards the total balance, since a deposit\n         * to the Morpho V2 might fail and the USDC might remain on this contract as a result of a\n         * bridged transfer.\n         */\n        uint256 balanceOnContract = IERC20(usdcToken).balanceOf(address(this));\n\n        IERC4626 platform = IERC4626(platformAddress);\n        return\n            platform.previewRedeem(platform.balanceOf(address(this))) +\n            balanceOnContract;\n    }\n}\n"
    },
    "contracts/strategies/crosschain/CrossChainStrategyHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title CrossChainStrategyHelper\n * @author Origin Protocol Inc\n * @dev This library is used to encode and decode the messages for the cross-chain strategy.\n *      It is used to ensure that the messages are valid and to get the message version and type.\n */\n\nimport { BytesHelper } from \"../../utils/BytesHelper.sol\";\n\nlibrary CrossChainStrategyHelper {\n    using BytesHelper for bytes;\n\n    uint32 public constant DEPOSIT_MESSAGE = 1;\n    uint32 public constant WITHDRAW_MESSAGE = 2;\n    uint32 public constant BALANCE_CHECK_MESSAGE = 3;\n\n    uint32 public constant CCTP_MESSAGE_VERSION = 1;\n    uint32 public constant ORIGIN_MESSAGE_VERSION = 1010;\n\n    // CCTP Message Header fields\n    // Ref: https://developers.circle.com/cctp/technical-guide#message-header\n    uint8 private constant VERSION_INDEX = 0;\n    uint8 private constant SOURCE_DOMAIN_INDEX = 4;\n    uint8 private constant SENDER_INDEX = 44;\n    uint8 private constant RECIPIENT_INDEX = 76;\n    uint8 private constant MESSAGE_BODY_INDEX = 148;\n\n    /**\n     * @dev Get the message version from the message.\n     *      It should always be 4 bytes long,\n     *      starting from the 0th index.\n     * @param message The message to get the version from\n     * @return The message version\n     */\n    function getMessageVersion(bytes memory message)\n        internal\n        pure\n        returns (uint32)\n    {\n        // uint32 bytes 0 to 4 is Origin message version\n        // uint32 bytes 4 to 8 is Message type\n        return message.extractUint32(0);\n    }\n\n    /**\n     * @dev Get the message type from the message.\n     *      It should always be 4 bytes long,\n     *      starting from the 4th index.\n     * @param message The message to get the type from\n     * @return The message type\n     */\n    function getMessageType(bytes memory message)\n        internal\n        pure\n        returns (uint32)\n    {\n        // uint32 bytes 0 to 4 is Origin message version\n        // uint32 bytes 4 to 8 is Message type\n        return message.extractUint32(4);\n    }\n\n    /**\n     * @dev Verify the message version and type.\n     *      The message version should be the same as the Origin message version,\n     *      and the message type should be the same as the expected message type.\n     * @param _message The message to verify\n     * @param _type The expected message type\n     */\n    function verifyMessageVersionAndType(bytes memory _message, uint32 _type)\n        internal\n        pure\n    {\n        require(\n            getMessageVersion(_message) == ORIGIN_MESSAGE_VERSION,\n            \"Invalid Origin Message Version\"\n        );\n        require(getMessageType(_message) == _type, \"Invalid Message type\");\n    }\n\n    /**\n     * @dev Get the message payload from the message.\n     *      The payload starts at the 8th byte.\n     * @param message The message to get the payload from\n     * @return The message payload\n     */\n    function getMessagePayload(bytes memory message)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        // uint32 bytes 0 to 4 is Origin message version\n        // uint32 bytes 4 to 8 is Message type\n        // Payload starts at byte 8\n        return message.extractSlice(8, message.length);\n    }\n\n    /**\n     * @dev Encode the deposit message.\n     *      The message version and type are always encoded in the message.\n     * @param nonce The nonce of the deposit\n     * @param depositAmount The amount of the deposit\n     * @return The encoded deposit message\n     */\n    function encodeDepositMessage(uint64 nonce, uint256 depositAmount)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return\n            abi.encodePacked(\n                ORIGIN_MESSAGE_VERSION,\n                DEPOSIT_MESSAGE,\n                abi.encode(nonce, depositAmount)\n            );\n    }\n\n    /**\n     * @dev Decode the deposit message.\n     *      The message version and type are verified in the message.\n     * @param message The message to decode\n     * @return The nonce and the amount of the deposit\n     */\n    function decodeDepositMessage(bytes memory message)\n        internal\n        pure\n        returns (uint64, uint256)\n    {\n        verifyMessageVersionAndType(message, DEPOSIT_MESSAGE);\n\n        (uint64 nonce, uint256 depositAmount) = abi.decode(\n            getMessagePayload(message),\n            (uint64, uint256)\n        );\n        return (nonce, depositAmount);\n    }\n\n    /**\n     * @dev Encode the withdrawal message.\n     *      The message version and type are always encoded in the message.\n     * @param nonce The nonce of the withdrawal\n     * @param withdrawAmount The amount of the withdrawal\n     * @return The encoded withdrawal message\n     */\n    function encodeWithdrawMessage(uint64 nonce, uint256 withdrawAmount)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return\n            abi.encodePacked(\n                ORIGIN_MESSAGE_VERSION,\n                WITHDRAW_MESSAGE,\n                abi.encode(nonce, withdrawAmount)\n            );\n    }\n\n    /**\n     * @dev Decode the withdrawal message.\n     *      The message version and type are verified in the message.\n     * @param message The message to decode\n     * @return The nonce and the amount of the withdrawal\n     */\n    function decodeWithdrawMessage(bytes memory message)\n        internal\n        pure\n        returns (uint64, uint256)\n    {\n        verifyMessageVersionAndType(message, WITHDRAW_MESSAGE);\n\n        (uint64 nonce, uint256 withdrawAmount) = abi.decode(\n            getMessagePayload(message),\n            (uint64, uint256)\n        );\n        return (nonce, withdrawAmount);\n    }\n\n    /**\n     * @dev Encode the balance check message.\n     *      The message version and type are always encoded in the message.\n     * @param nonce The nonce of the balance check\n     * @param balance The balance to check\n     * @param transferConfirmation Indicates if the message is a transfer confirmation. This is true\n     *                            when the message is a result of a deposit or a withdrawal.\n     * @return The encoded balance check message\n     */\n    function encodeBalanceCheckMessage(\n        uint64 nonce,\n        uint256 balance,\n        bool transferConfirmation\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                ORIGIN_MESSAGE_VERSION,\n                BALANCE_CHECK_MESSAGE,\n                abi.encode(nonce, balance, transferConfirmation)\n            );\n    }\n\n    /**\n     * @dev Decode the balance check message.\n     *      The message version and type are verified in the message.\n     * @param message The message to decode\n     * @return The nonce, the balance and indicates if the message is a transfer confirmation\n     */\n    function decodeBalanceCheckMessage(bytes memory message)\n        internal\n        pure\n        returns (\n            uint64,\n            uint256,\n            bool\n        )\n    {\n        verifyMessageVersionAndType(message, BALANCE_CHECK_MESSAGE);\n\n        (uint64 nonce, uint256 balance, bool transferConfirmation) = abi.decode(\n            getMessagePayload(message),\n            (uint64, uint256, bool)\n        );\n        return (nonce, balance, transferConfirmation);\n    }\n\n    /**\n     * @dev Decode the CCTP message header\n     * @param message Message to decode\n     * @return version Version of the message\n     * @return sourceDomainID Source domain ID\n     * @return sender Sender of the message\n     * @return recipient Recipient of the message\n     * @return messageBody Message body\n     */\n    function decodeMessageHeader(bytes memory message)\n        internal\n        pure\n        returns (\n            uint32 version,\n            uint32 sourceDomainID,\n            address sender,\n            address recipient,\n            bytes memory messageBody\n        )\n    {\n        version = message.extractUint32(VERSION_INDEX);\n        sourceDomainID = message.extractUint32(SOURCE_DOMAIN_INDEX);\n        // Address of MessageTransmitterV2 caller on source domain\n        sender = message.extractAddress(SENDER_INDEX);\n        // Address to handle message body on destination domain\n        recipient = message.extractAddress(RECIPIENT_INDEX);\n        messageBody = message.extractSlice(MESSAGE_BODY_INDEX, message.length);\n    }\n}\n"
    },
    "contracts/strategies/Generalized4626Strategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Generalized 4626 Strategy\n * @notice Investment strategy for ERC-4626 Tokenized Vaults\n * @author Origin Protocol Inc\n */\nimport { IERC4626 } from \"../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { IDistributor } from \"../interfaces/IMerkl.sol\";\n\ncontract Generalized4626Strategy is InitializableAbstractStrategy {\n    /// @notice The address of the Merkle Distributor contract.\n    IDistributor public constant merkleDistributor =\n        IDistributor(0x3Ef3D8bA38EBe18DB133cEc108f4D14CE00Dd9Ae);\n\n    /// @dev Replaced with an immutable variable\n    // slither-disable-next-line constable-states\n    address private _deprecate_shareToken;\n    /// @dev Replaced with an immutable variable\n    // slither-disable-next-line constable-states\n    address private _deprecate_assetToken;\n\n    IERC20 public immutable shareToken;\n    IERC20 public immutable assetToken;\n\n    // For future use\n    uint256[50] private __gap;\n\n    event ClaimedRewards(address indexed token, uint256 amount);\n\n    /**\n     * @param _baseConfig Base strategy config with platformAddress (ERC-4626 Vault contract), eg sfrxETH or sDAI,\n     * and vaultAddress (OToken Vault contract), eg VaultProxy or OETHVaultProxy\n     * @param _assetToken Address of the ERC-4626 asset token. eg frxETH or DAI\n     */\n    constructor(BaseStrategyConfig memory _baseConfig, address _assetToken)\n        InitializableAbstractStrategy(_baseConfig)\n    {\n        shareToken = IERC20(_baseConfig.platformAddress);\n        assetToken = IERC20(_assetToken);\n    }\n\n    function initialize() external virtual onlyGovernor initializer {\n        address[] memory rewardTokens = new address[](0);\n        address[] memory assets = new address[](1);\n        address[] memory pTokens = new address[](1);\n\n        assets[0] = address(assetToken);\n        pTokens[0] = address(platformAddress);\n\n        InitializableAbstractStrategy._initialize(\n            rewardTokens,\n            assets,\n            pTokens\n        );\n    }\n\n    /**\n     * @dev Deposit assets by converting them to shares\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        virtual\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @dev Deposit assets by converting them to shares\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal virtual {\n        require(_amount > 0, \"Must deposit something\");\n        require(_asset == address(assetToken), \"Unexpected asset address\");\n\n        // slither-disable-next-line unused-return\n        IERC4626(platformAddress).deposit(_amount, address(this));\n        emit Deposit(_asset, address(shareToken), _amount);\n    }\n\n    /**\n     * @dev Deposit the entire balance of assetToken to gain shareToken\n     */\n    function depositAll() external virtual override onlyVault nonReentrant {\n        uint256 balance = assetToken.balanceOf(address(this));\n        if (balance > 0) {\n            _deposit(address(assetToken), balance);\n        }\n    }\n\n    /**\n     * @dev Withdraw asset by burning shares\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external virtual override onlyVault nonReentrant {\n        _withdraw(_recipient, _asset, _amount);\n    }\n\n    function _withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) internal virtual {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n        require(_asset == address(assetToken), \"Unexpected asset address\");\n\n        // slither-disable-next-line unused-return\n        IERC4626(platformAddress).withdraw(_amount, _recipient, address(this));\n        emit Withdrawal(_asset, address(shareToken), _amount);\n    }\n\n    /**\n     * @dev Internal method to respond to the addition of new asset / share tokens\n     */\n    function _abstractSetPToken(address, address) internal virtual override {\n        _approveBase();\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll()\n        external\n        virtual\n        override\n        onlyVaultOrGovernor\n        nonReentrant\n    {\n        uint256 shareBalance = shareToken.balanceOf(address(this));\n        uint256 assetAmount = 0;\n        if (shareBalance > 0) {\n            assetAmount = IERC4626(platformAddress).redeem(\n                shareBalance,\n                vaultAddress,\n                address(this)\n            );\n            emit Withdrawal(\n                address(assetToken),\n                address(shareToken),\n                assetAmount\n            );\n        }\n    }\n\n    /**\n     * @notice Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        virtual\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == address(assetToken), \"Unexpected asset address\");\n        /* We are intentionally not counting the amount of assetToken parked on the\n         * contract toward the checkBalance. The deposit and withdraw functions\n         * should not result in assetToken being unused and owned by this strategy\n         * contract.\n         */\n        IERC4626 platform = IERC4626(platformAddress);\n        return platform.previewRedeem(platform.balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Governor approves the ERC-4626 Tokenized Vault to spend the asset.\n     */\n    function safeApproveAllTokens() external override onlyGovernor {\n        _approveBase();\n    }\n\n    function _approveBase() internal virtual {\n        // Approval the asset to be transferred to the ERC-4626 Tokenized Vault.\n        // Used by the ERC-4626 deposit() and mint() functions\n        // slither-disable-next-line unused-return\n        assetToken.approve(platformAddress, type(uint256).max);\n    }\n\n    /**\n     * @dev Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _asset == address(assetToken);\n    }\n\n    /**\n     * @notice is not supported for this strategy as the asset and\n     * ERC-4626 Tokenized Vault are set at deploy time.\n     * @dev If the ERC-4626 Tokenized Vault needed to be changed, a new\n     * contract would need to be deployed and the proxy updated.\n     */\n    function setPTokenAddress(address, address) external override onlyGovernor {\n        revert(\"unsupported function\");\n    }\n\n    /**\n     * @notice is not supported for this strategy as the asset and\n     * ERC-4626 Tokenized Vault are set at deploy time.\n     * @dev If the ERC-4626 Tokenized Vault needed to be changed, a new\n     * contract would need to be deployed and the proxy updated.\n     */\n    function removePToken(uint256) external override onlyGovernor {\n        revert(\"unsupported function\");\n    }\n\n    /// @notice Claim tokens from the Merkle Distributor\n    /// @param token The address of the token to claim.\n    /// @param amount The amount of tokens to claim.\n    /// @param proof The Merkle proof to validate the claim.\n    function merkleClaim(\n        address token,\n        uint256 amount,\n        bytes32[] calldata proof\n    ) external {\n        address[] memory users = new address[](1);\n        users[0] = address(this);\n\n        address[] memory tokens = new address[](1);\n        tokens[0] = token;\n\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = amount;\n\n        bytes32[][] memory proofs = new bytes32[][](1);\n        proofs[0] = proof;\n\n        merkleDistributor.claim(users, tokens, amounts, proofs);\n\n        emit ClaimedRewards(token, amount);\n    }\n}\n"
    },
    "contracts/token/OUSD.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD Token Contract\n * @dev ERC20 compatible contract for OUSD\n * @dev Implements an elastic supply\n * @author Origin Protocol Inc\n */\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\ncontract OUSD is Governable {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n\n    /// @dev Event triggered when the supply changes\n    /// @param totalSupply Updated token total supply\n    /// @param rebasingCredits Updated token rebasing credits\n    /// @param rebasingCreditsPerToken Updated token rebasing credits per token\n    event TotalSupplyUpdatedHighres(\n        uint256 totalSupply,\n        uint256 rebasingCredits,\n        uint256 rebasingCreditsPerToken\n    );\n    /// @dev Event triggered when an account opts in for rebasing\n    /// @param account Address of the account\n    event AccountRebasingEnabled(address account);\n    /// @dev Event triggered when an account opts out of rebasing\n    /// @param account Address of the account\n    event AccountRebasingDisabled(address account);\n    /// @dev Emitted when `value` tokens are moved from one account `from` to\n    ///      another `to`.\n    /// @param from Address of the account tokens are moved from\n    /// @param to Address of the account tokens are moved to\n    /// @param value Amount of tokens transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set by\n    ///      a call to {approve}. `value` is the new allowance.\n    /// @param owner Address of the owner approving allowance\n    /// @param spender Address of the spender allowance is granted to\n    /// @param value Amount of tokens spender can transfer\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    /// @dev Yield resulting from {changeSupply} that a `source` account would\n    ///      receive is directed to `target` account.\n    /// @param source Address of the source forwarding the yield\n    /// @param target Address of the target receiving the yield\n    event YieldDelegated(address source, address target);\n    /// @dev Yield delegation from `source` account to the `target` account is\n    ///      suspended.\n    /// @param source Address of the source suspending yield forwarding\n    /// @param target Address of the target no longer receiving yield from `source`\n    ///        account\n    event YieldUndelegated(address source, address target);\n\n    enum RebaseOptions {\n        NotSet,\n        StdNonRebasing,\n        StdRebasing,\n        YieldDelegationSource,\n        YieldDelegationTarget\n    }\n\n    uint256[154] private _gap; // Slots to align with deployed contract\n    uint256 private constant MAX_SUPPLY = type(uint128).max;\n    /// @dev The amount of tokens in existence\n    uint256 public totalSupply;\n    mapping(address => mapping(address => uint256)) private allowances;\n    /// @dev The vault with privileges to execute {mint}, {burn}\n    ///     and {changeSupply}\n    address public vaultAddress;\n    mapping(address => uint256) internal creditBalances;\n    // the 2 storage variables below need trailing underscores to not name collide with public functions\n    uint256 private rebasingCredits_; // Sum of all rebasing credits (creditBalances for rebasing accounts)\n    uint256 private rebasingCreditsPerToken_;\n    /// @dev The amount of tokens that are not rebasing - receiving yield\n    uint256 public nonRebasingSupply;\n    mapping(address => uint256) internal alternativeCreditsPerToken;\n    /// @dev A map of all addresses and their respective RebaseOptions\n    mapping(address => RebaseOptions) public rebaseState;\n    mapping(address => uint256) private __deprecated_isUpgraded;\n    /// @dev A map of addresses that have yields forwarded to. This is an\n    ///      inverse mapping of {yieldFrom}\n    /// Key Account forwarding yield\n    /// Value Account receiving yield\n    mapping(address => address) public yieldTo;\n    /// @dev A map of addresses that are receiving the yield. This is an\n    ///      inverse mapping of {yieldTo}\n    /// Key Account receiving yield\n    /// Value Account forwarding yield\n    mapping(address => address) public yieldFrom;\n\n    uint256 private constant RESOLUTION_INCREASE = 1e9;\n    uint256[34] private __gap; // including below gap totals up to 200\n\n    /// @dev Verifies that the caller is the Governor or Strategist.\n    modifier onlyGovernorOrStrategist() {\n        require(\n            isGovernor() || msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    /// @dev Initializes the contract and sets necessary variables.\n    /// @param _vaultAddress Address of the vault contract\n    /// @param _initialCreditsPerToken The starting rebasing credits per token.\n    function initialize(address _vaultAddress, uint256 _initialCreditsPerToken)\n        external\n        onlyGovernor\n    {\n        require(_vaultAddress != address(0), \"Zero vault address\");\n        require(vaultAddress == address(0), \"Already initialized\");\n\n        rebasingCreditsPerToken_ = _initialCreditsPerToken;\n        vaultAddress = _vaultAddress;\n    }\n\n    /// @dev Returns the symbol of the token, a shorter version\n    ///      of the name.\n    function symbol() external pure virtual returns (string memory) {\n        return \"OUSD\";\n    }\n\n    /// @dev Returns the name of the token.\n    function name() external pure virtual returns (string memory) {\n        return \"Origin Dollar\";\n    }\n\n    /// @dev Returns the number of decimals used to get its user representation.\n    function decimals() external pure virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault contract\n     */\n    modifier onlyVault() {\n        require(vaultAddress == msg.sender, \"Caller is not the Vault\");\n        _;\n    }\n\n    /**\n     * @return High resolution rebasingCreditsPerToken\n     */\n    function rebasingCreditsPerTokenHighres() external view returns (uint256) {\n        return rebasingCreditsPerToken_;\n    }\n\n    /**\n     * @return Low resolution rebasingCreditsPerToken\n     */\n    function rebasingCreditsPerToken() external view returns (uint256) {\n        return rebasingCreditsPerToken_ / RESOLUTION_INCREASE;\n    }\n\n    /**\n     * @return High resolution total number of rebasing credits\n     */\n    function rebasingCreditsHighres() external view returns (uint256) {\n        return rebasingCredits_;\n    }\n\n    /**\n     * @return Low resolution total number of rebasing credits\n     */\n    function rebasingCredits() external view returns (uint256) {\n        return rebasingCredits_ / RESOLUTION_INCREASE;\n    }\n\n    /**\n     * @notice Gets the balance of the specified address.\n     * @param _account Address to query the balance of.\n     * @return A uint256 representing the amount of base units owned by the\n     *         specified address.\n     */\n    function balanceOf(address _account) public view returns (uint256) {\n        RebaseOptions state = rebaseState[_account];\n        if (state == RebaseOptions.YieldDelegationSource) {\n            // Saves a slot read when transferring to or from a yield delegating source\n            // since we know creditBalances equals the balance.\n            return creditBalances[_account];\n        }\n        uint256 baseBalance = (creditBalances[_account] * 1e18) /\n            _creditsPerToken(_account);\n        if (state == RebaseOptions.YieldDelegationTarget) {\n            // creditBalances of yieldFrom accounts equals token balances\n            return baseBalance - creditBalances[yieldFrom[_account]];\n        }\n        return baseBalance;\n    }\n\n    /**\n     * @notice Gets the credits balance of the specified address.\n     * @dev Backwards compatible with old low res credits per token.\n     * @param _account The address to query the balance of.\n     * @return (uint256, uint256) Credit balance and credits per token of the\n     *         address\n     */\n    function creditsBalanceOf(address _account)\n        external\n        view\n        returns (uint256, uint256)\n    {\n        uint256 cpt = _creditsPerToken(_account);\n        if (cpt == 1e27) {\n            // For a period before the resolution upgrade, we created all new\n            // contract accounts at high resolution. Since they are not changing\n            // as a result of this upgrade, we will return their true values\n            return (creditBalances[_account], cpt);\n        } else {\n            return (\n                creditBalances[_account] / RESOLUTION_INCREASE,\n                cpt / RESOLUTION_INCREASE\n            );\n        }\n    }\n\n    /**\n     * @notice Gets the credits balance of the specified address.\n     * @param _account The address to query the balance of.\n     * @return (uint256, uint256, bool) Credit balance, credits per token of the\n     *         address, and isUpgraded\n     */\n    function creditsBalanceOfHighres(address _account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        return (\n            creditBalances[_account],\n            _creditsPerToken(_account),\n            true // all accounts have their resolution \"upgraded\"\n        );\n    }\n\n    // Backwards compatible view\n    function nonRebasingCreditsPerToken(address _account)\n        external\n        view\n        returns (uint256)\n    {\n        return alternativeCreditsPerToken[_account];\n    }\n\n    /**\n     * @notice Transfer tokens to a specified address.\n     * @param _to the address to transfer to.\n     * @param _value the amount to be transferred.\n     * @return true on success.\n     */\n    function transfer(address _to, uint256 _value) external returns (bool) {\n        require(_to != address(0), \"Transfer to zero address\");\n\n        _executeTransfer(msg.sender, _to, _value);\n\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n     * @notice Transfer tokens from one address to another.\n     * @param _from The address you want to send tokens from.\n     * @param _to The address you want to transfer to.\n     * @param _value The amount of tokens to be transferred.\n     * @return true on success.\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool) {\n        require(_to != address(0), \"Transfer to zero address\");\n        uint256 userAllowance = allowances[_from][msg.sender];\n        require(_value <= userAllowance, \"Allowance exceeded\");\n\n        unchecked {\n            allowances[_from][msg.sender] = userAllowance - _value;\n        }\n\n        _executeTransfer(_from, _to, _value);\n\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function _executeTransfer(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal {\n        (\n            int256 fromRebasingCreditsDiff,\n            int256 fromNonRebasingSupplyDiff\n        ) = _adjustAccount(_from, -_value.toInt256());\n        (\n            int256 toRebasingCreditsDiff,\n            int256 toNonRebasingSupplyDiff\n        ) = _adjustAccount(_to, _value.toInt256());\n\n        _adjustGlobals(\n            fromRebasingCreditsDiff + toRebasingCreditsDiff,\n            fromNonRebasingSupplyDiff + toNonRebasingSupplyDiff\n        );\n    }\n\n    function _adjustAccount(address _account, int256 _balanceChange)\n        internal\n        returns (int256 rebasingCreditsDiff, int256 nonRebasingSupplyDiff)\n    {\n        RebaseOptions state = rebaseState[_account];\n        int256 currentBalance = balanceOf(_account).toInt256();\n        if (currentBalance + _balanceChange < 0) {\n            revert(\"Transfer amount exceeds balance\");\n        }\n        uint256 newBalance = (currentBalance + _balanceChange).toUint256();\n\n        if (state == RebaseOptions.YieldDelegationSource) {\n            address target = yieldTo[_account];\n            uint256 targetOldBalance = balanceOf(target);\n            uint256 targetNewCredits = _balanceToRebasingCredits(\n                targetOldBalance + newBalance\n            );\n            rebasingCreditsDiff =\n                targetNewCredits.toInt256() -\n                creditBalances[target].toInt256();\n\n            creditBalances[_account] = newBalance;\n            creditBalances[target] = targetNewCredits;\n        } else if (state == RebaseOptions.YieldDelegationTarget) {\n            uint256 newCredits = _balanceToRebasingCredits(\n                newBalance + creditBalances[yieldFrom[_account]]\n            );\n            rebasingCreditsDiff =\n                newCredits.toInt256() -\n                creditBalances[_account].toInt256();\n            creditBalances[_account] = newCredits;\n        } else {\n            _autoMigrate(_account);\n            uint256 alternativeCreditsPerTokenMem = alternativeCreditsPerToken[\n                _account\n            ];\n            if (alternativeCreditsPerTokenMem > 0) {\n                nonRebasingSupplyDiff = _balanceChange;\n                if (alternativeCreditsPerTokenMem != 1e18) {\n                    alternativeCreditsPerToken[_account] = 1e18;\n                }\n                creditBalances[_account] = newBalance;\n            } else {\n                uint256 newCredits = _balanceToRebasingCredits(newBalance);\n                rebasingCreditsDiff =\n                    newCredits.toInt256() -\n                    creditBalances[_account].toInt256();\n                creditBalances[_account] = newCredits;\n            }\n        }\n    }\n\n    function _adjustGlobals(\n        int256 _rebasingCreditsDiff,\n        int256 _nonRebasingSupplyDiff\n    ) internal {\n        if (_rebasingCreditsDiff != 0) {\n            rebasingCredits_ = (rebasingCredits_.toInt256() +\n                _rebasingCreditsDiff).toUint256();\n        }\n        if (_nonRebasingSupplyDiff != 0) {\n            nonRebasingSupply = (nonRebasingSupply.toInt256() +\n                _nonRebasingSupplyDiff).toUint256();\n        }\n    }\n\n    /**\n     * @notice Function to check the amount of tokens that _owner has allowed\n     *      to `_spender`.\n     * @param _owner The address which owns the funds.\n     * @param _spender The address which will spend the funds.\n     * @return The number of tokens still available for the _spender.\n     */\n    function allowance(address _owner, address _spender)\n        external\n        view\n        returns (uint256)\n    {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Approve the passed address to spend the specified amount of\n     *      tokens on behalf of msg.sender.\n     * @param _spender The address which will spend the funds.\n     * @param _value The amount of tokens to be spent.\n     * @return true on success.\n     */\n    function approve(address _spender, uint256 _value) external returns (bool) {\n        allowances[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * @notice Creates `_amount` tokens and assigns them to `_account`,\n     *     increasing the total supply.\n     */\n    function mint(address _account, uint256 _amount) external onlyVault {\n        require(_account != address(0), \"Mint to the zero address\");\n\n        // Account\n        (\n            int256 toRebasingCreditsDiff,\n            int256 toNonRebasingSupplyDiff\n        ) = _adjustAccount(_account, _amount.toInt256());\n        // Globals\n        _adjustGlobals(toRebasingCreditsDiff, toNonRebasingSupplyDiff);\n        totalSupply = totalSupply + _amount;\n\n        require(totalSupply < MAX_SUPPLY, \"Max supply\");\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    /**\n     * @notice Destroys `_amount` tokens from `_account`,\n     *     reducing the total supply.\n     */\n    function burn(address _account, uint256 _amount) external onlyVault {\n        require(_account != address(0), \"Burn from the zero address\");\n        if (_amount == 0) {\n            return;\n        }\n\n        // Account\n        (\n            int256 toRebasingCreditsDiff,\n            int256 toNonRebasingSupplyDiff\n        ) = _adjustAccount(_account, -_amount.toInt256());\n        // Globals\n        _adjustGlobals(toRebasingCreditsDiff, toNonRebasingSupplyDiff);\n        totalSupply = totalSupply - _amount;\n\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    /**\n     * @dev Get the credits per token for an account. Returns a fixed amount\n     *      if the account is non-rebasing.\n     * @param _account Address of the account.\n     */\n    function _creditsPerToken(address _account)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 alternativeCreditsPerTokenMem = alternativeCreditsPerToken[\n            _account\n        ];\n        if (alternativeCreditsPerTokenMem != 0) {\n            return alternativeCreditsPerTokenMem;\n        } else {\n            return rebasingCreditsPerToken_;\n        }\n    }\n\n    /**\n     * @dev Auto migrate contracts to be non rebasing,\n     *     unless they have opted into yield.\n     * @param _account Address of the account.\n     */\n    function _autoMigrate(address _account) internal {\n        uint256 codeLen = _account.code.length;\n        bool isEOA = (codeLen == 0) ||\n            (codeLen == 23 && bytes3(_account.code) == 0xef0100);\n        // In previous code versions, contracts would not have had their\n        // rebaseState[_account] set to RebaseOptions.NonRebasing when migrated\n        // therefore we check the actual accounting used on the account as well.\n        if (\n            (!isEOA) &&\n            rebaseState[_account] == RebaseOptions.NotSet &&\n            alternativeCreditsPerToken[_account] == 0\n        ) {\n            _rebaseOptOut(_account);\n        }\n    }\n\n    /**\n     * @dev Calculates credits from contract's global rebasingCreditsPerToken_, and\n     *      also balance that corresponds to those credits. The latter is important\n     *      when adjusting the contract's global nonRebasingSupply to circumvent any\n     *      possible rounding errors.\n     *\n     * @param _balance Balance of the account.\n     */\n    function _balanceToRebasingCredits(uint256 _balance)\n        internal\n        view\n        returns (uint256 rebasingCredits)\n    {\n        // Rounds up, because we need to ensure that accounts always have\n        // at least the balance that they should have.\n        // Note this should always be used on an absolute account value,\n        // not on a possibly negative diff, because then the rounding would be wrong.\n        return ((_balance) * rebasingCreditsPerToken_ + 1e18 - 1) / 1e18;\n    }\n\n    /**\n     * @notice The calling account will start receiving yield after a successful call.\n     * @param _account Address of the account.\n     */\n    function governanceRebaseOptIn(address _account) external onlyGovernor {\n        require(_account != address(0), \"Zero address not allowed\");\n        _rebaseOptIn(_account);\n    }\n\n    /**\n     * @notice The calling account will start receiving yield after a successful call.\n     */\n    function rebaseOptIn() external {\n        _rebaseOptIn(msg.sender);\n    }\n\n    function _rebaseOptIn(address _account) internal {\n        uint256 balance = balanceOf(_account);\n\n        // prettier-ignore\n        require(\n            alternativeCreditsPerToken[_account] > 0 ||\n                // Accounts may explicitly `rebaseOptIn` regardless of\n                // accounting if they have a 0 balance.\n                creditBalances[_account] == 0\n            ,\n            \"Account must be non-rebasing\"\n        );\n        RebaseOptions state = rebaseState[_account];\n        // prettier-ignore\n        require(\n            state == RebaseOptions.StdNonRebasing ||\n                state == RebaseOptions.NotSet,\n            \"Only standard non-rebasing accounts can opt in\"\n        );\n\n        uint256 newCredits = _balanceToRebasingCredits(balance);\n\n        // Account\n        rebaseState[_account] = RebaseOptions.StdRebasing;\n        alternativeCreditsPerToken[_account] = 0;\n        creditBalances[_account] = newCredits;\n        // Globals\n        _adjustGlobals(newCredits.toInt256(), -balance.toInt256());\n\n        emit AccountRebasingEnabled(_account);\n    }\n\n    /**\n     * @notice The calling account will no longer receive yield\n     */\n    function rebaseOptOut() external {\n        _rebaseOptOut(msg.sender);\n    }\n\n    function _rebaseOptOut(address _account) internal {\n        require(\n            alternativeCreditsPerToken[_account] == 0,\n            \"Account must be rebasing\"\n        );\n        RebaseOptions state = rebaseState[_account];\n        require(\n            state == RebaseOptions.StdRebasing || state == RebaseOptions.NotSet,\n            \"Only standard rebasing accounts can opt out\"\n        );\n\n        uint256 oldCredits = creditBalances[_account];\n        uint256 balance = balanceOf(_account);\n\n        // Account\n        rebaseState[_account] = RebaseOptions.StdNonRebasing;\n        alternativeCreditsPerToken[_account] = 1e18;\n        creditBalances[_account] = balance;\n        // Globals\n        _adjustGlobals(-oldCredits.toInt256(), balance.toInt256());\n\n        emit AccountRebasingDisabled(_account);\n    }\n\n    /**\n     * @notice Distribute yield to users. This changes the exchange rate\n     *  between \"credits\" and OUSD tokens to change rebasing user's balances.\n     * @param _newTotalSupply New total supply of OUSD.\n     */\n    function changeSupply(uint256 _newTotalSupply) external onlyVault {\n        require(totalSupply > 0, \"Cannot increase 0 supply\");\n\n        if (totalSupply == _newTotalSupply) {\n            emit TotalSupplyUpdatedHighres(\n                totalSupply,\n                rebasingCredits_,\n                rebasingCreditsPerToken_\n            );\n            return;\n        }\n\n        totalSupply = _newTotalSupply > MAX_SUPPLY\n            ? MAX_SUPPLY\n            : _newTotalSupply;\n\n        uint256 rebasingSupply = totalSupply - nonRebasingSupply;\n        // round up in the favour of the protocol\n        rebasingCreditsPerToken_ =\n            (rebasingCredits_ * 1e18 + rebasingSupply - 1) /\n            rebasingSupply;\n\n        require(rebasingCreditsPerToken_ > 0, \"Invalid change in supply\");\n\n        emit TotalSupplyUpdatedHighres(\n            totalSupply,\n            rebasingCredits_,\n            rebasingCreditsPerToken_\n        );\n    }\n\n    /*\n     * @notice Send the yield from one account to another account.\n     *         Each account keeps its own balances.\n     */\n    function delegateYield(address _from, address _to)\n        external\n        onlyGovernorOrStrategist\n    {\n        require(_from != address(0), \"Zero from address not allowed\");\n        require(_to != address(0), \"Zero to address not allowed\");\n\n        require(_from != _to, \"Cannot delegate to self\");\n        require(\n            yieldFrom[_to] == address(0) &&\n                yieldTo[_to] == address(0) &&\n                yieldFrom[_from] == address(0) &&\n                yieldTo[_from] == address(0),\n            \"Blocked by existing yield delegation\"\n        );\n        RebaseOptions stateFrom = rebaseState[_from];\n        RebaseOptions stateTo = rebaseState[_to];\n\n        require(\n            stateFrom == RebaseOptions.NotSet ||\n                stateFrom == RebaseOptions.StdNonRebasing ||\n                stateFrom == RebaseOptions.StdRebasing,\n            \"Invalid rebaseState from\"\n        );\n\n        require(\n            stateTo == RebaseOptions.NotSet ||\n                stateTo == RebaseOptions.StdNonRebasing ||\n                stateTo == RebaseOptions.StdRebasing,\n            \"Invalid rebaseState to\"\n        );\n\n        if (alternativeCreditsPerToken[_from] == 0) {\n            _rebaseOptOut(_from);\n        }\n        if (alternativeCreditsPerToken[_to] > 0) {\n            _rebaseOptIn(_to);\n        }\n\n        uint256 fromBalance = balanceOf(_from);\n        uint256 toBalance = balanceOf(_to);\n        uint256 oldToCredits = creditBalances[_to];\n        uint256 newToCredits = _balanceToRebasingCredits(\n            fromBalance + toBalance\n        );\n\n        // Set up the bidirectional links\n        yieldTo[_from] = _to;\n        yieldFrom[_to] = _from;\n\n        // Local\n        rebaseState[_from] = RebaseOptions.YieldDelegationSource;\n        alternativeCreditsPerToken[_from] = 1e18;\n        creditBalances[_from] = fromBalance;\n        rebaseState[_to] = RebaseOptions.YieldDelegationTarget;\n        creditBalances[_to] = newToCredits;\n\n        // Global\n        int256 creditsChange = newToCredits.toInt256() -\n            oldToCredits.toInt256();\n        _adjustGlobals(creditsChange, -(fromBalance).toInt256());\n        emit YieldDelegated(_from, _to);\n    }\n\n    /*\n     * @notice Stop sending the yield from one account to another account.\n     */\n    function undelegateYield(address _from) external onlyGovernorOrStrategist {\n        // Require a delegation, which will also ensure a valid delegation\n        require(yieldTo[_from] != address(0), \"Zero address not allowed\");\n\n        address to = yieldTo[_from];\n        uint256 fromBalance = balanceOf(_from);\n        uint256 toBalance = balanceOf(to);\n        uint256 oldToCredits = creditBalances[to];\n        uint256 newToCredits = _balanceToRebasingCredits(toBalance);\n\n        // Remove the bidirectional links\n        yieldFrom[to] = address(0);\n        yieldTo[_from] = address(0);\n\n        // Local\n        rebaseState[_from] = RebaseOptions.StdNonRebasing;\n        // alternativeCreditsPerToken[from] already 1e18 from `delegateYield()`\n        creditBalances[_from] = fromBalance;\n        rebaseState[to] = RebaseOptions.StdRebasing;\n        // alternativeCreditsPerToken[to] already 0 from `delegateYield()`\n        creditBalances[to] = newToCredits;\n\n        // Global\n        int256 creditsChange = newToCredits.toInt256() -\n            oldToCredits.toInt256();\n        _adjustGlobals(creditsChange, fromBalance.toInt256());\n        emit YieldUndelegated(_from, to);\n    }\n}\n"
    },
    "contracts/utils/BytesHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nuint256 constant UINT32_LENGTH = 4;\nuint256 constant UINT64_LENGTH = 8;\nuint256 constant UINT256_LENGTH = 32;\n// Address is 20 bytes, but we expect the data to be padded with 0s to 32 bytes\nuint256 constant ADDRESS_LENGTH = 32;\n\nlibrary BytesHelper {\n    /**\n     * @dev Extract a slice from bytes memory\n     * @param data The bytes memory to slice\n     * @param start The start index (inclusive)\n     * @param end The end index (exclusive)\n     * @return result A new bytes memory containing the slice\n     */\n    function extractSlice(\n        bytes memory data,\n        uint256 start,\n        uint256 end\n    ) internal pure returns (bytes memory) {\n        require(end >= start, \"Invalid slice range\");\n        require(end <= data.length, \"Slice end exceeds data length\");\n\n        uint256 length = end - start;\n        bytes memory result = new bytes(length);\n\n        // Simple byte-by-byte copy\n        for (uint256 i = 0; i < length; i++) {\n            result[i] = data[start + i];\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Decode a uint32 from a bytes memory\n     * @param data The bytes memory to decode\n     * @return uint32 The decoded uint32\n     */\n    function decodeUint32(bytes memory data) internal pure returns (uint32) {\n        require(data.length == 4, \"Invalid data length\");\n        return uint32(uint256(bytes32(data)) >> 224);\n    }\n\n    /**\n     * @dev Extract a uint32 from a bytes memory\n     * @param data The bytes memory to extract from\n     * @param start The start index (inclusive)\n     * @return uint32 The extracted uint32\n     */\n    function extractUint32(bytes memory data, uint256 start)\n        internal\n        pure\n        returns (uint32)\n    {\n        return decodeUint32(extractSlice(data, start, start + UINT32_LENGTH));\n    }\n\n    /**\n     * @dev Decode an address from a bytes memory.\n     *      Expects the data to be padded with 0s to 32 bytes.\n     * @param data The bytes memory to decode\n     * @return address The decoded address\n     */\n    function decodeAddress(bytes memory data) internal pure returns (address) {\n        // We expect the data to be padded with 0s, so length is 32 not 20\n        require(data.length == 32, \"Invalid data length\");\n        return abi.decode(data, (address));\n    }\n\n    /**\n     * @dev Extract an address from a bytes memory\n     * @param data The bytes memory to extract from\n     * @param start The start index (inclusive)\n     * @return address The extracted address\n     */\n    function extractAddress(bytes memory data, uint256 start)\n        internal\n        pure\n        returns (address)\n    {\n        return decodeAddress(extractSlice(data, start, start + ADDRESS_LENGTH));\n    }\n\n    /**\n     * @dev Decode a uint256 from a bytes memory\n     * @param data The bytes memory to decode\n     * @return uint256 The decoded uint256\n     */\n    function decodeUint256(bytes memory data) internal pure returns (uint256) {\n        require(data.length == 32, \"Invalid data length\");\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @dev Extract a uint256 from a bytes memory\n     * @param data The bytes memory to extract from\n     * @param start The start index (inclusive)\n     * @return uint256 The extracted uint256\n     */\n    function extractUint256(bytes memory data, uint256 start)\n        internal\n        pure\n        returns (uint256)\n    {\n        return decodeUint256(extractSlice(data, start, start + UINT256_LENGTH));\n    }\n}\n"
    },
    "contracts/utils/Helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IBasicToken } from \"../interfaces/IBasicToken.sol\";\n\nlibrary Helpers {\n    /**\n     * @notice Fetch the `symbol()` from an ERC20 token\n     * @dev Grabs the `symbol()` from a contract\n     * @param _token Address of the ERC20 token\n     * @return string Symbol of the ERC20 token\n     */\n    function getSymbol(address _token) internal view returns (string memory) {\n        string memory symbol = IBasicToken(_token).symbol();\n        return symbol;\n    }\n\n    /**\n     * @notice Fetch the `decimals()` from an ERC20 token\n     * @dev Grabs the `decimals()` from a contract and fails if\n     *      the decimal value does not live within a certain range\n     * @param _token Address of the ERC20 token\n     * @return uint256 Decimals of the ERC20 token\n     */\n    function getDecimals(address _token) internal view returns (uint256) {\n        uint256 decimals = IBasicToken(_token).decimals();\n        require(\n            decimals >= 4 && decimals <= 18,\n            \"Token must have sufficient decimal places\"\n        );\n\n        return decimals;\n    }\n}\n"
    },
    "contracts/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Base contract any contracts that need to initialize state after deployment.\n * @author Origin Protocol Inc\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(\n            initializing || !initialized,\n            \"Initializable: contract is already initialized\"\n        );\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/utils/InitializableAbstractStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Base contract for vault strategies.\n * @author Origin Protocol Inc\n */\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\nabstract contract InitializableAbstractStrategy is Initializable, Governable {\n    using SafeERC20 for IERC20;\n\n    event PTokenAdded(address indexed _asset, address _pToken);\n    event PTokenRemoved(address indexed _asset, address _pToken);\n    event Deposit(address indexed _asset, address _pToken, uint256 _amount);\n    event Withdrawal(address indexed _asset, address _pToken, uint256 _amount);\n    event RewardTokenCollected(\n        address recipient,\n        address rewardToken,\n        uint256 amount\n    );\n    event RewardTokenAddressesUpdated(\n        address[] _oldAddresses,\n        address[] _newAddresses\n    );\n    event HarvesterAddressesUpdated(\n        address _oldHarvesterAddress,\n        address _newHarvesterAddress\n    );\n\n    /// @notice Address of the underlying platform\n    address public immutable platformAddress;\n    /// @notice Address of the OToken vault\n    address public immutable vaultAddress;\n\n    /// @dev Replaced with an immutable variable\n    // slither-disable-next-line constable-states\n    address private _deprecated_platformAddress;\n\n    /// @dev Replaced with an immutable\n    // slither-disable-next-line constable-states\n    address private _deprecated_vaultAddress;\n\n    /// @notice asset => pToken (Platform Specific Token Address)\n    mapping(address => address) public assetToPToken;\n\n    /// @notice Full list of all assets supported by the strategy\n    address[] internal assetsMapped;\n\n    // Deprecated: Reward token address\n    // slither-disable-next-line constable-states\n    address private _deprecated_rewardTokenAddress;\n\n    // Deprecated: now resides in Harvester's rewardTokenConfigs\n    // slither-disable-next-line constable-states\n    uint256 private _deprecated_rewardLiquidationThreshold;\n\n    /// @notice Address of the Harvester contract allowed to collect reward tokens\n    address public harvesterAddress;\n\n    /// @notice Address of the reward tokens. eg CRV, BAL, CVX, AURA\n    address[] public rewardTokenAddresses;\n\n    /* Reserved for future expansion. Used to be 100 storage slots\n     * and has decreased to accommodate:\n     * - harvesterAddress\n     * - rewardTokenAddresses\n     */\n    int256[98] private _reserved;\n\n    struct BaseStrategyConfig {\n        address platformAddress; // Address of the underlying platform\n        address vaultAddress; // Address of the OToken's Vault\n    }\n\n    /**\n     * @dev Verifies that the caller is the Governor or Strategist.\n     */\n    modifier onlyGovernorOrStrategist() virtual {\n        require(\n            isGovernor() || msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    /**\n     * @param _config The platform and OToken vault addresses\n     */\n    constructor(BaseStrategyConfig memory _config) {\n        platformAddress = _config.platformAddress;\n        vaultAddress = _config.vaultAddress;\n    }\n\n    /**\n     * @dev Internal initialize function, to set up initial internal state\n     * @param _rewardTokenAddresses Address of reward token for platform\n     * @param _assets Addresses of initial supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function _initialize(\n        address[] memory _rewardTokenAddresses,\n        address[] memory _assets,\n        address[] memory _pTokens\n    ) internal {\n        rewardTokenAddresses = _rewardTokenAddresses;\n\n        uint256 assetCount = _assets.length;\n        require(assetCount == _pTokens.length, \"Invalid input arrays\");\n        for (uint256 i = 0; i < assetCount; ++i) {\n            _setPTokenAddress(_assets[i], _pTokens[i]);\n        }\n    }\n\n    /**\n     * @notice Collect accumulated reward token and send to Vault.\n     */\n    function collectRewardTokens() external virtual onlyHarvester nonReentrant {\n        _collectRewardTokens();\n    }\n\n    /**\n     * @dev Default implementation that transfers reward tokens to the Harvester\n     * Implementing strategies need to add custom logic to collect the rewards.\n     */\n    function _collectRewardTokens() internal virtual {\n        uint256 rewardTokenCount = rewardTokenAddresses.length;\n        for (uint256 i = 0; i < rewardTokenCount; ++i) {\n            IERC20 rewardToken = IERC20(rewardTokenAddresses[i]);\n            uint256 balance = rewardToken.balanceOf(address(this));\n            if (balance > 0) {\n                emit RewardTokenCollected(\n                    harvesterAddress,\n                    address(rewardToken),\n                    balance\n                );\n                rewardToken.safeTransfer(harvesterAddress, balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault.\n     */\n    modifier onlyVault() {\n        require(msg.sender == vaultAddress, \"Caller is not the Vault\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Harvester.\n     */\n    modifier onlyHarvester() {\n        require(msg.sender == harvesterAddress, \"Caller is not the Harvester\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault or Governor.\n     */\n    modifier onlyVaultOrGovernor() {\n        require(\n            msg.sender == vaultAddress || msg.sender == governor(),\n            \"Caller is not the Vault or Governor\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault, Governor, or Strategist.\n     */\n    modifier onlyVaultOrGovernorOrStrategist() {\n        require(\n            msg.sender == vaultAddress ||\n                msg.sender == governor() ||\n                msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Vault, Governor, or Strategist\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Set the reward token addresses. Any old addresses will be overwritten.\n     * @param _rewardTokenAddresses Array of reward token addresses\n     */\n    function setRewardTokenAddresses(address[] calldata _rewardTokenAddresses)\n        external\n        onlyGovernor\n    {\n        uint256 rewardTokenCount = _rewardTokenAddresses.length;\n        for (uint256 i = 0; i < rewardTokenCount; ++i) {\n            require(\n                _rewardTokenAddresses[i] != address(0),\n                \"Can not set an empty address as a reward token\"\n            );\n        }\n\n        emit RewardTokenAddressesUpdated(\n            rewardTokenAddresses,\n            _rewardTokenAddresses\n        );\n        rewardTokenAddresses = _rewardTokenAddresses;\n    }\n\n    /**\n     * @notice Get the reward token addresses.\n     * @return address[] the reward token addresses.\n     */\n    function getRewardTokenAddresses()\n        external\n        view\n        returns (address[] memory)\n    {\n        return rewardTokenAddresses;\n    }\n\n    /**\n     * @notice Provide support for asset by passing its pToken address.\n     *      This method can only be called by the system Governor\n     * @param _asset    Address for the asset\n     * @param _pToken   Address for the corresponding platform token\n     */\n    function setPTokenAddress(address _asset, address _pToken)\n        external\n        virtual\n        onlyGovernor\n    {\n        _setPTokenAddress(_asset, _pToken);\n    }\n\n    /**\n     * @notice Remove a supported asset by passing its index.\n     *      This method can only be called by the system Governor\n     * @param _assetIndex Index of the asset to be removed\n     */\n    function removePToken(uint256 _assetIndex) external virtual onlyGovernor {\n        require(_assetIndex < assetsMapped.length, \"Invalid index\");\n        address asset = assetsMapped[_assetIndex];\n        address pToken = assetToPToken[asset];\n\n        if (_assetIndex < assetsMapped.length - 1) {\n            assetsMapped[_assetIndex] = assetsMapped[assetsMapped.length - 1];\n        }\n        assetsMapped.pop();\n        assetToPToken[asset] = address(0);\n\n        emit PTokenRemoved(asset, pToken);\n    }\n\n    /**\n     * @notice Provide support for asset by passing its pToken address.\n     *      Add to internal mappings and execute the platform specific,\n     * abstract method `_abstractSetPToken`\n     * @param _asset    Address for the asset\n     * @param _pToken   Address for the corresponding platform token\n     */\n    function _setPTokenAddress(address _asset, address _pToken) internal {\n        require(assetToPToken[_asset] == address(0), \"pToken already set\");\n        require(\n            _asset != address(0) && _pToken != address(0),\n            \"Invalid addresses\"\n        );\n\n        assetToPToken[_asset] = _pToken;\n        assetsMapped.push(_asset);\n\n        emit PTokenAdded(_asset, _pToken);\n\n        _abstractSetPToken(_asset, _pToken);\n    }\n\n    /**\n     * @notice Transfer token to governor. Intended for recovering tokens stuck in\n     *      strategy contracts, i.e. mistaken sends.\n     * @param _asset Address for the asset\n     * @param _amount Amount of the asset to transfer\n     */\n    function transferToken(address _asset, uint256 _amount)\n        public\n        virtual\n        onlyGovernor\n    {\n        require(!supportsAsset(_asset), \"Cannot transfer supported asset\");\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /**\n     * @notice Set the Harvester contract that can collect rewards.\n     * @param _harvesterAddress Address of the harvester contract.\n     */\n    function setHarvesterAddress(address _harvesterAddress)\n        external\n        onlyGovernor\n    {\n        emit HarvesterAddressesUpdated(harvesterAddress, _harvesterAddress);\n        harvesterAddress = _harvesterAddress;\n    }\n\n    /***************************************\n                 Abstract\n    ****************************************/\n\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        virtual;\n\n    function safeApproveAllTokens() external virtual;\n\n    /**\n     * @notice Deposit an amount of assets into the platform\n     * @param _asset               Address for the asset\n     * @param _amount              Units of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount) external virtual;\n\n    /**\n     * @notice Deposit all supported assets in this strategy contract to the platform\n     */\n    function depositAll() external virtual;\n\n    /**\n     * @notice Withdraw an `amount` of assets from the platform and\n     * send to the `_recipient`.\n     * @param _recipient         Address to which the asset should be sent\n     * @param _asset             Address of the asset\n     * @param _amount            Units of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external virtual;\n\n    /**\n     * @notice Withdraw all supported assets from platform and\n     * sends to the OToken's Vault.\n     */\n    function withdrawAll() external virtual;\n\n    /**\n     * @notice Get the total asset value held in the platform.\n     *      This includes any interest that was generated since depositing.\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        virtual\n        returns (uint256 balance);\n\n    /**\n     * @notice Check if an asset is supported.\n     * @param _asset    Address of the asset\n     * @return bool     Whether asset is supported\n     */\n    function supportsAsset(address _asset) public view virtual returns (bool);\n}\n"
    },
    "contracts/vault/VaultStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OToken VaultStorage contract\n * @notice The VaultStorage contract defines the storage for the Vault contracts\n * @author Origin Protocol Inc\n */\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { OUSD } from \"../token/OUSD.sol\";\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport \"../utils/Helpers.sol\";\n\ncontract VaultStorage is Initializable, Governable {\n    using SafeERC20 for IERC20;\n\n    event AssetSupported(address _asset);\n    event AssetRemoved(address _asset);\n    event AssetDefaultStrategyUpdated(address _asset, address _strategy);\n    event AssetAllocated(address _asset, address _strategy, uint256 _amount);\n    event StrategyApproved(address _addr);\n    event StrategyRemoved(address _addr);\n    event Mint(address _addr, uint256 _value);\n    event Redeem(address _addr, uint256 _value);\n    event CapitalPaused();\n    event CapitalUnpaused();\n    event RebasePaused();\n    event RebaseUnpaused();\n    event VaultBufferUpdated(uint256 _vaultBuffer);\n    event OusdMetaStrategyUpdated(address _ousdMetaStrategy);\n    event RedeemFeeUpdated(uint256 _redeemFeeBps);\n    event PriceProviderUpdated(address _priceProvider);\n    event AllocateThresholdUpdated(uint256 _threshold);\n    event RebaseThresholdUpdated(uint256 _threshold);\n    event StrategistUpdated(address _address);\n    event MaxSupplyDiffChanged(uint256 maxSupplyDiff);\n    event YieldDistribution(address _to, uint256 _yield, uint256 _fee);\n    event TrusteeFeeBpsChanged(uint256 _basis);\n    event TrusteeAddressChanged(address _address);\n    event NetOusdMintForStrategyThresholdChanged(uint256 _threshold);\n    event SwapperChanged(address _address);\n    event SwapAllowedUndervalueChanged(uint256 _basis);\n    event SwapSlippageChanged(address _asset, uint256 _basis);\n    event Swapped(\n        address indexed _fromAsset,\n        address indexed _toAsset,\n        uint256 _fromAssetAmount,\n        uint256 _toAssetAmount\n    );\n    event StrategyAddedToMintWhitelist(address indexed strategy);\n    event StrategyRemovedFromMintWhitelist(address indexed strategy);\n    event RebasePerSecondMaxChanged(uint256 rebaseRatePerSecond);\n    event DripDurationChanged(uint256 dripDuration);\n    event WithdrawalRequested(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount,\n        uint256 _queued\n    );\n    event WithdrawalClaimed(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount\n    );\n    event WithdrawalClaimable(uint256 _claimable, uint256 _newClaimable);\n    event WithdrawalClaimDelayUpdated(uint256 _newDelay);\n\n    // Since we are proxy, all state should be uninitalized.\n    // Since this storage contract does not have logic directly on it\n    // we should not be checking for to see if these variables can be constant.\n    // slither-disable-start uninitialized-state\n    // slither-disable-start constable-states\n\n    // Assets supported by the Vault, i.e. Stablecoins\n    enum UnitConversion {\n        DECIMALS,\n        GETEXCHANGERATE\n    }\n    // Changed to fit into a single storage slot so the decimals needs to be recached\n    struct Asset {\n        // Note: OETHVaultCore doesn't use `isSupported` when minting,\n        // redeeming or checking balance of assets.\n        bool isSupported;\n        UnitConversion unitConversion;\n        uint8 decimals;\n        // Max allowed slippage from the Oracle price when swapping collateral assets in basis points.\n        // For example 40 == 0.4% slippage\n        uint16 allowedOracleSlippageBps;\n    }\n\n    /// @dev mapping of supported vault assets to their configuration\n    mapping(address => Asset) internal assets;\n    /// @dev list of all assets supported by the vault.\n    address[] internal allAssets;\n\n    // Strategies approved for use by the Vault\n    struct Strategy {\n        bool isSupported;\n        uint256 _deprecated; // Deprecated storage slot\n    }\n    /// @dev mapping of strategy contracts to their configuration\n    mapping(address => Strategy) public strategies;\n    /// @dev list of all vault strategies\n    address[] internal allStrategies;\n\n    /// @notice Address of the Oracle price provider contract\n    address public priceProvider;\n    /// @notice pause rebasing if true\n    bool public rebasePaused;\n    /// @notice pause operations that change the OToken supply.\n    /// eg mint, redeem, allocate, mint/burn for strategy\n    bool public capitalPaused;\n    /// @notice Redemption fee in basis points. eg 50 = 0.5%\n    uint256 public redeemFeeBps;\n    /// @notice Percentage of assets to keep in Vault to handle (most) withdrawals. 100% = 1e18.\n    uint256 public vaultBuffer;\n    /// @notice OToken mints over this amount automatically allocate funds. 18 decimals.\n    uint256 public autoAllocateThreshold;\n    /// @notice OToken mints over this amount automatically rebase. 18 decimals.\n    uint256 public rebaseThreshold;\n\n    /// @dev Address of the OToken token. eg OUSD or OETH.\n    OUSD public oUSD;\n\n    /// @dev Storage slot for the address of the VaultAdmin contract that is delegated to\n    // keccak256(\"OUSD.vault.governor.admin.impl\");\n    bytes32 public constant adminImplPosition =\n        0xa2bd3d3cf188a41358c8b401076eb59066b09dec5775650c0de4c55187d17bd9;\n\n    /// @dev Address of the contract responsible for post rebase syncs with AMMs\n    address private _deprecated_rebaseHooksAddr = address(0);\n\n    /// @dev Deprecated: Address of Uniswap\n    address private _deprecated_uniswapAddr = address(0);\n\n    /// @notice Address of the Strategist\n    address public strategistAddr = address(0);\n\n    /// @notice Mapping of asset address to the Strategy that they should automatically\n    // be allocated to\n    mapping(address => address) public assetDefaultStrategies;\n\n    /// @notice Max difference between total supply and total value of assets. 18 decimals.\n    uint256 public maxSupplyDiff;\n\n    /// @notice Trustee contract that can collect a percentage of yield\n    address public trusteeAddress;\n\n    /// @notice Amount of yield collected in basis points. eg 2000 = 20%\n    uint256 public trusteeFeeBps;\n\n    /// @dev Deprecated: Tokens that should be swapped for stablecoins\n    address[] private _deprecated_swapTokens;\n\n    uint256 constant MINT_MINIMUM_UNIT_PRICE = 0.998e18;\n\n    /// @notice Metapool strategy that is allowed to mint/burn OTokens without changing collateral\n\n    address public ousdMetaStrategy;\n\n    /// @notice How much OTokens are currently minted by the strategy\n    int256 public netOusdMintedForStrategy;\n\n    /// @notice How much net total OTokens are allowed to be minted by all strategies\n    uint256 public netOusdMintForStrategyThreshold;\n\n    uint256 constant MIN_UNIT_PRICE_DRIFT = 0.7e18;\n    uint256 constant MAX_UNIT_PRICE_DRIFT = 1.3e18;\n\n    /// @notice Collateral swap configuration.\n    /// @dev is packed into a single storage slot to save gas.\n    struct SwapConfig {\n        // Contract that swaps the vault's collateral assets\n        address swapper;\n        // Max allowed percentage the total value can drop below the total supply in basis points.\n        // For example 100 == 1%\n        uint16 allowedUndervalueBps;\n    }\n    SwapConfig internal swapConfig = SwapConfig(address(0), 0);\n\n    // List of strategies that can mint oTokens directly\n    // Used in OETHBaseVaultCore\n    mapping(address => bool) public isMintWhitelistedStrategy;\n\n    /// @notice Address of the Dripper contract that streams harvested rewards to the Vault\n    /// @dev The vault is proxied so needs to be set with setDripper against the proxy contract.\n    address private _deprecated_dripper;\n\n    /// Withdrawal Queue Storage /////\n\n    struct WithdrawalQueueMetadata {\n        // cumulative total of all withdrawal requests included the ones that have already been claimed\n        uint128 queued;\n        // cumulative total of all the requests that can be claimed including the ones that have already been claimed\n        uint128 claimable;\n        // total of all the requests that have been claimed\n        uint128 claimed;\n        // index of the next withdrawal request starting at 0\n        uint128 nextWithdrawalIndex;\n    }\n\n    /// @notice Global metadata for the withdrawal queue including:\n    /// queued - cumulative total of all withdrawal requests included the ones that have already been claimed\n    /// claimable - cumulative total of all the requests that can be claimed including the ones already claimed\n    /// claimed - total of all the requests that have been claimed\n    /// nextWithdrawalIndex - index of the next withdrawal request starting at 0\n    WithdrawalQueueMetadata public withdrawalQueueMetadata;\n\n    struct WithdrawalRequest {\n        address withdrawer;\n        bool claimed;\n        uint40 timestamp; // timestamp of the withdrawal request\n        // Amount of oTokens to redeem. eg OETH\n        uint128 amount;\n        // cumulative total of all withdrawal requests including this one.\n        // this request can be claimed when this queued amount is less than or equal to the queue's claimable amount.\n        uint128 queued;\n    }\n\n    /// @notice Mapping of withdrawal request indices to the user withdrawal request data\n    mapping(uint256 => WithdrawalRequest) public withdrawalRequests;\n\n    /// @notice Sets a minimum delay that is required to elapse between\n    ///     requesting async withdrawals and claiming the request.\n    ///     When set to 0 async withdrawals are disabled.\n    uint256 public withdrawalClaimDelay;\n\n    /// @notice Time in seconds that the vault last rebased yield.\n    uint64 public lastRebase;\n\n    /// @notice Automatic rebase yield calculations. In seconds. Set to 0 or 1 to disable.\n    uint64 public dripDuration;\n\n    /// @notice max rebase percentage per second\n    ///   Can be used to set maximum yield of the protocol,\n    ///   spreading out yield over time\n    uint64 public rebasePerSecondMax;\n\n    /// @notice target rebase rate limit, based on past rates and funds available.\n    uint64 public rebasePerSecondTarget;\n\n    uint256 internal constant MAX_REBASE = 0.02 ether;\n    uint256 internal constant MAX_REBASE_PER_SECOND =\n        uint256(0.05 ether) / 1 days;\n\n    // For future use\n    uint256[43] private __gap;\n\n    // slither-disable-end constable-states\n    // slither-disable-end uninitialized-state\n\n    /**\n     * @notice set the implementation for the admin, this needs to be in a base class else we cannot set it\n     * @param newImpl address of the implementation\n     */\n    function setAdminImpl(address newImpl) external onlyGovernor {\n        require(\n            Address.isContract(newImpl),\n            \"new implementation is not a contract\"\n        );\n        bytes32 position = adminImplPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, newImpl)\n        }\n    }\n}\n"
    },
    "lib/openzeppelin/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is managed by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}