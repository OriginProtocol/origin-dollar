{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouterClient {\n  error UnsupportedDestinationChain(uint64 destChainSelector);\n  error InsufficientFeeTokenAmount();\n  error InvalidMsgValue();\n\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\n  /// @param chainSelector The chain to check.\n  /// @return supported is true if it is supported, false if not.\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\n\n  /// @notice Gets a list of all supported tokens which can be sent or received\n  /// to/from a given chain id.\n  /// @param chainSelector The chainSelector.\n  /// @return tokens The addresses of all tokens that are supported.\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\n\n  /// @param destinationChainSelector The destination chainSelector\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return fee returns execution fee for the message\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function getFee(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage memory message\n  ) external view returns (uint256 fee);\n\n  /// @notice Request a message to be sent to the destination chain\n  /// @param destinationChainSelector The destination chain ID\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return messageId The message ID\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\n  /// the overpayment with no refund.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\n    bytes data; // Data payload\n    EVMTokenAmount[] tokenAmounts; // Token transfers\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\n  }\n\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit;\n  }\n\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/libs/ExecutorOptions.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol\";\n\nlibrary ExecutorOptions {\n    using CalldataBytesLib for bytes;\n\n    uint8 internal constant WORKER_ID = 1;\n\n    uint8 internal constant OPTION_TYPE_LZRECEIVE = 1;\n    uint8 internal constant OPTION_TYPE_NATIVE_DROP = 2;\n    uint8 internal constant OPTION_TYPE_LZCOMPOSE = 3;\n    uint8 internal constant OPTION_TYPE_ORDERED_EXECUTION = 4;\n    uint8 internal constant OPTION_TYPE_LZREAD = 5;\n\n    error Executor_InvalidLzReceiveOption();\n    error Executor_InvalidNativeDropOption();\n    error Executor_InvalidLzComposeOption();\n    error Executor_InvalidLzReadOption();\n\n    /// @dev decode the next executor option from the options starting from the specified cursor\n    /// @param _options [executor_id][executor_option][executor_id][executor_option]...\n    ///        executor_option = [option_size][option_type][option]\n    ///        option_size = len(option_type) + len(option)\n    ///        executor_id: uint8, option_size: uint16, option_type: uint8, option: bytes\n    /// @param _cursor the cursor to start decoding from\n    /// @return optionType the type of the option\n    /// @return option the option of the executor\n    /// @return cursor the cursor to start decoding the next executor option\n    function nextExecutorOption(\n        bytes calldata _options,\n        uint256 _cursor\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {\n        unchecked {\n            // skip worker id\n            cursor = _cursor + 1;\n\n            // read option size\n            uint16 size = _options.toU16(cursor);\n            cursor += 2;\n\n            // read option type\n            optionType = _options.toU8(cursor);\n\n            // startCursor and endCursor are used to slice the option from _options\n            uint256 startCursor = cursor + 1; // skip option type\n            uint256 endCursor = cursor + size;\n            option = _options[startCursor:endCursor];\n            cursor += size;\n        }\n    }\n\n    function decodeLzReceiveOption(bytes calldata _option) internal pure returns (uint128 gas, uint128 value) {\n        if (_option.length != 16 && _option.length != 32) revert Executor_InvalidLzReceiveOption();\n        gas = _option.toU128(0);\n        value = _option.length == 32 ? _option.toU128(16) : 0;\n    }\n\n    function decodeNativeDropOption(bytes calldata _option) internal pure returns (uint128 amount, bytes32 receiver) {\n        if (_option.length != 48) revert Executor_InvalidNativeDropOption();\n        amount = _option.toU128(0);\n        receiver = _option.toB32(16);\n    }\n\n    function decodeLzComposeOption(\n        bytes calldata _option\n    ) internal pure returns (uint16 index, uint128 gas, uint128 value) {\n        if (_option.length != 18 && _option.length != 34) revert Executor_InvalidLzComposeOption();\n        index = _option.toU16(0);\n        gas = _option.toU128(2);\n        value = _option.length == 34 ? _option.toU128(18) : 0;\n    }\n\n    function decodeLzReadOption(\n        bytes calldata _option\n    ) internal pure returns (uint128 gas, uint32 calldataSize, uint128 value) {\n        if (_option.length != 20 && _option.length != 36) revert Executor_InvalidLzReadOption();\n        gas = _option.toU128(0);\n        calldataSize = _option.toU32(16);\n        value = _option.length == 36 ? _option.toU128(20) : 0;\n    }\n\n    function encodeLzReceiveOption(uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_gas) : abi.encodePacked(_gas, _value);\n    }\n\n    function encodeNativeDropOption(uint128 _amount, bytes32 _receiver) internal pure returns (bytes memory) {\n        return abi.encodePacked(_amount, _receiver);\n    }\n\n    function encodeLzComposeOption(uint16 _index, uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_index, _gas) : abi.encodePacked(_index, _gas, _value);\n    }\n\n    function encodeLzReadOption(\n        uint128 _gas,\n        uint32 _calldataSize,\n        uint128 _value\n    ) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_gas, _calldataSize) : abi.encodePacked(_gas, _calldataSize, _value);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/DVNOptions.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { BytesLib } from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport { BitMap256 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol\";\nimport { CalldataBytesLib } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol\";\n\nlibrary DVNOptions {\n    using CalldataBytesLib for bytes;\n    using BytesLib for bytes;\n\n    uint8 internal constant WORKER_ID = 2;\n    uint8 internal constant OPTION_TYPE_PRECRIME = 1;\n\n    error DVN_InvalidDVNIdx();\n    error DVN_InvalidDVNOptions(uint256 cursor);\n\n    /// @dev group dvn options by its idx\n    /// @param _options [dvn_id][dvn_option][dvn_id][dvn_option]...\n    ///        dvn_option = [option_size][dvn_idx][option_type][option]\n    ///        option_size = len(dvn_idx) + len(option_type) + len(option)\n    ///        dvn_id: uint8, dvn_idx: uint8, option_size: uint16, option_type: uint8, option: bytes\n    /// @return dvnOptions the grouped options, still share the same format of _options\n    /// @return dvnIndices the dvn indices\n    function groupDVNOptionsByIdx(\n        bytes memory _options\n    ) internal pure returns (bytes[] memory dvnOptions, uint8[] memory dvnIndices) {\n        if (_options.length == 0) return (dvnOptions, dvnIndices);\n\n        uint8 numDVNs = getNumDVNs(_options);\n\n        // if there is only 1 dvn, we can just return the whole options\n        if (numDVNs == 1) {\n            dvnOptions = new bytes[](1);\n            dvnOptions[0] = _options;\n\n            dvnIndices = new uint8[](1);\n            dvnIndices[0] = _options.toUint8(3); // dvn idx\n            return (dvnOptions, dvnIndices);\n        }\n\n        // otherwise, we need to group the options by dvn_idx\n        dvnIndices = new uint8[](numDVNs);\n        dvnOptions = new bytes[](numDVNs);\n        unchecked {\n            uint256 cursor = 0;\n            uint256 start = 0;\n            uint8 lastDVNIdx = 255; // 255 is an invalid dvn_idx\n\n            while (cursor < _options.length) {\n                ++cursor; // skip worker_id\n\n                // optionLength asserted in getNumDVNs (skip check)\n                uint16 optionLength = _options.toUint16(cursor);\n                cursor += 2;\n\n                // dvnIdx asserted in getNumDVNs (skip check)\n                uint8 dvnIdx = _options.toUint8(cursor);\n\n                // dvnIdx must equal to the lastDVNIdx for the first option\n                // so it is always skipped in the first option\n                // this operation slices out options whenever the scan finds a different lastDVNIdx\n                if (lastDVNIdx == 255) {\n                    lastDVNIdx = dvnIdx;\n                } else if (dvnIdx != lastDVNIdx) {\n                    uint256 len = cursor - start - 3; // 3 is for worker_id and option_length\n                    bytes memory opt = _options.slice(start, len);\n                    _insertDVNOptions(dvnOptions, dvnIndices, lastDVNIdx, opt);\n\n                    // reset the start and lastDVNIdx\n                    start += len;\n                    lastDVNIdx = dvnIdx;\n                }\n\n                cursor += optionLength;\n            }\n\n            // skip check the cursor here because the cursor is asserted in getNumDVNs\n            // if we have reached the end of the options, we need to process the last dvn\n            uint256 size = cursor - start;\n            bytes memory op = _options.slice(start, size);\n            _insertDVNOptions(dvnOptions, dvnIndices, lastDVNIdx, op);\n\n            // revert dvnIndices to start from 0\n            for (uint8 i = 0; i < numDVNs; ++i) {\n                --dvnIndices[i];\n            }\n        }\n    }\n\n    function _insertDVNOptions(\n        bytes[] memory _dvnOptions,\n        uint8[] memory _dvnIndices,\n        uint8 _dvnIdx,\n        bytes memory _newOptions\n    ) internal pure {\n        // dvnIdx starts from 0 but default value of dvnIndices is 0,\n        // so we tell if the slot is empty by adding 1 to dvnIdx\n        if (_dvnIdx == 255) revert DVN_InvalidDVNIdx();\n        uint8 dvnIdxAdj = _dvnIdx + 1;\n\n        for (uint256 j = 0; j < _dvnIndices.length; ++j) {\n            uint8 index = _dvnIndices[j];\n            if (dvnIdxAdj == index) {\n                _dvnOptions[j] = abi.encodePacked(_dvnOptions[j], _newOptions);\n                break;\n            } else if (index == 0) {\n                // empty slot, that means it is the first time we see this dvn\n                _dvnIndices[j] = dvnIdxAdj;\n                _dvnOptions[j] = _newOptions;\n                break;\n            }\n        }\n    }\n\n    /// @dev get the number of unique dvns\n    /// @param _options the format is the same as groupDVNOptionsByIdx\n    function getNumDVNs(bytes memory _options) internal pure returns (uint8 numDVNs) {\n        uint256 cursor = 0;\n        BitMap256 bitmap;\n\n        // find number of unique dvn_idx\n        unchecked {\n            while (cursor < _options.length) {\n                ++cursor; // skip worker_id\n\n                uint16 optionLength = _options.toUint16(cursor);\n                cursor += 2;\n                if (optionLength < 2) revert DVN_InvalidDVNOptions(cursor); // at least 1 byte for dvn_idx and 1 byte for option_type\n\n                uint8 dvnIdx = _options.toUint8(cursor);\n\n                // if dvnIdx is not set, increment numDVNs\n                // max num of dvns is 255, 255 is an invalid dvn_idx\n                // The order of the dvnIdx is not required to be sequential, as enforcing the order may weaken\n                // the composability of the options. e.g. if we refrain from enforcing the order, an OApp that has\n                // already enforced certain options can append additional options to the end of the enforced\n                // ones without restrictions.\n                if (dvnIdx == 255) revert DVN_InvalidDVNIdx();\n                if (!bitmap.get(dvnIdx)) {\n                    ++numDVNs;\n                    bitmap = bitmap.set(dvnIdx);\n                }\n\n                cursor += optionLength;\n            }\n        }\n        if (cursor != _options.length) revert DVN_InvalidDVNOptions(cursor);\n    }\n\n    /// @dev decode the next dvn option from _options starting from the specified cursor\n    /// @param _options the format is the same as groupDVNOptionsByIdx\n    /// @param _cursor the cursor to start decoding\n    /// @return optionType the type of the option\n    /// @return option the option\n    /// @return cursor the cursor to start decoding the next option\n    function nextDVNOption(\n        bytes calldata _options,\n        uint256 _cursor\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {\n        unchecked {\n            // skip worker id\n            cursor = _cursor + 1;\n\n            // read option size\n            uint16 size = _options.toU16(cursor);\n            cursor += 2;\n\n            // read option type\n            optionType = _options.toU8(cursor + 1); // skip dvn_idx\n\n            // startCursor and endCursor are used to slice the option from _options\n            uint256 startCursor = cursor + 2; // skip option type and dvn_idx\n            uint256 endCursor = cursor + size;\n            option = _options[startCursor:endCursor];\n            cursor += size;\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IMessageLibManager } from \"./IMessageLibManager.sol\";\nimport { IMessagingComposer } from \"./IMessagingComposer.sol\";\nimport { IMessagingChannel } from \"./IMessagingChannel.sol\";\nimport { IMessagingContext } from \"./IMessagingContext.sol\";\n\nstruct MessagingParams {\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes message;\n    bytes options;\n    bool payInLzToken;\n}\n\nstruct MessagingReceipt {\n    bytes32 guid;\n    uint64 nonce;\n    MessagingFee fee;\n}\n\nstruct MessagingFee {\n    uint256 nativeFee;\n    uint256 lzTokenFee;\n}\n\nstruct Origin {\n    uint32 srcEid;\n    bytes32 sender;\n    uint64 nonce;\n}\n\ninterface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\n\n    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);\n\n    event PacketDelivered(Origin origin, address receiver);\n\n    event LzReceiveAlert(\n        address indexed receiver,\n        address indexed executor,\n        Origin origin,\n        bytes32 guid,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    event LzTokenSet(address token);\n\n    event DelegateSet(address sender, address delegate);\n\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory);\n\n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory);\n\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;\n\n    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function initializable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function lzReceive(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n\n    // oapp can burn messages partially by calling this function with its own business logic if messages are verified in order\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;\n\n    function setLzToken(address _lzToken) external;\n\n    function lzToken() external view returns (address);\n\n    function nativeToken() external view returns (address);\n\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nstruct SetConfigParam {\n    uint32 eid;\n    uint32 configType;\n    bytes config;\n}\n\ninterface IMessageLibManager {\n    struct Timeout {\n        address lib;\n        uint256 expiry;\n    }\n\n    event LibraryRegistered(address newLib);\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\n    event ReceiveLibrarySet(address receiver, uint32 eid, address newLib);\n    event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);\n\n    function registerLibrary(address _lib) external;\n\n    function isRegisteredLibrary(address _lib) external view returns (bool);\n\n    function getRegisteredLibraries() external view returns (address[] memory);\n\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\n\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    function isValidReceiveLibrary(address _receiver, uint32 _eid, address _lib) external view returns (bool);\n\n    /// ------------------- OApp interfaces -------------------\n    function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;\n\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\n\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\n\n    function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\n\n    function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external;\n\n    function getConfig(\n        address _oapp,\n        address _lib,\n        uint32 _eid,\n        uint32 _configType\n    ) external view returns (bytes memory config);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingChannel {\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\n    event PacketNilified(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n    event PacketBurnt(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n\n    function eid() external view returns (uint32);\n\n    // this is an emergency function if a message cannot be verified for some reasons\n    // required to provide _nextNonce to avoid race condition\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\n\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\n\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\n\n    function inboundPayloadHash(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce\n    ) external view returns (bytes32);\n\n    function lazyInboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingComposer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingComposer {\n    event ComposeSent(address from, address to, bytes32 guid, uint16 index, bytes message);\n    event ComposeDelivered(address from, address to, bytes32 guid, uint16 index);\n    event LzComposeAlert(\n        address indexed from,\n        address indexed to,\n        address indexed executor,\n        bytes32 guid,\n        uint16 index,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    function composeQueue(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index\n    ) external view returns (bytes32 messageHash);\n\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external;\n\n    function lzCompose(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingContext {\n    function isSendingMessage() external view returns (bool);\n\n    function getSendContext() external view returns (uint32 dstEid, address sender);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nlibrary CalldataBytesLib {\n    function toU8(bytes calldata _bytes, uint256 _start) internal pure returns (uint8) {\n        return uint8(_bytes[_start]);\n    }\n\n    function toU16(bytes calldata _bytes, uint256 _start) internal pure returns (uint16) {\n        unchecked {\n            uint256 end = _start + 2;\n            return uint16(bytes2(_bytes[_start:end]));\n        }\n    }\n\n    function toU32(bytes calldata _bytes, uint256 _start) internal pure returns (uint32) {\n        unchecked {\n            uint256 end = _start + 4;\n            return uint32(bytes4(_bytes[_start:end]));\n        }\n    }\n\n    function toU64(bytes calldata _bytes, uint256 _start) internal pure returns (uint64) {\n        unchecked {\n            uint256 end = _start + 8;\n            return uint64(bytes8(_bytes[_start:end]));\n        }\n    }\n\n    function toU128(bytes calldata _bytes, uint256 _start) internal pure returns (uint128) {\n        unchecked {\n            uint256 end = _start + 16;\n            return uint128(bytes16(_bytes[_start:end]));\n        }\n    }\n\n    function toU256(bytes calldata _bytes, uint256 _start) internal pure returns (uint256) {\n        unchecked {\n            uint256 end = _start + 32;\n            return uint256(bytes32(_bytes[_start:end]));\n        }\n    }\n\n    function toAddr(bytes calldata _bytes, uint256 _start) internal pure returns (address) {\n        unchecked {\n            uint256 end = _start + 20;\n            return address(bytes20(_bytes[_start:end]));\n        }\n    }\n\n    function toB32(bytes calldata _bytes, uint256 _start) internal pure returns (bytes32) {\n        unchecked {\n            uint256 end = _start + 32;\n            return bytes32(_bytes[_start:end]);\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/BitMaps.sol\npragma solidity ^0.8.20;\n\ntype BitMap256 is uint256;\n\nusing BitMaps for BitMap256 global;\n\nlibrary BitMaps {\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap256 bitmap, uint8 index) internal pure returns (bool) {\n        uint256 mask = 1 << index;\n        return BitMap256.unwrap(bitmap) & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap256 bitmap, uint8 index) internal pure returns (BitMap256) {\n        uint256 mask = 1 << index;\n        return BitMap256.wrap(BitMap256.unwrap(bitmap) | mask);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { ILayerZeroEndpointV2 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\n/**\n * @title IOAppCore\n */\ninterface IOAppCore {\n    // Custom error messages\n    error OnlyPeer(uint32 eid, bytes32 sender);\n    error NoPeer(uint32 eid);\n    error InvalidEndpointCall();\n    error InvalidDelegate();\n\n    // Event emitted when a peer (OApp) is set for a corresponding endpoint\n    event PeerSet(uint32 eid, bytes32 peer);\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     */\n    function oAppVersion() external view returns (uint64 senderVersion, uint64 receiverVersion);\n\n    /**\n     * @notice Retrieves the LayerZero endpoint associated with the OApp.\n     * @return iEndpoint The LayerZero endpoint as an interface.\n     */\n    function endpoint() external view returns (ILayerZeroEndpointV2 iEndpoint);\n\n    /**\n     * @notice Retrieves the peer (OApp) associated with a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @return peer The peer address (OApp instance) associated with the corresponding endpoint.\n     */\n    function peers(uint32 _eid) external view returns (bytes32 peer);\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) external;\n\n    /**\n     * @notice Sets the delegate address for the OApp Core.\n     * @param _delegate The address of the delegate to be set.\n     */\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/libs/OptionsBuilder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { BytesLib } from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { ExecutorOptions } from \"@layerzerolabs/lz-evm-messagelib-v2/contracts/libs/ExecutorOptions.sol\";\nimport { DVNOptions } from \"@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/DVNOptions.sol\";\n\n/**\n * @title OptionsBuilder\n * @dev Library for building and encoding various message options.\n */\nlibrary OptionsBuilder {\n    using SafeCast for uint256;\n    using BytesLib for bytes;\n\n    // Constants for options types\n    uint16 internal constant TYPE_1 = 1; // legacy options type 1\n    uint16 internal constant TYPE_2 = 2; // legacy options type 2\n    uint16 internal constant TYPE_3 = 3;\n\n    // Custom error message\n    error InvalidSize(uint256 max, uint256 actual);\n    error InvalidOptionType(uint16 optionType);\n\n    // Modifier to ensure only options of type 3 are used\n    modifier onlyType3(bytes memory _options) {\n        if (_options.toUint16(0) != TYPE_3) revert InvalidOptionType(_options.toUint16(0));\n        _;\n    }\n\n    /**\n     * @dev Creates a new options container with type 3.\n     * @return options The newly created options container.\n     */\n    function newOptions() internal pure returns (bytes memory) {\n        return abi.encodePacked(TYPE_3);\n    }\n\n    /**\n     * @dev Adds an executor LZ receive option to the existing options.\n     * @param _options The existing options container.\n     * @param _gas The gasLimit used on the lzReceive() function in the OApp.\n     * @param _value The msg.value passed to the lzReceive() function in the OApp.\n     * @return options The updated options container.\n     *\n     * @dev When multiples of this option are added, they are summed by the executor\n     * eg. if (_gas: 200k, and _value: 1 ether) AND (_gas: 100k, _value: 0.5 ether) are sent in an option to the LayerZeroEndpoint,\n     * that becomes (300k, 1.5 ether) when the message is executed on the remote lzReceive() function.\n     */\n    function addExecutorLzReceiveOption(\n        bytes memory _options,\n        uint128 _gas,\n        uint128 _value\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeLzReceiveOption(_gas, _value);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZRECEIVE, option);\n    }\n\n    /**\n     * @dev Adds an executor native drop option to the existing options.\n     * @param _options The existing options container.\n     * @param _amount The amount for the native value that is airdropped to the 'receiver'.\n     * @param _receiver The receiver address for the native drop option.\n     * @return options The updated options container.\n     *\n     * @dev When multiples of this option are added, they are summed by the executor on the remote chain.\n     */\n    function addExecutorNativeDropOption(\n        bytes memory _options,\n        uint128 _amount,\n        bytes32 _receiver\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeNativeDropOption(_amount, _receiver);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_NATIVE_DROP, option);\n    }\n\n    // /**\n    //  * @dev Adds an executor native drop option to the existing options.\n    //  * @param _options The existing options container.\n    //  * @param _amount The amount for the native value that is airdropped to the 'receiver'.\n    //  * @param _receiver The receiver address for the native drop option.\n    //  * @return options The updated options container.\n    //  *\n    //  * @dev When multiples of this option are added, they are summed by the executor on the remote chain.\n    //  */\n    function addExecutorLzReadOption(\n        bytes memory _options,\n        uint128 _gas,\n        uint32 _size,\n        uint128 _value\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeLzReadOption(_gas, _size, _value);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZREAD, option);\n    }\n\n    /**\n     * @dev Adds an executor LZ compose option to the existing options.\n     * @param _options The existing options container.\n     * @param _index The index for the lzCompose() function call.\n     * @param _gas The gasLimit for the lzCompose() function call.\n     * @param _value The msg.value for the lzCompose() function call.\n     * @return options The updated options container.\n     *\n     * @dev When multiples of this option are added, they are summed PER index by the executor on the remote chain.\n     * @dev If the OApp sends N lzCompose calls on the remote, you must provide N incremented indexes starting with 0.\n     * ie. When your remote OApp composes (N = 3) messages, you must set this option for index 0,1,2\n     */\n    function addExecutorLzComposeOption(\n        bytes memory _options,\n        uint16 _index,\n        uint128 _gas,\n        uint128 _value\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeLzComposeOption(_index, _gas, _value);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZCOMPOSE, option);\n    }\n\n    /**\n     * @dev Adds an executor ordered execution option to the existing options.\n     * @param _options The existing options container.\n     * @return options The updated options container.\n     */\n    function addExecutorOrderedExecutionOption(\n        bytes memory _options\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_ORDERED_EXECUTION, bytes(\"\"));\n    }\n\n    /**\n     * @dev Adds a DVN pre-crime option to the existing options.\n     * @param _options The existing options container.\n     * @param _dvnIdx The DVN index for the pre-crime option.\n     * @return options The updated options container.\n     */\n    function addDVNPreCrimeOption(\n        bytes memory _options,\n        uint8 _dvnIdx\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return addDVNOption(_options, _dvnIdx, DVNOptions.OPTION_TYPE_PRECRIME, bytes(\"\"));\n    }\n\n    /**\n     * @dev Adds an executor option to the existing options.\n     * @param _options The existing options container.\n     * @param _optionType The type of the executor option.\n     * @param _option The encoded data for the executor option.\n     * @return options The updated options container.\n     */\n    function addExecutorOption(\n        bytes memory _options,\n        uint8 _optionType,\n        bytes memory _option\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _options,\n                ExecutorOptions.WORKER_ID,\n                _option.length.toUint16() + 1, // +1 for optionType\n                _optionType,\n                _option\n            );\n    }\n\n    /**\n     * @dev Adds a DVN option to the existing options.\n     * @param _options The existing options container.\n     * @param _dvnIdx The DVN index for the DVN option.\n     * @param _optionType The type of the DVN option.\n     * @param _option The encoded data for the DVN option.\n     * @return options The updated options container.\n     */\n    function addDVNOption(\n        bytes memory _options,\n        uint8 _dvnIdx,\n        uint8 _optionType,\n        bytes memory _option\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _options,\n                DVNOptions.WORKER_ID,\n                _option.length.toUint16() + 2, // +2 for optionType and dvnIdx\n                _dvnIdx,\n                _optionType,\n                _option\n            );\n    }\n\n    /**\n     * @dev Encodes legacy options of type 1.\n     * @param _executionGas The gasLimit value passed to lzReceive().\n     * @return legacyOptions The encoded legacy options.\n     */\n    function encodeLegacyOptionsType1(uint256 _executionGas) internal pure returns (bytes memory) {\n        if (_executionGas > type(uint128).max) revert InvalidSize(type(uint128).max, _executionGas);\n        return abi.encodePacked(TYPE_1, _executionGas);\n    }\n\n    /**\n     * @dev Encodes legacy options of type 2.\n     * @param _executionGas The gasLimit value passed to lzReceive().\n     * @param _nativeForDst The amount of native air dropped to the receiver.\n     * @param _receiver The _nativeForDst receiver address.\n     * @return legacyOptions The encoded legacy options of type 2.\n     */\n    function encodeLegacyOptionsType2(\n        uint256 _executionGas,\n        uint256 _nativeForDst,\n        bytes memory _receiver // @dev Use bytes instead of bytes32 in legacy type 2 for _receiver.\n    ) internal pure returns (bytes memory) {\n        if (_executionGas > type(uint128).max) revert InvalidSize(type(uint128).max, _executionGas);\n        if (_nativeForDst > type(uint128).max) revert InvalidSize(type(uint128).max, _nativeForDst);\n        if (_receiver.length > 32) revert InvalidSize(32, _receiver.length);\n        return abi.encodePacked(TYPE_2, _executionGas, _nativeForDst, _receiver);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/OAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IOAppCore, ILayerZeroEndpointV2 } from \"./interfaces/IOAppCore.sol\";\n\n/**\n * @title OAppCore\n * @dev Abstract contract implementing the IOAppCore interface with basic OApp configurations.\n */\nabstract contract OAppCore is IOAppCore, Ownable {\n    // The LayerZero endpoint associated with the given OApp\n    ILayerZeroEndpointV2 public immutable endpoint;\n\n    // Mapping to store peers associated with corresponding endpoints\n    mapping(uint32 eid => bytes32 peer) public peers;\n\n    /**\n     * @dev Constructor to initialize the OAppCore with the provided endpoint and delegate.\n     * @param _endpoint The address of the LOCAL Layer Zero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     *\n     * @dev The delegate typically should be set as the owner of the contract.\n     */\n    constructor(address _endpoint, address _delegate) {\n        endpoint = ILayerZeroEndpointV2(_endpoint);\n\n        if (_delegate == address(0)) revert InvalidDelegate();\n        endpoint.setDelegate(_delegate);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) public virtual onlyOwner {\n        _setPeer(_eid, _peer);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function _setPeer(uint32 _eid, bytes32 _peer) internal virtual {\n        peers[_eid] = _peer;\n        emit PeerSet(_eid, _peer);\n    }\n\n    /**\n     * @notice Internal function to get the peer address associated with a specific endpoint; reverts if NOT set.\n     * ie. the peer is set to bytes32(0).\n     * @param _eid The endpoint ID.\n     * @return peer The address of the peer associated with the specified endpoint.\n     */\n    function _getPeerOrRevert(uint32 _eid) internal view virtual returns (bytes32) {\n        bytes32 peer = peers[_eid];\n        if (peer == bytes32(0)) revert NoPeer(_eid);\n        return peer;\n    }\n\n    /**\n     * @notice Sets the delegate address for the OApp.\n     * @param _delegate The address of the delegate to be set.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides the ability for a delegate to set configs, on behalf of the OApp, directly on the Endpoint contract.\n     */\n    function setDelegate(address _delegate) public onlyOwner {\n        endpoint.setDelegate(_delegate);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/OAppSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { MessagingParams, MessagingFee, MessagingReceipt } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppSender\n * @dev Abstract contract implementing the OAppSender functionality for sending messages to a LayerZero endpoint.\n */\nabstract contract OAppSender is OAppCore {\n    using SafeERC20 for IERC20;\n\n    // Custom error messages\n    error NotEnoughNative(uint256 msgValue);\n    error LzTokenUnavailable();\n\n    // @dev The version of the OAppSender implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant SENDER_VERSION = 1;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppReceiver version. Indicates that the OAppReceiver is not implemented.\n     * ie. this is a SEND only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (SENDER_VERSION, 0);\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.quote() for fee calculation.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _payInLzToken Flag indicating whether to pay the fee in LZ tokens.\n     * @return fee The calculated MessagingFee for the message.\n     *      - nativeFee: The native fee for the message.\n     *      - lzTokenFee: The LZ token fee for the message.\n     */\n    function _quote(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        bool _payInLzToken\n    ) internal view virtual returns (MessagingFee memory fee) {\n        return\n            endpoint.quote(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _payInLzToken),\n                address(this)\n            );\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.send() for sending a message.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _fee The calculated LayerZero fee for the message.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess fee values sent to the endpoint.\n     * @return receipt The receipt for the sent message.\n     *      - guid: The unique identifier for the sent message.\n     *      - nonce: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     */\n    function _lzSend(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        MessagingFee memory _fee,\n        address _refundAddress\n    ) internal virtual returns (MessagingReceipt memory receipt) {\n        // @dev Push corresponding fees to the endpoint, any excess is sent back to the _refundAddress from the endpoint.\n        uint256 messageValue = _payNative(_fee.nativeFee);\n        if (_fee.lzTokenFee > 0) _payLzToken(_fee.lzTokenFee);\n\n        return\n            // solhint-disable-next-line check-send-result\n            endpoint.send{ value: messageValue }(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _fee.lzTokenFee > 0),\n                _refundAddress\n            );\n    }\n\n    /**\n     * @dev Internal function to pay the native fee associated with the message.\n     * @param _nativeFee The native fee to be paid.\n     * @return nativeFee The amount of native currency paid.\n     *\n     * @dev If the OApp needs to initiate MULTIPLE LayerZero messages in a single transaction,\n     * this will need to be overridden because msg.value would contain multiple lzFees.\n     * @dev Should be overridden in the event the LayerZero endpoint requires a different native currency.\n     * @dev Some EVMs use an ERC20 as a method for paying transactions/gasFees.\n     * @dev The endpoint is EITHER/OR, ie. it will NOT support both types of native payment at a time.\n     */\n    function _payNative(uint256 _nativeFee) internal virtual returns (uint256 nativeFee) {\n        if (msg.value != _nativeFee) revert NotEnoughNative(msg.value);\n        return _nativeFee;\n    }\n\n    /**\n     * @dev Internal function to pay the LZ token fee associated with the message.\n     * @param _lzTokenFee The LZ token fee to be paid.\n     *\n     * @dev If the caller is trying to pay in the specified lzToken, then the lzTokenFee is passed to the endpoint.\n     * @dev Any excess sent, is passed back to the specified _refundAddress in the _lzSend().\n     */\n    function _payLzToken(uint256 _lzTokenFee) internal virtual {\n        // @dev Cannot cache the token because it is not immutable in the endpoint.\n        address lzToken = endpoint.lzToken();\n        if (lzToken == address(0)) revert LzTokenUnavailable();\n\n        // Pay LZ token fee by sending tokens to the endpoint.\n        IERC20(lzToken).safeTransferFrom(msg.sender, address(endpoint), _lzTokenFee);\n    }\n}\n"
    },
    "@layerzerolabs/oft-evm/contracts/interfaces/IOFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { MessagingReceipt, MessagingFee } from \"@layerzerolabs/oapp-evm/contracts/oapp/OAppSender.sol\";\n\n/**\n * @dev Struct representing token parameters for the OFT send() operation.\n */\nstruct SendParam {\n    uint32 dstEid; // Destination endpoint ID.\n    bytes32 to; // Recipient address.\n    uint256 amountLD; // Amount to send in local decimals.\n    uint256 minAmountLD; // Minimum amount to send in local decimals.\n    bytes extraOptions; // Additional options supplied by the caller to be used in the LayerZero message.\n    bytes composeMsg; // The composed message for the send() operation.\n    bytes oftCmd; // The OFT command to be executed, unused in default OFT implementations.\n}\n\n/**\n * @dev Struct representing OFT limit information.\n * @dev These amounts can change dynamically and are up the specific oft implementation.\n */\nstruct OFTLimit {\n    uint256 minAmountLD; // Minimum amount in local decimals that can be sent to the recipient.\n    uint256 maxAmountLD; // Maximum amount in local decimals that can be sent to the recipient.\n}\n\n/**\n * @dev Struct representing OFT receipt information.\n */\nstruct OFTReceipt {\n    uint256 amountSentLD; // Amount of tokens ACTUALLY debited from the sender in local decimals.\n    // @dev In non-default implementations, the amountReceivedLD COULD differ from this value.\n    uint256 amountReceivedLD; // Amount of tokens to be received on the remote side.\n}\n\n/**\n * @dev Struct representing OFT fee details.\n * @dev Future proof mechanism to provide a standardized way to communicate fees to things like a UI.\n */\nstruct OFTFeeDetail {\n    int256 feeAmountLD; // Amount of the fee in local decimals.\n    string description; // Description of the fee.\n}\n\n/**\n * @title IOFT\n * @dev Interface for the OftChain (OFT) token.\n * @dev Does not inherit ERC20 to accommodate usage by OFTAdapter as well.\n * @dev This specific interface ID is '0x02e49c2c'.\n */\ninterface IOFT {\n    // Custom error messages\n    error InvalidLocalDecimals();\n    error SlippageExceeded(uint256 amountLD, uint256 minAmountLD);\n\n    // Events\n    event OFTSent(\n        bytes32 indexed guid, // GUID of the OFT message.\n        uint32 dstEid, // Destination Endpoint ID.\n        address indexed fromAddress, // Address of the sender on the src chain.\n        uint256 amountSentLD, // Amount of tokens sent in local decimals.\n        uint256 amountReceivedLD // Amount of tokens received in local decimals.\n    );\n    event OFTReceived(\n        bytes32 indexed guid, // GUID of the OFT message.\n        uint32 srcEid, // Source Endpoint ID.\n        address indexed toAddress, // Address of the recipient on the dst chain.\n        uint256 amountReceivedLD // Amount of tokens received in local decimals.\n    );\n\n    /**\n     * @notice Retrieves interfaceID and the version of the OFT.\n     * @return interfaceId The interface ID.\n     * @return version The version.\n     *\n     * @dev interfaceId: This specific interface ID is '0x02e49c2c'.\n     * @dev version: Indicates a cross-chain compatible msg encoding with other OFTs.\n     * @dev If a new feature is added to the OFT cross-chain msg encoding, the version will be incremented.\n     * ie. localOFT version(x,1) CAN send messages to remoteOFT version(x,1)\n     */\n    function oftVersion() external view returns (bytes4 interfaceId, uint64 version);\n\n    /**\n     * @notice Retrieves the address of the token associated with the OFT.\n     * @return token The address of the ERC20 token implementation.\n     */\n    function token() external view returns (address);\n\n    /**\n     * @notice Indicates whether the OFT contract requires approval of the 'token()' to send.\n     * @return requiresApproval Needs approval of the underlying token implementation.\n     *\n     * @dev Allows things like wallet implementers to determine integration requirements,\n     * without understanding the underlying token implementation.\n     */\n    function approvalRequired() external view returns (bool);\n\n    /**\n     * @notice Retrieves the shared decimals of the OFT.\n     * @return sharedDecimals The shared decimals of the OFT.\n     */\n    function sharedDecimals() external view returns (uint8);\n\n    /**\n     * @notice Provides the fee breakdown and settings data for an OFT. Unused in the default implementation.\n     * @param _sendParam The parameters for the send operation.\n     * @return limit The OFT limit information.\n     * @return oftFeeDetails The details of OFT fees.\n     * @return receipt The OFT receipt information.\n     */\n    function quoteOFT(\n        SendParam calldata _sendParam\n    ) external view returns (OFTLimit memory, OFTFeeDetail[] memory oftFeeDetails, OFTReceipt memory);\n\n    /**\n     * @notice Provides a quote for the send() operation.\n     * @param _sendParam The parameters for the send() operation.\n     * @param _payInLzToken Flag indicating whether the caller is paying in the LZ token.\n     * @return fee The calculated LayerZero messaging fee from the send() operation.\n     *\n     * @dev MessagingFee: LayerZero msg fee\n     *  - nativeFee: The native fee.\n     *  - lzTokenFee: The lzToken fee.\n     */\n    function quoteSend(SendParam calldata _sendParam, bool _payInLzToken) external view returns (MessagingFee memory);\n\n    /**\n     * @notice Executes the send() operation.\n     * @param _sendParam The parameters for the send operation.\n     * @param _fee The fee information supplied by the caller.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess funds from fees etc. on the src.\n     * @return receipt The LayerZero messaging receipt from the send() operation.\n     * @return oftReceipt The OFT receipt information.\n     *\n     * @dev MessagingReceipt: LayerZero msg receipt\n     *  - guid: The unique identifier for the sent message.\n     *  - nonce: The nonce of the sent message.\n     *  - fee: The LayerZero fee incurred for the message.\n     */\n    function send(\n        SendParam calldata _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory, OFTReceipt memory);\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/automation/AbstractCCIPBridgeHelperModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractSafeModule } from \"./AbstractSafeModule.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IRouterClient } from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport { Client } from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\n\nabstract contract AbstractCCIPBridgeHelperModule is AbstractSafeModule {\n    /**\n     * @notice Bridges a token from the source chain to the destination chain using CCIP\n     * @param ccipRouter The CCIP router contract\n     * @param destinationChainSelector The selector for the destination chain\n     * @param token The token to bridge\n     * @param amount The amount of token to bridge\n     */\n    function _bridgeTokenWithCCIP(\n        IRouterClient ccipRouter,\n        uint64 destinationChainSelector,\n        IERC20 token,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        // Approve CCIP Router to move the token\n        success = safeContract.execTransactionFromModule(\n            address(token),\n            0, // Value\n            abi.encodeWithSelector(token.approve.selector, ccipRouter, amount),\n            0 // Call\n        );\n        require(success, \"Failed to approve token\");\n\n        Client.EVMTokenAmount[]\n            memory tokenAmounts = new Client.EVMTokenAmount[](1);\n        Client.EVMTokenAmount memory tokenAmount = Client.EVMTokenAmount({\n            token: address(token),\n            amount: amount\n        });\n        tokenAmounts[0] = tokenAmount;\n\n        Client.EVM2AnyMessage memory ccipMessage = Client.EVM2AnyMessage({\n            receiver: abi.encode(address(safeContract)), // ABI-encoded receiver address\n            data: abi.encode(\"\"),\n            tokenAmounts: tokenAmounts,\n            extraArgs: Client._argsToBytes(\n                Client.EVMExtraArgsV1({ gasLimit: 0 })\n            ),\n            feeToken: address(0)\n        });\n\n        // Get CCIP fee\n        uint256 ccipFee = ccipRouter.getFee(\n            destinationChainSelector,\n            ccipMessage\n        );\n\n        // Send CCIP message\n        success = safeContract.execTransactionFromModule(\n            address(ccipRouter),\n            ccipFee, // Value\n            abi.encodeWithSelector(\n                ccipRouter.ccipSend.selector,\n                destinationChainSelector,\n                ccipMessage\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to send CCIP message\");\n    }\n}\n"
    },
    "contracts/automation/AbstractLZBridgeHelperModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractSafeModule } from \"./AbstractSafeModule.sol\";\n\nimport { IOFT, SendParam } from \"@layerzerolabs/oft-evm/contracts/interfaces/IOFT.sol\";\nimport { MessagingFee } from \"@layerzerolabs/oapp-evm/contracts/oapp/OAppSender.sol\";\nimport { OptionsBuilder } from \"@layerzerolabs/oapp-evm/contracts/oapp/libs/OptionsBuilder.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nabstract contract AbstractLZBridgeHelperModule is AbstractSafeModule {\n    using OptionsBuilder for bytes;\n\n    /**\n     * @dev Bridges token using LayerZero.\n     * @param lzEndpointId LayerZero endpoint id.\n     * @param token Token to bridge.\n     * @param lzAdapter LZ Adapter to use.\n     * @param amount Amount of token to bridge.\n     * @param slippageBps Slippage in 10^4 basis points.\n     * @param isNativeToken Whether the token is native token.\n     */\n    function _bridgeTokenWithLz(\n        uint32 lzEndpointId,\n        IERC20 token,\n        IOFT lzAdapter,\n        uint256 amount,\n        uint256 slippageBps,\n        bool isNativeToken\n    ) internal {\n        bool success;\n\n        if (!isNativeToken) {\n            // Approve LZ Adapter to move the token\n            success = safeContract.execTransactionFromModule(\n                address(token),\n                0, // Value\n                abi.encodeWithSelector(\n                    token.approve.selector,\n                    address(lzAdapter),\n                    amount\n                ),\n                0 // Call\n            );\n            require(success, \"Failed to approve token\");\n        }\n\n        // Calculate minimum amount to receive\n        uint256 minAmount = (amount * (10000 - slippageBps)) / 10000;\n\n        // Hardcoded gaslimit of 400k\n        bytes memory options = OptionsBuilder\n            .newOptions()\n            .addExecutorLzReceiveOption(400000, 0);\n\n        // Build send param\n        SendParam memory sendParam = SendParam({\n            dstEid: lzEndpointId,\n            to: bytes32(uint256(uint160(address(safeContract)))),\n            amountLD: amount,\n            minAmountLD: minAmount,\n            extraOptions: options,\n            composeMsg: bytes(\"\"),\n            oftCmd: bytes(\"\")\n        });\n\n        // Compute fees\n        MessagingFee memory msgFee = lzAdapter.quoteSend(sendParam, false);\n\n        uint256 value = isNativeToken\n            ? amount + msgFee.nativeFee\n            : msgFee.nativeFee;\n\n        // Execute transaction\n        success = safeContract.execTransactionFromModule(\n            address(lzAdapter),\n            value,\n            abi.encodeWithSelector(\n                lzAdapter.send.selector,\n                sendParam,\n                msgFee,\n                address(safeContract)\n            ),\n            0\n        );\n        require(success, \"Failed to bridge token\");\n    }\n}\n"
    },
    "contracts/automation/AbstractSafeModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AccessControlEnumerable } from \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ISafe } from \"../interfaces/ISafe.sol\";\n\nabstract contract AbstractSafeModule is AccessControlEnumerable {\n    ISafe public immutable safeContract;\n\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n\n    modifier onlySafe() {\n        require(\n            msg.sender == address(safeContract),\n            \"Caller is not the safe contract\"\n        );\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(\n            hasRole(OPERATOR_ROLE, msg.sender),\n            \"Caller is not an operator\"\n        );\n        _;\n    }\n\n    constructor(address _safeContract) {\n        safeContract = ISafe(_safeContract);\n        _grantRole(DEFAULT_ADMIN_ROLE, address(safeContract));\n        _grantRole(OPERATOR_ROLE, address(safeContract));\n    }\n\n    /**\n     * @dev Helps recovering any tokens accidentally sent to this module.\n     * @param token Token to transfer. 0x0 to transfer Native token.\n     * @param amount Amount to transfer. 0 to transfer all balance.\n     */\n    function transferTokens(address token, uint256 amount) external onlySafe {\n        if (address(token) == address(0)) {\n            // Move ETH\n            amount = amount > 0 ? amount : address(this).balance;\n            payable(address(safeContract)).transfer(amount);\n            return;\n        }\n\n        // Move all balance if amount set to 0\n        amount = amount > 0 ? amount : IERC20(token).balanceOf(address(this));\n\n        // Transfer to Safe contract\n        // slither-disable-next-line unchecked-transfer unused-return\n        IERC20(token).transfer(address(safeContract), amount);\n    }\n\n    receive() external payable {\n        // Accept ETH to pay for bridge fees\n    }\n}\n"
    },
    "contracts/automation/BaseBridgeHelperModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line max-line-length\nimport { AbstractCCIPBridgeHelperModule, AbstractSafeModule, IRouterClient } from \"./AbstractCCIPBridgeHelperModule.sol\";\n\nimport { AccessControlEnumerable } from \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC4626 } from \"../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\nimport { BridgedWOETHStrategy } from \"../strategies/BridgedWOETHStrategy.sol\";\n\ncontract BaseBridgeHelperModule is\n    AccessControlEnumerable,\n    AbstractCCIPBridgeHelperModule\n{\n    IVault public constant vault =\n        IVault(0x98a0CbeF61bD2D21435f433bE4CD42B56B38CC93);\n    IWETH9 public constant weth =\n        IWETH9(0x4200000000000000000000000000000000000006);\n    IERC20 public constant oethb =\n        IERC20(0xDBFeFD2e8460a6Ee4955A68582F85708BAEA60A3);\n    IERC4626 public constant bridgedWOETH =\n        IERC4626(0xD8724322f44E5c58D7A815F542036fb17DbbF839);\n\n    BridgedWOETHStrategy public constant bridgedWOETHStrategy =\n        BridgedWOETHStrategy(0x80c864704DD06C3693ed5179190786EE38ACf835);\n\n    IRouterClient public constant CCIP_ROUTER =\n        IRouterClient(0x881e3A65B4d4a04dD529061dd0071cf975F58bCD);\n\n    uint64 public constant CCIP_ETHEREUM_CHAIN_SELECTOR = 5009297550715157269;\n\n    constructor(address _safeContract) AbstractSafeModule(_safeContract) {}\n\n    /**\n     * @dev Bridges wOETH to Ethereum.\n     * @param woethAmount Amount of wOETH to bridge.\n     */\n    function bridgeWOETHToEthereum(uint256 woethAmount)\n        public\n        payable\n        onlyOperator\n    {\n        _bridgeTokenWithCCIP(\n            CCIP_ROUTER,\n            CCIP_ETHEREUM_CHAIN_SELECTOR,\n            IERC20(address(bridgedWOETH)),\n            woethAmount\n        );\n    }\n\n    /**\n     * @dev Bridges WETH to Ethereum.\n     * @param wethAmount Amount of WETH to bridge.\n     */\n    function bridgeWETHToEthereum(uint256 wethAmount)\n        public\n        payable\n        onlyOperator\n    {\n        _bridgeTokenWithCCIP(\n            CCIP_ROUTER,\n            CCIP_ETHEREUM_CHAIN_SELECTOR,\n            IERC20(address(weth)),\n            wethAmount\n        );\n    }\n\n    /**\n     * @dev Deposits wOETH into the bridgedWOETH strategy.\n     * @param woethAmount Amount of wOETH to deposit.\n     * @param redeemWithVault Whether to redeem the wOETH for WETH using the Vault.\n     * @return Amount of WETH received.\n     */\n    function depositWOETH(uint256 woethAmount, bool redeemWithVault)\n        external\n        onlyOperator\n        returns (uint256)\n    {\n        return _depositWOETH(woethAmount, redeemWithVault);\n    }\n\n    /**\n     * @dev Deposits wOETH into the bridgedWOETH strategy and bridges it to Ethereum.\n     * @param woethAmount Amount of wOETH to deposit.\n     * @return Amount of WETH received.\n     */\n    function depositWOETHAndBridgeWETH(uint256 woethAmount)\n        external\n        onlyOperator\n        returns (uint256)\n    {\n        uint256 wethAmount = _depositWOETH(woethAmount, true);\n        bridgeWETHToEthereum(wethAmount);\n        return wethAmount;\n    }\n\n    /**\n     * @dev Deposits wOETH into the bridgedWOETH strategy.\n     * @param woethAmount Amount of wOETH to deposit.\n     * @param redeemWithVault Whether to redeem the wOETH for WETH using the Vault.\n     * @return Amount of WETH received.\n     */\n    function _depositWOETH(uint256 woethAmount, bool redeemWithVault)\n        internal\n        returns (uint256)\n    {\n        // Update oracle price\n        bridgedWOETHStrategy.updateWOETHOraclePrice();\n\n        // Rebase to account for any yields from price update\n        vault.rebase();\n\n        uint256 oethbAmount = oethb.balanceOf(address(safeContract));\n\n        // Approve bridgedWOETH strategy to move wOETH\n        bool success = safeContract.execTransactionFromModule(\n            address(bridgedWOETH),\n            0, // Value\n            abi.encodeWithSelector(\n                bridgedWOETH.approve.selector,\n                address(bridgedWOETHStrategy),\n                woethAmount\n            ),\n            0 // Call\n        );\n\n        // Deposit to bridgedWOETH strategy\n        success = safeContract.execTransactionFromModule(\n            address(bridgedWOETHStrategy),\n            0, // Value\n            abi.encodeWithSelector(\n                bridgedWOETHStrategy.depositBridgedWOETH.selector,\n                woethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to deposit bridged WOETH\");\n\n        oethbAmount = oethb.balanceOf(address(safeContract)) - oethbAmount;\n\n        // Rebase to account for any yields from price update\n        // and backing asset change from deposit\n        vault.rebase();\n\n        if (!redeemWithVault) {\n            return oethbAmount;\n        }\n\n        // Redeem for WETH using Vault\n        success = safeContract.execTransactionFromModule(\n            address(vault),\n            0, // Value\n            abi.encodeWithSelector(\n                vault.redeem.selector,\n                oethbAmount,\n                oethbAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to redeem OETHb\");\n\n        return oethbAmount;\n    }\n\n    /**\n     * @dev Deposits WETH into the Vault and redeems wOETH from the bridgedWOETH strategy.\n     * @param wethAmount Amount of WETH to deposit.\n     * @return Amount of wOETH received.\n     */\n    function depositWETHAndRedeemWOETH(uint256 wethAmount)\n        external\n        onlyOperator\n        returns (uint256)\n    {\n        return _withdrawWOETH(wethAmount);\n    }\n\n    function depositWETHAndBridgeWOETH(uint256 wethAmount)\n        external\n        onlyOperator\n        returns (uint256)\n    {\n        uint256 woethAmount = _withdrawWOETH(wethAmount);\n        bridgeWOETHToEthereum(woethAmount);\n        return woethAmount;\n    }\n\n    /**\n     * @dev Withdraws wOETH from the bridgedWOETH strategy.\n     * @param wethAmount Amount of WETH to use to withdraw.\n     * @return Amount of wOETH received.\n     */\n    function _withdrawWOETH(uint256 wethAmount) internal returns (uint256) {\n        // Approve Vault to move WETH\n        bool success = safeContract.execTransactionFromModule(\n            address(weth),\n            0, // Value\n            abi.encodeWithSelector(\n                weth.approve.selector,\n                address(vault),\n                wethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to approve WETH\");\n\n        // Mint OETHb with WETH\n        success = safeContract.execTransactionFromModule(\n            address(vault),\n            0, // Value\n            abi.encodeWithSelector(\n                vault.mint.selector,\n                address(weth),\n                wethAmount,\n                wethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to mint OETHb\");\n\n        // Approve bridgedWOETH strategy to move OETHb\n        success = safeContract.execTransactionFromModule(\n            address(oethb),\n            0, // Value\n            abi.encodeWithSelector(\n                oethb.approve.selector,\n                address(bridgedWOETHStrategy),\n                wethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to approve OETHb\");\n\n        uint256 woethAmount = bridgedWOETH.balanceOf(address(safeContract));\n\n        // Withdraw from bridgedWOETH strategy\n        success = safeContract.execTransactionFromModule(\n            address(bridgedWOETHStrategy),\n            0, // Value\n            abi.encodeWithSelector(\n                bridgedWOETHStrategy.withdrawBridgedWOETH.selector,\n                wethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to withdraw bridged WOETH\");\n\n        woethAmount =\n            bridgedWOETH.balanceOf(address(safeContract)) -\n            woethAmount;\n\n        return woethAmount;\n    }\n}\n"
    },
    "contracts/automation/CurvePoolBoosterBribesModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractSafeModule } from \"./AbstractSafeModule.sol\";\n\ninterface ICurvePoolBooster {\n    function manageTotalRewardAmount(\n        uint256 bridgeFee,\n        uint256 additionalGasLimit\n    ) external;\n\n    function manageNumberOfPeriods(\n        uint8 extraNumberOfPeriods,\n        uint256 bridgeFee,\n        uint256 additionalGasLimit\n    ) external;\n\n    function manageRewardPerVote(\n        uint256 newMaxRewardPerVote,\n        uint256 bridgeFee,\n        uint256 additionalGasLimit\n    ) external;\n}\n\ncontract CurvePoolBoosterBribesModule is AbstractSafeModule {\n    address[] public POOLS;\n\n    event PoolBoosterAddressAdded(address pool);\n    event PoolBoosterAddressRemoved(address pool);\n\n    constructor(\n        address _safeContract,\n        address _operator,\n        address[] memory _pools\n    ) AbstractSafeModule(_safeContract) {\n        _grantRole(OPERATOR_ROLE, _operator);\n        _addPoolBoosterAddress(_pools);\n    }\n\n    function addPoolBoosterAddress(address[] memory pools)\n        external\n        onlyOperator\n    {\n        _addPoolBoosterAddress(pools);\n    }\n\n    function _addPoolBoosterAddress(address[] memory pools) internal {\n        for (uint256 i = 0; i < pools.length; i++) {\n            POOLS.push(pools[i]);\n            emit PoolBoosterAddressAdded(pools[i]);\n        }\n    }\n\n    function removePoolBoosterAddress(address[] calldata pools)\n        external\n        onlyOperator\n    {\n        for (uint256 i = 0; i < pools.length; i++) {\n            _removePoolBoosterAddress(pools[i]);\n        }\n    }\n\n    function _removePoolBoosterAddress(address pool) internal {\n        uint256 length = POOLS.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (POOLS[i] == pool) {\n                POOLS[i] = POOLS[length - 1];\n                POOLS.pop();\n                emit PoolBoosterAddressRemoved(pool);\n                break;\n            }\n        }\n    }\n\n    function manageBribes() external onlyOperator {\n        uint256[] memory rewardsPerVote = new uint256[](POOLS.length);\n        _manageBribes(rewardsPerVote);\n    }\n\n    function manageBribes(uint256[] memory rewardsPerVote)\n        external\n        onlyOperator\n    {\n        require(POOLS.length == rewardsPerVote.length, \"Length mismatch\");\n        _manageBribes(rewardsPerVote);\n    }\n\n    function _manageBribes(uint256[] memory rewardsPerVote)\n        internal\n        onlyOperator\n    {\n        uint256 length = POOLS.length;\n        for (uint256 i = 0; i < length; i++) {\n            address poolBoosterAddress = POOLS[i];\n\n            // PoolBooster need to have a balance of at least 0.003 ether to operate\n            // 0.001 ether are used for the bridge fee\n            require(\n                poolBoosterAddress.balance > 0.003 ether,\n                \"Insufficient balance for bribes\"\n            );\n\n            require(\n                safeContract.execTransactionFromModule(\n                    poolBoosterAddress,\n                    0, // Value\n                    abi.encodeWithSelector(\n                        ICurvePoolBooster.manageNumberOfPeriods.selector,\n                        1, // extraNumberOfPeriods\n                        0.001 ether, // bridgeFee\n                        1000000 // additionalGasLimit\n                    ),\n                    0\n                ),\n                \"Manage number of periods failed\"\n            );\n\n            require(\n                safeContract.execTransactionFromModule(\n                    poolBoosterAddress,\n                    0, // Value\n                    abi.encodeWithSelector(\n                        ICurvePoolBooster.manageTotalRewardAmount.selector,\n                        0.001 ether, // bridgeFee\n                        1000000 // additionalGasLimit\n                    ),\n                    0\n                ),\n                \"Manage total reward failed\"\n            );\n\n            // Skip setting reward per vote if it's zero\n            if (rewardsPerVote[i] == 0) continue;\n            require(\n                safeContract.execTransactionFromModule(\n                    poolBoosterAddress,\n                    0, // Value\n                    abi.encodeWithSelector(\n                        ICurvePoolBooster.manageRewardPerVote.selector,\n                        rewardsPerVote[i], // newMaxRewardPerVote\n                        0.001 ether, // bridgeFee\n                        1000000 // additionalGasLimit\n                    ),\n                    0\n                ),\n                \"Set reward per vote failed\"\n            );\n        }\n    }\n\n    function getPools() external view returns (address[] memory) {\n        return POOLS;\n    }\n}\n"
    },
    "contracts/automation/EthereumBridgeHelperModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractLZBridgeHelperModule, AbstractSafeModule } from \"./AbstractLZBridgeHelperModule.sol\";\nimport { AbstractCCIPBridgeHelperModule, IRouterClient } from \"./AbstractCCIPBridgeHelperModule.sol\";\n\nimport { AccessControlEnumerable } from \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\n\nimport { IOFT } from \"@layerzerolabs/oft-evm/contracts/interfaces/IOFT.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC4626 } from \"../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract EthereumBridgeHelperModule is\n    AccessControlEnumerable,\n    AbstractLZBridgeHelperModule,\n    AbstractCCIPBridgeHelperModule\n{\n    IVault public constant vault =\n        IVault(0x39254033945AA2E4809Cc2977E7087BEE48bd7Ab);\n    IWETH9 public constant weth =\n        IWETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20 public constant oeth =\n        IERC20(0x856c4Efb76C1D1AE02e20CEB03A2A6a08b0b8dC3);\n    IERC4626 public constant woeth =\n        IERC4626(0xDcEe70654261AF21C44c093C300eD3Bb97b78192);\n\n    uint32 public constant LZ_PLUME_ENDPOINT_ID = 30370;\n    IOFT public constant LZ_WOETH_OMNICHAIN_ADAPTER =\n        IOFT(0x7d1bEa5807e6af125826d56ff477745BB89972b8);\n    IOFT public constant LZ_ETH_OMNICHAIN_ADAPTER =\n        IOFT(0x77b2043768d28E9C9aB44E1aBfC95944bcE57931);\n\n    IRouterClient public constant CCIP_ROUTER =\n        IRouterClient(0x80226fc0Ee2b096224EeAc085Bb9a8cba1146f7D);\n\n    uint64 public constant CCIP_BASE_CHAIN_SELECTOR = 15971525489660198786;\n\n    constructor(address _safeContract) AbstractSafeModule(_safeContract) {}\n\n    /**\n     * @dev Bridges wOETH to Plume.\n     * @param woethAmount Amount of wOETH to bridge.\n     * @param slippageBps Slippage in 10^4 basis points.\n     */\n    function bridgeWOETHToPlume(uint256 woethAmount, uint256 slippageBps)\n        public\n        payable\n        onlyOperator\n    {\n        _bridgeTokenWithLz(\n            LZ_PLUME_ENDPOINT_ID,\n            woeth,\n            LZ_WOETH_OMNICHAIN_ADAPTER,\n            woethAmount,\n            slippageBps,\n            false\n        );\n    }\n\n    /**\n     * @dev Bridges wOETH to Base using CCIP.\n     * @param woethAmount Amount of wOETH to bridge.\n     */\n    function bridgeWOETHToBase(uint256 woethAmount)\n        public\n        payable\n        onlyOperator\n    {\n        _bridgeTokenWithCCIP(\n            CCIP_ROUTER,\n            CCIP_BASE_CHAIN_SELECTOR,\n            woeth,\n            woethAmount\n        );\n    }\n\n    /**\n     * @dev Bridges wETH to Plume.\n     * @param wethAmount Amount of wETH to bridge.\n     * @param slippageBps Slippage in 10^4 basis points.\n     */\n    function bridgeWETHToPlume(uint256 wethAmount, uint256 slippageBps)\n        public\n        payable\n        onlyOperator\n    {\n        // Unwrap into ETH\n        safeContract.execTransactionFromModule(\n            address(weth),\n            0, // Value\n            abi.encodeWithSelector(weth.withdraw.selector, wethAmount),\n            0 // Call\n        );\n\n        _bridgeTokenWithLz(\n            LZ_PLUME_ENDPOINT_ID,\n            IERC20(address(weth)),\n            LZ_ETH_OMNICHAIN_ADAPTER,\n            wethAmount,\n            slippageBps,\n            true\n        );\n    }\n\n    /**\n     * @dev Bridges wETH to Base using CCIP.\n     * @param wethAmount Amount of wETH to bridge.\n     */\n    function bridgeWETHToBase(uint256 wethAmount) public payable onlyOperator {\n        _bridgeTokenWithCCIP(\n            CCIP_ROUTER,\n            CCIP_BASE_CHAIN_SELECTOR,\n            IERC20(address(weth)),\n            wethAmount\n        );\n    }\n\n    /**\n     * @dev Mints OETH and wraps it into wOETH.\n     * @param wethAmount Amount of WETH to mint.\n     * @param useNativeToken Whether to use native token to mint.\n     * @return Amount of wOETH minted.\n     */\n    function mintAndWrap(uint256 wethAmount, bool useNativeToken)\n        external\n        onlyOperator\n        returns (uint256)\n    {\n        if (useNativeToken) {\n            wrapETH(wethAmount);\n        }\n\n        return _mintAndWrap(wethAmount);\n    }\n\n    function wrapETH(uint256 ethAmount) public payable onlyOperator {\n        // Deposit ETH into WETH\n        safeContract.execTransactionFromModule(\n            address(weth),\n            ethAmount, // Value\n            abi.encodeWithSelector(weth.deposit.selector),\n            0 // Call\n        );\n    }\n\n    /**\n     * @dev Mints OETH and wraps it into wOETH.\n     * @param wethAmount Amount of WETH to mint.\n     * @return Amount of wOETH minted.\n     */\n    function _mintAndWrap(uint256 wethAmount) internal returns (uint256) {\n        // Approve Vault to move WETH\n        bool success = safeContract.execTransactionFromModule(\n            address(weth),\n            0, // Value\n            abi.encodeWithSelector(\n                weth.approve.selector,\n                address(vault),\n                wethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to approve WETH\");\n\n        // Mint OETH\n        success = safeContract.execTransactionFromModule(\n            address(vault),\n            0, // Value\n            abi.encodeWithSelector(\n                vault.mint.selector,\n                address(weth),\n                wethAmount,\n                wethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to mint OETH\");\n\n        // Approve wOETH to move OETH\n        success = safeContract.execTransactionFromModule(\n            address(oeth),\n            0, // Value\n            abi.encodeWithSelector(\n                oeth.approve.selector,\n                address(woeth),\n                wethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to approve OETH\");\n\n        uint256 woethAmount = woeth.balanceOf(address(safeContract));\n\n        // Wrap OETH into wOETH\n        success = safeContract.execTransactionFromModule(\n            address(woeth),\n            0, // Value\n            abi.encodeWithSelector(\n                woeth.deposit.selector,\n                wethAmount,\n                address(safeContract)\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to wrap OETH\");\n\n        // Compute amount of wOETH minted\n        return woeth.balanceOf(address(safeContract)) - woethAmount;\n    }\n\n    /**\n     * @dev Mints OETH and wraps it into wOETH, then bridges it to Plume.\n     * @param wethAmount Amount of WETH to mint.\n     * @param slippageBps Bridge slippage in 10^4 basis points.\n     * @param useNativeToken Whether to use native token to mint.\n     */\n    function mintWrapAndBridgeToPlume(\n        uint256 wethAmount,\n        uint256 slippageBps,\n        bool useNativeToken\n    ) external payable onlyOperator {\n        if (useNativeToken) {\n            wrapETH(wethAmount);\n        }\n\n        uint256 woethAmount = _mintAndWrap(wethAmount);\n        bridgeWOETHToPlume(woethAmount, slippageBps);\n    }\n\n    /**\n     * @dev Mints OETH and wraps it into wOETH, then bridges it to Base using CCIP.\n     * @param wethAmount Amount of WETH to mint.\n     * @param useNativeToken Whether to use native token to mint.\n     */\n    function mintWrapAndBridgeToBase(uint256 wethAmount, bool useNativeToken)\n        external\n        payable\n        onlyOperator\n    {\n        if (useNativeToken) {\n            wrapETH(wethAmount);\n        }\n\n        uint256 woethAmount = _mintAndWrap(wethAmount);\n        bridgeWOETHToBase(woethAmount);\n    }\n\n    /**\n     * @dev Unwraps wOETH and redeems it to get WETH.\n     * @param woethAmount Amount of wOETH to unwrap.\n     * @return Amount of WETH received.\n     */\n    function unwrapAndRedeem(uint256 woethAmount)\n        external\n        onlyOperator\n        returns (uint256)\n    {\n        return _unwrapAndRedeem(woethAmount);\n    }\n\n    /**\n     * @dev Unwraps wOETH and redeems it to get WETH.\n     * @param woethAmount Amount of wOETH to unwrap.\n     * @return Amount of WETH received.\n     */\n    function _unwrapAndRedeem(uint256 woethAmount) internal returns (uint256) {\n        uint256 oethAmount = oeth.balanceOf(address(safeContract));\n\n        // Unwrap wOETH\n        bool success = safeContract.execTransactionFromModule(\n            address(woeth),\n            0, // Value\n            abi.encodeWithSelector(\n                woeth.redeem.selector,\n                woethAmount,\n                address(safeContract),\n                address(safeContract)\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to unwrap wOETH\");\n\n        oethAmount = oeth.balanceOf(address(safeContract)) - oethAmount;\n\n        // Redeem OETH using Vault to get WETH\n        success = safeContract.execTransactionFromModule(\n            address(vault),\n            0, // Value\n            abi.encodeWithSelector(\n                vault.redeem.selector,\n                oethAmount,\n                oethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to redeem OETH\");\n\n        return oethAmount;\n    }\n\n    /**\n     * @dev Unwraps wOETH and redeems it to get WETH, then bridges it to Plume.\n     * @param woethAmount Amount of wOETH to unwrap.\n     * @param slippageBps Bridge slippage in 10^4 basis points.\n     */\n    function unwrapRedeemAndBridgeToPlume(\n        uint256 woethAmount,\n        uint256 slippageBps\n    ) external payable onlyOperator {\n        uint256 wethAmount = _unwrapAndRedeem(woethAmount);\n        // Unwrap into ETH\n        safeContract.execTransactionFromModule(\n            address(weth),\n            0, // Value\n            abi.encodeWithSelector(weth.withdraw.selector, wethAmount),\n            0 // Call\n        );\n\n        bridgeWETHToPlume(wethAmount, slippageBps);\n    }\n\n    /**\n     * @dev Unwraps wOETH and redeems it to get WETH, then bridges it to Base using CCIP.\n     * @param woethAmount Amount of wOETH to unwrap.\n     */\n    function unwrapRedeemAndBridgeToBase(uint256 woethAmount)\n        external\n        payable\n        onlyOperator\n    {\n        uint256 wethAmount = _unwrapAndRedeem(woethAmount);\n        bridgeWETHToBase(wethAmount);\n    }\n}\n"
    },
    "contracts/automation/PlumeBridgeHelperModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractSafeModule } from \"./AbstractSafeModule.sol\";\nimport { AbstractLZBridgeHelperModule } from \"./AbstractLZBridgeHelperModule.sol\";\n\nimport { AccessControlEnumerable } from \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\n\nimport { IOFT } from \"@layerzerolabs/oft-evm/contracts/interfaces/IOFT.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC4626 } from \"../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\nimport { BridgedWOETHStrategy } from \"../strategies/BridgedWOETHStrategy.sol\";\n\ncontract PlumeBridgeHelperModule is\n    AccessControlEnumerable,\n    AbstractLZBridgeHelperModule\n{\n    IVault public constant vault =\n        IVault(0xc8c8F8bEA5631A8AF26440AF32a55002138cB76a);\n    IWETH9 public constant weth =\n        IWETH9(0xca59cA09E5602fAe8B629DeE83FfA819741f14be);\n    IERC20 public constant oethp =\n        IERC20(0xFCbe50DbE43bF7E5C88C6F6Fb9ef432D4165406E);\n    IERC4626 public constant bridgedWOETH =\n        IERC4626(0xD8724322f44E5c58D7A815F542036fb17DbbF839);\n\n    uint32 public constant LZ_ETHEREUM_ENDPOINT_ID = 30101;\n    IOFT public constant LZ_WOETH_OMNICHAIN_ADAPTER =\n        IOFT(0x592CB6A596E7919930bF49a27AdAeCA7C055e4DB);\n    IOFT public constant LZ_ETH_OMNICHAIN_ADAPTER =\n        IOFT(0x4683CE822272CD66CEa73F5F1f9f5cBcaEF4F066);\n\n    BridgedWOETHStrategy public constant bridgedWOETHStrategy =\n        BridgedWOETHStrategy(0x1E3EdD5e019207D6355Ea77F724b1F1BF639B569);\n\n    constructor(address _safeContract) AbstractSafeModule(_safeContract) {}\n\n    /**\n     * @dev Bridges wOETH to Ethereum.\n     * @param woethAmount Amount of wOETH to bridge.\n     * @param slippageBps Slippage in 10^4 basis points.\n     */\n    function bridgeWOETHToEthereum(uint256 woethAmount, uint256 slippageBps)\n        public\n        payable\n        onlyOperator\n    {\n        _bridgeTokenWithLz(\n            LZ_ETHEREUM_ENDPOINT_ID,\n            IERC20(address(bridgedWOETH)),\n            LZ_WOETH_OMNICHAIN_ADAPTER,\n            woethAmount,\n            slippageBps,\n            false\n        );\n    }\n\n    /**\n     * @dev Bridges wETH to Ethereum.\n     * @param wethAmount Amount of wETH to bridge.\n     * @param slippageBps Slippage in 10^4 basis points.\n     */\n    function bridgeWETHToEthereum(uint256 wethAmount, uint256 slippageBps)\n        public\n        payable\n        onlyOperator\n    {\n        _bridgeTokenWithLz(\n            LZ_ETHEREUM_ENDPOINT_ID,\n            IERC20(address(weth)),\n            LZ_ETH_OMNICHAIN_ADAPTER,\n            wethAmount,\n            slippageBps,\n            false\n        );\n    }\n\n    /**\n     * @dev Deposits wOETH into the bridgedWOETH strategy.\n     * @param woethAmount Amount of wOETH to deposit.\n     * @param redeemWithVault Whether to redeem with Vault.\n     * @return Amount of OETHp received.\n     */\n    function depositWOETH(uint256 woethAmount, bool redeemWithVault)\n        external\n        onlyOperator\n        returns (uint256)\n    {\n        return _depositWOETH(woethAmount, redeemWithVault);\n    }\n\n    /**\n     * @dev Deposits wOETH into the bridgedWOETH strategy and bridges it to Ethereum.\n     * @param woethAmount Amount of wOETH to deposit.\n     * @param slippageBps Slippage in 10^4 basis points.\n     * @return Amount of WETH received.\n     */\n    function depositWOETHAndBridgeWETH(uint256 woethAmount, uint256 slippageBps)\n        external\n        payable\n        onlyOperator\n        returns (uint256)\n    {\n        uint256 wethAmount = _depositWOETH(woethAmount, true);\n        bridgeWETHToEthereum(wethAmount, slippageBps);\n        return wethAmount;\n    }\n\n    /**\n     * @dev Deposits wOETH into the bridgedWOETH strategy.\n     * @param woethAmount Amount of wOETH to deposit.\n     * @param redeemWithVault Whether to redeem with Vault.\n     * @return Amount of OETHp received.\n     */\n    function _depositWOETH(uint256 woethAmount, bool redeemWithVault)\n        internal\n        returns (uint256)\n    {\n        // Update oracle price\n        bridgedWOETHStrategy.updateWOETHOraclePrice();\n\n        // Rebase to account for any yields from price update\n        vault.rebase();\n\n        uint256 oethpAmount = oethp.balanceOf(address(safeContract));\n\n        // Approve bridgedWOETH strategy to move wOETH\n        bool success = safeContract.execTransactionFromModule(\n            address(bridgedWOETH),\n            0, // Value\n            abi.encodeWithSelector(\n                bridgedWOETH.approve.selector,\n                address(bridgedWOETHStrategy),\n                woethAmount\n            ),\n            0 // Call\n        );\n\n        // Deposit to bridgedWOETH strategy\n        success = safeContract.execTransactionFromModule(\n            address(bridgedWOETHStrategy),\n            0, // Value\n            abi.encodeWithSelector(\n                bridgedWOETHStrategy.depositBridgedWOETH.selector,\n                woethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to deposit bridged WOETH\");\n\n        oethpAmount = oethp.balanceOf(address(safeContract)) - oethpAmount;\n\n        // Rebase to account for any yields from price update\n        // and backing asset change from deposit\n        vault.rebase();\n\n        if (!redeemWithVault) {\n            return oethpAmount;\n        }\n\n        // Redeem for WETH using Vault\n        success = safeContract.execTransactionFromModule(\n            address(vault),\n            0, // Value\n            abi.encodeWithSelector(\n                vault.redeem.selector,\n                oethpAmount,\n                oethpAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to redeem OETHp\");\n\n        return oethpAmount;\n    }\n\n    /**\n     * @dev Deposits wETH into the vault.\n     * @param wethAmount Amount of wETH to deposit.\n     * @return Amount of OETHp received.\n     */\n    function depositWETHAndRedeemWOETH(uint256 wethAmount)\n        external\n        onlyOperator\n        returns (uint256)\n    {\n        return _withdrawWOETH(wethAmount);\n    }\n\n    /**\n     * @dev Deposits wETH into the vault and bridges it to Ethereum.\n     * @param wethAmount Amount of wETH to deposit.\n     * @param slippageBps Slippage in 10^4 basis points.\n     * @return Amount of WOETH received.\n     */\n    function depositWETHAndBridgeWOETH(uint256 wethAmount, uint256 slippageBps)\n        external\n        payable\n        onlyOperator\n        returns (uint256)\n    {\n        uint256 woethAmount = _withdrawWOETH(wethAmount);\n        bridgeWOETHToEthereum(woethAmount, slippageBps);\n        return woethAmount;\n    }\n\n    /**\n     * @dev Withdraws wOETH from the bridgedWOETH strategy.\n     * @param wethAmount Amount of WETH to use to withdraw.\n     * @return Amount of wOETH received.\n     */\n    function _withdrawWOETH(uint256 wethAmount) internal returns (uint256) {\n        // Approve Vault to move WETH\n        bool success = safeContract.execTransactionFromModule(\n            address(weth),\n            0, // Value\n            abi.encodeWithSelector(\n                weth.approve.selector,\n                address(vault),\n                wethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to approve WETH\");\n\n        // Mint OETHp with WETH\n        success = safeContract.execTransactionFromModule(\n            address(vault),\n            0, // Value\n            abi.encodeWithSelector(\n                vault.mint.selector,\n                address(weth),\n                wethAmount,\n                wethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to mint OETHp\");\n\n        // Approve bridgedWOETH strategy to move OETHp\n        success = safeContract.execTransactionFromModule(\n            address(oethp),\n            0, // Value\n            abi.encodeWithSelector(\n                oethp.approve.selector,\n                address(bridgedWOETHStrategy),\n                wethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to approve OETHp\");\n\n        uint256 woethAmount = bridgedWOETH.balanceOf(address(safeContract));\n\n        // Withdraw from bridgedWOETH strategy\n        success = safeContract.execTransactionFromModule(\n            address(bridgedWOETHStrategy),\n            0, // Value\n            abi.encodeWithSelector(\n                bridgedWOETHStrategy.withdrawBridgedWOETH.selector,\n                wethAmount\n            ),\n            0 // Call\n        );\n        require(success, \"Failed to withdraw bridged WOETH\");\n\n        woethAmount =\n            bridgedWOETH.balanceOf(address(safeContract)) -\n            woethAmount;\n\n        return woethAmount;\n    }\n}\n"
    },
    "contracts/beacon/BeaconRoots.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Library to retrieve beacon block roots.\n * @author Origin Protocol Inc\n */\nlibrary BeaconRoots {\n    /// @notice The address of beacon block roots oracle\n    /// See https://eips.ethereum.org/EIPS/eip-4788\n    address internal constant BEACON_ROOTS_ADDRESS =\n        0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02;\n\n    /// @notice Returns the beacon block root for the previous block.\n    /// This comes from the Beacon Roots contract defined in EIP-4788.\n    /// This will revert if the block is more than 8,191 blocks old as\n    /// that is the size of the beacon root's ring buffer.\n    /// @param timestamp The timestamp of the block for which to get the parent root.\n    /// @return parentRoot The parent block root for the given timestamp.\n    function parentBlockRoot(uint64 timestamp)\n        internal\n        view\n        returns (bytes32 parentRoot)\n    {\n        // Call the Beacon Roots contract to get the parent block root.\n        // This does not have a function signature, so we use a staticcall.\n        (bool success, bytes memory result) = BEACON_ROOTS_ADDRESS.staticcall(\n            abi.encode(timestamp)\n        );\n\n        require(success && result.length > 0, \"Invalid beacon timestamp\");\n        parentRoot = abi.decode(result, (bytes32));\n    }\n}\n"
    },
    "contracts/beacon/PartialWithdrawal.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Library to request full or partial withdrawals from validators on the beacon chain.\n * @author Origin Protocol Inc\n */\nlibrary PartialWithdrawal {\n    /// @notice The address where the withdrawal request is sent to\n    /// See https://eips.ethereum.org/EIPS/eip-7002\n    address internal constant WITHDRAWAL_REQUEST_ADDRESS =\n        0x00000961Ef480Eb55e80D19ad83579A64c007002;\n\n    /// @notice Requests a partial withdrawal for a given validator public key and amount.\n    /// @param validatorPubKey The public key of the validator to withdraw from\n    /// @param amount The amount of ETH to withdraw\n    function request(bytes calldata validatorPubKey, uint64 amount)\n        internal\n        returns (uint256 fee_)\n    {\n        require(validatorPubKey.length == 48, \"Invalid validator byte length\");\n        fee_ = fee();\n\n        // Call the Withdrawal Request contract with the validator public key\n        // and amount to be withdrawn packed together\n\n        // This is a general purpose EL to CL request:\n        // https://eips.ethereum.org/EIPS/eip-7685\n        (bool success, ) = WITHDRAWAL_REQUEST_ADDRESS.call{ value: fee_ }(\n            abi.encodePacked(validatorPubKey, amount)\n        );\n\n        require(success, \"Withdrawal request failed\");\n    }\n\n    /// @notice Gets fee for withdrawal requests contract on Beacon chain\n    function fee() internal view returns (uint256) {\n        // Get fee from the withdrawal request contract\n        (bool success, bytes memory result) = WITHDRAWAL_REQUEST_ADDRESS\n            .staticcall(\"\");\n\n        require(success && result.length > 0, \"Failed to get fee\");\n        return abi.decode(result, (uint256));\n    }\n}\n"
    },
    "contracts/buyback/AbstractBuyback.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Strategizable } from \"../governance/Strategizable.sol\";\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ICVXLocker } from \"../interfaces/ICVXLocker.sol\";\nimport { ISwapper } from \"../interfaces/ISwapper.sol\";\n\nimport { Initializable } from \"../utils/Initializable.sol\";\n\nabstract contract AbstractBuyback is Initializable, Strategizable {\n    using SafeERC20 for IERC20;\n\n    event SwapRouterUpdated(address indexed _address);\n\n    event RewardsSourceUpdated(address indexed _address);\n    event TreasuryManagerUpdated(address indexed _address);\n    event CVXShareBpsUpdated(uint256 bps);\n\n    // Emitted whenever OUSD/OETH is swapped for OGN/CVX or any other token\n    event OTokenBuyback(\n        address indexed oToken,\n        address indexed swappedFor,\n        uint256 swapAmountIn,\n        uint256 amountOut\n    );\n\n    // Address of 1-inch Swap Router\n    address public swapRouter;\n\n    // slither-disable-next-line constable-states\n    address private __deprecated_ousd;\n    // slither-disable-next-line constable-states\n    address private __deprecated_ogv;\n    // slither-disable-next-line constable-states\n    address private __deprecated_usdt;\n    // slither-disable-next-line constable-states\n    address private __deprecated_weth9;\n\n    // Address that receives OGN after swaps\n    address public rewardsSource;\n\n    // Address that receives all other tokens after swaps\n    address public treasuryManager;\n\n    // slither-disable-next-line constable-states\n    uint256 private __deprecated_treasuryBps;\n\n    address public immutable oToken;\n    address public immutable ogn;\n    address public immutable cvx;\n    address public immutable cvxLocker;\n\n    // Amount of `oToken` balance to use for OGN buyback\n    uint256 public balanceForOGN;\n\n    // Amount of `oToken` balance to use for CVX buyback\n    uint256 public balanceForCVX;\n\n    // Percentage of `oToken` balance to be used for CVX\n    uint256 public cvxShareBps; // 10000 = 100%\n\n    constructor(\n        address _oToken,\n        address _ogn,\n        address _cvx,\n        address _cvxLocker\n    ) {\n        // Make sure nobody owns the implementation contract\n        _setGovernor(address(0));\n\n        oToken = _oToken;\n        ogn = _ogn;\n        cvx = _cvx;\n        cvxLocker = _cvxLocker;\n    }\n\n    /**\n     * @param _swapRouter Address of Uniswap V3 Router\n     * @param _strategistAddr Address of Strategist multi-sig wallet\n     * @param _treasuryManagerAddr Address that receives the treasury's share of OUSD\n     * @param _rewardsSource Address of RewardsSource contract\n     * @param _cvxShareBps Percentage of balance to use for CVX\n     */\n    function initialize(\n        address _swapRouter,\n        address _strategistAddr,\n        address _treasuryManagerAddr,\n        address _rewardsSource,\n        uint256 _cvxShareBps\n    ) external onlyGovernor initializer {\n        _setStrategistAddr(_strategistAddr);\n\n        _setSwapRouter(_swapRouter);\n        _setRewardsSource(_rewardsSource);\n\n        _setTreasuryManager(_treasuryManagerAddr);\n\n        _setCVXShareBps(_cvxShareBps);\n    }\n\n    /**\n     * @dev Set address of Uniswap Universal Router for performing liquidation\n     * of platform fee tokens. Setting to 0x0 will pause swaps.\n     *\n     * @param _router Address of the Uniswap Universal router\n     */\n    function setSwapRouter(address _router) external onlyGovernor {\n        _setSwapRouter(_router);\n    }\n\n    function _setSwapRouter(address _router) internal {\n        address oldRouter = swapRouter;\n        swapRouter = _router;\n\n        if (oldRouter != address(0)) {\n            // Remove allowance of old router, if any\n\n            if (IERC20(ogn).allowance(address(this), oldRouter) != 0) {\n                // slither-disable-next-line unused-return\n                IERC20(ogn).safeApprove(oldRouter, 0);\n            }\n\n            if (IERC20(cvx).allowance(address(this), oldRouter) != 0) {\n                // slither-disable-next-line unused-return\n                IERC20(cvx).safeApprove(oldRouter, 0);\n            }\n        }\n\n        emit SwapRouterUpdated(_router);\n    }\n\n    /**\n     * @dev Sets the address that receives the OGN buyback rewards\n     * @param _address Address\n     */\n    function setRewardsSource(address _address) external onlyGovernor {\n        _setRewardsSource(_address);\n    }\n\n    function _setRewardsSource(address _address) internal {\n        require(_address != address(0), \"Address not set\");\n        rewardsSource = _address;\n        emit RewardsSourceUpdated(_address);\n    }\n\n    /**\n     * @dev Sets the address that can receive and manage the funds for Treasury\n     * @param _address Address\n     */\n    function setTreasuryManager(address _address) external onlyGovernor {\n        _setTreasuryManager(_address);\n    }\n\n    function _setTreasuryManager(address _address) internal {\n        require(_address != address(0), \"Address not set\");\n        treasuryManager = _address;\n        emit TreasuryManagerUpdated(_address);\n    }\n\n    /**\n     * @dev Sets the percentage of oToken to use for Flywheel tokens\n     * @param _bps BPS, 10000 to 100%\n     */\n    function setCVXShareBps(uint256 _bps) external onlyGovernor {\n        _setCVXShareBps(_bps);\n    }\n\n    function _setCVXShareBps(uint256 _bps) internal {\n        require(_bps <= 10000, \"Invalid bps value\");\n        cvxShareBps = _bps;\n        emit CVXShareBpsUpdated(_bps);\n    }\n\n    /**\n     * @dev Computes the split of oToken balance that can be\n     *      used for OGN and CVX buybacks.\n     */\n    function _updateBuybackSplits()\n        internal\n        returns (uint256 _balanceForOGN, uint256 _balanceForCVX)\n    {\n        _balanceForOGN = balanceForOGN;\n        _balanceForCVX = balanceForCVX;\n\n        uint256 totalBalance = IERC20(oToken).balanceOf(address(this));\n        uint256 unsplitBalance = totalBalance - _balanceForOGN - _balanceForCVX;\n\n        // Check if all balance is accounted for\n        if (unsplitBalance != 0) {\n            // If not, split unaccounted balance based on `cvxShareBps`\n            uint256 addToCVX = (unsplitBalance * cvxShareBps) / 10000;\n            _balanceForCVX = _balanceForCVX + addToCVX;\n            _balanceForOGN = _balanceForOGN + unsplitBalance - addToCVX;\n\n            // Update storage\n            balanceForOGN = _balanceForOGN;\n            balanceForCVX = _balanceForCVX;\n        }\n    }\n\n    function updateBuybackSplits() external onlyGovernor {\n        // slither-disable-next-line unused-return\n        _updateBuybackSplits();\n    }\n\n    function _swapToken(\n        address tokenOut,\n        uint256 oTokenAmount,\n        uint256 minAmountOut,\n        bytes calldata swapData\n    ) internal returns (uint256 amountOut) {\n        require(oTokenAmount > 0, \"Invalid Swap Amount\");\n        require(swapRouter != address(0), \"Swap Router not set\");\n        require(minAmountOut > 0, \"Invalid minAmount\");\n\n        // Transfer OToken to Swapper for swapping\n        // slither-disable-next-line unchecked-transfer unused-return\n        IERC20(oToken).transfer(swapRouter, oTokenAmount);\n\n        // Swap\n        amountOut = ISwapper(swapRouter).swap(\n            oToken,\n            tokenOut,\n            oTokenAmount,\n            minAmountOut,\n            swapData\n        );\n\n        require(amountOut >= minAmountOut, \"Higher Slippage\");\n\n        emit OTokenBuyback(oToken, tokenOut, oTokenAmount, amountOut);\n    }\n\n    /**\n     * @dev Swaps `oTokenAmount` to OGN\n     * @param oTokenAmount Amount of OUSD/OETH to swap\n     * @param minOGN Minimum OGN to receive for oTokenAmount\n     * @param swapData 1inch Swap Data\n     */\n    function swapForOGN(\n        uint256 oTokenAmount,\n        uint256 minOGN,\n        bytes calldata swapData\n    ) external onlyGovernorOrStrategist nonReentrant {\n        (uint256 _amountForOGN, ) = _updateBuybackSplits();\n        require(_amountForOGN >= oTokenAmount, \"Balance underflow\");\n        require(rewardsSource != address(0), \"RewardsSource contract not set\");\n\n        unchecked {\n            // Subtract the amount to swap from net balance\n            balanceForOGN = _amountForOGN - oTokenAmount;\n        }\n\n        uint256 ognReceived = _swapToken(ogn, oTokenAmount, minOGN, swapData);\n\n        // Transfer OGN received to RewardsSource contract\n        // slither-disable-next-line unchecked-transfer unused-return\n        IERC20(ogn).transfer(rewardsSource, ognReceived);\n    }\n\n    /**\n     * @dev Swaps `oTokenAmount` to CVX\n     * @param oTokenAmount Amount of OUSD/OETH to swap\n     * @param minCVX Minimum CVX to receive for oTokenAmount\n     * @param swapData 1inch Swap Data\n     */\n    function swapForCVX(\n        uint256 oTokenAmount,\n        uint256 minCVX,\n        bytes calldata swapData\n    ) external onlyGovernorOrStrategist nonReentrant {\n        (, uint256 _amountForCVX) = _updateBuybackSplits();\n        require(_amountForCVX >= oTokenAmount, \"Balance underflow\");\n\n        unchecked {\n            // Subtract the amount to swap from net balance\n            balanceForCVX = _amountForCVX - oTokenAmount;\n        }\n\n        uint256 cvxReceived = _swapToken(cvx, oTokenAmount, minCVX, swapData);\n\n        // Lock all CVX\n        _lockAllCVX(cvxReceived);\n    }\n\n    /**\n     * @dev Locks all CVX held by the contract on behalf of the Treasury Manager\n     */\n    function lockAllCVX() external onlyGovernorOrStrategist {\n        _lockAllCVX(IERC20(cvx).balanceOf(address(this)));\n    }\n\n    function _lockAllCVX(uint256 cvxAmount) internal {\n        require(\n            treasuryManager != address(0),\n            \"Treasury manager address not set\"\n        );\n\n        // Lock all available CVX on behalf of `treasuryManager`\n        ICVXLocker(cvxLocker).lock(treasuryManager, cvxAmount, 0);\n    }\n\n    /**\n     * @dev Approve CVX Locker to move CVX held by this contract\n     */\n    function safeApproveAllTokens() external onlyGovernorOrStrategist {\n        IERC20(cvx).safeApprove(cvxLocker, type(uint256).max);\n    }\n\n    /**\n     * @notice Owner function to withdraw a specific amount of a token\n     * @param token token to be transferered\n     * @param amount amount of the token to be transferred\n     */\n    function transferToken(address token, uint256 amount)\n        external\n        onlyGovernor\n        nonReentrant\n    {\n        IERC20(token).safeTransfer(_governor(), amount);\n    }\n}\n"
    },
    "contracts/buyback/ARMBuyback.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractBuyback } from \"./AbstractBuyback.sol\";\n\ncontract ARMBuyback is AbstractBuyback {\n    constructor(\n        address _oToken,\n        address _ogn,\n        address _cvx,\n        address _cvxLocker\n    ) AbstractBuyback(_oToken, _ogn, _cvx, _cvxLocker) {}\n}\n"
    },
    "contracts/buyback/OETHBuyback.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractBuyback } from \"./AbstractBuyback.sol\";\n\ncontract OETHBuyback is AbstractBuyback {\n    constructor(\n        address _oToken,\n        address _ogn,\n        address _cvx,\n        address _cvxLocker\n    ) AbstractBuyback(_oToken, _ogn, _cvx, _cvxLocker) {}\n}\n"
    },
    "contracts/buyback/OUSDBuyback.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractBuyback } from \"./AbstractBuyback.sol\";\n\ncontract OUSDBuyback is AbstractBuyback {\n    constructor(\n        address _oToken,\n        address _ogn,\n        address _cvx,\n        address _cvxLocker\n    ) AbstractBuyback(_oToken, _ogn, _cvx, _cvxLocker) {}\n}\n"
    },
    "contracts/echidna/Debugger.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary Debugger {\n    event Debug(string debugString);\n    event Debug(string description, string data);\n    event Debug(string prefix, string description, string data);\n    event Debug(string description, bytes32 data);\n    event Debug(string prefix, string description, bytes32 data);\n    event Debug(string description, uint256 data);\n    event Debug(string prefix, string description, uint256 data);\n    event Debug(string description, int256 data);\n    event Debug(string prefix, string description, int256 data);\n    event Debug(string description, address data);\n    event Debug(string prefix, string description, address data);\n    event Debug(string description, bool data);\n    event Debug(string prefix, string description, bool data);\n\n    function log(string memory debugString) internal {\n        emit Debug(debugString);\n    }\n\n    function log(string memory description, string memory data) internal {\n        emit Debug(description, data);\n    }\n\n    function log(\n        string memory prefix,\n        string memory description,\n        string memory data\n    ) internal {\n        emit Debug(prefix, description, data);\n    }\n\n    function log(string memory description, bytes32 data) internal {\n        emit Debug(description, data);\n    }\n\n    function log(\n        string memory prefix,\n        string memory description,\n        bytes32 data\n    ) internal {\n        emit Debug(prefix, description, data);\n    }\n\n    function log(string memory description, uint256 data) internal {\n        emit Debug(description, data);\n    }\n\n    function log(\n        string memory prefix,\n        string memory description,\n        uint256 data\n    ) internal {\n        emit Debug(prefix, description, data);\n    }\n\n    function log(string memory description, int256 data) internal {\n        emit Debug(description, data);\n    }\n\n    function log(\n        string memory prefix,\n        string memory description,\n        int256 data\n    ) internal {\n        emit Debug(prefix, description, data);\n    }\n\n    function log(string memory description, address data) internal {\n        emit Debug(description, data);\n    }\n\n    function log(\n        string memory prefix,\n        string memory description,\n        address data\n    ) internal {\n        emit Debug(prefix, description, data);\n    }\n\n    function log(string memory description, bool data) internal {\n        emit Debug(description, data);\n    }\n\n    function log(\n        string memory prefix,\n        string memory description,\n        bool data\n    ) internal {\n        emit Debug(prefix, description, data);\n    }\n}\n"
    },
    "contracts/echidna/Echidna.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./EchidnaTestApproval.sol\";\n\n/**\n * @title Echidna test contract for OUSD\n * @notice Target contract to be tested, containing all mixins\n * @author Rappie\n */\ncontract Echidna is EchidnaTestApproval {\n\n}\n"
    },
    "contracts/echidna/EchidnaConfig.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Top-level mixin for configuring the desired fuzzing setup\n * @author Rappie\n */\ncontract EchidnaConfig {\n    address internal constant ADDRESS_VAULT = address(0x10000);\n    address internal constant ADDRESS_OUTSIDER_USER = address(0x20000);\n\n    address internal constant ADDRESS_USER0 = address(0x30000);\n    address internal constant ADDRESS_USER1 = address(0x40000);\n\n    // Will be set in EchidnaSetup constructor\n    address internal ADDRESS_OUTSIDER_CONTRACT;\n    address internal ADDRESS_CONTRACT0;\n    address internal ADDRESS_CONTRACT1;\n\n    // Toggle known issues\n    //\n    // This can be used to skip tests that are known to fail. This is useful\n    // when debugging a specific issue, but should be disabled when running\n    // the full test suite.\n    //\n    //   True => skip tests that are known to fail\n    //   False => run all tests\n    //\n    bool internal constant TOGGLE_KNOWN_ISSUES = false;\n\n    // Toggle known issues within limits\n    //\n    // Same as TOGGLE_KNOWN_ISSUES, but also skip tests that are known to fail\n    // within limits set by the variables below.\n    //\n    bool internal constant TOGGLE_KNOWN_ISSUES_WITHIN_LIMITS = true;\n\n    // Starting balance\n    //\n    // Gives OUSD a non-zero starting supply, which can be useful to ignore\n    // certain edge cases.\n    //\n    // The starting balance is given to outsider accounts that are not used as\n    // accounts while fuzzing.\n    //\n    bool internal constant TOGGLE_STARTING_BALANCE = true;\n    uint256 internal constant STARTING_BALANCE = 1_000_000e18;\n\n    // Change supply\n    //\n    // Set a limit to the amount of change per rebase, which can be useful to\n    // ignore certain edge cases.\n    //\n    //  True => limit the amount of change to a percentage of total supply\n    //  False => no limit\n    //\n    bool internal constant TOGGLE_CHANGESUPPLY_LIMIT = true;\n    uint256 internal constant CHANGESUPPLY_DIVISOR = 10; // 10% of total supply\n\n    // Mint limit\n    //\n    // Set a limit the amount minted per mint, which can be useful to\n    // ignore certain edge cases.\n    //\n    //  True => limit the amount of minted tokens\n    //  False => no limit\n    //\n    bool internal constant TOGGLE_MINT_LIMIT = true;\n    uint256 internal constant MINT_MODULO = 1_000_000_000_000e18;\n\n    // Known rounding errors\n    uint256 internal constant TRANSFER_ROUNDING_ERROR = 1e18 - 1;\n    uint256 internal constant OPT_IN_ROUNDING_ERROR = 1e18 - 1;\n    uint256 internal constant MINT_ROUNDING_ERROR = 1e18 - 1;\n\n    /**\n     * @notice Modifier to skip tests that are known to fail\n     * @dev see TOGGLE_KNOWN_ISSUES for more information\n     */\n    modifier hasKnownIssue() {\n        if (TOGGLE_KNOWN_ISSUES) return;\n        _;\n    }\n\n    /**\n     * @notice Modifier to skip tests that are known to fail within limits\n     * @dev see TOGGLE_KNOWN_ISSUES_WITHIN_LIMITS for more information\n     */\n    modifier hasKnownIssueWithinLimits() {\n        if (TOGGLE_KNOWN_ISSUES_WITHIN_LIMITS) return;\n        _;\n    }\n\n    /**\n     * @notice Translate an account ID to an address\n     * @param accountId The ID of the account\n     * @return account The address of the account\n     */\n    function getAccount(uint8 accountId)\n        internal\n        view\n        returns (address account)\n    {\n        accountId = accountId / 64;\n        if (accountId == 0) return account = ADDRESS_USER0;\n        if (accountId == 1) return account = ADDRESS_USER1;\n        if (accountId == 2) return account = ADDRESS_CONTRACT0;\n        if (accountId == 3) return account = ADDRESS_CONTRACT1;\n        require(false, \"Unknown account ID\");\n    }\n}\n"
    },
    "contracts/echidna/EchidnaDebug.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"./EchidnaHelper.sol\";\nimport \"./Debugger.sol\";\n\nimport \"../token/OUSD.sol\";\n\n/**\n * @title Room for random debugging functions\n * @author Rappie\n */\ncontract EchidnaDebug is EchidnaHelper {\n    function debugOUSD() public pure {\n        // assert(ousd.balanceOf(ADDRESS_USER0) == 1000);\n        // assert(ousd.rebaseState(ADDRESS_USER0) != OUSD.RebaseOptions.OptIn);\n        // assert(Address.isContract(ADDRESS_CONTRACT0));\n        // Debugger.log(\"nonRebasingSupply\", ousd.nonRebasingSupply());\n        // assert(false);\n    }\n}\n"
    },
    "contracts/echidna/EchidnaHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./EchidnaSetup.sol\";\nimport \"./Debugger.sol\";\n\n/**\n * @title Mixin containing helper functions\n * @author Rappie\n */\ncontract EchidnaHelper is EchidnaSetup {\n    /**\n     * @notice Mint tokens to an account\n     * @param toAcc Account to mint to\n     * @param amount Amount to mint\n     * @return Amount minted (in case of capped mint with modulo)\n     */\n    function mint(uint8 toAcc, uint256 amount) public returns (uint256) {\n        address to = getAccount(toAcc);\n\n        if (TOGGLE_MINT_LIMIT) {\n            amount = amount % MINT_MODULO;\n        }\n\n        hevm.prank(ADDRESS_VAULT);\n        ousd.mint(to, amount);\n\n        return amount;\n    }\n\n    /**\n     * @notice Burn tokens from an account\n     * @param fromAcc Account to burn from\n     * @param amount Amount to burn\n     */\n    function burn(uint8 fromAcc, uint256 amount) public {\n        address from = getAccount(fromAcc);\n        hevm.prank(ADDRESS_VAULT);\n        ousd.burn(from, amount);\n    }\n\n    /**\n     * @notice Change the total supply of OUSD (rebase)\n     * @param amount New total supply\n     */\n    function changeSupply(uint256 amount) public {\n        if (TOGGLE_CHANGESUPPLY_LIMIT) {\n            amount =\n                ousd.totalSupply() +\n                (amount % (ousd.totalSupply() / CHANGESUPPLY_DIVISOR));\n        }\n\n        hevm.prank(ADDRESS_VAULT);\n        ousd.changeSupply(amount);\n    }\n\n    /**\n     * @notice Transfer tokens between accounts\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function transfer(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n        hevm.prank(from);\n        // slither-disable-next-line unchecked-transfer\n        ousd.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfer approved tokens between accounts\n     * @param authorizedAcc Account that is authorized to transfer\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function transferFrom(\n        uint8 authorizedAcc,\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address authorized = getAccount(authorizedAcc);\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n        hevm.prank(authorized);\n        // slither-disable-next-line unchecked-transfer\n        ousd.transferFrom(from, to, amount);\n    }\n\n    /**\n     * @notice Opt in to rebasing\n     * @param targetAcc Account to opt in\n     */\n    function optIn(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n        hevm.prank(target);\n        ousd.rebaseOptIn();\n    }\n\n    /**\n     * @notice Opt out of rebasing\n     * @param targetAcc Account to opt out\n     */\n    function optOut(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n        hevm.prank(target);\n        ousd.rebaseOptOut();\n    }\n\n    /**\n     * @notice Approve an account to spend OUSD\n     * @param ownerAcc Account that owns the OUSD\n     * @param spenderAcc Account that is approved to spend the OUSD\n     * @param amount Amount to approve\n     */\n    function approve(\n        uint8 ownerAcc,\n        uint8 spenderAcc,\n        uint256 amount\n    ) public {\n        address owner = getAccount(ownerAcc);\n        address spender = getAccount(spenderAcc);\n        hevm.prank(owner);\n        // slither-disable-next-line unused-return\n        ousd.approve(spender, amount);\n    }\n\n    /**\n     * @notice Get the sum of all OUSD balances\n     * @return total Total balance\n     */\n    function getTotalBalance() public view returns (uint256 total) {\n        total += ousd.balanceOf(ADDRESS_VAULT);\n        total += ousd.balanceOf(ADDRESS_OUTSIDER_USER);\n        total += ousd.balanceOf(ADDRESS_OUTSIDER_CONTRACT);\n        total += ousd.balanceOf(ADDRESS_USER0);\n        total += ousd.balanceOf(ADDRESS_USER1);\n        total += ousd.balanceOf(ADDRESS_CONTRACT0);\n        total += ousd.balanceOf(ADDRESS_CONTRACT1);\n    }\n\n    /**\n     * @notice Get the sum of all non-rebasing OUSD balances\n     * @return total Total balance\n     */\n    function getTotalNonRebasingBalance() public returns (uint256 total) {\n        total += ousd._isNonRebasingAccountEchidna(ADDRESS_VAULT)\n            ? ousd.balanceOf(ADDRESS_VAULT)\n            : 0;\n        total += ousd._isNonRebasingAccountEchidna(ADDRESS_OUTSIDER_USER)\n            ? ousd.balanceOf(ADDRESS_OUTSIDER_USER)\n            : 0;\n        total += ousd._isNonRebasingAccountEchidna(ADDRESS_OUTSIDER_CONTRACT)\n            ? ousd.balanceOf(ADDRESS_OUTSIDER_CONTRACT)\n            : 0;\n        total += ousd._isNonRebasingAccountEchidna(ADDRESS_USER0)\n            ? ousd.balanceOf(ADDRESS_USER0)\n            : 0;\n        total += ousd._isNonRebasingAccountEchidna(ADDRESS_USER1)\n            ? ousd.balanceOf(ADDRESS_USER1)\n            : 0;\n        total += ousd._isNonRebasingAccountEchidna(ADDRESS_CONTRACT0)\n            ? ousd.balanceOf(ADDRESS_CONTRACT0)\n            : 0;\n        total += ousd._isNonRebasingAccountEchidna(ADDRESS_CONTRACT1)\n            ? ousd.balanceOf(ADDRESS_CONTRACT1)\n            : 0;\n    }\n}\n"
    },
    "contracts/echidna/EchidnaSetup.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./IHevm.sol\";\nimport \"./EchidnaConfig.sol\";\nimport \"./OUSDEchidna.sol\";\n\ncontract Dummy {}\n\n/**\n * @title Mixin for setup and deployment\n * @author Rappie\n */\ncontract EchidnaSetup is EchidnaConfig {\n    IHevm hevm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    OUSDEchidna ousd = new OUSDEchidna();\n\n    /**\n     * @notice Deploy the OUSD contract and set up initial state\n     */\n    constructor() {\n        ousd.initialize(ADDRESS_VAULT, 1e18);\n\n        // Deploy dummny contracts as users\n        Dummy outsider = new Dummy();\n        ADDRESS_OUTSIDER_CONTRACT = address(outsider);\n        Dummy dummy0 = new Dummy();\n        ADDRESS_CONTRACT0 = address(dummy0);\n        Dummy dummy1 = new Dummy();\n        ADDRESS_CONTRACT1 = address(dummy1);\n\n        // Start out with a reasonable amount of OUSD\n        if (TOGGLE_STARTING_BALANCE) {\n            // Rebasing tokens\n            hevm.prank(ADDRESS_VAULT);\n            ousd.mint(ADDRESS_OUTSIDER_USER, STARTING_BALANCE / 2);\n\n            // Non-rebasing tokens\n            hevm.prank(ADDRESS_VAULT);\n            ousd.mint(ADDRESS_OUTSIDER_CONTRACT, STARTING_BALANCE / 2);\n        }\n    }\n}\n"
    },
    "contracts/echidna/EchidnaTestAccounting.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./EchidnaDebug.sol\";\nimport \"./EchidnaTestSupply.sol\";\n\n/**\n * @title Mixin for testing accounting functions\n * @author Rappie\n */\ncontract EchidnaTestAccounting is EchidnaTestSupply {\n    /**\n     * @notice After opting in, balance should not increase. (Ok to lose rounding funds doing this)\n     * @param targetAcc Account to opt in\n     */\n    function testOptInBalance(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        optIn(targetAcc);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        assert(balanceAfter <= balanceBefore);\n    }\n\n    /**\n     * @notice After opting out, balance should remain the same\n     * @param targetAcc Account to opt out\n     */\n    function testOptOutBalance(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        optOut(targetAcc);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        assert(balanceAfter == balanceBefore);\n    }\n\n    /**\n     * @notice Account balance should remain the same after opting in minus rounding error\n     * @param targetAcc Account to opt in\n     */\n    function testOptInBalanceRounding(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        optIn(targetAcc);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        int256 delta = int256(balanceAfter) - int256(balanceBefore);\n        Debugger.log(\"delta\", delta);\n\n        // slither-disable-next-line tautology\n        assert(-1 * delta >= 0);\n        assert(-1 * delta <= int256(OPT_IN_ROUNDING_ERROR));\n    }\n\n    /**\n     * @notice After opting in, total supply should remain the same\n     * @param targetAcc Account to opt in\n     */\n    function testOptInTotalSupply(uint8 targetAcc) public {\n        uint256 totalSupplyBefore = ousd.totalSupply();\n        optIn(targetAcc);\n        uint256 totalSupplyAfter = ousd.totalSupply();\n\n        assert(totalSupplyAfter == totalSupplyBefore);\n    }\n\n    /**\n     * @notice After opting out, total supply should remain the same\n     * @param targetAcc Account to opt out\n     */\n    function testOptOutTotalSupply(uint8 targetAcc) public {\n        uint256 totalSupplyBefore = ousd.totalSupply();\n        optOut(targetAcc);\n        uint256 totalSupplyAfter = ousd.totalSupply();\n\n        assert(totalSupplyAfter == totalSupplyBefore);\n    }\n\n    /**\n     * @notice Account balance should remain the same when a smart contract auto converts\n     * @param targetAcc Account to auto convert\n     */\n    function testAutoConvertBalance(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        // slither-disable-next-line unused-return\n        ousd._isNonRebasingAccountEchidna(target);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        assert(balanceAfter == balanceBefore);\n    }\n\n    /**\n     * @notice The `balanceOf` function should never revert\n     * @param targetAcc Account to check balance of\n     */\n    function testBalanceOfShouldNotRevert(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        // slither-disable-next-line unused-return\n        try ousd.balanceOf(target) {\n            assert(true);\n        } catch {\n            assert(false);\n        }\n    }\n}\n"
    },
    "contracts/echidna/EchidnaTestApproval.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./EchidnaTestMintBurn.sol\";\nimport \"./Debugger.sol\";\n\n/**\n * @title Mixin for testing approval related functions\n * @author Rappie\n */\ncontract EchidnaTestApproval is EchidnaTestMintBurn {\n    /**\n     * @notice Performing `transferFrom` with an amount inside the allowance should not revert\n     * @param authorizedAcc The account that is authorized to transfer\n     * @param fromAcc The account that is transferring\n     * @param toAcc The account that is receiving\n     * @param amount The amount to transfer\n     */\n    function testTransferFromShouldNotRevert(\n        uint8 authorizedAcc,\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address authorized = getAccount(authorizedAcc);\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(amount <= ousd.balanceOf(from));\n        require(amount <= ousd.allowance(from, authorized));\n\n        hevm.prank(authorized);\n        // slither-disable-next-line unchecked-transfer\n        try ousd.transferFrom(from, to, amount) {\n            // pass\n        } catch {\n            assert(false);\n        }\n    }\n\n    /**\n     * @notice Performing `transferFrom` with an amount outside the allowance should revert\n     * @param authorizedAcc The account that is authorized to transfer\n     * @param fromAcc The account that is transferring\n     * @param toAcc The account that is receiving\n     * @param amount The amount to transfer\n     */\n    function testTransferFromShouldRevert(\n        uint8 authorizedAcc,\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address authorized = getAccount(authorizedAcc);\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(amount > 0);\n        require(\n            !(amount <= ousd.balanceOf(from) &&\n                amount <= ousd.allowance(from, authorized))\n        );\n\n        hevm.prank(authorized);\n        // slither-disable-next-line unchecked-transfer\n        try ousd.transferFrom(from, to, amount) {\n            assert(false);\n        } catch {\n            // pass\n        }\n    }\n\n    /**\n     * @notice Approving an amount should update the allowance and overwrite any previous allowance\n     * @param ownerAcc The account that is approving\n     * @param spenderAcc The account that is being approved\n     * @param amount The amount to approve\n     */\n    function testApprove(\n        uint8 ownerAcc,\n        uint8 spenderAcc,\n        uint256 amount\n    ) public {\n        address owner = getAccount(ownerAcc);\n        address spender = getAccount(spenderAcc);\n\n        approve(ownerAcc, spenderAcc, amount);\n        uint256 allowanceAfter1 = ousd.allowance(owner, spender);\n\n        assert(allowanceAfter1 == amount);\n\n        approve(ownerAcc, spenderAcc, amount / 2);\n        uint256 allowanceAfter2 = ousd.allowance(owner, spender);\n\n        assert(allowanceAfter2 == amount / 2);\n    }\n}\n"
    },
    "contracts/echidna/EchidnaTestMintBurn.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./EchidnaDebug.sol\";\nimport \"./EchidnaTestAccounting.sol\";\n\n/**\n * @title Mixin for testing Mint and Burn functions\n * @author Rappie\n */\ncontract EchidnaTestMintBurn is EchidnaTestAccounting {\n    /**\n     * @notice Minting 0 tokens should not affect account balance\n     * @param targetAcc Account to mint to\n     */\n    function testMintZeroBalance(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        mint(targetAcc, 0);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        assert(balanceAfter == balanceBefore);\n    }\n\n    /**\n     * @notice Burning 0 tokens should not affect account balance\n     * @param targetAcc Account to burn from\n     */\n    function testBurnZeroBalance(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        burn(targetAcc, 0);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        assert(balanceAfter == balanceBefore);\n    }\n\n    /**\n     * @notice Minting tokens must increase the account balance by at least amount\n     * @param targetAcc Account to mint to\n     * @param amount Amount to mint\n     * @custom:error testMintBalance(uint8,uint256): failed!\n     *   Call sequence:\n     *       changeSupply(1)\n     *       testMintBalance(0,1)\n     *   Event sequence:\n     *       Debug(balanceBefore, 0)\n     *       Debug(balanceAfter, 0)\n     */\n    function testMintBalance(uint8 targetAcc, uint256 amount)\n        public\n        hasKnownIssue\n        hasKnownIssueWithinLimits\n    {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        uint256 amountMinted = mint(targetAcc, amount);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        Debugger.log(\"amountMinted\", amountMinted);\n        Debugger.log(\"balanceBefore\", balanceBefore);\n        Debugger.log(\"balanceAfter\", balanceAfter);\n\n        assert(balanceAfter >= balanceBefore + amountMinted);\n    }\n\n    /**\n     * @notice Burning tokens must decrease the account balance by at least amount\n     * @param targetAcc Account to burn from\n     * @param amount Amount to burn\n     * @custom:error testBurnBalance(uint8,uint256): failed!\n     *   Call sequence:\n     *       changeSupply(1)\n     *       mint(0,3)\n     *       testBurnBalance(0,1)\n     *   Event sequence:\n     *       Debug(balanceBefore, 2)\n     *       Debug(balanceAfter, 2)\n     */\n    function testBurnBalance(uint8 targetAcc, uint256 amount)\n        public\n        hasKnownIssue\n        hasKnownIssueWithinLimits\n    {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        burn(targetAcc, amount);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        Debugger.log(\"balanceBefore\", balanceBefore);\n        Debugger.log(\"balanceAfter\", balanceAfter);\n\n        assert(balanceAfter <= balanceBefore - amount);\n    }\n\n    /**\n     * @notice Minting tokens should not increase the account balance by less than rounding error above amount\n     * @param targetAcc Account to mint to\n     * @param amount Amount to mint\n     */\n    function testMintBalanceRounding(uint8 targetAcc, uint256 amount) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        uint256 amountMinted = mint(targetAcc, amount);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        int256 delta = int256(balanceAfter) - int256(balanceBefore);\n\n        // delta == amount, if no error\n        // delta < amount,  if too little is minted\n        // delta > amount,  if too much is minted\n        int256 error = int256(amountMinted) - delta;\n\n        assert(error >= 0);\n        assert(error <= int256(MINT_ROUNDING_ERROR));\n    }\n\n    /**\n     * @notice A burn of an account balance must result in a zero balance\n     * @param targetAcc Account to burn from\n     */\n    function testBurnAllBalanceToZero(uint8 targetAcc) public hasKnownIssue {\n        address target = getAccount(targetAcc);\n\n        burn(targetAcc, ousd.balanceOf(target));\n        assert(ousd.balanceOf(target) == 0);\n    }\n\n    /**\n     * @notice You should always be able to burn an account's balance\n     * @param targetAcc Account to burn from\n     */\n    function testBurnAllBalanceShouldNotRevert(uint8 targetAcc)\n        public\n        hasKnownIssue\n    {\n        address target = getAccount(targetAcc);\n        uint256 balance = ousd.balanceOf(target);\n\n        hevm.prank(ADDRESS_VAULT);\n        try ousd.burn(target, balance) {\n            assert(true);\n        } catch {\n            assert(false);\n        }\n    }\n}\n"
    },
    "contracts/echidna/EchidnaTestSupply.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./EchidnaDebug.sol\";\nimport \"./EchidnaTestTransfer.sol\";\n\nimport { StableMath } from \"../utils/StableMath.sol\";\n\n/**\n * @title Mixin for testing supply related functions\n * @author Rappie\n */\ncontract EchidnaTestSupply is EchidnaTestTransfer {\n    using StableMath for uint256;\n\n    uint256 prevRebasingCreditsPerToken = type(uint256).max;\n\n    /**\n     * @notice After a `changeSupply`, the total supply should exactly\n     * match the target total supply. (This is needed to ensure successive\n     * rebases are correct).\n     * @param supply New total supply\n     * @custom:error testChangeSupply(uint256): failed!\n     *   Call sequence:\n     *       testChangeSupply(1044505275072865171609)\n     *   Event sequence:\n     *       TotalSupplyUpdatedHighres(1044505275072865171610, 1000000000000000000000000, 957391048054055578595)\n     */\n    function testChangeSupply(uint256 supply)\n        public\n        hasKnownIssue\n        hasKnownIssueWithinLimits\n    {\n        hevm.prank(ADDRESS_VAULT);\n        ousd.changeSupply(supply);\n\n        assert(ousd.totalSupply() == supply);\n    }\n\n    /**\n     * @notice The total supply must not be less than the sum of account balances.\n     * (The difference will go into future rebases)\n     * @custom:error testTotalSupplyLessThanTotalBalance(): failed!\n     *   Call sequence:\n     *     mint(0,1)\n     *     changeSupply(1)\n     *     optOut(64)\n     *     transfer(0,64,1)\n     *     testTotalSupplyLessThanTotalBalance()\n     *   Event sequence:\n     *     Debug(totalSupply, 1000000000000000001000001)\n     *     Debug(totalBalance, 1000000000000000001000002)\n     */\n    function testTotalSupplyLessThanTotalBalance()\n        public\n        hasKnownIssue\n        hasKnownIssueWithinLimits\n    {\n        uint256 totalSupply = ousd.totalSupply();\n        uint256 totalBalance = getTotalBalance();\n\n        Debugger.log(\"totalSupply\", totalSupply);\n        Debugger.log(\"totalBalance\", totalBalance);\n\n        assert(totalSupply >= totalBalance);\n    }\n\n    /**\n     * @notice Non-rebasing supply should not be larger than total supply\n     * @custom:error testNonRebasingSupplyVsTotalSupply(): failed!\n     *   Call sequence:\n     *     mint(0,2)\n     *     changeSupply(3)\n     *     burn(0,1)\n     *     optOut(0)\n     *     testNonRebasingSupplyVsTotalSupply()\n     */\n    function testNonRebasingSupplyVsTotalSupply() public hasKnownIssue {\n        uint256 nonRebasingSupply = ousd.nonRebasingSupply();\n        uint256 totalSupply = ousd.totalSupply();\n\n        assert(nonRebasingSupply <= totalSupply);\n    }\n\n    /**\n     * @notice Global `rebasingCreditsPerToken` should never increase\n     * @custom:error testRebasingCreditsPerTokenNotIncreased(): failed!\n     *   Call sequence:\n     *     testRebasingCreditsPerTokenNotIncreased()\n     *     changeSupply(1)\n     *     testRebasingCreditsPerTokenNotIncreased()\n     */\n    function testRebasingCreditsPerTokenNotIncreased() public hasKnownIssue {\n        uint256 curRebasingCreditsPerToken = ousd\n            .rebasingCreditsPerTokenHighres();\n\n        Debugger.log(\n            \"prevRebasingCreditsPerToken\",\n            prevRebasingCreditsPerToken\n        );\n        Debugger.log(\"curRebasingCreditsPerToken\", curRebasingCreditsPerToken);\n\n        assert(curRebasingCreditsPerToken <= prevRebasingCreditsPerToken);\n\n        prevRebasingCreditsPerToken = curRebasingCreditsPerToken;\n    }\n\n    /**\n     * @notice The rebasing credits per token ratio must greater than zero\n     */\n    function testRebasingCreditsPerTokenAboveZero() public {\n        assert(ousd.rebasingCreditsPerTokenHighres() > 0);\n    }\n\n    /**\n     * @notice The sum of all non-rebasing balances should not be larger than\n     * non-rebasing supply\n     * @custom:error testTotalNonRebasingSupplyLessThanTotalBalance(): failed!\n     *   Call sequence\n     *     mint(0,2)\n     *     changeSupply(1)\n     *     optOut(0)\n     *     burn(0,1)\n     *     testTotalNonRebasingSupplyLessThanTotalBalance()\n     *   Event sequence:\n     *     Debug(totalNonRebasingSupply, 500000000000000000000001)\n     *     Debug(totalNonRebasingBalance, 500000000000000000000002)\n     */\n    function testTotalNonRebasingSupplyLessThanTotalBalance()\n        public\n        hasKnownIssue\n        hasKnownIssueWithinLimits\n    {\n        uint256 totalNonRebasingSupply = ousd.nonRebasingSupply();\n        uint256 totalNonRebasingBalance = getTotalNonRebasingBalance();\n\n        Debugger.log(\"totalNonRebasingSupply\", totalNonRebasingSupply);\n        Debugger.log(\"totalNonRebasingBalance\", totalNonRebasingBalance);\n\n        assert(totalNonRebasingSupply >= totalNonRebasingBalance);\n    }\n\n    /**\n     * @notice An accounts credits / credits per token should not be larger it's balance\n     * @param targetAcc The account to check\n     */\n    function testCreditsPerTokenVsBalance(uint8 targetAcc) public {\n        address target = getAccount(targetAcc);\n\n        (uint256 credits, uint256 creditsPerToken, ) = ousd\n            .creditsBalanceOfHighres(target);\n        uint256 expectedBalance = credits.divPrecisely(creditsPerToken);\n\n        uint256 balance = ousd.balanceOf(target);\n\n        Debugger.log(\"credits\", credits);\n        Debugger.log(\"creditsPerToken\", creditsPerToken);\n        Debugger.log(\"expectedBalance\", expectedBalance);\n        Debugger.log(\"balance\", balance);\n\n        assert(expectedBalance == balance);\n    }\n}\n"
    },
    "contracts/echidna/EchidnaTestTransfer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./EchidnaDebug.sol\";\nimport \"./Debugger.sol\";\n\n/**\n * @title Mixin for testing transfer related functions\n * @author Rappie\n */\ncontract EchidnaTestTransfer is EchidnaDebug {\n    /**\n     * @notice The receiving account's balance after a transfer must not increase by\n     * less than the amount transferred\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     * @custom:error testTransferBalanceReceivedLess(uint8,uint8,uint256): failed!\n     *   Call sequence:\n     *     changeSupply(1)\n     *     mint(64,2)\n     *     testTransferBalanceReceivedLess(64,0,1)\n     *   Event sequence:\n     *     Debug(totalSupply, 1000000000000000000500002)\n     *     Debug(toBalBefore, 0)\n     *     Debug(toBalAfter, 0)\n     */\n    function testTransferBalanceReceivedLess(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public hasKnownIssue hasKnownIssueWithinLimits {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(from != to);\n\n        uint256 toBalBefore = ousd.balanceOf(to);\n        transfer(fromAcc, toAcc, amount);\n        uint256 toBalAfter = ousd.balanceOf(to);\n\n        Debugger.log(\"totalSupply\", ousd.totalSupply());\n        Debugger.log(\"toBalBefore\", toBalBefore);\n        Debugger.log(\"toBalAfter\", toBalAfter);\n\n        assert(toBalAfter >= toBalBefore + amount);\n    }\n\n    /**\n     * @notice The receiving account's balance after a transfer must not\n     * increase by more than the amount transferred\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function testTransferBalanceReceivedMore(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(from != to);\n\n        uint256 toBalBefore = ousd.balanceOf(to);\n        transfer(fromAcc, toAcc, amount);\n        uint256 toBalAfter = ousd.balanceOf(to);\n\n        Debugger.log(\"totalSupply\", ousd.totalSupply());\n        Debugger.log(\"toBalBefore\", toBalBefore);\n        Debugger.log(\"toBalAfter\", toBalAfter);\n\n        assert(toBalAfter <= toBalBefore + amount);\n    }\n\n    /**\n     * @notice The sending account's balance after a transfer must not\n     * decrease by less than the amount transferred\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     * @custom:error testTransferBalanceSentLess(uint8,uint8,uint256): failed!\n     *   Call sequence:\n     *     mint(0,1)\n     *     changeSupply(1)\n     *     testTransferBalanceSentLess(0,64,1)\n     *   Event sequence:\n     *     Debug(totalSupply, 1000000000000000000500001)\n     *     Debug(fromBalBefore, 1)\n     *     Debug(fromBalAfter, 1)\n     */\n    function testTransferBalanceSentLess(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public hasKnownIssue hasKnownIssueWithinLimits {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(from != to);\n\n        uint256 fromBalBefore = ousd.balanceOf(from);\n        transfer(fromAcc, toAcc, amount);\n        uint256 fromBalAfter = ousd.balanceOf(from);\n\n        Debugger.log(\"totalSupply\", ousd.totalSupply());\n        Debugger.log(\"fromBalBefore\", fromBalBefore);\n        Debugger.log(\"fromBalAfter\", fromBalAfter);\n\n        assert(fromBalAfter <= fromBalBefore - amount);\n    }\n\n    /**\n     * @notice The sending account's balance after a transfer must not\n     * decrease by more than the amount transferred\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function testTransferBalanceSentMore(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(from != to);\n\n        uint256 fromBalBefore = ousd.balanceOf(from);\n        transfer(fromAcc, toAcc, amount);\n        uint256 fromBalAfter = ousd.balanceOf(from);\n\n        Debugger.log(\"totalSupply\", ousd.totalSupply());\n        Debugger.log(\"fromBalBefore\", fromBalBefore);\n        Debugger.log(\"fromBalAfter\", fromBalAfter);\n\n        assert(fromBalAfter >= fromBalBefore - amount);\n    }\n\n    /**\n     * @notice The receiving account's balance after a transfer must not\n     * increase by less than the amount transferred (minus rounding error)\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function testTransferBalanceReceivedLessRounding(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(from != to);\n\n        uint256 toBalBefore = ousd.balanceOf(to);\n        transfer(fromAcc, toAcc, amount);\n        uint256 toBalAfter = ousd.balanceOf(to);\n\n        int256 toDelta = int256(toBalAfter) - int256(toBalBefore);\n\n        // delta == amount, if no error\n        // delta < amount,  if too little is sent\n        // delta > amount,  if too much is sent\n        int256 error = int256(amount) - toDelta;\n\n        Debugger.log(\"totalSupply\", ousd.totalSupply());\n        Debugger.log(\"toBalBefore\", toBalBefore);\n        Debugger.log(\"toBalAfter\", toBalAfter);\n        Debugger.log(\"toDelta\", toDelta);\n        Debugger.log(\"error\", error);\n\n        assert(error >= 0);\n        assert(error <= int256(TRANSFER_ROUNDING_ERROR));\n    }\n\n    /**\n     * @notice The sending account's balance after a transfer must\n     * not decrease by less than the amount transferred (minus rounding error)\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function testTransferBalanceSentLessRounding(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(from != to);\n\n        uint256 fromBalBefore = ousd.balanceOf(from);\n        transfer(fromAcc, toAcc, amount);\n        uint256 fromBalAfter = ousd.balanceOf(from);\n\n        int256 fromDelta = int256(fromBalAfter) - int256(fromBalBefore);\n\n        // delta == -amount, if no error\n        // delta < -amount,  if too much is sent\n        // delta > -amount,  if too little is sent\n        int256 error = int256(amount) + fromDelta;\n\n        Debugger.log(\"totalSupply\", ousd.totalSupply());\n        Debugger.log(\"fromBalBefore\", fromBalBefore);\n        Debugger.log(\"fromBalAfter\", fromBalAfter);\n        Debugger.log(\"fromDelta\", fromDelta);\n        Debugger.log(\"error\", error);\n\n        assert(error >= 0);\n        assert(error <= int256(TRANSFER_ROUNDING_ERROR));\n    }\n\n    /**\n     * @notice An account should always be able to successfully transfer\n     * an amount within its balance.\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     * @custom:error testTransferWithinBalanceDoesNotRevert(uint8,uint8,uint8): failed!\n     *   Call sequence:\n     *       mint(0,1)\n     *       changeSupply(3)\n     *       optOut(0)\n     *       testTransferWithinBalanceDoesNotRevert(0,128,2)\n     *       optIn(0)\n     *       testTransferWithinBalanceDoesNotRevert(128,0,1)\n     *   Event sequence:\n     *       error Revert Panic(17): SafeMath over-/under-flows\n     */\n    function testTransferWithinBalanceDoesNotRevert(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public hasKnownIssue {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        require(amount > 0);\n        amount = amount % ousd.balanceOf(from);\n\n        Debugger.log(\"Total supply\", ousd.totalSupply());\n\n        hevm.prank(from);\n        // slither-disable-next-line unchecked-transfer\n        try ousd.transfer(to, amount) {\n            assert(true);\n        } catch {\n            assert(false);\n        }\n    }\n\n    /**\n     * @notice An account should never be able to successfully transfer\n     * an amount greater than their balance.\n     * @param fromAcc Account to transfer from\n     * @param toAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function testTransferExceedingBalanceReverts(\n        uint8 fromAcc,\n        uint8 toAcc,\n        uint256 amount\n    ) public {\n        address from = getAccount(fromAcc);\n        address to = getAccount(toAcc);\n\n        amount = ousd.balanceOf(from) + 1 + amount;\n\n        hevm.prank(from);\n        // slither-disable-next-line unchecked-transfer\n        try ousd.transfer(to, amount) {\n            assert(false);\n        } catch {\n            assert(true);\n        }\n    }\n\n    /**\n     * @notice A transfer to the same account should not change that account's balance\n     * @param targetAcc Account to transfer to\n     * @param amount Amount to transfer\n     */\n    function testTransferSelf(uint8 targetAcc, uint256 amount) public {\n        address target = getAccount(targetAcc);\n\n        uint256 balanceBefore = ousd.balanceOf(target);\n        transfer(targetAcc, targetAcc, amount);\n        uint256 balanceAfter = ousd.balanceOf(target);\n\n        assert(balanceBefore == balanceAfter);\n    }\n\n    /**\n     * @notice Transfers to the zero account revert\n     * @param fromAcc Account to transfer from\n     * @param amount Amount to transfer\n     */\n    function testTransferToZeroAddress(uint8 fromAcc, uint256 amount) public {\n        address from = getAccount(fromAcc);\n\n        hevm.prank(from);\n        // slither-disable-next-line unchecked-transfer\n        try ousd.transfer(address(0), amount) {\n            assert(false);\n        } catch {\n            assert(true);\n        }\n    }\n}\n"
    },
    "contracts/echidna/IHevm.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n// https://github.com/ethereum/hevm/blob/main/doc/src/controlling-the-unit-testing-environment.md#cheat-codes\n\ninterface IHevm {\n    function warp(uint256 x) external;\n\n    function roll(uint256 x) external;\n\n    function store(\n        address c,\n        bytes32 loc,\n        bytes32 val\n    ) external;\n\n    function load(address c, bytes32 loc) external returns (bytes32 val);\n\n    function sign(uint256 sk, bytes32 digest)\n        external\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        );\n\n    function addr(uint256 sk) external returns (address addr);\n\n    function ffi(string[] calldata) external returns (bytes memory);\n\n    function prank(address sender) external;\n}\n"
    },
    "contracts/echidna/OUSDEchidna.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../token/OUSD.sol\";\n\ncontract OUSDEchidna is OUSD {\n    constructor() OUSD() {}\n\n    function _isNonRebasingAccountEchidna(address _account)\n        public\n        returns (bool)\n    {\n        _autoMigrate(_account);\n        return alternativeCreditsPerToken[_account] > 0;\n    }\n}\n"
    },
    "contracts/governance/Governable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Base for contracts that are managed by the Origin Protocol's Governor.\n * @dev Copy of the openzeppelin Ownable.sol contract with nomenclature change\n *      from owner to governor and renounce methods removed. Does not use\n *      Context.sol like Ownable.sol does for simplification.\n * @author Origin Protocol Inc\n */\nabstract contract Governable {\n    // Storage position of the owner and pendingOwner of the contract\n    // keccak256(\"OUSD.governor\");\n    bytes32 private constant governorPosition =\n        0x7bea13895fa79d2831e0a9e28edede30099005a50d652d8957cf8a607ee6ca4a;\n\n    // keccak256(\"OUSD.pending.governor\");\n    bytes32 private constant pendingGovernorPosition =\n        0x44c4d30b2eaad5130ad70c3ba6972730566f3e6359ab83e800d905c61b1c51db;\n\n    // keccak256(\"OUSD.reentry.status\");\n    bytes32 private constant reentryStatusPosition =\n        0x53bf423e48ed90e97d02ab0ebab13b2a235a6bfbe9c321847d5c175333ac4535;\n\n    // See OpenZeppelin ReentrancyGuard implementation\n    uint256 constant _NOT_ENTERED = 1;\n    uint256 constant _ENTERED = 2;\n\n    event PendingGovernorshipTransfer(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    event GovernorshipTransferred(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    /**\n     * @notice Returns the address of the current Governor.\n     */\n    function governor() public view returns (address) {\n        return _governor();\n    }\n\n    /**\n     * @dev Returns the address of the current Governor.\n     */\n    function _governor() internal view returns (address governorOut) {\n        bytes32 position = governorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            governorOut := sload(position)\n        }\n    }\n\n    /**\n     * @dev Returns the address of the pending Governor.\n     */\n    function _pendingGovernor()\n        internal\n        view\n        returns (address pendingGovernor)\n    {\n        bytes32 position = pendingGovernorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            pendingGovernor := sload(position)\n        }\n    }\n\n    /**\n     * @dev Throws if called by any account other than the Governor.\n     */\n    modifier onlyGovernor() {\n        require(isGovernor(), \"Caller is not the Governor\");\n        _;\n    }\n\n    /**\n     * @notice Returns true if the caller is the current Governor.\n     */\n    function isGovernor() public view returns (bool) {\n        return msg.sender == _governor();\n    }\n\n    function _setGovernor(address newGovernor) internal {\n        emit GovernorshipTransferred(_governor(), newGovernor);\n\n        bytes32 position = governorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, newGovernor)\n        }\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        bytes32 position = reentryStatusPosition;\n        uint256 _reentry_status;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _reentry_status := sload(position)\n        }\n\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_reentry_status != _ENTERED, \"Reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, _ENTERED)\n        }\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, _NOT_ENTERED)\n        }\n    }\n\n    function _setPendingGovernor(address newGovernor) internal {\n        bytes32 position = pendingGovernorPosition;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(position, newGovernor)\n        }\n    }\n\n    /**\n     * @notice Transfers Governance of the contract to a new account (`newGovernor`).\n     * Can only be called by the current Governor. Must be claimed for this to complete\n     * @param _newGovernor Address of the new Governor\n     */\n    function transferGovernance(address _newGovernor) external onlyGovernor {\n        _setPendingGovernor(_newGovernor);\n        emit PendingGovernorshipTransfer(_governor(), _newGovernor);\n    }\n\n    /**\n     * @notice Claim Governance of the contract to a new account (`newGovernor`).\n     * Can only be called by the new Governor.\n     */\n    function claimGovernance() external {\n        require(\n            msg.sender == _pendingGovernor(),\n            \"Only the pending Governor can complete the claim\"\n        );\n        _changeGovernor(msg.sender);\n    }\n\n    /**\n     * @dev Change Governance of the contract to a new account (`newGovernor`).\n     * @param _newGovernor Address of the new Governor\n     */\n    function _changeGovernor(address _newGovernor) internal {\n        require(_newGovernor != address(0), \"New Governor is address(0)\");\n        _setGovernor(_newGovernor);\n    }\n}\n"
    },
    "contracts/governance/Strategizable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Governable } from \"./Governable.sol\";\n\ncontract Strategizable is Governable {\n    event StrategistUpdated(address _address);\n\n    // Address of strategist\n    address public strategistAddr;\n\n    // For future use\n    uint256[50] private __gap;\n\n    /**\n     * @dev Verifies that the caller is either Governor or Strategist.\n     */\n    modifier onlyGovernorOrStrategist() virtual {\n        require(\n            msg.sender == strategistAddr || isGovernor(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Set address of Strategist\n     * @param _address Address of Strategist\n     */\n    function setStrategistAddr(address _address) external onlyGovernor {\n        _setStrategistAddr(_address);\n    }\n\n    /**\n     * @dev Set address of Strategist\n     * @param _address Address of Strategist\n     */\n    function _setStrategistAddr(address _address) internal {\n        strategistAddr = _address;\n        emit StrategistUpdated(_address);\n    }\n}\n"
    },
    "contracts/harvest/AbstractHarvester.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\nimport { IUniswapV2Router } from \"../interfaces/uniswap/IUniswapV2Router02.sol\";\nimport { IUniswapV3Router } from \"../interfaces/uniswap/IUniswapV3Router.sol\";\nimport { IBalancerVault } from \"../interfaces/balancer/IBalancerVault.sol\";\nimport { ICurvePool } from \"../strategies/ICurvePool.sol\";\nimport \"../utils/Helpers.sol\";\n\nabstract contract AbstractHarvester is Governable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using StableMath for uint256;\n\n    enum SwapPlatform {\n        UniswapV2Compatible,\n        UniswapV3,\n        Balancer,\n        Curve\n    }\n\n    event SupportedStrategyUpdate(address strategyAddress, bool isSupported);\n    event RewardTokenConfigUpdated(\n        address tokenAddress,\n        uint16 allowedSlippageBps,\n        uint16 harvestRewardBps,\n        SwapPlatform swapPlatform,\n        address swapPlatformAddr,\n        bytes swapData,\n        uint256 liquidationLimit,\n        bool doSwapRewardToken\n    );\n    event RewardTokenSwapped(\n        address indexed rewardToken,\n        address indexed swappedInto,\n        SwapPlatform swapPlatform,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    event RewardProceedsTransferred(\n        address indexed token,\n        address farmer,\n        uint256 protcolYield,\n        uint256 farmerFee\n    );\n    event RewardProceedsAddressChanged(address newProceedsAddress);\n\n    error EmptyAddress();\n    error InvalidSlippageBps();\n    error InvalidHarvestRewardBps();\n\n    error InvalidSwapPlatform(SwapPlatform swapPlatform);\n\n    error InvalidUniswapV2PathLength();\n    error InvalidTokenInSwapPath(address token);\n    error EmptyBalancerPoolId();\n    error InvalidCurvePoolAssetIndex(address token);\n\n    error UnsupportedStrategy(address strategyAddress);\n\n    error SlippageError(uint256 actualBalance, uint256 minExpected);\n    error BalanceMismatchAfterSwap(uint256 actualBalance, uint256 minExpected);\n\n    // Configuration properties for harvesting logic of reward tokens\n    struct RewardTokenConfig {\n        // Max allowed slippage when swapping reward token for a stablecoin denominated in basis points.\n        uint16 allowedSlippageBps;\n        // Reward when calling a harvest function denominated in basis points.\n        uint16 harvestRewardBps;\n        // Address of compatible exchange protocol (Uniswap V2/V3, SushiSwap, Balancer and Curve).\n        address swapPlatformAddr;\n        /* When true the reward token is being swapped. In a need of (temporarily) disabling the swapping of\n         * a reward token this needs to be set to false.\n         */\n        bool doSwapRewardToken;\n        // Platform to use for Swapping\n        SwapPlatform swapPlatform;\n        /* How much token can be sold per one harvest call. If the balance of rewards tokens\n         * exceeds that limit multiple harvest calls are required to harvest all of the tokens.\n         * Set it to MAX_INT to effectively disable the limit.\n         */\n        uint256 liquidationLimit;\n    }\n\n    mapping(address => RewardTokenConfig) public rewardTokenConfigs;\n    mapping(address => bool) public supportedStrategies;\n\n    address public immutable vaultAddress;\n\n    /**\n     * Address receiving rewards proceeds. Initially the Vault contract later will possibly\n     * be replaced by another contract that eases out rewards distribution.\n     **/\n    address public rewardProceedsAddress;\n\n    /**\n     * All tokens are swapped to this token before it gets transferred\n     * to the `rewardProceedsAddress`. USDT for OUSD and WETH for OETH.\n     **/\n    address public immutable baseTokenAddress;\n    // Cached decimals for `baseTokenAddress`\n    uint256 public immutable baseTokenDecimals;\n\n    // Uniswap V2 path for reward tokens using Uniswap V2 Router\n    mapping(address => address[]) public uniswapV2Path;\n    // Uniswap V3 path for reward tokens using Uniswap V3 Router\n    mapping(address => bytes) public uniswapV3Path;\n    // Pool ID to use for reward tokens on Balancer\n    mapping(address => bytes32) public balancerPoolId;\n\n    struct CurvePoolIndices {\n        // Casted into uint128 and stored in a struct to save gas\n        uint128 rewardTokenIndex;\n        uint128 baseTokenIndex;\n    }\n    // Packed indices of assets on the Curve pool\n    mapping(address => CurvePoolIndices) public curvePoolIndices;\n\n    constructor(address _vaultAddress, address _baseTokenAddress) {\n        require(_vaultAddress != address(0));\n        require(_baseTokenAddress != address(0));\n\n        vaultAddress = _vaultAddress;\n        baseTokenAddress = _baseTokenAddress;\n\n        // Cache decimals as well\n        baseTokenDecimals = Helpers.getDecimals(_baseTokenAddress);\n    }\n\n    /***************************************\n                 Configuration\n    ****************************************/\n\n    /**\n     * Set the Address receiving rewards proceeds.\n     * @param _rewardProceedsAddress Address of the reward token\n     */\n    function setRewardProceedsAddress(address _rewardProceedsAddress)\n        external\n        onlyGovernor\n    {\n        if (_rewardProceedsAddress == address(0)) {\n            revert EmptyAddress();\n        }\n\n        rewardProceedsAddress = _rewardProceedsAddress;\n        emit RewardProceedsAddressChanged(_rewardProceedsAddress);\n    }\n\n    /**\n     * @dev Add/update a reward token configuration that holds harvesting config variables\n     * @param _tokenAddress Address of the reward token\n     * @param tokenConfig.allowedSlippageBps uint16 maximum allowed slippage denominated in basis points.\n     *          Example: 300 == 3% slippage\n     * @param tokenConfig.harvestRewardBps uint16 amount of reward tokens the caller of the function is rewarded.\n     *          Example: 100 == 1%\n     * @param tokenConfig.swapPlatformAddr Address Address of a UniswapV2 compatible contract to perform\n     *          the exchange from reward tokens to stablecoin (currently hard-coded to USDT)\n     * @param tokenConfig.liquidationLimit uint256 Maximum amount of token to be sold per one swap function call.\n     *          When value is 0 there is no limit.\n     * @param tokenConfig.doSwapRewardToken bool Disables swapping of the token when set to true,\n     *          does not cause it to revert though.\n     * @param tokenConfig.swapPlatform SwapPlatform to use for Swapping\n     * @param swapData Additional data required for swapping\n     */\n    function setRewardTokenConfig(\n        address _tokenAddress,\n        RewardTokenConfig calldata tokenConfig,\n        bytes calldata swapData\n    ) external onlyGovernor {\n        if (tokenConfig.allowedSlippageBps > 1000) {\n            revert InvalidSlippageBps();\n        }\n\n        if (tokenConfig.harvestRewardBps > 1000) {\n            revert InvalidHarvestRewardBps();\n        }\n\n        address newRouterAddress = tokenConfig.swapPlatformAddr;\n        if (newRouterAddress == address(0)) {\n            // Swap router address should be non zero address\n            revert EmptyAddress();\n        }\n\n        address oldRouterAddress = rewardTokenConfigs[_tokenAddress]\n            .swapPlatformAddr;\n        rewardTokenConfigs[_tokenAddress] = tokenConfig;\n\n        // Revert if feed does not exist\n        // slither-disable-next-line unused-return\n\n        IERC20 token = IERC20(_tokenAddress);\n        // if changing token swap provider cancel existing allowance\n        if (\n            /* oldRouterAddress == address(0) when there is no pre-existing\n             * configuration for said rewards token\n             */\n            oldRouterAddress != address(0) &&\n            oldRouterAddress != newRouterAddress\n        ) {\n            token.safeApprove(oldRouterAddress, 0);\n        }\n\n        // Give SwapRouter infinite approval when needed\n        if (oldRouterAddress != newRouterAddress) {\n            token.safeApprove(newRouterAddress, 0);\n            token.safeApprove(newRouterAddress, type(uint256).max);\n        }\n\n        SwapPlatform _platform = tokenConfig.swapPlatform;\n        if (_platform == SwapPlatform.UniswapV2Compatible) {\n            uniswapV2Path[_tokenAddress] = _decodeUniswapV2Path(\n                swapData,\n                _tokenAddress\n            );\n        } else if (_platform == SwapPlatform.UniswapV3) {\n            uniswapV3Path[_tokenAddress] = _decodeUniswapV3Path(\n                swapData,\n                _tokenAddress\n            );\n        } else if (_platform == SwapPlatform.Balancer) {\n            balancerPoolId[_tokenAddress] = _decodeBalancerPoolId(\n                swapData,\n                newRouterAddress,\n                _tokenAddress\n            );\n        } else if (_platform == SwapPlatform.Curve) {\n            curvePoolIndices[_tokenAddress] = _decodeCurvePoolIndices(\n                swapData,\n                newRouterAddress,\n                _tokenAddress\n            );\n        } else {\n            // Note: This code is unreachable since Solidity reverts when\n            // the value is outside the range of defined values of the enum\n            // (even if it's under the max length of the base type)\n            revert InvalidSwapPlatform(_platform);\n        }\n\n        emit RewardTokenConfigUpdated(\n            _tokenAddress,\n            tokenConfig.allowedSlippageBps,\n            tokenConfig.harvestRewardBps,\n            _platform,\n            newRouterAddress,\n            swapData,\n            tokenConfig.liquidationLimit,\n            tokenConfig.doSwapRewardToken\n        );\n    }\n\n    /**\n     * @dev Decodes the data passed into Uniswap V2 path and validates\n     *      it to make sure the path is for `token` to `baseToken`\n     *\n     * @param data Ecnoded data passed to the `setRewardTokenConfig`\n     * @param token The address of the reward token\n     * @return path The validated Uniswap V2 path\n     */\n    function _decodeUniswapV2Path(bytes calldata data, address token)\n        internal\n        view\n        returns (address[] memory path)\n    {\n        (path) = abi.decode(data, (address[]));\n        uint256 len = path.length;\n\n        if (len < 2) {\n            // Path should have at least two tokens\n            revert InvalidUniswapV2PathLength();\n        }\n\n        // Do some validation\n        if (path[0] != token) {\n            revert InvalidTokenInSwapPath(path[0]);\n        }\n\n        if (path[len - 1] != baseTokenAddress) {\n            revert InvalidTokenInSwapPath(path[len - 1]);\n        }\n    }\n\n    /**\n     * @dev Decodes the data passed into Uniswap V3 path and validates\n     *      it to make sure the path is for `token` to `baseToken`\n     *\n     * @param data Ecnoded data passed to the `setRewardTokenConfig`\n     * @param token The address of the reward token\n     * @return path The validated Uniswap V3 path\n     */\n    function _decodeUniswapV3Path(bytes calldata data, address token)\n        internal\n        view\n        returns (bytes calldata path)\n    {\n        path = data;\n\n        address decodedAddress = address(uint160(bytes20(data[0:20])));\n\n        if (decodedAddress != token) {\n            // Invalid Reward Token in swap path\n            revert InvalidTokenInSwapPath(decodedAddress);\n        }\n\n        decodedAddress = address(uint160(bytes20(data[path.length - 20:])));\n        if (decodedAddress != baseTokenAddress) {\n            // Invalid Base Token in swap path\n            revert InvalidTokenInSwapPath(decodedAddress);\n        }\n    }\n\n    /**\n     * @dev Decodes the data passed to Balancer Pool ID\n     *\n     * @param data Ecnoded data passed to the `setRewardTokenConfig`\n     * @return poolId The pool ID\n     */\n    function _decodeBalancerPoolId(\n        bytes calldata data,\n        address balancerVault,\n        address token\n    ) internal view returns (bytes32 poolId) {\n        (poolId) = abi.decode(data, (bytes32));\n\n        if (poolId == bytes32(0)) {\n            revert EmptyBalancerPoolId();\n        }\n\n        IBalancerVault bVault = IBalancerVault(balancerVault);\n\n        // Note: this reverts if token is not a pool asset\n        // slither-disable-next-line unused-return\n        bVault.getPoolTokenInfo(poolId, token);\n\n        // slither-disable-next-line unused-return\n        bVault.getPoolTokenInfo(poolId, baseTokenAddress);\n    }\n\n    /**\n     * @dev Decodes the data passed to get the pool indices and\n     *      checks it against the Curve Pool to make sure it's\n     *      not misconfigured. The indices are packed into a single\n     *      uint256 for gas savings\n     *\n     * @param data Ecnoded data passed to the `setRewardTokenConfig`\n     * @param poolAddress Curve pool address\n     * @param token The address of the reward token\n     * @return indices Packed pool asset indices\n     */\n    function _decodeCurvePoolIndices(\n        bytes calldata data,\n        address poolAddress,\n        address token\n    ) internal view returns (CurvePoolIndices memory indices) {\n        indices = abi.decode(data, (CurvePoolIndices));\n\n        ICurvePool pool = ICurvePool(poolAddress);\n        if (token != pool.coins(indices.rewardTokenIndex)) {\n            revert InvalidCurvePoolAssetIndex(token);\n        }\n        if (baseTokenAddress != pool.coins(indices.baseTokenIndex)) {\n            revert InvalidCurvePoolAssetIndex(baseTokenAddress);\n        }\n    }\n\n    /**\n     * @dev Flags a strategy as supported or not supported one\n     * @param _strategyAddress Address of the strategy\n     * @param _isSupported Bool marking strategy as supported or not supported\n     */\n    function setSupportedStrategy(address _strategyAddress, bool _isSupported)\n        external\n        onlyGovernor\n    {\n        supportedStrategies[_strategyAddress] = _isSupported;\n        emit SupportedStrategyUpdate(_strategyAddress, _isSupported);\n    }\n\n    /***************************************\n                    Rewards\n    ****************************************/\n\n    /**\n     * @dev Transfer token to governor. Intended for recovering tokens stuck in\n     *      contract, i.e. mistaken sends.\n     * @param _asset Address for the asset\n     * @param _amount Amount of the asset to transfer\n     */\n    function transferToken(address _asset, uint256 _amount)\n        external\n        onlyGovernor\n    {\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /**\n     * @dev Collect reward tokens from a specific strategy and swap them for\n     *      base token on the configured swap platform. Can be called by anyone.\n     *      Rewards incentivizing the caller are sent to the caller of this function.\n     * @param _strategyAddr Address of the strategy to collect rewards from\n     */\n    function harvestAndSwap(address _strategyAddr) external nonReentrant {\n        // Remember _harvest function checks for the validity of _strategyAddr\n        _harvestAndSwap(_strategyAddr, msg.sender);\n    }\n\n    /**\n     * @dev Collect reward tokens from a specific strategy and swap them for\n     *      base token on the configured swap platform. Can be called by anyone\n     * @param _strategyAddr Address of the strategy to collect rewards from\n     * @param _rewardTo Address where to send a share of harvest rewards to as an incentive\n     *      for executing this function\n     */\n    function harvestAndSwap(address _strategyAddr, address _rewardTo)\n        external\n        nonReentrant\n    {\n        // Remember _harvest function checks for the validity of _strategyAddr\n        _harvestAndSwap(_strategyAddr, _rewardTo);\n    }\n\n    /**\n     * @dev Collect reward tokens from a specific strategy and swap them for\n     *      base token on the configured swap platform\n     * @param _strategyAddr Address of the strategy to collect rewards from\n     * @param _rewardTo Address where to send a share of harvest rewards to as an incentive\n     *      for executing this function\n     */\n    function _harvestAndSwap(address _strategyAddr, address _rewardTo)\n        internal\n    {\n        _harvest(_strategyAddr);\n        IStrategy strategy = IStrategy(_strategyAddr);\n        address[] memory rewardTokens = strategy.getRewardTokenAddresses();\n        uint256 len = rewardTokens.length;\n        for (uint256 i = 0; i < len; ++i) {\n            // This harvester contract is not used anymore. Keeping the code\n            // for passing test deployment. Safe to use address(0x1) as oracle.\n            _swap(rewardTokens[i], _rewardTo, IOracle(address(0x1)));\n        }\n    }\n\n    /**\n     * @dev Collect reward tokens from a specific strategy and swap them for\n     *      base token on the configured swap platform\n     * @param _strategyAddr Address of the strategy to collect rewards from.\n     */\n    function _harvest(address _strategyAddr) internal virtual {\n        if (!supportedStrategies[_strategyAddr]) {\n            revert UnsupportedStrategy(_strategyAddr);\n        }\n\n        IStrategy strategy = IStrategy(_strategyAddr);\n        strategy.collectRewardTokens();\n    }\n\n    /**\n     * @dev Swap a reward token for the base token on the configured\n     *      swap platform. The token must have a registered price feed\n     *      with the price provider\n     * @param _swapToken Address of the token to swap\n     * @param _rewardTo Address where to send the share of harvest rewards to\n     * @param _priceProvider Oracle to get prices of the swap token\n     */\n    function _swap(\n        address _swapToken,\n        address _rewardTo,\n        IOracle _priceProvider\n    ) internal virtual {\n        uint256 balance = IERC20(_swapToken).balanceOf(address(this));\n\n        // No need to swap if the reward token is the base token. eg USDT or WETH.\n        // There is also no limit on the transfer. Everything in the harvester will be transferred\n        // to the Dripper regardless of the liquidationLimit config.\n        if (_swapToken == baseTokenAddress) {\n            IERC20(_swapToken).safeTransfer(rewardProceedsAddress, balance);\n            // currently not paying the farmer any rewards as there is no swap\n            emit RewardProceedsTransferred(\n                baseTokenAddress,\n                address(0),\n                balance,\n                0\n            );\n            return;\n        }\n\n        RewardTokenConfig memory tokenConfig = rewardTokenConfigs[_swapToken];\n\n        /* This will trigger a return when reward token configuration has not yet been set\n         * or we have temporarily disabled swapping of specific reward token via setting\n         * doSwapRewardToken to false.\n         */\n        if (!tokenConfig.doSwapRewardToken) {\n            return;\n        }\n\n        if (balance == 0) {\n            return;\n        }\n\n        if (tokenConfig.liquidationLimit > 0) {\n            balance = Math.min(balance, tokenConfig.liquidationLimit);\n        }\n\n        // This'll revert if there is no price feed\n        uint256 oraclePrice = _priceProvider.price(_swapToken);\n\n        // Oracle price is 1e18\n        uint256 minExpected = (balance *\n            (1e4 - tokenConfig.allowedSlippageBps) * // max allowed slippage\n            oraclePrice).scaleBy(\n                baseTokenDecimals,\n                Helpers.getDecimals(_swapToken)\n            ) /\n            1e4 / // fix the max slippage decimal position\n            1e18; // and oracle price decimals position\n\n        // Do the swap\n        uint256 amountReceived = _doSwap(\n            tokenConfig.swapPlatform,\n            tokenConfig.swapPlatformAddr,\n            _swapToken,\n            balance,\n            minExpected\n        );\n\n        if (amountReceived < minExpected) {\n            revert SlippageError(amountReceived, minExpected);\n        }\n\n        emit RewardTokenSwapped(\n            _swapToken,\n            baseTokenAddress,\n            tokenConfig.swapPlatform,\n            balance,\n            amountReceived\n        );\n\n        IERC20 baseToken = IERC20(baseTokenAddress);\n        uint256 baseTokenBalance = baseToken.balanceOf(address(this));\n        if (baseTokenBalance < amountReceived) {\n            // Note: It's possible to bypass this check by transferring `baseToken`\n            // directly to Harvester before calling the `harvestAndSwap`. However,\n            // there's no incentive for an attacker to do that. Doing a balance diff\n            // will increase the gas cost significantly\n            revert BalanceMismatchAfterSwap(baseTokenBalance, amountReceived);\n        }\n\n        // Farmer only gets fee from the base amount they helped farm,\n        // They do not get anything from anything that already was there\n        // on the Harvester\n        uint256 farmerFee = amountReceived.mulTruncateScale(\n            tokenConfig.harvestRewardBps,\n            1e4\n        );\n        uint256 protocolYield = baseTokenBalance - farmerFee;\n\n        baseToken.safeTransfer(rewardProceedsAddress, protocolYield);\n        baseToken.safeTransfer(_rewardTo, farmerFee);\n        emit RewardProceedsTransferred(\n            baseTokenAddress,\n            _rewardTo,\n            protocolYield,\n            farmerFee\n        );\n    }\n\n    function _doSwap(\n        SwapPlatform swapPlatform,\n        address routerAddress,\n        address rewardTokenAddress,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        if (swapPlatform == SwapPlatform.UniswapV2Compatible) {\n            return\n                _swapWithUniswapV2(\n                    routerAddress,\n                    rewardTokenAddress,\n                    amountIn,\n                    minAmountOut\n                );\n        } else if (swapPlatform == SwapPlatform.UniswapV3) {\n            return\n                _swapWithUniswapV3(\n                    routerAddress,\n                    rewardTokenAddress,\n                    amountIn,\n                    minAmountOut\n                );\n        } else if (swapPlatform == SwapPlatform.Balancer) {\n            return\n                _swapWithBalancer(\n                    routerAddress,\n                    rewardTokenAddress,\n                    amountIn,\n                    minAmountOut\n                );\n        } else if (swapPlatform == SwapPlatform.Curve) {\n            return\n                _swapWithCurve(\n                    routerAddress,\n                    rewardTokenAddress,\n                    amountIn,\n                    minAmountOut\n                );\n        } else {\n            // Should never be invoked since we catch invalid values\n            // in the `setRewardTokenConfig` function before it's set\n            revert InvalidSwapPlatform(swapPlatform);\n        }\n    }\n\n    /**\n     * @dev Swaps the token to `baseToken` with Uniswap V2\n     *\n     * @param routerAddress Uniswap V2 Router address\n     * @param swapToken Address of the tokenIn\n     * @param amountIn Amount of `swapToken` to swap\n     * @param minAmountOut Minimum expected amount of `baseToken`\n     *\n     * @return amountOut Amount of `baseToken` received after the swap\n     */\n    function _swapWithUniswapV2(\n        address routerAddress,\n        address swapToken,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        address[] memory path = uniswapV2Path[swapToken];\n\n        uint256[] memory amounts = IUniswapV2Router(routerAddress)\n            .swapExactTokensForTokens(\n                amountIn,\n                minAmountOut,\n                path,\n                address(this),\n                block.timestamp\n            );\n\n        amountOut = amounts[amounts.length - 1];\n    }\n\n    /**\n     * @dev Swaps the token to `baseToken` with Uniswap V3\n     *\n     * @param routerAddress Uniswap V3 Router address\n     * @param swapToken Address of the tokenIn\n     * @param amountIn Amount of `swapToken` to swap\n     * @param minAmountOut Minimum expected amount of `baseToken`\n     *\n     * @return amountOut Amount of `baseToken` received after the swap\n     */\n    function _swapWithUniswapV3(\n        address routerAddress,\n        address swapToken,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        bytes memory path = uniswapV3Path[swapToken];\n\n        IUniswapV3Router.ExactInputParams memory params = IUniswapV3Router\n            .ExactInputParams({\n                path: path,\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountIn: amountIn,\n                amountOutMinimum: minAmountOut\n            });\n        amountOut = IUniswapV3Router(routerAddress).exactInput(params);\n    }\n\n    /**\n     * @dev Swaps the token to `baseToken` on Balancer\n     *\n     * @param balancerVaultAddress BalancerVaultAddress\n     * @param swapToken Address of the tokenIn\n     * @param amountIn Amount of `swapToken` to swap\n     * @param minAmountOut Minimum expected amount of `baseToken`\n     *\n     * @return amountOut Amount of `baseToken` received after the swap\n     */\n    function _swapWithBalancer(\n        address balancerVaultAddress,\n        address swapToken,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        bytes32 poolId = balancerPoolId[swapToken];\n\n        IBalancerVault.SingleSwap memory singleSwap = IBalancerVault\n            .SingleSwap({\n                poolId: poolId,\n                kind: IBalancerVault.SwapKind.GIVEN_IN,\n                assetIn: swapToken,\n                assetOut: baseTokenAddress,\n                amount: amountIn,\n                userData: hex\"\"\n            });\n\n        IBalancerVault.FundManagement memory fundMgmt = IBalancerVault\n            .FundManagement({\n                sender: address(this),\n                fromInternalBalance: false,\n                recipient: payable(address(this)),\n                toInternalBalance: false\n            });\n\n        amountOut = IBalancerVault(balancerVaultAddress).swap(\n            singleSwap,\n            fundMgmt,\n            minAmountOut,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Swaps the token to `baseToken` on Curve\n     *\n     * @param poolAddress Curve Pool Address\n     * @param swapToken Address of the tokenIn\n     * @param amountIn Amount of `swapToken` to swap\n     * @param minAmountOut Minimum expected amount of `baseToken`\n     *\n     * @return amountOut Amount of `baseToken` received after the swap\n     */\n    function _swapWithCurve(\n        address poolAddress,\n        address swapToken,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        CurvePoolIndices memory indices = curvePoolIndices[swapToken];\n\n        // Note: Not all CurvePools return the `amountOut`, make sure\n        // to use only pool that do. Otherwise the swap would revert\n        // always\n        amountOut = ICurvePool(poolAddress).exchange(\n            uint256(indices.rewardTokenIndex),\n            uint256(indices.baseTokenIndex),\n            amountIn,\n            minAmountOut\n        );\n    }\n}\n"
    },
    "contracts/harvest/Dripper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\n/**\n * @title OUSD Dripper\n *\n * The dripper contract smooths out the yield from point-in-time yield events\n * and spreads the yield out over a configurable time period. This ensures a\n * continuous per block yield to makes users happy as their next rebase\n * amount is always moving up. Also, this makes historical day to day yields\n * smooth, rather than going from a near zero day, to a large APY day, then\n * back to a near zero day again.\n *\n *\n * Design notes\n * - USDT has a smaller resolution than the number of seconds\n * in a week, which can make per second payouts have a rounding error. However\n * the total effect is not large - cents per day, and this money is\n * not lost, just distributed in the future. While we could use a higher\n * decimal precision for the drip perSecond, we chose simpler code.\n * - By calculating the changing drip rates on collects only, harvests and yield\n * events don't have to call anything on this contract or pay any extra gas.\n * Collect() is already be paying for a single write, since it has to reset\n * the lastCollect time.\n * - By having a collectAndRebase method, and having our external systems call\n * that, the OUSD vault does not need any changes, not even to know the address\n * of the dripper.\n * - A rejected design was to retro-calculate the drip rate on each collect,\n * based on the balance at the time of the collect. While this would have\n * required less state, and would also have made the contract respond more quickly\n * to new income, it would break the predictability that is this contract's entire\n * purpose. If we did this, the amount of fundsAvailable() would make sharp increases\n * when funds were deposited.\n * - When the dripper recalculates the rate, it targets spending the balance over\n * the duration. This means that every time that collect is called, if no\n * new funds have been deposited the duration is being pushed back and the\n * rate decreases. This is expected, and ends up following a smoother but\n * longer curve the more collect() is called without incoming yield.\n *\n */\n\ncontract Dripper is Governable {\n    using SafeERC20 for IERC20;\n\n    struct Drip {\n        uint64 lastCollect; // overflows 262 billion years after the sun dies\n        uint192 perSecond; // drip rate per second\n    }\n\n    address immutable vault; // OUSD vault\n    address immutable token; // token to drip out\n    uint256 public dripDuration; // in seconds\n    Drip public drip; // active drip parameters\n\n    constructor(address _vault, address _token) {\n        vault = _vault;\n        token = _token;\n    }\n\n    /// @notice How much funds have dripped out already and are currently\n    //   available to be sent to the vault.\n    /// @return The amount that would be sent if a collect was called\n    function availableFunds() external view returns (uint256) {\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        return _availableFunds(balance, drip);\n    }\n\n    /// @notice Collect all dripped funds and send to vault.\n    ///  Recalculate new drip rate.\n    function collect() external {\n        _collect();\n    }\n\n    /// @notice Collect all dripped funds, send to vault, recalculate new drip\n    ///  rate, and rebase OUSD.\n    function collectAndRebase() external {\n        _collect();\n        IVault(vault).rebase();\n    }\n\n    /// @dev Change the drip duration. Governor only.\n    /// @param _durationSeconds the number of seconds to drip out the entire\n    ///  balance over if no collects were called during that time.\n    function setDripDuration(uint256 _durationSeconds)\n        external\n        virtual\n        onlyGovernor\n    {\n        require(_durationSeconds > 0, \"duration must be non-zero\");\n        dripDuration = _durationSeconds;\n        _collect(); // duration change take immediate effect\n    }\n\n    /// @dev Transfer out ERC20 tokens held by the contract. Governor only.\n    /// @param _asset ERC20 token address\n    /// @param _amount amount to transfer\n    function transferToken(address _asset, uint256 _amount)\n        external\n        onlyGovernor\n    {\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /// @dev Calculate available funds by taking the lower of either the\n    ///  currently dripped out funds or the balance available.\n    ///  Uses passed in parameters to calculate with for gas savings.\n    /// @param _balance current balance in contract\n    /// @param _drip current drip parameters\n    function _availableFunds(uint256 _balance, Drip memory _drip)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 elapsed = block.timestamp - _drip.lastCollect;\n        uint256 allowed = (elapsed * _drip.perSecond);\n        return (allowed > _balance) ? _balance : allowed;\n    }\n\n    /// @dev Sends the currently dripped funds to be vault, and sets\n    ///  the new drip rate based on the new balance.\n    function _collect() internal virtual {\n        // Calculate send\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        uint256 amountToSend = _availableFunds(balance, drip);\n        uint256 remaining = balance - amountToSend;\n        // Calculate new drip perSecond\n        //   Gas savings by setting entire struct at one time\n        drip = Drip({\n            perSecond: uint192(remaining / dripDuration),\n            lastCollect: uint64(block.timestamp)\n        });\n        // Send funds\n        IERC20(token).safeTransfer(vault, amountToSend);\n    }\n\n    /// @dev Transfer out all ERC20 held by the contract. Governor only.\n    /// @param _asset ERC20 token address\n    function transferAllToken(address _asset, address _receiver)\n        external\n        onlyGovernor\n    {\n        IERC20(_asset).safeTransfer(\n            _receiver,\n            IERC20(_asset).balanceOf(address(this))\n        );\n    }\n}\n"
    },
    "contracts/harvest/FixedRateDripper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { Dripper } from \"./Dripper.sol\";\n\n/**\n * @title Fixed Rate Dripper\n *\n * Similar to the Dripper, Fixed Rate Dripper drips out yield per second.\n * However the Strategist decides the rate and it doesn't change after\n * a drip.\n *\n */\n\ncontract FixedRateDripper is Dripper {\n    using SafeERC20 for IERC20;\n\n    event DripRateUpdated(uint192 oldDripRate, uint192 newDripRate);\n\n    /**\n     * @dev Verifies that the caller is the Governor or Strategist.\n     */\n    modifier onlyGovernorOrStrategist() {\n        require(\n            isGovernor() || msg.sender == IVault(vault).strategistAddr(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    constructor(address _vault, address _token) Dripper(_vault, _token) {}\n\n    /// @inheritdoc Dripper\n    function setDripDuration(uint256) external virtual override {\n        // Not used in FixedRateDripper\n        revert(\"Drip duration disabled\");\n    }\n\n    /// @inheritdoc Dripper\n    function _collect() internal virtual override {\n        // Calculate amount to send\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        uint256 amountToSend = _availableFunds(balance, drip);\n\n        // Update timestamp\n        drip.lastCollect = uint64(block.timestamp);\n\n        // Send funds\n        IERC20(token).safeTransfer(vault, amountToSend);\n    }\n\n    /**\n     * @dev Sets the drip rate. Callable by Strategist or Governor.\n     *      Can be set to zero to stop dripper.\n     * @param _perSecond Rate of WETH to drip per second\n     */\n    function setDripRate(uint192 _perSecond) external onlyGovernorOrStrategist {\n        emit DripRateUpdated(_perSecond, drip.perSecond);\n\n        /**\n         * Note: It's important to call `_collect` before updating\n         * the drip rate especially on a new proxy contract.\n         * When `lastCollect` is not set/initialized, the elapsed\n         * time would be calculated as `block.number` seconds,\n         * resulting in a huge yield, if `collect` isn't called first.\n         */\n        // Collect at existing rate\n        _collect();\n\n        // Update rate\n        drip.perSecond = _perSecond;\n    }\n}\n"
    },
    "contracts/harvest/Harvester.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractHarvester } from \"./AbstractHarvester.sol\";\n\ncontract Harvester is AbstractHarvester {\n    constructor(address _vault, address _usdtAddress)\n        AbstractHarvester(_vault, _usdtAddress)\n    {}\n}\n"
    },
    "contracts/harvest/OETHBaseHarvester.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Governable } from \"../governance/Governable.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\nimport { ISwapRouter } from \"../interfaces/aerodrome/ISwapRouter.sol\";\n\ncontract OETHBaseHarvester is Governable {\n    using SafeERC20 for IERC20;\n\n    IVault public immutable vault;\n    IStrategy public immutable amoStrategy;\n    IERC20 public immutable aero;\n    IERC20 public immutable weth;\n    ISwapRouter public immutable swapRouter;\n\n    address public operatorAddr;\n\n    // Similar sig to `AbstractHarvester.RewardTokenSwapped` for\n    // future compatibility with monitoring\n    event RewardTokenSwapped(\n        address indexed rewardToken,\n        address indexed swappedInto,\n        uint8 swapPlatform,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    event OperatorChanged(address oldOperator, address newOperator);\n    event YieldSent(address recipient, uint256 yield, uint256 fee);\n\n    /**\n     * @notice Verifies that the caller is either Governor or Strategist.\n     */\n    modifier onlyGovernorOrStrategist() {\n        require(\n            msg.sender == vault.strategistAddr() || isGovernor(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Verifies that the caller is either Governor or Strategist.\n     */\n    modifier onlyGovernorOrStrategistOrOperator() {\n        require(\n            msg.sender == operatorAddr ||\n                msg.sender == vault.strategistAddr() ||\n                isGovernor(),\n            \"Caller is not the Operator or Strategist or Governor\"\n        );\n        _;\n    }\n\n    constructor(\n        address _vault,\n        address _amoStrategy,\n        address _aero,\n        address _weth,\n        address _swapRouter\n    ) {\n        vault = IVault(_vault);\n        amoStrategy = IStrategy(_amoStrategy);\n        aero = IERC20(_aero);\n        weth = IERC20(_weth);\n        swapRouter = ISwapRouter(_swapRouter);\n    }\n\n    /**\n     * @dev Changes the operator address which can call `harvest`\n     * @param _operatorAddr New operator address\n     */\n    function setOperatorAddr(address _operatorAddr) external onlyGovernor {\n        emit OperatorChanged(operatorAddr, _operatorAddr);\n        operatorAddr = _operatorAddr;\n    }\n\n    /**\n     * @notice Collects AERO from AMO strategy and\n     *      sends it to the Strategist multisig.\n     *      Anyone can call it.\n     */\n    function harvest() external onlyGovernorOrStrategistOrOperator {\n        address strategistAddr = vault.strategistAddr();\n        require(strategistAddr != address(0), \"Guardian address not set\");\n\n        // Collect all AERO\n        amoStrategy.collectRewardTokens();\n\n        uint256 aeroBalance = aero.balanceOf(address(this));\n        if (aeroBalance == 0) {\n            // Do nothing if there's no AERO to transfer\n            return;\n        }\n\n        // Transfer everything to Strategist\n        aero.safeTransfer(strategistAddr, aeroBalance);\n    }\n\n    /**\n     * @notice Harvests AERO from AMO strategy and then swaps some (or all)\n     *          of it into WETH to distribute yield and fee.\n     *         When `feeBps` is set to 10000 (100%), all WETH received is\n     *          sent to strategist.\n     *\n     * @param aeroToSwap Amount of AERO to swap\n     * @param minWETHExpected Min. amount of WETH to expect\n     * @param feeBps Performance fee bps (Sent to strategist)\n     * @param sendYieldToDripper Sends yield to Dripper, if set to true.\n     *                           Otherwise, to the Guardian\n     */\n    function harvestAndSwap(\n        uint256 aeroToSwap,\n        uint256 minWETHExpected,\n        uint256 feeBps,\n        bool sendYieldToDripper\n    ) external onlyGovernorOrStrategist {\n        address strategistAddr = vault.strategistAddr();\n        require(strategistAddr != address(0), \"Guardian address not set\");\n\n        // Yields can either be sent to the Dripper or Strategist\n        address yieldRecipient = sendYieldToDripper\n            ? vault.dripper()\n            : strategistAddr;\n        require(yieldRecipient != address(0), \"Yield recipient not set\");\n\n        require(feeBps <= 10000, \"Invalid Fee Bps\");\n\n        // Collect all AERO\n        amoStrategy.collectRewardTokens();\n\n        uint256 aeroBalance = aero.balanceOf(address(this));\n        if (aeroBalance == 0) {\n            // Do nothing if there's no AERO to transfer/swap\n            return;\n        }\n\n        if (aeroToSwap > 0) {\n            if (aeroBalance < aeroToSwap) {\n                // Transfer in balance from the multisig as needed\n                // slither-disable-next-line unchecked-transfer arbitrary-send-erc20\n                aero.safeTransferFrom(\n                    strategistAddr,\n                    address(this),\n                    aeroToSwap - aeroBalance\n                );\n            }\n\n            _doSwap(aeroToSwap, minWETHExpected);\n\n            // Figure out AERO left in contract after swap\n            aeroBalance = aero.balanceOf(address(this));\n        }\n\n        // Transfer out any leftover AERO after swap\n        if (aeroBalance > 0) {\n            aero.safeTransfer(strategistAddr, aeroBalance);\n        }\n\n        // Computes using all balance the contract holds,\n        // not just the WETH received from swap. Use `transferToken`\n        // if there's any WETH left that needs to be taken out\n        uint256 availableWETHBalance = weth.balanceOf(address(this));\n        // Computation rounds in favor of protocol\n        uint256 fee = (availableWETHBalance * feeBps) / 10000;\n        uint256 yield = availableWETHBalance - fee;\n\n        // Transfer yield, if any\n        if (yield > 0) {\n            weth.safeTransfer(yieldRecipient, yield);\n        }\n\n        // Transfer fee to the Guardian, if any\n        if (fee > 0) {\n            weth.safeTransfer(strategistAddr, fee);\n        }\n\n        emit YieldSent(yieldRecipient, yield, fee);\n    }\n\n    /**\n     * @notice Swaps AERO to WETH on Aerodrome\n     * @param aeroToSwap Amount of AERO to swap\n     * @param minWETHExpected Min. amount of WETH to expect\n     */\n    function _doSwap(uint256 aeroToSwap, uint256 minWETHExpected) internal {\n        // Let the swap router move funds\n        aero.approve(address(swapRouter), aeroToSwap);\n\n        // Do the swap\n        uint256 wethReceived = swapRouter.exactInputSingle(\n            ISwapRouter.ExactInputSingleParams({\n                tokenIn: address(aero),\n                tokenOut: address(weth),\n                tickSpacing: 200, // From AERO/WETH pool contract\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountIn: aeroToSwap,\n                amountOutMinimum: minWETHExpected,\n                sqrtPriceLimitX96: 0\n            })\n        );\n\n        emit RewardTokenSwapped(\n            address(aero),\n            address(weth),\n            0,\n            aeroToSwap,\n            wethReceived\n        );\n    }\n\n    /**\n     * @notice Transfer token to governor. Intended for recovering tokens stuck in\n     *      the contract, i.e. mistaken sends.\n     *      Also, allows to transfer any AERO left in the contract.\n     * @param _asset Address for the asset\n     * @param _amount Amount of the asset to transfer\n     */\n    function transferToken(address _asset, uint256 _amount)\n        external\n        virtual\n        onlyGovernor\n    {\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n}\n"
    },
    "contracts/harvest/OETHDripper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Dripper } from \"./Dripper.sol\";\n\n/**\n * @title OETH Dripper Contract\n * @author Origin Protocol Inc\n */\ncontract OETHDripper is Dripper {\n    constructor(address _vault, address _token) Dripper(_vault, _token) {}\n}\n"
    },
    "contracts/harvest/OETHFixedRateDripper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { FixedRateDripper } from \"./FixedRateDripper.sol\";\n\n/**\n * @title OETH FixedRateDripper Contract\n * @author Origin Protocol Inc\n */\ncontract OETHFixedRateDripper is FixedRateDripper {\n    constructor(address _vault, address _token)\n        FixedRateDripper(_vault, _token)\n    {}\n}\n"
    },
    "contracts/harvest/OETHHarvester.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractHarvester } from \"./AbstractHarvester.sol\";\n\ncontract OETHHarvester is AbstractHarvester {\n    constructor(address _vault, address _wethAddress)\n        AbstractHarvester(_vault, _wethAddress)\n    {}\n}\n"
    },
    "contracts/harvest/OETHHarvesterSimple.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Strategizable } from \"../governance/Strategizable.sol\";\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Initializable } from \"../utils/Initializable.sol\";\n\n/// @title OETH Harvester Simple Contract\n/// @notice Contract to harvest rewards from strategies\n/// @author Origin Protocol Inc\ncontract OETHHarvesterSimple is Initializable, Strategizable {\n    using SafeERC20 for IERC20;\n\n    ////////////////////////////////////////////////////\n    /// --- CONSTANTS & IMMUTABLES\n    ////////////////////////////////////////////////////\n    /// @notice wrapped native token address (WETH or wS)\n    address public immutable wrappedNativeToken;\n\n    ////////////////////////////////////////////////////\n    /// --- STORAGE\n    ////////////////////////////////////////////////////\n    /// @notice Dripper address\n    address public dripper;\n\n    /// @notice Mapping of supported strategies\n    mapping(address => bool) public supportedStrategies;\n\n    /// @notice Gap for upgrade safety\n    uint256[48] private ___gap;\n\n    ////////////////////////////////////////////////////\n    /// --- EVENTS\n    ////////////////////////////////////////////////////\n    event Harvested(\n        address indexed strategy,\n        address token,\n        uint256 amount,\n        address indexed receiver\n    );\n    event SupportedStrategyUpdated(address strategy, bool status);\n    event DripperUpdated(address dripper);\n\n    ////////////////////////////////////////////////////\n    /// --- CONSTRUCTOR\n    ////////////////////////////////////////////////////\n    constructor(address _wrappedNativeToken) {\n        wrappedNativeToken = _wrappedNativeToken;\n\n        // prevent implementation contract to be governed\n        _setGovernor(address(0));\n    }\n\n    /// @notice Initialize the contract\n    function initialize() external onlyGovernor initializer {\n        // Call it to set `initialized` to true and to prevent the implementation\n        // from getting initialized in future through the proxy\n    }\n\n    ////////////////////////////////////////////////////\n    /// --- MUTATIVE FUNCTIONS\n    ////////////////////////////////////////////////////\n    /// @notice Harvest rewards from a strategy and transfer to strategist or dripper\n    /// @param _strategy Address of the strategy to harvest\n    function harvestAndTransfer(address _strategy) external {\n        _harvestAndTransfer(_strategy);\n    }\n\n    /// @notice Harvest rewards from multiple strategies and transfer to strategist or dripper\n    /// @param _strategies Array of strategy addresses to harvest\n    function harvestAndTransfer(address[] calldata _strategies) external {\n        for (uint256 i = 0; i < _strategies.length; i++) {\n            _harvestAndTransfer(_strategies[i]);\n        }\n    }\n\n    /// @notice Internal logic to harvest rewards from a strategy\n    function _harvestAndTransfer(address _strategy) internal virtual {\n        // Ensure strategy is supported\n        require(supportedStrategies[_strategy], \"Strategy not supported\");\n\n        // Store locally for some gas savings\n        address _strategist = strategistAddr;\n        address _dripper = dripper;\n\n        // Harvest rewards\n        IStrategy(_strategy).collectRewardTokens();\n\n        // Cache reward tokens\n        address[] memory rewardTokens = IStrategy(_strategy)\n            .getRewardTokenAddresses();\n\n        uint256 len = rewardTokens.length;\n        for (uint256 i = 0; i < len; i++) {\n            // Cache balance\n            address token = rewardTokens[i];\n            uint256 balance = IERC20(token).balanceOf(address(this));\n            if (balance > 0) {\n                // Determine receiver\n                address receiver = token == wrappedNativeToken\n                    ? _dripper\n                    : _strategist;\n                require(receiver != address(0), \"Invalid receiver\");\n\n                // Transfer to the Strategist or the Dripper\n                IERC20(token).safeTransfer(receiver, balance);\n                emit Harvested(_strategy, token, balance, receiver);\n            }\n        }\n    }\n\n    ////////////////////////////////////////////////////\n    /// --- GOVERNANCE\n    ////////////////////////////////////////////////////\n    /// @notice Set supported strategy\n    /// @param _strategy Address of the strategy\n    /// @param _isSupported Boolean indicating if strategy is supported\n    function setSupportedStrategy(address _strategy, bool _isSupported)\n        external\n        onlyGovernorOrStrategist\n    {\n        require(_strategy != address(0), \"Invalid strategy\");\n        supportedStrategies[_strategy] = _isSupported;\n        emit SupportedStrategyUpdated(_strategy, _isSupported);\n    }\n\n    /// @notice Transfer tokens to strategist\n    /// @param _asset Address of the token\n    /// @param _amount Amount of tokens to transfer\n    function transferToken(address _asset, uint256 _amount)\n        external\n        onlyGovernorOrStrategist\n    {\n        IERC20(_asset).safeTransfer(strategistAddr, _amount);\n    }\n\n    /// @notice Set the dripper address\n    /// @param _dripper Address of the dripper\n    function setDripper(address _dripper) external onlyGovernor {\n        _setDripper(_dripper);\n    }\n\n    /// @notice Internal logic to set the dripper address\n    function _setDripper(address _dripper) internal {\n        require(_dripper != address(0), \"Invalid dripper\");\n        dripper = _dripper;\n        emit DripperUpdated(_dripper);\n    }\n}\n"
    },
    "contracts/harvest/OSonicHarvester.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { SuperOETHHarvester } from \"./SuperOETHHarvester.sol\";\n\ncontract OSonicHarvester is SuperOETHHarvester {\n    /// @param _wrappedNativeToken Address of the native Wrapped S (wS) token\n    constructor(address _wrappedNativeToken)\n        SuperOETHHarvester(_wrappedNativeToken)\n    {}\n}\n"
    },
    "contracts/harvest/SuperOETHHarvester.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { OETHHarvesterSimple, IERC20, IStrategy, SafeERC20 } from \"./OETHHarvesterSimple.sol\";\n\ncontract SuperOETHHarvester is OETHHarvesterSimple {\n    using SafeERC20 for IERC20;\n\n    constructor(address _wrappedNativeToken)\n        OETHHarvesterSimple(_wrappedNativeToken)\n    {}\n\n    /// @inheritdoc OETHHarvesterSimple\n    function _harvestAndTransfer(address _strategy) internal virtual override {\n        // Ensure strategy is supported\n        require(supportedStrategies[_strategy], \"Strategy not supported\");\n\n        address receiver = strategistAddr;\n        require(receiver != address(0), \"Invalid receiver\");\n\n        // Harvest rewards\n        IStrategy(_strategy).collectRewardTokens();\n\n        // Cache reward tokens\n        address[] memory rewardTokens = IStrategy(_strategy)\n            .getRewardTokenAddresses();\n\n        uint256 len = rewardTokens.length;\n        for (uint256 i = 0; i < len; i++) {\n            // Cache balance\n            address token = rewardTokens[i];\n            uint256 balance = IERC20(token).balanceOf(address(this));\n            if (balance > 0) {\n                // Transfer everything to the strategist\n                IERC20(token).safeTransfer(receiver, balance);\n                emit Harvested(_strategy, token, balance, receiver);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/aerodrome/ICLGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface ICLGauge {\n    /// @notice Returns the claimable rewards for a given account and tokenId\n    /// @dev Throws if account is not the position owner\n    /// @dev pool.updateRewardsGrowthGlobal() needs to be called first, to return the correct claimable rewards\n    /// @param account The address of the user\n    /// @param tokenId The tokenId of the position\n    /// @return The amount of claimable reward\n    function earned(address account, uint256 tokenId)\n        external\n        view\n        returns (uint256);\n\n    /// @notice Retrieve rewards for all tokens owned by an account\n    /// @dev Throws if not called by the voter\n    /// @param account The account of the user\n    function getReward(address account) external;\n\n    /// @notice Retrieve rewards for a tokenId\n    /// @dev Throws if not called by the position owner\n    /// @param tokenId The tokenId of the position\n    function getReward(uint256 tokenId) external;\n\n    /// @notice Notifies gauge of gauge rewards.\n    /// @param amount Amount of gauge rewards (emissions) to notify. Must be greater than 604_800.\n    function notifyRewardAmount(uint256 amount) external;\n\n    /// @dev Notifies gauge of gauge rewards without distributing its fees.\n    ///      Assumes gauge reward tokens is 18 decimals.\n    ///      If not 18 decimals, rewardRate may have rounding issues.\n    /// @param amount Amount of gauge rewards (emissions) to notify. Must be greater than 604_800.\n    function notifyRewardWithoutClaim(uint256 amount) external;\n\n    /// @notice Used to deposit a CL position into the gauge\n    /// @notice Allows the user to receive emissions instead of fees\n    /// @param tokenId The tokenId of the position\n    function deposit(uint256 tokenId) external;\n\n    /// @notice Used to withdraw a CL position from the gauge\n    /// @notice Allows the user to receive fees instead of emissions\n    /// @notice Outstanding emissions will be collected on withdrawal\n    /// @param tokenId The tokenId of the position\n    function withdraw(uint256 tokenId) external;\n\n    // /// @notice Fetch all tokenIds staked by a given account\n    // /// @param depositor The address of the user\n    // /// @return The tokenIds of the staked positions\n    // function stakedValues(address depositor) external view returns (uint256[] memory);\n\n    // /// @notice Fetch a staked tokenId by index\n    // /// @param depositor The address of the user\n    // /// @param index The index of the staked tokenId\n    // /// @return The tokenId of the staked position\n    // function stakedByIndex(address depositor, uint256 index) external view returns (uint256);\n\n    // /// @notice Check whether a position is staked in the gauge by a certain user\n    // /// @param depositor The address of the user\n    // /// @param tokenId The tokenId of the position\n    // /// @return Whether the position is staked in the gauge\n    // function stakedContains(address depositor, uint256 tokenId) external view returns (bool);\n\n    // /// @notice The amount of positions staked in the gauge by a certain user\n    // /// @param depositor The address of the user\n    // /// @return The amount of positions staked in the gauge\n    // function stakedLength(address depositor) external view returns (uint256);\n\n    function feesVotingReward() external view returns (address);\n}\n"
    },
    "contracts/interfaces/aerodrome/ICLPool.sol": {
      "content": "pragma solidity >=0.5.0;\n\n/// @title The interface for a CL Pool\n/// @notice A CL pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface ICLPool {\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            bool unlocked\n        );\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The gauge corresponding to this pool\n    /// @return The gauge contract address\n    function gauge() external view returns (address);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    /// @dev This value includes staked liquidity\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from\n    /// the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise\n    /// equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n}\n"
    },
    "contracts/interfaces/aerodrome/INonfungiblePositionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Non-fungible token for positions\n/// @notice Wraps CL positions in a non-fungible token interface which allows for them to be transferred\n/// and authorized.\n// slither-disable-start erc20-interface\ninterface INonfungiblePositionManager {\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) external returns (address);\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    /// @notice Returns the position information associated with a given token ID.\n    /// @dev Throws if the token ID is not valid.\n    /// @param tokenId The ID of the token that represents the position\n    /// @return nonce The nonce for permits\n    /// @return operator The address that is approved for spending\n    /// @return token0 The address of the token0 for a specific pool\n    /// @return token1 The address of the token1 for a specific pool\n    /// @return tickSpacing The tick spacing associated with the pool\n    /// @return tickLower The lower end of the tick range for the position\n    /// @return tickUpper The higher end of the tick range for the position\n    /// @return liquidity The liquidity of the position\n    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\n    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\n    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\n    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            int24 tickSpacing,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    struct MintParams {\n        address token0;\n        address token1;\n        int24 tickSpacing;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n        uint160 sqrtPriceX96;\n    }\n\n    /// @notice Creates a new position wrapped in a NFT\n    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\n    /// a method does not exist, i.e. the pool is assumed to be initialized.\n    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\n    /// @return tokenId The ID of the token that represents the minted position\n    /// @return liquidity The amount of liquidity for this position\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function mint(MintParams calldata params)\n        external\n        payable\n        returns (\n            uint256 tokenId,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\n    /// @param params tokenId The ID of the token for which liquidity is being increased,\n    /// amount0Desired The desired amount of token0 to be spent,\n    /// amount1Desired The desired amount of token1 to be spent,\n    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\n    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return liquidity The new liquidity amount as a result of the increase\n    /// @return amount0 The amount of token0 to acheive resulting liquidity\n    /// @return amount1 The amount of token1 to acheive resulting liquidity\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Decreases the amount of liquidity in a position and accounts it to the position\n    /// @param params tokenId The ID of the token for which liquidity is being decreased,\n    /// amount The amount by which liquidity will be decreased,\n    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\n    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return amount0 The amount of token0 accounted to the position's tokens owed\n    /// @return amount1 The amount of token1 accounted to the position's tokens owed\n    /// @dev The use of this function can cause a loss to users of the NonfungiblePositionManager\n    /// @dev for tokens that have very high decimals.\n    /// @dev The amount of tokens necessary for the loss is: 3.4028237e+38.\n    /// @dev This is equivalent to 1e20 value with 18 decimals.\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\n    /// @notice Used to update staked positions before deposit and withdraw\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\n    /// recipient The account that should receive the tokens,\n    /// amount0Max The maximum amount of token0 to collect,\n    /// amount1Max The maximum amount of token1 to collect\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(CollectParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\n    /// must be collected first.\n    /// @param tokenId The ID of the token that is being burned\n    function burn(uint256 tokenId) external payable;\n\n    /// @notice Sets a new Token Descriptor\n    /// @param _tokenDescriptor Address of the new Token Descriptor to be chosen\n    function setTokenDescriptor(address _tokenDescriptor) external;\n\n    /// @notice Sets a new Owner address\n    /// @param _owner Address of the new Owner to be chosen\n    function setOwner(address _owner) external;\n}\n// slither-disable-end erc20-interface\n"
    },
    "contracts/interfaces/aerodrome/ISugarHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\npragma abicoder v2;\n\nimport { INonfungiblePositionManager } from \"./INonfungiblePositionManager.sol\";\n\ninterface ISugarHelper {\n    struct PopulatedTick {\n        int24 tick;\n        uint160 sqrtRatioX96;\n        int128 liquidityNet;\n        uint128 liquidityGross;\n    }\n\n    ///\n    /// Wrappers for LiquidityAmounts\n    ///\n\n    function getAmountsForLiquidity(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) external pure returns (uint256 amount0, uint256 amount1);\n\n    function getLiquidityForAmounts(\n        uint256 amount0,\n        uint256 amount1,\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96\n    ) external pure returns (uint128 liquidity);\n\n    /// @notice Computes the amount of token0 for a given amount of token1 and price range\n    /// @param amount1 Amount of token1 to estimate liquidity\n    /// @param pool Address of the pool to be used\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param tickLow Lower tick boundary\n    /// @param tickLow Upper tick boundary\n    /// @dev   If the given pool address is not the zero address, will fetch `sqrtRatioX96` from pool\n    /// @return amount0 Estimated amount of token0\n    function estimateAmount0(\n        uint256 amount1,\n        address pool,\n        uint160 sqrtRatioX96,\n        int24 tickLow,\n        int24 tickHigh\n    ) external view returns (uint256 amount0);\n\n    /// @notice Computes the amount of token1 for a given amount of token0 and price range\n    /// @param amount0 Amount of token0 to estimate liquidity\n    /// @param pool Address of the pool to be used\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param tickLow Lower tick boundary\n    /// @param tickLow Upper tick boundary\n    /// @dev   If the given pool address is not the zero address, will fetch `sqrtRatioX96` from pool\n    /// @return amount1 Estimated amount of token1\n    function estimateAmount1(\n        uint256 amount0,\n        address pool,\n        uint160 sqrtRatioX96,\n        int24 tickLow,\n        int24 tickHigh\n    ) external view returns (uint256 amount1);\n\n    ///\n    /// Wrappers for PositionValue\n    ///\n\n    function principal(\n        INonfungiblePositionManager positionManager,\n        uint256 tokenId,\n        uint160 sqrtRatioX96\n    ) external view returns (uint256 amount0, uint256 amount1);\n\n    function fees(INonfungiblePositionManager positionManager, uint256 tokenId)\n        external\n        view\n        returns (uint256 amount0, uint256 amount1);\n\n    ///\n    /// Wrappers for TickMath\n    ///\n\n    function getSqrtRatioAtTick(int24 tick)\n        external\n        pure\n        returns (uint160 sqrtRatioX96);\n\n    function getTickAtSqrtRatio(uint160 sqrtRatioX96)\n        external\n        pure\n        returns (int24 tick);\n\n    /// @notice Fetches Tick Data for all populated Ticks in given bitmaps\n    /// @param pool Address of the pool from which to fetch data\n    /// @param startTick Tick from which the first bitmap will be fetched\n    /// @dev   The number of bitmaps fetched by this function should always be `MAX_BITMAPS`,\n    ///        unless there are less than `MAX_BITMAPS` left to iterate through\n    /// @return populatedTicks Array of all Populated Ticks in the provided bitmaps\n    function getPopulatedTicks(address pool, int24 startTick)\n        external\n        view\n        returns (PopulatedTick[] memory populatedTicks);\n}\n"
    },
    "contracts/interfaces/aerodrome/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via CL\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        int24 tickSpacing;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        int24 tickSpacing;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params)\n        external\n        payable\n        returns (uint256 amountIn);\n}\n"
    },
    "contracts/interfaces/balancer/IBalancerVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"../../utils/InitializableAbstractStrategy.sol\";\n\ninterface IBalancerVault {\n    enum WeightedPoolJoinKind {\n        INIT,\n        EXACT_TOKENS_IN_FOR_BPT_OUT,\n        TOKEN_IN_FOR_EXACT_BPT_OUT,\n        ALL_TOKENS_IN_FOR_EXACT_BPT_OUT,\n        ADD_TOKEN\n    }\n\n    enum WeightedPoolExitKind {\n        EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n        EXACT_BPT_IN_FOR_TOKENS_OUT,\n        BPT_IN_FOR_EXACT_TOKENS_OUT,\n        REMOVE_TOKEN\n    }\n\n    /**\n     * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\n     * Pool shares.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\n     * these maximums.\n     *\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\n     * back to the caller (not the sender, which is important for relayers).\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\n     *\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\n     *\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\n     * directly to the Pool's contract, as is `recipient`.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n\n    struct JoinPoolRequest {\n        address[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n\n    /**\n     * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\n     * `getPoolTokenInfo`).\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\n     * it just enforces these minimums.\n     *\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\n     *\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\n     * do so will trigger a revert.\n     *\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\n     * `tokens` array. This array must match the Pool's registered tokens.\n     *\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\n     * passed directly to the Pool's contract.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external;\n\n    struct ExitPoolRequest {\n        address[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n\n    /**\n     * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\n     * the tokens' `balances` changed.\n     *\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\n     *\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\n     * order as passed to `registerTokens`.\n     *\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\n     * instead.\n     */\n    function getPoolTokens(bytes32 poolId)\n        external\n        view\n        returns (\n            IERC20[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangeBlock\n        );\n\n    /**\n     * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\n     * it lets integrators reuse a user's Vault allowance.\n     *\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\n     */\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable;\n\n    struct UserBalanceOp {\n        UserBalanceOpKind kind;\n        address asset;\n        uint256 amount;\n        address sender;\n        address payable recipient;\n    }\n\n    enum UserBalanceOpKind {\n        DEPOSIT_INTERNAL,\n        WITHDRAW_INTERNAL,\n        TRANSFER_INTERNAL,\n        TRANSFER_EXTERNAL\n    }\n\n    enum SwapKind {\n        GIVEN_IN,\n        GIVEN_OUT\n    }\n\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        address assetIn;\n        address assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n\n    function swap(\n        SingleSwap calldata singleSwap,\n        FundManagement calldata funds,\n        uint256 limit,\n        uint256 deadline\n    ) external returns (uint256 amountCalculated);\n\n    function getPoolTokenInfo(bytes32 poolId, address token)\n        external\n        view\n        returns (\n            uint256 cash,\n            uint256 managed,\n            uint256 lastChangeBlock,\n            address assetManager\n        );\n}\n"
    },
    "contracts/interfaces/balancer/IMetaStablePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IRateProvider } from \"./IRateProvider.sol\";\n\ninterface IMetaStablePool {\n    function getRateProviders()\n        external\n        view\n        returns (IRateProvider[] memory providers);\n}\n"
    },
    "contracts/interfaces/balancer/IRateProvider.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\ninterface IRateProvider {\n    function getRate() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/cctp/ICCTP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface ICCTPTokenMessenger {\n    function depositForBurn(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller,\n        uint256 maxFee,\n        uint32 minFinalityThreshold\n    ) external;\n\n    function depositForBurnWithHook(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller,\n        uint256 maxFee,\n        uint32 minFinalityThreshold,\n        bytes memory hookData\n    ) external;\n\n    function getMinFeeAmount(uint256 amount) external view returns (uint256);\n}\n\ninterface ICCTPMessageTransmitter {\n    function sendMessage(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        uint32 minFinalityThreshold,\n        bytes memory messageBody\n    ) external;\n\n    function receiveMessage(bytes calldata message, bytes calldata attestation)\n        external\n        returns (bool);\n}\n\ninterface IMessageHandlerV2 {\n    /**\n     * @notice Handles an incoming finalized message from an IReceiverV2\n     * @dev Finalized messages have finality threshold values greater than or equal to 2000\n     * @param sourceDomain The source domain of the message\n     * @param sender The sender of the message\n     * @param finalityThresholdExecuted the finality threshold at which the message was attested to\n     * @param messageBody The raw bytes of the message body\n     * @return success True, if successful; false, if not.\n     */\n    function handleReceiveFinalizedMessage(\n        uint32 sourceDomain,\n        bytes32 sender,\n        uint32 finalityThresholdExecuted,\n        bytes calldata messageBody\n    ) external returns (bool);\n\n    /**\n     * @notice Handles an incoming unfinalized message from an IReceiverV2\n     * @dev Unfinalized messages have finality threshold values less than 2000\n     * @param sourceDomain The source domain of the message\n     * @param sender The sender of the message\n     * @param finalityThresholdExecuted The finality threshold at which the message was attested to\n     * @param messageBody The raw bytes of the message body\n     * @return success True, if successful; false, if not.\n     */\n    function handleReceiveUnfinalizedMessage(\n        uint32 sourceDomain,\n        bytes32 sender,\n        uint32 finalityThresholdExecuted,\n        bytes calldata messageBody\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/chainlink/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "contracts/interfaces/IBasicToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBasicToken {\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IBeaconProofs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IBeaconProofs {\n    function verifyValidator(\n        bytes32 beaconBlockRoot,\n        bytes32 pubKeyHash,\n        bytes calldata validatorPubKeyProof,\n        uint40 validatorIndex,\n        bytes32 withdrawalCredentials\n    ) external view;\n\n    function verifyValidatorWithdrawable(\n        bytes32 beaconBlockRoot,\n        uint40 validatorIndex,\n        uint64 withdrawableEpoch,\n        bytes calldata withdrawableEpochProof\n    ) external view;\n\n    function verifyBalancesContainer(\n        bytes32 beaconBlockRoot,\n        bytes32 balancesContainerLeaf,\n        bytes calldata balancesContainerProof\n    ) external view;\n\n    function verifyValidatorBalance(\n        bytes32 balancesContainerRoot,\n        bytes32 validatorBalanceLeaf,\n        bytes calldata balanceProof,\n        uint40 validatorIndex\n    ) external view returns (uint256 validatorBalance);\n\n    function verifyPendingDepositsContainer(\n        bytes32 beaconBlockRoot,\n        bytes32 pendingDepositsContainerRoot,\n        bytes calldata proof\n    ) external view;\n\n    function verifyPendingDeposit(\n        bytes32 pendingDepositsContainerRoot,\n        bytes32 pendingDepositRoot,\n        bytes calldata proof,\n        uint32 pendingDepositIndex\n    ) external view;\n\n    function verifyFirstPendingDeposit(\n        bytes32 beaconBlockRoot,\n        uint64 slot,\n        bytes calldata firstPendingDepositSlotProof\n    ) external view returns (bool isEmptyDepositQueue);\n\n    function merkleizePendingDeposit(\n        bytes32 pubKeyHash,\n        bytes calldata withdrawalCredentials,\n        uint64 amountGwei,\n        bytes calldata signature,\n        uint64 slot\n    ) external pure returns (bytes32 root);\n\n    function merkleizeSignature(bytes calldata signature)\n        external\n        pure\n        returns (bytes32 root);\n}\n"
    },
    "contracts/interfaces/ICampaignRemoteManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface ICampaignRemoteManager {\n    function createCampaign(\n        CampaignCreationParams memory params,\n        uint256 destinationChainId,\n        uint256 additionalGasLimit,\n        address votemarket\n    ) external payable;\n\n    function manageCampaign(\n        CampaignManagementParams memory params,\n        uint256 destinationChainId,\n        uint256 additionalGasLimit,\n        address votemarket\n    ) external payable;\n\n    function closeCampaign(\n        CampaignClosingParams memory params,\n        uint256 destinationChainId,\n        uint256 additionalGasLimit,\n        address votemarket\n    ) external payable;\n\n    struct CampaignCreationParams {\n        uint256 chainId;\n        address gauge;\n        address manager;\n        address rewardToken;\n        uint8 numberOfPeriods;\n        uint256 maxRewardPerVote;\n        uint256 totalRewardAmount;\n        address[] addresses;\n        address hook;\n        bool isWhitelist;\n    }\n\n    struct CampaignManagementParams {\n        uint256 campaignId;\n        address rewardToken;\n        uint8 numberOfPeriods;\n        uint256 totalRewardAmount;\n        uint256 maxRewardPerVote;\n    }\n\n    struct CampaignClosingParams {\n        uint256 campaignId;\n    }\n}\n"
    },
    "contracts/interfaces/IChildLiquidityGaugeFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\ninterface IChildLiquidityGaugeFactory {\n    event DeployedGauge(\n        address indexed _implementation,\n        address indexed _lp_token,\n        address indexed _deployer,\n        bytes32 _salt,\n        address _gauge\n    );\n    event Minted(\n        address indexed _user,\n        address indexed _gauge,\n        uint256 _new_total\n    );\n    event TransferOwnership(address _old_owner, address _new_owner);\n    event UpdateCallProxy(address _old_call_proxy, address _new_call_proxy);\n    event UpdateImplementation(\n        address _old_implementation,\n        address _new_implementation\n    );\n    event UpdateManager(address _manager);\n    event UpdateMirrored(address indexed _gauge, bool _mirrored);\n    event UpdateRoot(address _factory, address _implementation);\n    event UpdateVotingEscrow(\n        address _old_voting_escrow,\n        address _new_voting_escrow\n    );\n\n    function accept_transfer_ownership() external;\n\n    function call_proxy() external view returns (address);\n\n    function commit_transfer_ownership(address _future_owner) external;\n\n    function crv() external view returns (address);\n\n    function deploy_gauge(address _lp_token, bytes32 _salt)\n        external\n        returns (address);\n\n    function deploy_gauge(\n        address _lp_token,\n        bytes32 _salt,\n        address _manager\n    ) external returns (address);\n\n    function future_owner() external view returns (address);\n\n    function gauge_data(address arg0) external view returns (uint256);\n\n    function get_gauge(uint256 arg0) external view returns (address);\n\n    function get_gauge_count() external view returns (uint256);\n\n    function get_gauge_from_lp_token(address arg0)\n        external\n        view\n        returns (address);\n\n    function get_implementation() external view returns (address);\n\n    function is_mirrored(address _gauge) external view returns (bool);\n\n    function is_valid_gauge(address _gauge) external view returns (bool);\n\n    function last_request(address _gauge) external view returns (uint256);\n\n    function manager() external view returns (address);\n\n    function mint(address _gauge) external;\n\n    function mint_many(address[32] memory _gauges) external;\n\n    function minted(address arg0, address arg1) external view returns (uint256);\n\n    function owner() external view returns (address);\n\n    function root_factory() external view returns (address);\n\n    function root_implementation() external view returns (address);\n\n    function set_call_proxy(address _new_call_proxy) external;\n\n    function set_crv(address _crv) external;\n\n    function set_implementation(address _implementation) external;\n\n    function set_manager(address _new_manager) external;\n\n    function set_mirrored(address _gauge, bool _mirrored) external;\n\n    function set_root(address _factory, address _implementation) external;\n\n    function set_voting_escrow(address _voting_escrow) external;\n\n    function version() external view returns (string memory);\n\n    function voting_escrow() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IComptroller {\n    // Claim all the COMP accrued by specific holders in specific markets for their supplies and/or borrows\n    function claimComp(\n        address[] memory holders,\n        address[] memory cTokens,\n        bool borrowers,\n        bool suppliers\n    ) external;\n\n    function oracle() external view returns (address);\n}\n"
    },
    "contracts/interfaces/ICreateX.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.4;\n\n/**\n * @title CreateX Factory Interface Definition\n * @author pcaversaccio (https://web.archive.org/web/20230921103111/https://pcaversaccio.com/)\n * @custom:coauthor Matt Solomon (https://web.archive.org/web/20230921103335/https://mattsolomon.dev/)\n */\ninterface ICreateX {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                            TYPES                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    struct Values {\n        uint256 constructorAmount;\n        uint256 initCallAmount;\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                           EVENTS                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    event ContractCreation(address indexed newContract, bytes32 indexed salt);\n    event ContractCreation(address indexed newContract);\n    event Create3ProxyContractCreation(\n        address indexed newContract,\n        bytes32 indexed salt\n    );\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    error FailedContractCreation(address emitter);\n    error FailedContractInitialisation(address emitter, bytes revertData);\n    error InvalidSalt(address emitter);\n    error InvalidNonceValue(address emitter);\n    error FailedEtherTransfer(address emitter, bytes revertData);\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                           CREATE                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    function deployCreate(bytes memory initCode)\n        external\n        payable\n        returns (address newContract);\n\n    function deployCreateAndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values,\n        address refundAddress\n    ) external payable returns (address newContract);\n\n    function deployCreateAndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values\n    ) external payable returns (address newContract);\n\n    function deployCreateClone(address implementation, bytes memory data)\n        external\n        payable\n        returns (address proxy);\n\n    function computeCreateAddress(address deployer, uint256 nonce)\n        external\n        view\n        returns (address computedAddress);\n\n    function computeCreateAddress(uint256 nonce)\n        external\n        view\n        returns (address computedAddress);\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                           CREATE2                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    function deployCreate2(bytes32 salt, bytes memory initCode)\n        external\n        payable\n        returns (address newContract);\n\n    function deployCreate2(bytes memory initCode)\n        external\n        payable\n        returns (address newContract);\n\n    function deployCreate2AndInit(\n        bytes32 salt,\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values,\n        address refundAddress\n    ) external payable returns (address newContract);\n\n    function deployCreate2AndInit(\n        bytes32 salt,\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values\n    ) external payable returns (address newContract);\n\n    function deployCreate2AndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values,\n        address refundAddress\n    ) external payable returns (address newContract);\n\n    function deployCreate2AndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values\n    ) external payable returns (address newContract);\n\n    function deployCreate2Clone(\n        bytes32 salt,\n        address implementation,\n        bytes memory data\n    ) external payable returns (address proxy);\n\n    function deployCreate2Clone(address implementation, bytes memory data)\n        external\n        payable\n        returns (address proxy);\n\n    function computeCreate2Address(\n        bytes32 salt,\n        bytes32 initCodeHash,\n        address deployer\n    ) external pure returns (address computedAddress);\n\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash)\n        external\n        view\n        returns (address computedAddress);\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                           CREATE3                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    function deployCreate3(bytes32 salt, bytes memory initCode)\n        external\n        payable\n        returns (address newContract);\n\n    function deployCreate3(bytes memory initCode)\n        external\n        payable\n        returns (address newContract);\n\n    function deployCreate3AndInit(\n        bytes32 salt,\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values,\n        address refundAddress\n    ) external payable returns (address newContract);\n\n    function deployCreate3AndInit(\n        bytes32 salt,\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values\n    ) external payable returns (address newContract);\n\n    function deployCreate3AndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values,\n        address refundAddress\n    ) external payable returns (address newContract);\n\n    function deployCreate3AndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values\n    ) external payable returns (address newContract);\n\n    function computeCreate3Address(bytes32 salt, address deployer)\n        external\n        pure\n        returns (address computedAddress);\n\n    function computeCreate3Address(bytes32 salt)\n        external\n        view\n        returns (address computedAddress);\n}\n"
    },
    "contracts/interfaces/ICurveLiquidityGaugeV6.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\ninterface ICurveLiquidityGaugeV6 {\n    event ApplyOwnership(address admin);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n    event CommitOwnership(address admin);\n    event Deposit(address indexed provider, uint256 value);\n    event SetGaugeManager(address _gauge_manager);\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event UpdateLiquidityLimit(\n        address indexed user,\n        uint256 original_balance,\n        uint256 original_supply,\n        uint256 working_balance,\n        uint256 working_supply\n    );\n    event Withdraw(address indexed provider, uint256 value);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function add_reward(address _reward_token, address _distributor) external;\n\n    function allowance(address arg0, address arg1)\n        external\n        view\n        returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function balanceOf(address arg0) external view returns (uint256);\n\n    function claim_rewards() external;\n\n    function claim_rewards(address _addr) external;\n\n    function claim_rewards(address _addr, address _receiver) external;\n\n    function claimable_reward(address _user, address _reward_token)\n        external\n        view\n        returns (uint256);\n\n    function claimable_tokens(address addr) external returns (uint256);\n\n    function claimed_reward(address _addr, address _token)\n        external\n        view\n        returns (uint256);\n\n    function decimals() external view returns (uint256);\n\n    function decreaseAllowance(address _spender, uint256 _subtracted_value)\n        external\n        returns (bool);\n\n    function deposit(uint256 _value) external;\n\n    function deposit(uint256 _value, address _addr) external;\n\n    function deposit(\n        uint256 _value,\n        address _addr,\n        bool _claim_rewards\n    ) external;\n\n    function deposit_reward_token(address _reward_token, uint256 _amount)\n        external;\n\n    function deposit_reward_token(\n        address _reward_token,\n        uint256 _amount,\n        uint256 _epoch\n    ) external;\n\n    function factory() external view returns (address);\n\n    function future_epoch_time() external view returns (uint256);\n\n    function increaseAllowance(address _spender, uint256 _added_value)\n        external\n        returns (bool);\n\n    function inflation_rate() external view returns (uint256);\n\n    function integrate_checkpoint() external view returns (uint256);\n\n    function integrate_checkpoint_of(address arg0)\n        external\n        view\n        returns (uint256);\n\n    function integrate_fraction(address arg0) external view returns (uint256);\n\n    function integrate_inv_supply(uint256 arg0) external view returns (uint256);\n\n    function integrate_inv_supply_of(address arg0)\n        external\n        view\n        returns (uint256);\n\n    function is_killed() external view returns (bool);\n\n    function kick(address addr) external;\n\n    function lp_token() external view returns (address);\n\n    function manager() external view returns (address);\n\n    function name() external view returns (string memory);\n\n    function nonces(address arg0) external view returns (uint256);\n\n    function period() external view returns (int128);\n\n    function period_timestamp(uint256 arg0) external view returns (uint256);\n\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (bool);\n\n    function reward_count() external view returns (uint256);\n\n    function reward_integral_for(address arg0, address arg1)\n        external\n        view\n        returns (uint256);\n\n    function reward_tokens(uint256 arg0) external view returns (address);\n\n    function rewards_receiver(address arg0) external view returns (address);\n\n    function salt() external view returns (bytes32);\n\n    function set_gauge_manager(address _gauge_manager) external;\n\n    function set_killed(bool _is_killed) external;\n\n    function set_reward_distributor(address _reward_token, address _distributor)\n        external;\n\n    function set_rewards_receiver(address _receiver) external;\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function user_checkpoint(address addr) external returns (bool);\n\n    function version() external view returns (string memory);\n\n    function withdraw(uint256 _value) external;\n\n    function withdraw(uint256 _value, bool _claim_rewards) external;\n\n    function working_balances(address arg0) external view returns (uint256);\n\n    function working_supply() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ICurveMinter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\ninterface ICurveMinter {\n    event Minted(address indexed recipient, address gauge, uint256 minted);\n\n    function allowed_to_mint_for(address arg0, address arg1)\n        external\n        view\n        returns (bool);\n\n    function controller() external view returns (address);\n\n    function mint(address gauge_addr) external;\n\n    function mint_for(address gauge_addr, address _for) external;\n\n    function mint_many(address[8] memory gauge_addrs) external;\n\n    function minted(address arg0, address arg1) external view returns (uint256);\n\n    function toggle_approve_mint(address minting_user) external;\n\n    function token() external view returns (address);\n}\n"
    },
    "contracts/interfaces/ICurveStableSwapNG.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\ninterface ICurveStableSwapNG {\n    event AddLiquidity(\n        address indexed provider,\n        uint256[] token_amounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 token_supply\n    );\n    event ApplyNewFee(uint256 fee, uint256 offpeg_fee_multiplier);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event RampA(\n        uint256 old_A,\n        uint256 new_A,\n        uint256 initial_time,\n        uint256 future_time\n    );\n    event RemoveLiquidity(\n        address indexed provider,\n        uint256[] token_amounts,\n        uint256[] fees,\n        uint256 token_supply\n    );\n    event RemoveLiquidityImbalance(\n        address indexed provider,\n        uint256[] token_amounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 token_supply\n    );\n    event RemoveLiquidityOne(\n        address indexed provider,\n        int128 token_id,\n        uint256 token_amount,\n        uint256 coin_amount,\n        uint256 token_supply\n    );\n    event SetNewMATime(uint256 ma_exp_time, uint256 D_ma_time);\n    event StopRampA(uint256 A, uint256 t);\n    event TokenExchange(\n        address indexed buyer,\n        int128 sold_id,\n        uint256 tokens_sold,\n        int128 bought_id,\n        uint256 tokens_bought\n    );\n    event TokenExchangeUnderlying(\n        address indexed buyer,\n        int128 sold_id,\n        uint256 tokens_sold,\n        int128 bought_id,\n        uint256 tokens_bought\n    );\n    event Transfer(\n        address indexed sender,\n        address indexed receiver,\n        uint256 value\n    );\n\n    function A() external view returns (uint256);\n\n    function A_precise() external view returns (uint256);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function D_ma_time() external view returns (uint256);\n\n    function D_oracle() external view returns (uint256);\n\n    function N_COINS() external view returns (uint256);\n\n    function add_liquidity(uint256[] memory _amounts, uint256 _min_mint_amount)\n        external\n        returns (uint256);\n\n    function add_liquidity(\n        uint256[] memory _amounts,\n        uint256 _min_mint_amount,\n        address _receiver\n    ) external returns (uint256);\n\n    function admin_balances(uint256 arg0) external view returns (uint256);\n\n    function admin_fee() external view returns (uint256);\n\n    function allowance(address arg0, address arg1)\n        external\n        view\n        returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function balanceOf(address arg0) external view returns (uint256);\n\n    function balances(uint256 i) external view returns (uint256);\n\n    function calc_token_amount(uint256[] memory _amounts, bool _is_deposit)\n        external\n        view\n        returns (uint256);\n\n    function calc_withdraw_one_coin(uint256 _burn_amount, int128 i)\n        external\n        view\n        returns (uint256);\n\n    function coins(uint256 arg0) external view returns (address);\n\n    function decimals() external view returns (uint8);\n\n    function dynamic_fee(int128 i, int128 j) external view returns (uint256);\n\n    function ema_price(uint256 i) external view returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy\n    ) external returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy,\n        address _receiver\n    ) external returns (uint256);\n\n    function exchange_received(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy\n    ) external returns (uint256);\n\n    function exchange_received(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy,\n        address _receiver\n    ) external returns (uint256);\n\n    function fee() external view returns (uint256);\n\n    function future_A() external view returns (uint256);\n\n    function future_A_time() external view returns (uint256);\n\n    function get_balances() external view returns (uint256[] memory);\n\n    function get_dx(\n        int128 i,\n        int128 j,\n        uint256 dy\n    ) external view returns (uint256);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function get_p(uint256 i) external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function initial_A() external view returns (uint256);\n\n    function initial_A_time() external view returns (uint256);\n\n    function last_price(uint256 i) external view returns (uint256);\n\n    function ma_exp_time() external view returns (uint256);\n\n    function ma_last_time() external view returns (uint256);\n\n    function name() external view returns (string memory);\n\n    function nonces(address arg0) external view returns (uint256);\n\n    function offpeg_fee_multiplier() external view returns (uint256);\n\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (bool);\n\n    function price_oracle(uint256 i) external view returns (uint256);\n\n    function ramp_A(uint256 _future_A, uint256 _future_time) external;\n\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[] memory _min_amounts\n    ) external returns (uint256[] memory);\n\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[] memory _min_amounts,\n        address _receiver\n    ) external returns (uint256[] memory);\n\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[] memory _min_amounts,\n        address _receiver,\n        bool _claim_admin_fees\n    ) external returns (uint256[] memory);\n\n    function remove_liquidity_imbalance(\n        uint256[] memory _amounts,\n        uint256 _max_burn_amount\n    ) external returns (uint256);\n\n    function remove_liquidity_imbalance(\n        uint256[] memory _amounts,\n        uint256 _max_burn_amount,\n        address _receiver\n    ) external returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_received\n    ) external returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_received,\n        address _receiver\n    ) external returns (uint256);\n\n    function salt() external view returns (bytes32);\n\n    function set_ma_exp_time(uint256 _ma_exp_time, uint256 _D_ma_time) external;\n\n    function set_new_fee(uint256 _new_fee, uint256 _new_offpeg_fee_multiplier)\n        external;\n\n    function stop_ramp_A() external;\n\n    function stored_rates() external view returns (uint256[] memory);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function version() external view returns (string memory);\n\n    function withdraw_admin_fees() external;\n}\n"
    },
    "contracts/interfaces/ICurveXChainLiquidityGauge.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\ninterface ICurveXChainLiquidityGauge {\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n    event Deposit(address indexed provider, uint256 value);\n    event SetGaugeManager(address _gauge_manager);\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event UpdateLiquidityLimit(\n        address indexed user,\n        uint256 original_balance,\n        uint256 original_supply,\n        uint256 working_balance,\n        uint256 working_supply\n    );\n    event Withdraw(address indexed provider, uint256 value);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function add_reward(address _reward_token, address _distributor) external;\n\n    function allowance(address arg0, address arg1)\n        external\n        view\n        returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function balanceOf(address arg0) external view returns (uint256);\n\n    function claim_rewards() external;\n\n    function claim_rewards(address _addr) external;\n\n    function claim_rewards(address _addr, address _receiver) external;\n\n    function claimable_reward(address _user, address _reward_token)\n        external\n        view\n        returns (uint256);\n\n    function claimable_tokens(address addr) external returns (uint256);\n\n    function claimed_reward(address _addr, address _token)\n        external\n        view\n        returns (uint256);\n\n    function decimals() external view returns (uint256);\n\n    function decreaseAllowance(address _spender, uint256 _subtracted_value)\n        external\n        returns (bool);\n\n    function deposit(uint256 _value) external;\n\n    function deposit(uint256 _value, address _addr) external;\n\n    function deposit(\n        uint256 _value,\n        address _addr,\n        bool _claim_rewards\n    ) external;\n\n    function deposit_reward_token(address _reward_token, uint256 _amount)\n        external;\n\n    function deposit_reward_token(\n        address _reward_token,\n        uint256 _amount,\n        uint256 _epoch\n    ) external;\n\n    function factory() external view returns (address);\n\n    function increaseAllowance(address _spender, uint256 _added_value)\n        external\n        returns (bool);\n\n    function inflation_rate(uint256 arg0) external view returns (uint256);\n\n    function initialize(\n        address _lp_token,\n        address _root,\n        address _manager\n    ) external;\n\n    function integrate_checkpoint() external view returns (uint256);\n\n    function integrate_checkpoint_of(address arg0)\n        external\n        view\n        returns (uint256);\n\n    function integrate_fraction(address arg0) external view returns (uint256);\n\n    function integrate_inv_supply(int128 arg0) external view returns (uint256);\n\n    function integrate_inv_supply_of(address arg0)\n        external\n        view\n        returns (uint256);\n\n    function is_killed() external view returns (bool);\n\n    function lp_token() external view returns (address);\n\n    function manager() external view returns (address);\n\n    function name() external view returns (string memory);\n\n    function nonces(address arg0) external view returns (uint256);\n\n    function period() external view returns (int128);\n\n    function period_timestamp(int128 arg0) external view returns (uint256);\n\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (bool);\n\n    function recover_remaining(address _reward_token) external;\n\n    function reward_count() external view returns (uint256);\n\n    function reward_integral_for(address arg0, address arg1)\n        external\n        view\n        returns (uint256);\n\n    function reward_remaining(address arg0) external view returns (uint256);\n\n    function reward_tokens(uint256 arg0) external view returns (address);\n\n    function rewards_receiver(address arg0) external view returns (address);\n\n    function root_gauge() external view returns (address);\n\n    function set_gauge_manager(address _gauge_manager) external;\n\n    function set_killed(bool _is_killed) external;\n\n    function set_manager(address _gauge_manager) external;\n\n    function set_reward_distributor(address _reward_token, address _distributor)\n        external;\n\n    function set_rewards_receiver(address _receiver) external;\n\n    function set_root_gauge(address _root) external;\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function update_voting_escrow() external;\n\n    function user_checkpoint(address addr) external returns (bool);\n\n    function version() external view returns (string memory);\n\n    function voting_escrow() external view returns (address);\n\n    function withdraw(uint256 _value) external;\n\n    function withdraw(uint256 _value, bool _claim_rewards) external;\n\n    function withdraw(\n        uint256 _value,\n        bool _claim_rewards,\n        address _receiver\n    ) external;\n\n    function working_balances(address arg0) external view returns (uint256);\n\n    function working_supply() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ICVXLocker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ICVXLocker {\n    function lock(\n        address _account,\n        uint256 _amount,\n        uint256 _spendRatio\n    ) external;\n\n    function lockedBalanceOf(address _account) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IDepositContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IDepositContract {\n    /// @notice A processed deposit event.\n    event DepositEvent(\n        bytes pubkey,\n        bytes withdrawal_credentials,\n        bytes amount,\n        bytes signature,\n        bytes index\n    );\n\n    /// @notice Submit a Phase 0 DepositData object.\n    /// @param pubkey A BLS12-381 public key.\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\n    /// @param signature A BLS12-381 signature.\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\n    /// Used as a protection against malformed input.\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawal_credentials,\n        bytes calldata signature,\n        bytes32 deposit_data_root\n    ) external payable;\n\n    /// @notice Query the current deposit root hash.\n    /// @return The deposit root hash.\n    function get_deposit_root() external view returns (bytes32);\n\n    /// @notice Query the current deposit count.\n    /// @return The deposit count encoded as a little endian 64-bit number.\n    function get_deposit_count() external view returns (bytes memory);\n}\n"
    },
    "contracts/interfaces/IMerkl.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IDistributor {\n    event Claimed(address indexed user, address indexed token, uint256 amount);\n\n    function claim(\n        address[] calldata users,\n        address[] calldata tokens,\n        uint256[] calldata amounts,\n        bytes32[][] calldata proofs\n    ) external;\n}\n"
    },
    "contracts/interfaces/IMockVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IVault } from \"./IVault.sol\";\n\ninterface IMockVault is IVault {\n    function outstandingWithdrawalsAmount() external view returns (uint256);\n\n    function wethAvailable() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IOracle {\n    /**\n     * @dev returns the asset price in USD, in 8 decimal digits.\n     *\n     * The version of priceProvider deployed for OETH has 18 decimal digits\n     */\n    function price(address asset) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IOUSD.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IOUSD {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event GovernorshipTransferred(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n    event PendingGovernorshipTransfer(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n    event TotalSupplyUpdatedHighres(\n        uint256 totalSupply,\n        uint256 rebasingCredits,\n        uint256 rebasingCreditsPerToken\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function _totalSupply() external view returns (uint256);\n\n    function allowance(address _owner, address _spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function balanceOf(address _account) external view returns (uint256);\n\n    function burn(address account, uint256 amount) external;\n\n    function changeSupply(uint256 _newTotalSupply) external;\n\n    function claimGovernance() external;\n\n    function creditsBalanceOf(address _account)\n        external\n        view\n        returns (uint256, uint256);\n\n    function creditsBalanceOfHighres(address _account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            bool\n        );\n\n    function decimals() external view returns (uint8);\n\n    function decreaseAllowance(address _spender, uint256 _subtractedValue)\n        external\n        returns (bool);\n\n    function governor() external view returns (address);\n\n    function increaseAllowance(address _spender, uint256 _addedValue)\n        external\n        returns (bool);\n\n    function initialize(\n        string memory _nameArg,\n        string memory _symbolArg,\n        address _vaultAddress\n    ) external;\n\n    function isGovernor() external view returns (bool);\n\n    function isUpgraded(address) external view returns (uint256);\n\n    function mint(address _account, uint256 _amount) external;\n\n    function name() external view returns (string memory);\n\n    function nonRebasingCreditsPerToken(address)\n        external\n        view\n        returns (uint256);\n\n    function nonRebasingSupply() external view returns (uint256);\n\n    function rebaseOptIn() external;\n\n    function rebaseOptOut() external;\n\n    function rebaseState(address) external view returns (uint8);\n\n    function rebasingCredits() external view returns (uint256);\n\n    function rebasingCreditsHighres() external view returns (uint256);\n\n    function rebasingCreditsPerToken() external view returns (uint256);\n\n    function rebasingCreditsPerTokenHighres() external view returns (uint256);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function transferGovernance(address _newGovernor) external;\n\n    function vaultAddress() external view returns (address);\n}\n"
    },
    "contracts/interfaces/ISafe.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface ISafe {\n    function execTransactionFromModule(\n        address,\n        uint256,\n        bytes memory,\n        uint8\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/ISSVNetwork.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct Cluster {\n    uint32 validatorCount;\n    uint64 networkFeeIndex;\n    uint64 index;\n    bool active;\n    uint256 balance;\n}\n\ninterface ISSVNetwork {\n    /**********/\n    /* Errors */\n    /**********/\n\n    error CallerNotOwner(); // 0x5cd83192\n    error CallerNotWhitelisted(); // 0x8c6e5d71\n    error FeeTooLow(); // 0x732f9413\n    error FeeExceedsIncreaseLimit(); // 0x958065d9\n    error NoFeeDeclared(); // 0x1d226c30\n    error ApprovalNotWithinTimeframe(); // 0x97e4b518\n    error OperatorDoesNotExist(); // 0x961e3e8c\n    error InsufficientBalance(); // 0xf4d678b8\n    error ValidatorDoesNotExist(); // 0xe51315d2\n    error ClusterNotLiquidatable(); // 0x60300a8d\n    error InvalidPublicKeyLength(); // 0x637297a4\n    error InvalidOperatorIdsLength(); // 0x38186224\n    error ClusterAlreadyEnabled(); // 0x3babafd2\n    error ClusterIsLiquidated(); // 0x95a0cf33\n    error ClusterDoesNotExists(); // 0x185e2b16\n    error IncorrectClusterState(); // 0x12e04c87\n    error UnsortedOperatorsList(); // 0xdd020e25\n    error NewBlockPeriodIsBelowMinimum(); // 0x6e6c9cac\n    error ExceedValidatorLimit(); // 0x6df5ab76\n    error TokenTransferFailed(); // 0x045c4b02\n    error SameFeeChangeNotAllowed(); // 0xc81272f8\n    error FeeIncreaseNotAllowed(); // 0x410a2b6c\n    error NotAuthorized(); // 0xea8e4eb5\n    error OperatorsListNotUnique(); // 0xa5a1ff5d\n    error OperatorAlreadyExists(); // 0x289c9494\n    error TargetModuleDoesNotExist(); // 0x8f9195fb\n    error MaxValueExceeded(); // 0x91aa3017\n    error FeeTooHigh(); // 0xcd4e6167\n    error PublicKeysSharesLengthMismatch(); // 0x9ad467b8\n    error IncorrectValidatorStateWithData(bytes publicKey); // 0x89307938\n    error ValidatorAlreadyExistsWithData(bytes publicKey); // 0x388e7999\n    error EmptyPublicKeysList(); // df83e679\n\n    // legacy errors\n    error ValidatorAlreadyExists(); // 0x8d09a73e\n    error IncorrectValidatorState(); // 0x2feda3c1\n\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    event ClusterDeposited(\n        address indexed owner,\n        uint64[] operatorIds,\n        uint256 value,\n        Cluster cluster\n    );\n    event ClusterLiquidated(\n        address indexed owner,\n        uint64[] operatorIds,\n        Cluster cluster\n    );\n    event ClusterReactivated(\n        address indexed owner,\n        uint64[] operatorIds,\n        Cluster cluster\n    );\n    event ClusterWithdrawn(\n        address indexed owner,\n        uint64[] operatorIds,\n        uint256 value,\n        Cluster cluster\n    );\n    event DeclareOperatorFeePeriodUpdated(uint64 value);\n    event ExecuteOperatorFeePeriodUpdated(uint64 value);\n    event FeeRecipientAddressUpdated(\n        address indexed owner,\n        address recipientAddress\n    );\n    event Initialized(uint8 version);\n    event LiquidationThresholdPeriodUpdated(uint64 value);\n    event MinimumLiquidationCollateralUpdated(uint256 value);\n    event NetworkEarningsWithdrawn(uint256 value, address recipient);\n    event NetworkFeeUpdated(uint256 oldFee, uint256 newFee);\n    event OperatorAdded(\n        uint64 indexed operatorId,\n        address indexed owner,\n        bytes publicKey,\n        uint256 fee\n    );\n    event OperatorFeeDeclarationCancelled(\n        address indexed owner,\n        uint64 indexed operatorId\n    );\n    event OperatorFeeDeclared(\n        address indexed owner,\n        uint64 indexed operatorId,\n        uint256 blockNumber,\n        uint256 fee\n    );\n    event OperatorFeeExecuted(\n        address indexed owner,\n        uint64 indexed operatorId,\n        uint256 blockNumber,\n        uint256 fee\n    );\n    event OperatorFeeIncreaseLimitUpdated(uint64 value);\n    event OperatorMaximumFeeUpdated(uint64 maxFee);\n    event OperatorRemoved(uint64 indexed operatorId);\n    event OperatorWhitelistUpdated(\n        uint64 indexed operatorId,\n        address whitelisted\n    );\n    event OperatorWithdrawn(\n        address indexed owner,\n        uint64 indexed operatorId,\n        uint256 value\n    );\n    event OwnershipTransferStarted(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event Upgraded(address indexed implementation);\n    event ValidatorAdded(\n        address indexed owner,\n        uint64[] operatorIds,\n        bytes publicKey,\n        bytes shares,\n        Cluster cluster\n    );\n    event ValidatorExited(\n        address indexed owner,\n        uint64[] operatorIds,\n        bytes publicKey\n    );\n    event ValidatorRemoved(\n        address indexed owner,\n        uint64[] operatorIds,\n        bytes publicKey,\n        Cluster cluster\n    );\n\n    fallback() external;\n\n    function acceptOwnership() external;\n\n    function cancelDeclaredOperatorFee(uint64 operatorId) external;\n\n    function declareOperatorFee(uint64 operatorId, uint256 fee) external;\n\n    function deposit(\n        address clusterOwner,\n        uint64[] memory operatorIds,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function executeOperatorFee(uint64 operatorId) external;\n\n    function exitValidator(bytes memory publicKey, uint64[] memory operatorIds)\n        external;\n\n    function bulkExitValidator(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds\n    ) external;\n\n    function getVersion() external pure returns (string memory version);\n\n    function initialize(\n        address token_,\n        address ssvOperators_,\n        address ssvClusters_,\n        address ssvDAO_,\n        address ssvViews_,\n        uint64 minimumBlocksBeforeLiquidation_,\n        uint256 minimumLiquidationCollateral_,\n        uint32 validatorsPerOperatorLimit_,\n        uint64 declareOperatorFeePeriod_,\n        uint64 executeOperatorFeePeriod_,\n        uint64 operatorMaxFeeIncrease_\n    ) external;\n\n    function liquidate(\n        address clusterOwner,\n        uint64[] memory operatorIds,\n        Cluster memory cluster\n    ) external;\n\n    function owner() external view returns (address);\n\n    function pendingOwner() external view returns (address);\n\n    function proxiableUUID() external view returns (bytes32);\n\n    function reactivate(\n        uint64[] memory operatorIds,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function reduceOperatorFee(uint64 operatorId, uint256 fee) external;\n\n    function registerOperator(bytes memory publicKey, uint256 fee)\n        external\n        returns (uint64 id);\n\n    function registerValidator(\n        bytes memory publicKey,\n        uint64[] memory operatorIds,\n        bytes memory sharesData,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function bulkRegisterValidator(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds,\n        bytes[] calldata sharesData,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function removeOperator(uint64 operatorId) external;\n\n    function removeValidator(\n        bytes memory publicKey,\n        uint64[] memory operatorIds,\n        Cluster memory cluster\n    ) external;\n\n    function bulkRemoveValidator(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds,\n        Cluster memory cluster\n    ) external;\n\n    function renounceOwnership() external;\n\n    function setFeeRecipientAddress(address recipientAddress) external;\n\n    function setOperatorWhitelist(uint64 operatorId, address whitelisted)\n        external;\n\n    function transferOwnership(address newOwner) external;\n\n    function updateDeclareOperatorFeePeriod(uint64 timeInSeconds) external;\n\n    function updateExecuteOperatorFeePeriod(uint64 timeInSeconds) external;\n\n    function updateLiquidationThresholdPeriod(uint64 blocks) external;\n\n    function updateMaximumOperatorFee(uint64 maxFee) external;\n\n    function updateMinimumLiquidationCollateral(uint256 amount) external;\n\n    function updateModule(uint8 moduleId, address moduleAddress) external;\n\n    function updateNetworkFee(uint256 fee) external;\n\n    function updateOperatorFeeIncreaseLimit(uint64 percentage) external;\n\n    function upgradeTo(address newImplementation) external;\n\n    function upgradeToAndCall(address newImplementation, bytes memory data)\n        external\n        payable;\n\n    function withdraw(\n        uint64[] memory operatorIds,\n        uint256 amount,\n        Cluster memory cluster\n    ) external;\n\n    function withdrawAllOperatorEarnings(uint64 operatorId) external;\n\n    function withdrawNetworkEarnings(uint256 amount) external;\n\n    function withdrawOperatorEarnings(uint64 operatorId, uint256 amount)\n        external;\n}\n"
    },
    "contracts/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Platform interface to integrate with lending platform like Compound, AAVE etc.\n */\ninterface IStrategy {\n    /**\n     * @dev Deposit the given asset to platform\n     * @param _asset asset address\n     * @param _amount Amount to deposit\n     */\n    function deposit(address _asset, uint256 _amount) external;\n\n    /**\n     * @dev Deposit the entire balance of all supported assets in the Strategy\n     *      to the platform\n     */\n    function depositAll() external;\n\n    /**\n     * @dev Withdraw given asset from Lending platform\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external;\n\n    /**\n     * @dev Liquidate all assets in strategy and return them to Vault.\n     */\n    function withdrawAll() external;\n\n    /**\n     * @dev Returns the current balance of the given asset.\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        returns (uint256 balance);\n\n    /**\n     * @dev Returns bool indicating whether strategy supports asset.\n     */\n    function supportsAsset(address _asset) external view returns (bool);\n\n    /**\n     * @dev Collect reward tokens from the Strategy.\n     */\n    function collectRewardTokens() external;\n\n    /**\n     * @dev The address array of the reward tokens for the Strategy.\n     */\n    function getRewardTokenAddresses() external view returns (address[] memory);\n\n    function harvesterAddress() external view returns (address);\n\n    function transferToken(address token, uint256 amount) external;\n\n    function setRewardTokenAddresses(address[] calldata _rewardTokenAddresses)\n        external;\n}\n"
    },
    "contracts/interfaces/ISwapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface ISwapper {\n    /**\n     * @param fromAsset The token address of the asset being sold.\n     * @param toAsset The token address of the asset being purchased.\n     * @param fromAssetAmount The amount of assets being sold.\n     * @param minToAssetAmmount The minimum amount of assets to be purchased.\n     * @param data tx.data returned from 1Inch's /v5.0/1/swap API\n     */\n    function swap(\n        address fromAsset,\n        address toAsset,\n        uint256 fromAssetAmount,\n        uint256 minToAssetAmmount,\n        bytes calldata data\n    ) external returns (uint256 toAssetAmount);\n}\n"
    },
    "contracts/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { VaultStorage } from \"../vault/VaultStorage.sol\";\n\ninterface IVault {\n    // slither-disable-start constable-states\n\n    event AssetAllocated(address _asset, address _strategy, uint256 _amount);\n    event StrategyApproved(address _addr);\n    event StrategyRemoved(address _addr);\n    event Mint(address _addr, uint256 _value);\n    event Redeem(address _addr, uint256 _value);\n    event CapitalPaused();\n    event CapitalUnpaused();\n    event DefaultStrategyUpdated(address _strategy);\n    event RebasePaused();\n    event RebaseUnpaused();\n    event VaultBufferUpdated(uint256 _vaultBuffer);\n    event AllocateThresholdUpdated(uint256 _threshold);\n    event RebaseThresholdUpdated(uint256 _threshold);\n    event StrategistUpdated(address _address);\n    event MaxSupplyDiffChanged(uint256 maxSupplyDiff);\n    event YieldDistribution(address _to, uint256 _yield, uint256 _fee);\n    event TrusteeFeeBpsChanged(uint256 _basis);\n    event TrusteeAddressChanged(address _address);\n    event StrategyAddedToMintWhitelist(address indexed strategy);\n    event StrategyRemovedFromMintWhitelist(address indexed strategy);\n    event RebasePerSecondMaxChanged(uint256 rebaseRatePerSecond);\n    event DripDurationChanged(uint256 dripDuration);\n    event WithdrawalRequested(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount,\n        uint256 _queued\n    );\n    event WithdrawalClaimed(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount\n    );\n    event WithdrawalClaimable(uint256 _claimable, uint256 _newClaimable);\n    event WithdrawalClaimDelayUpdated(uint256 _newDelay);\n\n    // Governable.sol\n    function transferGovernance(address _newGovernor) external;\n\n    function claimGovernance() external;\n\n    function governor() external view returns (address);\n\n    // VaultAdmin.sol\n    function setVaultBuffer(uint256 _vaultBuffer) external;\n\n    function vaultBuffer() external view returns (uint256);\n\n    function setAutoAllocateThreshold(uint256 _threshold) external;\n\n    function autoAllocateThreshold() external view returns (uint256);\n\n    function setRebaseThreshold(uint256 _threshold) external;\n\n    function rebaseThreshold() external view returns (uint256);\n\n    function setStrategistAddr(address _address) external;\n\n    function strategistAddr() external view returns (address);\n\n    function setMaxSupplyDiff(uint256 _maxSupplyDiff) external;\n\n    function maxSupplyDiff() external view returns (uint256);\n\n    function setTrusteeAddress(address _address) external;\n\n    function trusteeAddress() external view returns (address);\n\n    function setTrusteeFeeBps(uint256 _basis) external;\n\n    function trusteeFeeBps() external view returns (uint256);\n\n    function approveStrategy(address _addr) external;\n\n    function removeStrategy(address _addr) external;\n\n    function setDefaultStrategy(address _strategy) external;\n\n    function defaultStrategy() external view returns (address);\n\n    function pauseRebase() external;\n\n    function unpauseRebase() external;\n\n    function rebasePaused() external view returns (bool);\n\n    function pauseCapital() external;\n\n    function unpauseCapital() external;\n\n    function capitalPaused() external view returns (bool);\n\n    function transferToken(address _asset, uint256 _amount) external;\n\n    function withdrawAllFromStrategy(address _strategyAddr) external;\n\n    function withdrawAllFromStrategies() external;\n\n    function withdrawFromStrategy(\n        address _strategyFromAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external;\n\n    function depositToStrategy(\n        address _strategyToAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external;\n\n    // VaultCore.sol\n    function mint(\n        address _asset,\n        uint256 _amount,\n        uint256 _minimumOusdAmount\n    ) external;\n\n    function mintForStrategy(uint256 _amount) external;\n\n    function redeem(uint256 _amount, uint256 _minimumUnitAmount) external;\n\n    function burnForStrategy(uint256 _amount) external;\n\n    function allocate() external;\n\n    function rebase() external;\n\n    function totalValue() external view returns (uint256 value);\n\n    function checkBalance(address _asset) external view returns (uint256);\n\n    /// @notice Deprecated: use calculateRedeemOutput\n    function calculateRedeemOutputs(uint256 _amount)\n        external\n        view\n        returns (uint256[] memory);\n\n    function calculateRedeemOutput(uint256 _amount)\n        external\n        view\n        returns (uint256);\n\n    function getAssetCount() external view returns (uint256);\n\n    function getAllAssets() external view returns (address[] memory);\n\n    function getStrategyCount() external view returns (uint256);\n\n    function getAllStrategies() external view returns (address[] memory);\n\n    /// @notice Deprecated.\n    function isSupportedAsset(address _asset) external view returns (bool);\n\n    function dripper() external view returns (address);\n\n    function asset() external view returns (address);\n\n    function initialize(address) external;\n\n    function addWithdrawalQueueLiquidity() external;\n\n    function requestWithdrawal(uint256 _amount)\n        external\n        returns (uint256 requestId, uint256 queued);\n\n    function claimWithdrawal(uint256 requestId)\n        external\n        returns (uint256 amount);\n\n    function claimWithdrawals(uint256[] memory requestIds)\n        external\n        returns (uint256[] memory amounts, uint256 totalAmount);\n\n    function withdrawalQueueMetadata()\n        external\n        view\n        returns (VaultStorage.WithdrawalQueueMetadata memory);\n\n    function withdrawalRequests(uint256 requestId)\n        external\n        view\n        returns (VaultStorage.WithdrawalRequest memory);\n\n    function addStrategyToMintWhitelist(address strategyAddr) external;\n\n    function removeStrategyFromMintWhitelist(address strategyAddr) external;\n\n    function isMintWhitelistedStrategy(address strategyAddr)\n        external\n        view\n        returns (bool);\n\n    function withdrawalClaimDelay() external view returns (uint256);\n\n    function setWithdrawalClaimDelay(uint256 newDelay) external;\n\n    function lastRebase() external view returns (uint64);\n\n    function dripDuration() external view returns (uint64);\n\n    function setDripDuration(uint256 _dripDuration) external;\n\n    function rebasePerSecondMax() external view returns (uint64);\n\n    function setRebaseRateMax(uint256 yearlyApr) external;\n\n    function rebasePerSecondTarget() external view returns (uint64);\n\n    function previewYield() external view returns (uint256 yield);\n\n    function weth() external view returns (address);\n\n    // slither-disable-end constable-states\n}\n"
    },
    "contracts/interfaces/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWETH9 {\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    function allowance(address, address) external view returns (uint256);\n\n    function approve(address guy, uint256 wad) external returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function deposit() external payable;\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address dst, uint256 wad) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function withdraw(uint256 wad) external;\n}\n"
    },
    "contracts/interfaces/IWstETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWstETH {\n    /**\n     * @notice Get amount of wstETH for a given amount of stETH\n     * @param _stETHAmount amount of stETH\n     * @return Amount of wstETH for a given stETH amount\n     */\n    function getWstETHByStETH(uint256 _stETHAmount)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Get amount of stETH for a given amount of wstETH\n     * @param _wstETHAmount amount of wstETH\n     * @return Amount of stETH for a given wstETH amount\n     */\n    function getStETHByWstETH(uint256 _wstETHAmount)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Get amount of stETH for a one wstETH\n     * @return Amount of stETH for 1 wstETH\n     */\n    function stEthPerToken() external view returns (uint256);\n\n    /**\n     * @notice Get amount of wstETH for a one stETH\n     * @return Amount of wstETH for a 1 stETH\n     */\n    function tokensPerStEth() external view returns (uint256);\n\n    /**\n     * @notice Exchanges stETH to wstETH\n     * @param _stETHAmount amount of stETH to wrap in exchange for wstETH\n     * @dev Requirements:\n     *  - `_stETHAmount` must be non-zero\n     *  - msg.sender must approve at least `_stETHAmount` stETH to this\n     *    contract.\n     *  - msg.sender must have at least `_stETHAmount` of stETH.\n     * User should first approve _stETHAmount to the WstETH contract\n     * @return Amount of wstETH user receives after wrap\n     */\n    function wrap(uint256 _stETHAmount) external returns (uint256);\n\n    /**\n     * @notice Exchanges wstETH to stETH\n     * @param _wstETHAmount amount of wstETH to uwrap in exchange for stETH\n     * @dev Requirements:\n     *  - `_wstETHAmount` must be non-zero\n     *  - msg.sender must have at least `_wstETHAmount` wstETH.\n     * @return Amount of stETH user receives after unwrap\n     */\n    function unwrap(uint256 _wstETHAmount) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/morpho/compound/ICompoundOracle.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.0;\n\ninterface ICompoundOracle {\n    function getUnderlyingPrice(address) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/morpho/ILens.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.0;\n\nimport \"./compound/ICompoundOracle.sol\";\nimport \"./IMorpho.sol\";\n\ninterface ILens {\n    /// STORAGE ///\n\n    function MAX_BASIS_POINTS() external view returns (uint256);\n\n    function WAD() external view returns (uint256);\n\n    function morpho() external view returns (IMorpho);\n\n    function comptroller() external view returns (IComptroller);\n\n    /// GENERAL ///\n\n    function getTotalSupply()\n        external\n        view\n        returns (\n            uint256 p2pSupplyAmount,\n            uint256 poolSupplyAmount,\n            uint256 totalSupplyAmount\n        );\n\n    function getTotalBorrow()\n        external\n        view\n        returns (\n            uint256 p2pBorrowAmount,\n            uint256 poolBorrowAmount,\n            uint256 totalBorrowAmount\n        );\n\n    /// MARKETS ///\n\n    function isMarketCreated(address _poolToken) external view returns (bool);\n\n    function isMarketCreatedAndNotPaused(address _poolToken)\n        external\n        view\n        returns (bool);\n\n    function isMarketCreatedAndNotPausedNorPartiallyPaused(address _poolToken)\n        external\n        view\n        returns (bool);\n\n    function getAllMarkets()\n        external\n        view\n        returns (address[] memory marketsCreated_);\n\n    function getMainMarketData(address _poolToken)\n        external\n        view\n        returns (\n            uint256 avgSupplyRatePerBlock,\n            uint256 avgBorrowRatePerBlock,\n            uint256 p2pSupplyAmount,\n            uint256 p2pBorrowAmount,\n            uint256 poolSupplyAmount,\n            uint256 poolBorrowAmount\n        );\n\n    function getAdvancedMarketData(address _poolToken)\n        external\n        view\n        returns (\n            uint256 p2pSupplyIndex,\n            uint256 p2pBorrowIndex,\n            uint256 poolSupplyIndex,\n            uint256 poolBorrowIndex,\n            uint32 lastUpdateBlockNumber,\n            uint256 p2pSupplyDelta,\n            uint256 p2pBorrowDelta\n        );\n\n    function getMarketConfiguration(address _poolToken)\n        external\n        view\n        returns (\n            address underlying,\n            bool isCreated,\n            bool p2pDisabled,\n            bool isPaused,\n            bool isPartiallyPaused,\n            uint16 reserveFactor,\n            uint16 p2pIndexCursor,\n            uint256 collateralFactor\n        );\n\n    function getTotalMarketSupply(address _poolToken)\n        external\n        view\n        returns (uint256 p2pSupplyAmount, uint256 poolSupplyAmount);\n\n    function getTotalMarketBorrow(address _poolToken)\n        external\n        view\n        returns (uint256 p2pBorrowAmount, uint256 poolBorrowAmount);\n\n    /// INDEXES ///\n\n    function getCurrentP2PSupplyIndex(address _poolToken)\n        external\n        view\n        returns (uint256);\n\n    function getCurrentP2PBorrowIndex(address _poolToken)\n        external\n        view\n        returns (uint256);\n\n    function getCurrentPoolIndexes(address _poolToken)\n        external\n        view\n        returns (\n            uint256 currentPoolSupplyIndex,\n            uint256 currentPoolBorrowIndex\n        );\n\n    function getIndexes(address _poolToken, bool _computeUpdatedIndexes)\n        external\n        view\n        returns (\n            uint256 p2pSupplyIndex,\n            uint256 p2pBorrowIndex,\n            uint256 poolSupplyIndex,\n            uint256 poolBorrowIndex\n        );\n\n    /// USERS ///\n\n    function getEnteredMarkets(address _user)\n        external\n        view\n        returns (address[] memory enteredMarkets);\n\n    function getUserHealthFactor(\n        address _user,\n        address[] calldata _updatedMarkets\n    ) external view returns (uint256);\n\n    function getUserBalanceStates(\n        address _user,\n        address[] calldata _updatedMarkets\n    )\n        external\n        view\n        returns (\n            uint256 collateralValue,\n            uint256 debtValue,\n            uint256 maxDebtValue\n        );\n\n    function getCurrentSupplyBalanceInOf(address _poolToken, address _user)\n        external\n        view\n        returns (\n            uint256 balanceOnPool,\n            uint256 balanceInP2P,\n            uint256 totalBalance\n        );\n\n    function getCurrentBorrowBalanceInOf(address _poolToken, address _user)\n        external\n        view\n        returns (\n            uint256 balanceOnPool,\n            uint256 balanceInP2P,\n            uint256 totalBalance\n        );\n\n    function getUserMaxCapacitiesForAsset(address _user, address _poolToken)\n        external\n        view\n        returns (uint256 withdrawable, uint256 borrowable);\n\n    function getUserHypotheticalBalanceStates(\n        address _user,\n        address _poolToken,\n        uint256 _withdrawnAmount,\n        uint256 _borrowedAmount\n    ) external view returns (uint256 debtValue, uint256 maxDebtValue);\n\n    function getUserLiquidityDataForAsset(\n        address _user,\n        address _poolToken,\n        bool _computeUpdatedIndexes,\n        ICompoundOracle _oracle\n    ) external view returns (Types.AssetLiquidityData memory assetData);\n\n    function isLiquidatable(address _user, address[] memory _updatedMarkets)\n        external\n        view\n        returns (bool);\n\n    function computeLiquidationRepayAmount(\n        address _user,\n        address _poolTokenBorrowed,\n        address _poolTokenCollateral,\n        address[] calldata _updatedMarkets\n    ) external view returns (uint256 toRepay);\n\n    /// RATES ///\n\n    function getAverageSupplyRatePerBlock(address _poolToken)\n        external\n        view\n        returns (\n            uint256 avgSupplyRatePerBlock,\n            uint256 p2pSupplyAmount,\n            uint256 poolSupplyAmount\n        );\n\n    function getAverageBorrowRatePerBlock(address _poolToken)\n        external\n        view\n        returns (\n            uint256 avgBorrowRatePerBlock,\n            uint256 p2pBorrowAmount,\n            uint256 poolBorrowAmount\n        );\n\n    function getNextUserSupplyRatePerBlock(\n        address _poolToken,\n        address _user,\n        uint256 _amount\n    )\n        external\n        view\n        returns (\n            uint256 nextSupplyRatePerBlock,\n            uint256 balanceOnPool,\n            uint256 balanceInP2P,\n            uint256 totalBalance\n        );\n\n    function getNextUserBorrowRatePerBlock(\n        address _poolToken,\n        address _user,\n        uint256 _amount\n    )\n        external\n        view\n        returns (\n            uint256 nextBorrowRatePerBlock,\n            uint256 balanceOnPool,\n            uint256 balanceInP2P,\n            uint256 totalBalance\n        );\n\n    function getCurrentUserSupplyRatePerBlock(address _poolToken, address _user)\n        external\n        view\n        returns (uint256);\n\n    function getCurrentUserBorrowRatePerBlock(address _poolToken, address _user)\n        external\n        view\n        returns (uint256);\n\n    function getRatesPerBlock(address _poolToken)\n        external\n        view\n        returns (\n            uint256 p2pSupplyRate,\n            uint256 p2pBorrowRate,\n            uint256 poolSupplyRate,\n            uint256 poolBorrowRate\n        );\n\n    /// REWARDS ///\n\n    function getUserUnclaimedRewards(\n        address[] calldata _poolTokens,\n        address _user\n    ) external view returns (uint256 unclaimedRewards);\n\n    function getAccruedSupplierComp(\n        address _supplier,\n        address _poolToken,\n        uint256 _balance\n    ) external view returns (uint256);\n\n    function getAccruedBorrowerComp(\n        address _borrower,\n        address _poolToken,\n        uint256 _balance\n    ) external view returns (uint256);\n\n    function getCurrentCompSupplyIndex(address _poolToken)\n        external\n        view\n        returns (uint256);\n\n    function getCurrentCompBorrowIndex(address _poolToken)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/interfaces/morpho/IMorpho.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.0;\n\nimport \"./Types.sol\";\nimport \"../IComptroller.sol\";\nimport \"./compound/ICompoundOracle.sol\";\n\n// prettier-ignore\ninterface IMorpho {\n    function comptroller() external view returns (IComptroller);\n    function supply(address _poolTokenAddress, address _onBehalf, uint256 _amount) external;\n    function supply(address _poolTokenAddress, address _onBehalf, uint256 _amount, uint256 _maxGasForMatching) external;\n    function withdraw(address _poolTokenAddress, uint256 _amount) external;\n    function claimRewards(\n        address[] calldata _cTokenAddresses,\n        bool _tradeForMorphoToken\n    ) external returns (uint256 claimedAmount);\n}\n"
    },
    "contracts/interfaces/morpho/Types.sol": {
      "content": "// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.0;\n\n/// @title Types.\n/// @author Morpho Labs.\n/// @custom:contact security@morpho.xyz\n/// @dev Common types and structs used in Moprho contracts.\nlibrary Types {\n    /// ENUMS ///\n\n    enum PositionType {\n        SUPPLIERS_IN_P2P,\n        SUPPLIERS_ON_POOL,\n        BORROWERS_IN_P2P,\n        BORROWERS_ON_POOL\n    }\n\n    /// STRUCTS ///\n\n    struct SupplyBalance {\n        uint256 inP2P; // In supplier's peer-to-peer unit, a unit that grows in underlying value, to keep track of the interests earned by suppliers in peer-to-peer. Multiply by the peer-to-peer supply index to get the underlying amount.\n        uint256 onPool; // In cToken. Multiply by the pool supply index to get the underlying amount.\n    }\n\n    struct BorrowBalance {\n        uint256 inP2P; // In borrower's peer-to-peer unit, a unit that grows in underlying value, to keep track of the interests paid by borrowers in peer-to-peer. Multiply by the peer-to-peer borrow index to get the underlying amount.\n        uint256 onPool; // In cdUnit, a unit that grows in value, to keep track of the debt increase when borrowers are on Compound. Multiply by the pool borrow index to get the underlying amount.\n    }\n\n    // Max gas to consume during the matching process for supply, borrow, withdraw and repay functions.\n    struct MaxGasForMatching {\n        uint64 supply;\n        uint64 borrow;\n        uint64 withdraw;\n        uint64 repay;\n    }\n\n    struct Delta {\n        uint256 p2pSupplyDelta; // Difference between the stored peer-to-peer supply amount and the real peer-to-peer supply amount (in pool supply unit).\n        uint256 p2pBorrowDelta; // Difference between the stored peer-to-peer borrow amount and the real peer-to-peer borrow amount (in pool borrow unit).\n        uint256 p2pSupplyAmount; // Sum of all stored peer-to-peer supply (in peer-to-peer supply unit).\n        uint256 p2pBorrowAmount; // Sum of all stored peer-to-peer borrow (in peer-to-peer borrow unit).\n    }\n\n    struct AssetLiquidityData {\n        uint256 collateralValue; // The collateral value of the asset.\n        uint256 maxDebtValue; // The maximum possible debt value of the asset.\n        uint256 debtValue; // The debt value of the asset.\n        uint256 underlyingPrice; // The price of the token.\n        uint256 collateralFactor; // The liquidation threshold applied on this token.\n    }\n\n    struct LiquidityData {\n        uint256 collateralValue; // The collateral value.\n        uint256 maxDebtValue; // The maximum debt value possible.\n        uint256 debtValue; // The debt value.\n    }\n\n    // Variables are packed together to save gas (will not exceed their limit during Morpho's lifetime).\n    struct LastPoolIndexes {\n        uint32 lastUpdateBlockNumber; // The last time the peer-to-peer indexes were updated.\n        uint112 lastSupplyPoolIndex; // Last pool supply index.\n        uint112 lastBorrowPoolIndex; // Last pool borrow index.\n    }\n\n    struct MarketParameters {\n        uint16 reserveFactor; // Proportion of the interest earned by users sent to the DAO for each market, in basis point (100% = 10 000). The value is set at market creation.\n        uint16 p2pIndexCursor; // Position of the peer-to-peer rate in the pool's spread. Determine the weights of the weighted arithmetic average in the indexes computations ((1 - p2pIndexCursor) * r^S + p2pIndexCursor * r^B) (in basis point).\n    }\n\n    struct MarketStatus {\n        bool isCreated; // Whether or not this market is created.\n        bool isPaused; // Whether the market is paused or not (all entry points on Morpho are frozen; supply, borrow, withdraw, repay and liquidate).\n        bool isPartiallyPaused; // Whether the market is partially paused or not (only supply and borrow are frozen).\n    }\n}\n"
    },
    "contracts/interfaces/plume/IFeeRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// As the copyright holder of this work, Ubiquity Labs retains\n// the right to distribute, use, and modify this code under any license of\n// their choosing, in addition to the terms of the GPL-v2 or later.\npragma solidity ^0.8.25;\n\ninterface IFeeRegistry {\n    function registerFee(\n        bool isTokenA,\n        uint32 binId,\n        uint256 binFeeInQuote\n    ) external;\n}\n"
    },
    "contracts/interfaces/plume/ILiquidityRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// As the copyright holder of this work, Ubiquity Labs retains\n// the right to distribute, use, and modify this code under any license of\n// their choosing, in addition to the terms of the GPL-v2 or later.\npragma solidity ^0.8.25;\n\nimport { IMaverickV2Pool } from \"./IMaverickV2Pool.sol\";\n\ninterface ILiquidityRegistry {\n    function notifyBinLiquidity(\n        IMaverickV2Pool pool,\n        uint256 tokenId,\n        uint32 binId,\n        uint256 currentBinLpBalance\n    ) external;\n}\n"
    },
    "contracts/interfaces/plume/IMaverickV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// As the copyright holder of this work, Ubiquity Labs retains\n// the right to distribute, use, and modify this code under any license of\n// their choosing, in addition to the terms of the GPL-v2 or later.\npragma solidity ^0.8.25;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IFeeRegistry } from \"./IFeeRegistry.sol\";\nimport { IMaverickV2Pool } from \"./IMaverickV2Pool.sol\";\n\ninterface IMaverickV2Factory {\n    error FactorAlreadyInitialized();\n    error FactorNotInitialized();\n    error FactoryInvalidTokenOrder(IERC20 _tokenA, IERC20 _tokenB);\n    error FactoryInvalidFee();\n    error FactoryInvalidKinds(uint8 kinds);\n    error FactoryInvalidTickSpacing(uint256 tickSpacing);\n    error FactoryInvalidLookback(uint256 lookback);\n    error FactoryInvalidTokenDecimals(uint8 decimalsA, uint8 decimalsB);\n    error FactoryPoolAlreadyExists(\n        uint256 feeAIn,\n        uint256 feeBIn,\n        uint256 tickSpacing,\n        uint256 lookback,\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint8 kinds,\n        address accessor\n    );\n    error FactoryAccessorMustBeNonZero();\n    error NotImplemented();\n\n    event PoolCreated(\n        IMaverickV2Pool poolAddress,\n        uint8 protocolFeeRatio,\n        uint256 feeAIn,\n        uint256 feeBIn,\n        uint256 tickSpacing,\n        uint256 lookback,\n        int32 activeTick,\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint8 kinds,\n        address accessor\n    );\n    event SetFactoryProtocolFeeReceiver(address receiver);\n    event SetFactoryProtocolFeeRegistry(IFeeRegistry registry);\n\n    struct DeployParameters {\n        uint64 feeAIn;\n        uint64 feeBIn;\n        uint32 lookback;\n        int32 activeTick;\n        uint64 tokenAScale;\n        uint64 tokenBScale;\n        // slot\n        IERC20 tokenA;\n        // slot\n        IERC20 tokenB;\n        // slot\n        uint16 tickSpacing;\n        uint8 options;\n        address accessor;\n    }\n\n    /**\n     * @notice Called by deployer library to initialize a pool.\n     */\n    function deployParameters()\n        external\n        view\n        returns (\n            uint64 feeAIn,\n            uint64 feeBIn,\n            uint32 lookback,\n            int32 activeTick,\n            uint64 tokenAScale,\n            uint64 tokenBScale,\n            // slot\n            IERC20 tokenA,\n            // slot\n            IERC20 tokenB,\n            // slot\n            uint16 tickSpacing,\n            uint8 options,\n            address accessor\n        );\n\n    /**\n     * @notice Create a new MaverickV2Pool with symmetric swap fees.\n     * @param fee Fraction of the pool swap amount that is retained as an LP in\n     * D18 scale.\n     * @param tickSpacing Tick spacing of pool where 1.0001^tickSpacing is the\n     * bin width.\n     * @param lookback Pool lookback in seconds.\n     * @param tokenA Address of tokenA.\n     * @param tokenB Address of tokenB.\n     * @param activeTick Tick position that contains the active bins.\n     * @param kinds 1-15 number to represent the active kinds\n     * 0b0001 = static;\n     * 0b0010 = right;\n     * 0b0100 = left;\n     * 0b1000 = both.\n     * E.g. a pool with all 4 modes will have kinds = b1111 = 15\n     */\n    function create(\n        uint64 fee,\n        uint16 tickSpacing,\n        uint32 lookback,\n        IERC20 tokenA,\n        IERC20 tokenB,\n        int32 activeTick,\n        uint8 kinds\n    ) external returns (IMaverickV2Pool);\n\n    /**\n     * @notice Create a new MaverickV2Pool.\n     * @param feeAIn Fraction of the pool swap amount for tokenA-input swaps\n     * that is retained as an LP in D18 scale.\n     * @param feeBIn Fraction of the pool swap amount for tokenB-input swaps\n     * that is retained as an LP in D18 scale.\n     * @param tickSpacing Tick spacing of pool where 1.0001^tickSpacing is the\n     * bin width.\n     * @param lookback Pool lookback in seconds.\n     * @param tokenA Address of tokenA.\n     * @param tokenB Address of tokenB.\n     * @param activeTick Tick position that contains the active bins.\n     * @param kinds 1-15 number to represent the active kinds\n     * 0b0001 = static;\n     * 0b0010 = right;\n     * 0b0100 = left;\n     * 0b1000 = both.\n     * e.g. a pool with all 4 modes will have kinds = b1111 = 15\n     */\n    function create(\n        uint64 feeAIn,\n        uint64 feeBIn,\n        uint16 tickSpacing,\n        uint32 lookback,\n        IERC20 tokenA,\n        IERC20 tokenB,\n        int32 activeTick,\n        uint8 kinds\n    ) external returns (IMaverickV2Pool);\n\n    /**\n     * @notice Bool indicating whether the pool was deployed from this factory.\n     */\n    function isFactoryPool(IMaverickV2Pool pool) external view returns (bool);\n\n    /**\n     * @notice Address that receives the protocol fee\n     */\n    function protocolFeeReceiver() external view returns (address);\n\n    /**\n     * @notice Address notified on swaps of the protocol fee\n     */\n    function protocolFeeRegistry() external view returns (IFeeRegistry);\n\n    /**\n     * @notice Lookup a pool for given parameters.\n     */\n    function lookup(\n        uint256 feeAIn,\n        uint256 feeBIn,\n        uint256 tickSpacing,\n        uint256 lookback,\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint8 kinds\n    ) external view returns (IMaverickV2Pool);\n\n    /**\n     * @notice Lookup a pool for given parameters.\n     */\n    function lookup(\n        IERC20 _tokenA,\n        IERC20 _tokenB,\n        uint256 startIndex,\n        uint256 endIndex\n    ) external view returns (IMaverickV2Pool[] memory pools);\n\n    /**\n     * @notice Lookup a pool for given parameters.\n     */\n    function lookup(uint256 startIndex, uint256 endIndex)\n        external\n        view\n        returns (IMaverickV2Pool[] memory pools);\n\n    /**\n     * @notice Count of permissionless pools.\n     */\n    function poolCount() external view returns (uint256 _poolCount);\n\n    /**\n     * @notice Count of pools for a given accessor and token pair.  For\n     * permissionless pools, pass `accessor = address(0)`.\n     */\n    function poolByTokenCount(\n        IERC20 _tokenA,\n        IERC20 _tokenB,\n        address accessor\n    ) external view returns (uint256 _poolCount);\n\n    /**\n     * @notice Get the current factory owner.\n     */\n    function owner() external view returns (address);\n}\n"
    },
    "contracts/interfaces/plume/IMaverickV2LiquidityManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.25;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IMaverickV2Pool } from \"./IMaverickV2Pool.sol\";\n\nimport { IMaverickV2Position } from \"./IMaverickV2Position.sol\";\nimport { IMaverickV2PoolLens } from \"./IMaverickV2PoolLens.sol\";\n\ninterface IMaverickV2LiquidityManager {\n    error LiquidityManagerNotFactoryPool();\n    error LiquidityManagerNotTokenIdOwner();\n\n    /**\n     * @notice Maverick V2 NFT position contract that tracks NFT-based\n     * liquditiy positions.\n     */\n    function position() external view returns (IMaverickV2Position);\n\n    /**\n     * @notice Create Maverick V2 pool.  Function is a pass through to the pool\n     * factory and is provided here so that is can be assembled as part of a\n     * multicall transaction.\n     */\n    function createPool(\n        uint64 fee,\n        uint16 tickSpacing,\n        uint32 lookback,\n        IERC20 tokenA,\n        IERC20 tokenB,\n        int32 activeTick,\n        uint8 kinds\n    ) external payable returns (IMaverickV2Pool pool);\n\n    /**\n     * @notice Add Liquidity position NFT for msg.sender by specifying\n     * msg.sender's token index.\n     * @dev Token index is different from tokenId.\n     * On the Position NFT contract a user can own multiple NFT tokenIds and\n     * these are indexes by an enumeration index which is the `index` input\n     * here.\n     *\n     * See addLiquidity for a description of the add params.\n     */\n    function addPositionLiquidityToSenderByTokenIndex(\n        IMaverickV2Pool pool,\n        uint256 index,\n        bytes memory packedSqrtPriceBreaks,\n        bytes[] memory packedArgs\n    )\n        external\n        payable\n        returns (\n            uint256 tokenAAmount,\n            uint256 tokenBAmount,\n            uint32[] memory binIds\n        );\n\n    /**\n     * @notice Mint new tokenId in the Position NFt contract to msg.sender.\n     * Both mints an NFT and adds liquidity to the pool that is held by the\n     * NFT.\n     */\n    function mintPositionNftToSender(\n        IMaverickV2Pool pool,\n        bytes calldata packedSqrtPriceBreaks,\n        bytes[] calldata packedArgs\n    )\n        external\n        payable\n        returns (\n            uint256 tokenAAmount,\n            uint256 tokenBAmount,\n            uint32[] memory binIds,\n            uint256 tokenId\n        );\n\n    /**\n     * @notice Donates liqudity to a pool that is held by the position contract\n     * and will never be retrievable.  Can be used to start a pool and ensure\n     * there will always be a base level of liquditiy in the pool.\n     */\n    function donateLiquidity(\n        IMaverickV2Pool pool,\n        IMaverickV2Pool.AddLiquidityParams memory args\n    ) external payable;\n\n    /**\n     * @notice Packs sqrtPrice breaks array with this format: [length,\n     * array[0], array[1],..., array[length-1]] where length is 1 byte.\n     */\n    function packUint88Array(uint88[] memory fullArray)\n        external\n        pure\n        returns (bytes memory packedArray);\n\n    /**\n     * @notice Packs addLiquidity paramters array element-wise.\n     */\n    function packAddLiquidityArgsArray(\n        IMaverickV2Pool.AddLiquidityParams[] memory args\n    ) external pure returns (bytes[] memory argsPacked);\n}\n"
    },
    "contracts/interfaces/plume/IMaverickV2Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// As the copyright holder of this work, Ubiquity Labs retains\n// the right to distribute, use, and modify this code under any license of\n// their choosing, in addition to the terms of the GPL-v2 or later.\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IMaverickV2Factory } from \"./IMaverickV2Factory.sol\";\n\ninterface IMaverickV2Pool {\n    error PoolZeroLiquidityAdded();\n    error PoolMinimumLiquidityNotMet();\n    error PoolLocked();\n    error PoolInvalidFee();\n    error PoolTicksNotSorted(uint256 index, int256 previousTick, int256 tick);\n    error PoolTicksAmountsLengthMismatch(\n        uint256 ticksLength,\n        uint256 amountsLength\n    );\n    error PoolBinIdsAmountsLengthMismatch(\n        uint256 binIdsLength,\n        uint256 amountsLength\n    );\n    error PoolKindNotSupported(uint256 kinds, uint256 kind);\n    error PoolInsufficientBalance(\n        uint256 deltaLpAmount,\n        uint256 accountBalance\n    );\n    error PoolReservesExceedMaximum(uint256 amount);\n    error PoolValueExceedsBits(uint256 amount, uint256 bits);\n    error PoolTickMaxExceeded(uint256 tick);\n    error PoolMigrateBinFirst();\n    error PoolCurrentTickBeyondSwapLimit(int32 startingTick);\n    error PoolSenderNotAccessor(address sender_, address accessor);\n    error PoolSenderNotFactory(address sender_, address accessor);\n    error PoolFunctionNotImplemented();\n    error PoolTokenNotSolvent(\n        uint256 internalReserve,\n        uint256 tokenBalance,\n        IERC20 token\n    );\n    error PoolNoProtocolFeeReceiverSet();\n\n    event PoolSwap(\n        address sender,\n        address recipient,\n        SwapParams params,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    event PoolFlashLoan(\n        address sender,\n        address recipient,\n        uint256 amountA,\n        uint256 amountB\n    );\n    event PoolProtocolFeeCollected(IERC20 token, uint256 protocolFee);\n\n    event PoolAddLiquidity(\n        address sender,\n        address recipient,\n        uint256 subaccount,\n        AddLiquidityParams params,\n        uint256 tokenAAmount,\n        uint256 tokenBAmount,\n        uint32[] binIds\n    );\n\n    event PoolMigrateBinsUpStack(\n        address sender,\n        uint32 binId,\n        uint32 maxRecursion\n    );\n\n    event PoolRemoveLiquidity(\n        address sender,\n        address recipient,\n        uint256 subaccount,\n        RemoveLiquidityParams params,\n        uint256 tokenAOut,\n        uint256 tokenBOut\n    );\n\n    event PoolTickState(int32 tick, uint256 reserveA, uint256 reserveB);\n    event PoolTickBinUpdate(int32 tick, uint8 kind, uint32 binId);\n    event PoolSqrtPrice(uint256 sqrtPrice);\n\n    /**\n     * @notice Tick state parameters.\n     */\n    struct TickState {\n        uint128 reserveA;\n        uint128 reserveB;\n        uint128 totalSupply;\n        uint32[4] binIdsByTick;\n    }\n\n    /**\n     * @notice Tick data parameters.\n     * @param currentReserveA Current reserve of token A.\n     * @param currentReserveB Current reserve of token B.\n     * @param currentLiquidity Current liquidity amount.\n     */\n    struct TickData {\n        uint256 currentReserveA;\n        uint256 currentReserveB;\n        uint256 currentLiquidity;\n    }\n\n    /**\n     * @notice Bin state parameters.\n     * @param mergeBinBalance LP token balance that this bin possesses of the merge bin.\n     * @param mergeId Bin ID of the bin that this bin has merged into.\n     * @param totalSupply Total amount of LP tokens in this bin.\n     * @param kind One of the 4 kinds (0=static, 1=right, 2=left, 3=both).\n     * @param tick The lower price tick of the bin in its current state.\n     * @param tickBalance Balance of the tick.\n     */\n    struct BinState {\n        uint128 mergeBinBalance;\n        uint128 tickBalance;\n        uint128 totalSupply;\n        uint8 kind;\n        int32 tick;\n        uint32 mergeId;\n    }\n\n    /**\n     * @notice Parameters for swap.\n     * @param amount Amount of the token that is either the input if exactOutput is false\n     * or the output if exactOutput is true.\n     * @param tokenAIn Boolean indicating whether tokenA is the input.\n     * @param exactOutput Boolean indicating whether the amount specified is\n     * the exact output amount (true).\n     * @param tickLimit The furthest tick a swap will execute in. If no limit\n     * is desired, value should be set to type(int32).max for a tokenAIn swap\n     * and type(int32).min for a swap where tokenB is the input.\n     */\n    struct SwapParams {\n        uint256 amount;\n        bool tokenAIn;\n        bool exactOutput;\n        int32 tickLimit;\n    }\n\n    /**\n     * @notice Parameters associated with adding liquidity.\n     * @param kind One of the 4 kinds (0=static, 1=right, 2=left, 3=both).\n     * @param ticks Array of ticks to add liquidity to.\n     * @param amounts Array of bin LP amounts to add.\n     */\n    struct AddLiquidityParams {\n        uint8 kind;\n        int32[] ticks;\n        uint128[] amounts;\n    }\n\n    /**\n     * @notice Parameters for each bin that will have liquidity removed.\n     * @param binIds Index array of the bins losing liquidity.\n     * @param amounts Array of bin LP amounts to remove.\n     */\n    struct RemoveLiquidityParams {\n        uint32[] binIds;\n        uint128[] amounts;\n    }\n\n    /**\n     * @notice State of the pool.\n     * @param reserveA Pool tokenA balanceOf at end of last operation\n     * @param reserveB Pool tokenB balanceOf at end of last operation\n     * @param lastTwaD8 Value of log time weighted average price at last block.\n     * Value is 8-decimal scale and is in the fractional tick domain.  E.g. a\n     * value of 12.3e8 indicates the TWAP was 3/10ths of the way into the 12th\n     * tick.\n     * @param lastLogPriceD8 Value of log price at last block. Value is\n     * 8-decimal scale and is in the fractional tick domain.  E.g. a value of\n     * 12.3e8 indicates the price was 3/10ths of the way into the 12th tick.\n     * @param lastTimestamp Last block.timestamp value in seconds for latest\n     * swap transaction.\n     * @param activeTick Current tick position that contains the active bins.\n     * @param isLocked Pool isLocked, E.g., locked or unlocked; isLocked values\n     * defined in Pool.sol.\n     * @param binCounter Index of the last bin created.\n     * @param protocolFeeRatioD3 Ratio of the swap fee that is kept for the\n     * protocol.\n     */\n    struct State {\n        uint128 reserveA;\n        uint128 reserveB;\n        int64 lastTwaD8;\n        int64 lastLogPriceD8;\n        uint40 lastTimestamp;\n        int32 activeTick;\n        bool isLocked;\n        uint32 binCounter;\n        uint8 protocolFeeRatioD3;\n    }\n\n    /**\n     * @notice Internal data used for data passing between Pool and Bin code.\n     */\n    struct BinDelta {\n        uint128 deltaA;\n        uint128 deltaB;\n    }\n\n    /**\n     * @notice 1-15 number to represent the active kinds.\n     * @notice 0b0001 = static;\n     * @notice 0b0010 = right;\n     * @notice 0b0100 = left;\n     * @notice 0b1000 = both;\n     *\n     * E.g. a pool with all 4 modes will have kinds = b1111 = 15\n     */\n    function kinds() external view returns (uint8 _kinds);\n\n    /**\n     * @notice Pool swap fee for the given direction (A-in or B-in swap) in\n     * 18-decimal format. E.g. 0.01e18 is a 1% swap fee.\n     */\n    function fee(bool tokenAIn) external view returns (uint256);\n\n    /**\n     * @notice TickSpacing of pool where 1.0001^tickSpacing is the bin width.\n     */\n    function tickSpacing() external view returns (uint256);\n\n    /**\n     * @notice Lookback period of pool in seconds.\n     */\n    function lookback() external view returns (uint256);\n\n    /**\n     * @notice Address of Pool accessor.  This is Zero address for\n     * permissionless pools.\n     */\n    function accessor() external view returns (address);\n\n    /**\n     * @notice Pool tokenA.  Address of tokenA is such that tokenA < tokenB.\n     */\n    function tokenA() external view returns (IERC20);\n\n    /**\n     * @notice Pool tokenB.\n     */\n    function tokenB() external view returns (IERC20);\n\n    /**\n     * @notice Deploying factory of the pool and also contract that has ability\n     * to set and collect protocol fees for the pool.\n     */\n    function factory() external view returns (IMaverickV2Factory);\n\n    /**\n     * @notice Most significant bit of scale value is a flag to indicate whether\n     * tokenA has more or less than 18 decimals.  Scale is used in conjuction\n     * with Math.toScale/Math.fromScale functions to convert from token amounts\n     * to D18 scale internal pool accounting.\n     */\n    function tokenAScale() external view returns (uint256);\n\n    /**\n     * @notice Most significant bit of scale value is a flag to indicate whether\n     * tokenA has more or less than 18 decimals.  Scale is used in conjuction\n     * with Math.toScale/Math.fromScale functions to convert from token amounts\n     * to D18 scale internal pool accounting.\n     */\n    function tokenBScale() external view returns (uint256);\n\n    /**\n     * @notice ID of bin at input tick position and kind.\n     */\n    function binIdByTickKind(int32 tick, uint256 kind)\n        external\n        view\n        returns (uint32);\n\n    /**\n     * @notice Accumulated tokenA protocol fee.\n     */\n    function protocolFeeA() external view returns (uint128);\n\n    /**\n     * @notice Accumulated tokenB protocol fee.\n     */\n    function protocolFeeB() external view returns (uint128);\n\n    /**\n     * @notice Lending fee rate on flash loans.\n     */\n    function lendingFeeRateD18() external view returns (uint256);\n\n    /**\n     * @notice External function to get the current time-weighted average price.\n     */\n    function getCurrentTwa() external view returns (int256);\n\n    /**\n     * @notice External function to get the state of the pool.\n     */\n    function getState() external view returns (State memory);\n\n    /**\n     * @notice Return state of Bin at input binId.\n     */\n    function getBin(uint32 binId) external view returns (BinState memory bin);\n\n    /**\n     * @notice Return state of Tick at input tick position.\n     */\n    function getTick(int32 tick)\n        external\n        view\n        returns (TickState memory tickState);\n\n    /**\n     * @notice Retrieves the balance of a user within a bin.\n     * @param user The user's address.\n     * @param subaccount The subaccount for the user.\n     * @param binId The ID of the bin.\n     */\n    function balanceOf(\n        address user,\n        uint256 subaccount,\n        uint32 binId\n    ) external view returns (uint128 lpToken);\n\n    /**\n     * @notice Add liquidity to a pool. This function allows users to deposit\n     * tokens into a liquidity pool.\n     * @dev This function will call `maverickV2AddLiquidityCallback` on the\n     * calling contract to collect the tokenA/tokenB payment.\n     * @param recipient The account that will receive credit for the added liquidity.\n     * @param subaccount The account that will receive credit for the added liquidity.\n     * @param params Parameters containing the details for adding liquidity,\n     * such as token types and amounts.\n     * @param data Bytes information that gets passed to the callback.\n     * @return tokenAAmount The amount of token A added to the pool.\n     * @return tokenBAmount The amount of token B added to the pool.\n     * @return binIds An array of bin IDs where the liquidity is stored.\n     */\n    function addLiquidity(\n        address recipient,\n        uint256 subaccount,\n        AddLiquidityParams calldata params,\n        bytes calldata data\n    )\n        external\n        returns (\n            uint256 tokenAAmount,\n            uint256 tokenBAmount,\n            uint32[] memory binIds\n        );\n\n    /**\n     * @notice Removes liquidity from the pool.\n     * @dev Liquidy can only be removed from a bin that is either unmerged or\n     * has a mergeId of an unmerged bin.  If a bin is merged more than one\n     * level deep, it must be migrated up the merge stack to the root bin\n     * before liquidity removal.\n     * @param recipient The address to receive the tokens.\n     * @param subaccount The subaccount for the recipient.\n     * @param params The parameters for removing liquidity.\n     * @return tokenAOut The amount of token A received.\n     * @return tokenBOut The amount of token B received.\n     */\n    function removeLiquidity(\n        address recipient,\n        uint256 subaccount,\n        RemoveLiquidityParams calldata params\n    ) external returns (uint256 tokenAOut, uint256 tokenBOut);\n\n    /**\n     * @notice Migrate bins up the linked list of merged bins so that its\n     * mergeId is the currrent active bin.\n     * @dev Liquidy can only be removed from a bin that is either unmerged or\n     * has a mergeId of an unmerged bin.  If a bin is merged more than one\n     * level deep, it must be migrated up the merge stack to the root bin\n     * before liquidity removal.\n     * @param binId The ID of the bin to migrate.\n     * @param maxRecursion The maximum recursion depth for the migration.\n     */\n    function migrateBinUpStack(uint32 binId, uint32 maxRecursion) external;\n\n    /**\n     * @notice Swap tokenA/tokenB assets in the pool.  The swap user has two\n     * options for funding their swap.\n     * - The user can push the input token amount to the pool before calling\n     * the swap function. In order to avoid having the pool call the callback,\n     * the user should pass a zero-length `data` bytes object with the swap\n     * call.\n     * - The user can send the input token amount to the pool when the pool\n     * calls the `maverickV2SwapCallback` function on the calling contract.\n     * That callback has input parameters that specify the token address of the\n     * input token, the input and output amounts, and the bytes data sent to\n     * the swap function.\n     * @dev  If the users elects to do a callback-based swap, the output\n     * assets will be sent before the callback is called, allowing the user to\n     * execute flash swaps.  However, the pool does have reentrancy protection,\n     * so a swapper will not be able to interact with the same pool again\n     * while they are in the callback function.\n     * @param recipient The address to receive the output tokens.\n     * @param params Parameters containing the details of the swap\n     * @param data Bytes information that gets passed to the callback.\n     */\n    function swap(\n        address recipient,\n        SwapParams memory params,\n        bytes calldata data\n    ) external returns (uint256 amountIn, uint256 amountOut);\n\n    /**\n     * @notice Loan tokenA/tokenB assets from the pool to recipient. The fee\n     * rate of a loan is determined by `lendingFeeRateD18`, which is set at the\n     * protocol level by the factory.  This function calls\n     * `maverickV2FlashLoanCallback` on the calling contract.  At the end of\n     * the callback, the caller must pay back the loan with fee (if there is a\n     * fee).\n     * @param recipient The address to receive the loaned tokens.\n     * @param amountB Loan amount of tokenA sent to recipient.\n     * @param amountB Loan amount of tokenB sent to recipient.\n     * @param data Bytes information that gets passed to the callback.\n     */\n    function flashLoan(\n        address recipient,\n        uint256 amountA,\n        uint256 amountB,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice Distributes accumulated protocol fee to factory protocolFeeReceiver\n     */\n    function distributeFees(bool isTokenA)\n        external\n        returns (uint256 protocolFee, IERC20 token);\n}\n"
    },
    "contracts/interfaces/plume/IMaverickV2PoolLens.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.25;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IMaverickV2Factory } from \"./IMaverickV2Factory.sol\";\nimport { IMaverickV2Pool } from \"./IMaverickV2Pool.sol\";\n\ninterface IMaverickV2PoolLens {\n    error LensTargetPriceOutOfBounds(\n        uint256 targetSqrtPrice,\n        uint256 sqrtLowerTickPrice,\n        uint256 sqrtUpperTickPrice\n    );\n    error LensTooLittleLiquidity(\n        uint256 relativeLiquidityAmount,\n        uint256 deltaA,\n        uint256 deltaB\n    );\n    error LensTargetingTokenWithNoDelta(\n        bool targetIsA,\n        uint256 deltaA,\n        uint256 deltaB\n    );\n\n    /**\n     * @notice Add liquidity slippage parameters for a distribution of liquidity.\n     * @param pool Pool where liquidity is being added.\n     * @param kind Bin kind; all bins must have the same kind in a given call\n     * to addLiquidity.\n     * @param ticks Array of tick values to add liquidity to.\n     * @param relativeLiquidityAmounts Relative liquidity amounts for the\n     * specified ticks.  Liquidity in this case is not bin LP balance, it is\n     * the bin liquidity as defined by liquidity = deltaA / (sqrt(upper) -\n     * sqrt(lower)) or deltaB = liquidity / sqrt(lower) - liquidity /\n     * sqrt(upper).\n     * @param addSpec Slippage specification.\n     */\n    struct AddParamsViewInputs {\n        IMaverickV2Pool pool;\n        uint8 kind;\n        int32[] ticks;\n        uint128[] relativeLiquidityAmounts;\n        AddParamsSpecification addSpec;\n    }\n\n    /**\n     * @notice Multi-price add param specification.\n     * @param slippageFactorD18 Max slippage allowed as a percent in D18 scale. e.g. 1% slippage is 0.01e18\n     * @param numberOfPriceBreaksPerSide Number of price break values on either\n     * side of current price.\n     * @param targetAmount Target token contribution amount in tokenA if\n     * targetIsA is true, otherwise this is the target amount for tokenB.\n     * @param targetIsA  Indicates if the target amount is for tokenA or tokenB\n     */\n    struct AddParamsSpecification {\n        uint256 slippageFactorD18;\n        uint256 numberOfPriceBreaksPerSide;\n        uint256 targetAmount;\n        bool targetIsA;\n    }\n\n    /**\n     * @notice Specification for deriving create pool parameters. Creating a\n     * pool in the liquidity manager has several steps:\n     *\n     * - Deploy pool\n     * - Donate a small amount of initial liquidity in the activeTick\n     * - Execute a small swap to set the pool price to the desired value\n     * - Add liquidity\n     *\n     * In order to execute these steps, the caller must specify the parameters\n     * of each step.  The PoolLens has helper function to derive the values\n     * used by the LiquidityManager, but this struct is the input to that\n     * helper function and represents the core intent of the pool creator.\n     *\n     * @param fee Fraction of the pool swap amount that is retained as an LP in\n     * D18 scale.\n     * @param tickSpacing Tick spacing of pool where 1.0001^tickSpacing is the\n     * bin width.\n     * @param lookback Pool lookback in seconds.\n     * @param tokenA Address of tokenA.\n     * @param tokenB Address of tokenB.\n     * @param activeTick Tick position that contains the active bins.\n     * @param kinds 1-15 number to represent the active kinds\n     * 0b0001 = static;\n     * 0b0010 = right;\n     * 0b0100 = left;\n     * 0b1000 = both.\n     * e.g. a pool with all 4 modes will have kinds = b1111 = 15\n     * @param initialTargetB Amount of B to be donated to the pool after pool\n     * create.  This amount needs to be big enough to meet the minimum bin\n     * liquidity.\n     * @param sqrtPrice Target sqrt price of the pool.\n     * @param kind Bin kind; all bins must have the same kind in a given call\n     * to addLiquidity.\n     * @param ticks Array of tick values to add liquidity to.\n     * @param relativeLiquidityAmounts Relative liquidity amounts for the\n     * specified ticks.  Liquidity in this case is not bin LP balance, it is\n     * the bin liquidity as defined by liquidity = deltaA / (sqrt(upper) -\n     * sqrt(lower)) or deltaB = liquidity / sqrt(lower) - liquidity /\n     * sqrt(upper).\n     * @param targetAmount Target token contribution amount in tokenA if\n     * targetIsA is true, otherwise this is the target amount for tokenB.\n     * @param targetIsA  Indicates if the target amount is for tokenA or tokenB\n     */\n    struct CreateAndAddParamsViewInputs {\n        uint64 feeAIn;\n        uint64 feeBIn;\n        uint16 tickSpacing;\n        uint32 lookback;\n        IERC20 tokenA;\n        IERC20 tokenB;\n        int32 activeTick;\n        uint8 kinds;\n        // donate params\n        uint256 initialTargetB;\n        uint256 sqrtPrice;\n        // add target\n        uint8 kind;\n        int32[] ticks;\n        uint128[] relativeLiquidityAmounts;\n        uint256 targetAmount;\n        bool targetIsA;\n    }\n\n    struct Output {\n        uint256 deltaAOut;\n        uint256 deltaBOut;\n        uint256[] deltaAs;\n        uint256[] deltaBs;\n        uint128[] deltaLpBalances;\n    }\n\n    struct Reserves {\n        uint256 amountA;\n        uint256 amountB;\n    }\n\n    struct BinPositionKinds {\n        uint128[4] values;\n    }\n\n    struct PoolState {\n        IMaverickV2Pool.TickState[] tickStateMapping;\n        IMaverickV2Pool.BinState[] binStateMapping;\n        BinPositionKinds[] binIdByTickKindMapping;\n        IMaverickV2Pool.State state;\n        Reserves protocolFees;\n    }\n\n    struct BoostedPositionSpecification {\n        IMaverickV2Pool pool;\n        uint32[] binIds;\n        uint128[] ratios;\n        uint8 kind;\n    }\n\n    struct CreateAndAddParamsInputs {\n        uint64 feeAIn;\n        uint64 feeBIn;\n        uint16 tickSpacing;\n        uint32 lookback;\n        IERC20 tokenA;\n        IERC20 tokenB;\n        int32 activeTick;\n        uint8 kinds;\n        // donate params\n        IMaverickV2Pool.AddLiquidityParams donateParams;\n        // swap params\n        uint256 swapAmount;\n        // add params\n        IMaverickV2Pool.AddLiquidityParams addParams;\n        bytes[] packedAddParams;\n        uint256 deltaAOut;\n        uint256 deltaBOut;\n        uint256 preAddReserveA;\n        uint256 preAddReserveB;\n    }\n\n    struct TickDeltas {\n        uint256 deltaAOut;\n        uint256 deltaBOut;\n        uint256[] deltaAs;\n        uint256[] deltaBs;\n    }\n\n    /**\n     * @notice Converts add parameter slippage specification into add\n     * parameters.  The return values are given in both raw format and as packed\n     * values that can be used in the LiquidityManager contract.\n     */\n    function getAddLiquidityParams(AddParamsViewInputs memory params)\n        external\n        view\n        returns (\n            bytes memory packedSqrtPriceBreaks,\n            bytes[] memory packedArgs,\n            uint88[] memory sqrtPriceBreaks,\n            IMaverickV2Pool.AddLiquidityParams[] memory addParams,\n            IMaverickV2PoolLens.TickDeltas[] memory tickDeltas\n        );\n\n    /**\n     * @notice Converts add parameter slippage specification and new pool\n     * specification into CreateAndAddParamsInputs parameters that can be used in the\n     * LiquidityManager contract.\n     */\n    function getCreatePoolAtPriceAndAddLiquidityParams(\n        CreateAndAddParamsViewInputs memory params\n    ) external view returns (CreateAndAddParamsInputs memory output);\n\n    /**\n     * @notice View function that provides information about pool ticks within\n     * a tick radius from the activeTick. Ticks with no reserves are not\n     * included in part o f the return array.\n     */\n    function getTicksAroundActive(IMaverickV2Pool pool, int32 tickRadius)\n        external\n        view\n        returns (\n            int32[] memory ticks,\n            IMaverickV2Pool.TickState[] memory tickStates\n        );\n\n    /**\n     * @notice View function that provides information about pool ticks within\n     * a range. Ticks with no reserves are not included in part o f the return\n     * array.\n     */\n    function getTicks(\n        IMaverickV2Pool pool,\n        int32 tickStart,\n        int32 tickEnd\n    )\n        external\n        view\n        returns (\n            int32[] memory ticks,\n            IMaverickV2Pool.TickState[] memory tickStates\n        );\n\n    /**\n     * @notice View function that provides information about pool ticks within\n     * a range.  Information returned includes all pool state needed to emulate\n     * a swap off chain. Ticks with no reserves are not included in part o f\n     * the return array.\n     */\n    function getTicksAroundActiveWLiquidity(\n        IMaverickV2Pool pool,\n        int32 tickRadius\n    )\n        external\n        view\n        returns (\n            int32[] memory ticks,\n            IMaverickV2Pool.TickState[] memory tickStates,\n            uint256[] memory liquidities,\n            uint256[] memory sqrtLowerTickPrices,\n            uint256[] memory sqrtUpperTickPrices,\n            IMaverickV2Pool.State memory poolState,\n            uint256 sqrtPrice,\n            uint256 feeAIn,\n            uint256 feeBIn\n        );\n\n    /**\n     * @notice View function that provides pool state information.\n     */\n    function getFullPoolState(\n        IMaverickV2Pool pool,\n        uint32 binStart,\n        uint32 binEnd\n    ) external view returns (PoolState memory poolState);\n\n    /**\n     * @notice View function that provides price and liquidity of a given tick.\n     */\n    function getTickSqrtPriceAndL(IMaverickV2Pool pool, int32 tick)\n        external\n        view\n        returns (uint256 sqrtPrice, uint256 liquidity);\n\n    /**\n     * @notice Pool sqrt price.\n     */\n    function getPoolSqrtPrice(IMaverickV2Pool pool)\n        external\n        view\n        returns (uint256 sqrtPrice);\n\n    /**\n     * @notice Pool price.\n     */\n    function getPoolPrice(IMaverickV2Pool pool)\n        external\n        view\n        returns (uint256 price);\n\n    /**\n     * @notice Token scale of two tokens in a pool.\n     */\n    function tokenScales(IMaverickV2Pool pool)\n        external\n        view\n        returns (uint256 tokenAScale, uint256 tokenBScale);\n}\n"
    },
    "contracts/interfaces/plume/IMaverickV2Position.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.25;\n\nimport { IMaverickV2Factory } from \"./IMaverickV2Factory.sol\";\nimport { IMaverickV2Pool } from \"./IMaverickV2Pool.sol\";\nimport { ILiquidityRegistry } from \"./ILiquidityRegistry.sol\";\n\ninterface IMaverickV2Position {\n    event PositionClearData(uint256 indexed tokenId);\n    event PositionSetData(\n        uint256 indexed tokenId,\n        uint256 index,\n        PositionPoolBinIds newData\n    );\n    event SetLpReward(ILiquidityRegistry lpReward);\n\n    error PositionDuplicatePool(uint256 index, IMaverickV2Pool pool);\n    error PositionNotFactoryPool();\n    error PositionPermissionedLiquidityPool();\n\n    struct PositionPoolBinIds {\n        IMaverickV2Pool pool;\n        uint32[] binIds;\n    }\n\n    struct PositionFullInformation {\n        PositionPoolBinIds poolBinIds;\n        uint256 amountA;\n        uint256 amountB;\n        uint256[] binAAmounts;\n        uint256[] binBAmounts;\n        int32[] ticks;\n        uint256[] liquidities;\n    }\n\n    /**\n     * @notice Factory that tracks lp rewards.\n     */\n    function lpReward() external view returns (ILiquidityRegistry);\n\n    /**\n     * @notice Pool factory.\n     */\n    function factory() external view returns (IMaverickV2Factory);\n\n    /**\n     * @notice Mint NFT that holds liquidity in a Maverick V2 Pool. To mint\n     * liquidity to an NFT, add liquidity to bins in a pool where the\n     * add liquidity recipient is this contract and the subaccount is the\n     * tokenId. LiquidityManager can be used to simplify minting Position NFTs.\n     */\n    function mint(\n        address recipient,\n        IMaverickV2Pool pool,\n        uint32[] memory binIds\n    ) external returns (uint256 tokenId);\n\n    /**\n     * @notice Overwrites tokenId pool/binId information for a given data index.\n     */\n    function setTokenIdData(\n        uint256 tokenId,\n        uint256 index,\n        IMaverickV2Pool pool,\n        uint32[] memory binIds\n    ) external;\n\n    /**\n     * @notice Overwrites entire pool/binId data set for a given tokenId.\n     */\n    function setTokenIdData(uint256 tokenId, PositionPoolBinIds[] memory data)\n        external;\n\n    /**\n     * @notice Append new pool/binIds data array to tokenId.\n     */\n    function appendTokenIdData(\n        uint256 tokenId,\n        IMaverickV2Pool pool,\n        uint32[] memory binIds\n    ) external;\n\n    /**\n     * @notice Get array pool/binIds data for a given tokenId.\n     */\n    function getTokenIdData(uint256 tokenId)\n        external\n        view\n        returns (PositionPoolBinIds[] memory);\n\n    /**\n     * @notice Get value from array of pool/binIds data for a given tokenId.\n     */\n    function getTokenIdData(uint256 tokenId, uint256 index)\n        external\n        view\n        returns (PositionPoolBinIds memory);\n\n    /**\n     * @notice Length of array of pool/binIds data for a given tokenId.\n     */\n    function tokenIdDataLength(uint256 tokenId)\n        external\n        view\n        returns (uint256 length);\n\n    /**\n     * @notice Remove liquidity from tokenId for a given pool.  User can\n     * specify arbitrary bins to remove from for their subaccount in the pool\n     * even if those bins are not in the tokenIdData set.\n     */\n    function removeLiquidity(\n        uint256 tokenId,\n        address recipient,\n        IMaverickV2Pool pool,\n        IMaverickV2Pool.RemoveLiquidityParams memory params\n    ) external returns (uint256 tokenAAmount, uint256 tokenBAmount);\n\n    /**\n     * @notice Remove liquidity from tokenId for a given pool to sender.  User\n     * can specify arbitrary bins to remove from for their subaccount in the\n     * pool even if those bins are not in the tokenIdData set.\n     */\n    function removeLiquidityToSender(\n        uint256 tokenId,\n        IMaverickV2Pool pool,\n        IMaverickV2Pool.RemoveLiquidityParams memory params\n    ) external returns (uint256 tokenAAmount, uint256 tokenBAmount);\n\n    /**\n     * @notice NFT asset information for a given range of pool/binIds indexes.\n     * This function only returns the liquidity in the pools/binIds stored as\n     * part of the tokenIdData, but it is possible that the NFT has additional\n     * liquidity in pools/binIds that have not been recorded.\n     */\n    function tokenIdPositionInformation(\n        uint256 tokenId,\n        uint256 startIndex,\n        uint256 stopIndex\n    ) external view returns (PositionFullInformation[] memory output);\n\n    /**\n     * @notice NFT asset information for a given pool/binIds index. This\n     * function only returns the liquidity in the pools/binIds stored as part\n     * of the tokenIdData, but it is possible that the NFT has additional\n     * liquidity in pools/binIds that have not been recorded.\n     */\n    function tokenIdPositionInformation(uint256 tokenId, uint256 index)\n        external\n        view\n        returns (PositionFullInformation memory output);\n\n    /**\n     * @notice Get remove parameters for removing a fractional part of the\n     * liquidity owned by a given tokenId.  The fractional factor to remove is\n     * given by proporationD18 in 18-decimal scale.\n     */\n    function getRemoveParams(\n        uint256 tokenId,\n        uint256 index,\n        uint256 proportionD18\n    )\n        external\n        view\n        returns (IMaverickV2Pool.RemoveLiquidityParams memory params);\n\n    /**\n     * @notice Register the bin balances in the nft with the LpReward contract.\n     */\n    function checkpointBinLpBalance(\n        uint256 tokenId,\n        IMaverickV2Pool pool,\n        uint32[] memory binIds\n    ) external;\n}\n"
    },
    "contracts/interfaces/plume/IMaverickV2Quoter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.25;\n\nimport { IMaverickV2Pool } from \"./IMaverickV2Pool.sol\";\n\ninterface IMaverickV2Quoter {\n    error QuoterInvalidSwap();\n    error QuoterInvalidAddLiquidity();\n\n    /**\n     * @notice Calculates a swap on a MaverickV2Pool and returns the resulting\n     * amount and estimated gas.  The gas estimate is only a rough estimate and\n     * may not match a swap's gas.\n     * @param pool The MaverickV2Pool to swap on.\n     * @param amount The input amount.\n     * @param tokenAIn Indicates if token A is the input token.\n     * @param exactOutput Indicates if the amount is the output amount (true)\n     * or input amount (false). If the tickLimit is reached, the full value of\n     * the exactOutput may not be returned because the pool will stop swapping\n     * before the whole order is filled.\n     * @param tickLimit The tick limit for the swap. Once the swap lands in\n     * this tick, it will stop and return the output amount swapped up to that\n     * tick.\n     */\n    function calculateSwap(\n        IMaverickV2Pool pool,\n        uint128 amount,\n        bool tokenAIn,\n        bool exactOutput,\n        int32 tickLimit\n    )\n        external\n        returns (\n            uint256 amountIn,\n            uint256 amountOut,\n            uint256 gasEstimate\n        );\n\n    /**\n     * @notice Calculates a multihop swap and returns the resulting amount and\n     * estimated gas. The gas estimate is only a rough estimate and\n     * may not match a swap's gas.\n     * @param path The path of pools to swap through. Path is given by an\n     * packed array of (pool, tokenAIn) tuples. So each step in the path is 160\n     * + 8 = 168 bits of data. e.g. path = abi.encodePacked(pool1, true, pool2, false);\n     * @param amount The input amount.\n     * @param exactOutput A boolean indicating if exact output is required.\n     */\n    function calculateMultiHopSwap(\n        bytes memory path,\n        uint256 amount,\n        bool exactOutput\n    ) external returns (uint256 returnAmount, uint256 gasEstimate);\n\n    /**\n     * @notice Computes the token amounts required for a given set of\n     * addLiquidity parameters. The gas estimate is only a rough estimate and\n     * may not match a add's gas.\n     */\n    function calculateAddLiquidity(\n        IMaverickV2Pool pool,\n        IMaverickV2Pool.AddLiquidityParams calldata params\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 gasEstimate\n        );\n\n    /**\n     * @notice Pool's sqrt price.\n     */\n    function poolSqrtPrice(IMaverickV2Pool pool)\n        external\n        view\n        returns (uint256 sqrtPrice);\n}\n"
    },
    "contracts/interfaces/plume/IPoolDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport { IMaverickV2Pool } from \"./IMaverickV2Pool.sol\";\n\ninterface IPoolDistributor {\n    function rewardToken() external view returns (address);\n\n    function claimLp(\n        address recipient,\n        uint256 tokenId,\n        IMaverickV2Pool pool,\n        uint32[] memory binIds,\n        uint256 epoch\n    ) external returns (uint256 amount);\n}\n"
    },
    "contracts/interfaces/plume/IVotingDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\ninterface IVotingDistributor {\n    function lastEpoch() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/poolBooster/IPoolBoostCentralRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IPoolBoostCentralRegistry {\n    /**\n     * @dev all the supported pool booster types are listed here. It is possible\n     *      to have multiple versions of the factory that supports the same type of\n     *      pool booster. Factories are immutable and this can happen when a factory\n     *      or related pool booster required code update.\n     *      e.g. \"PoolBoosterSwapxDouble\" & \"PoolBoosterSwapxDouble_v2\"\n     */\n    enum PoolBoosterType {\n        // Supports bribing 2 contracts per pool. Appropriate for Ichi vault concentrated\n        // liquidity pools where (which is expected in most/all cases) both pool gauges\n        // require bribing.\n        SwapXDoubleBooster,\n        // Supports bribing a single contract per pool. Appropriate for Classic Stable &\n        // Classic Volatile pools and Ichi vaults where only 1 side (1 of the 2 gauges)\n        // needs bribing\n        SwapXSingleBooster,\n        // Supports bribing a single contract per pool. Appropriate for Metropolis pools\n        MetropolisBooster,\n        // Supports creating a Merkl campaign.\n        MerklBooster,\n        // Supports creating a plain Curve pool booster\n        CurvePoolBoosterPlain\n    }\n\n    struct PoolBoosterEntry {\n        address boosterAddress;\n        address ammPoolAddress;\n        PoolBoosterType boosterType;\n    }\n\n    event PoolBoosterCreated(\n        address poolBoosterAddress,\n        address ammPoolAddress,\n        PoolBoosterType poolBoosterType,\n        address factoryAddress\n    );\n    event PoolBoosterRemoved(address poolBoosterAddress);\n\n    function emitPoolBoosterCreated(\n        address _poolBoosterAddress,\n        address _ammPoolAddress,\n        PoolBoosterType _boosterType\n    ) external;\n\n    function emitPoolBoosterRemoved(address _poolBoosterAddress) external;\n}\n"
    },
    "contracts/interfaces/sonic/ISFC.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n/**\n * @title Special Fee Contract for Sonic network\n * @notice The SFC maintains a list of validators and delegators and distributes rewards to them.\n * @custom:security-contact security@fantom.foundation\n */\ninterface ISFC {\n    error StakeIsFullySlashed();\n\n    event CreatedValidator(\n        uint256 indexed validatorID,\n        address indexed auth,\n        uint256 createdEpoch,\n        uint256 createdTime\n    );\n    event Delegated(\n        address indexed delegator,\n        uint256 indexed validatorID,\n        uint256 amount\n    );\n    event Undelegated(\n        address indexed delegator,\n        uint256 indexed validatorID,\n        uint256 indexed wrID,\n        uint256 amount\n    );\n    event Withdrawn(\n        address indexed delegator,\n        uint256 indexed validatorID,\n        uint256 indexed wrID,\n        uint256 amount,\n        uint256 penalty\n    );\n    event ClaimedRewards(\n        address indexed delegator,\n        uint256 indexed validatorID,\n        uint256 rewards\n    );\n    event RestakedRewards(\n        address indexed delegator,\n        uint256 indexed validatorID,\n        uint256 rewards\n    );\n    event BurntFTM(uint256 amount);\n    event UpdatedSlashingRefundRatio(\n        uint256 indexed validatorID,\n        uint256 refundRatio\n    );\n    event RefundedSlashedLegacyDelegation(\n        address indexed delegator,\n        uint256 indexed validatorID,\n        uint256 amount\n    );\n\n    event DeactivatedValidator(\n        uint256 indexed validatorID,\n        uint256 deactivatedEpoch,\n        uint256 deactivatedTime\n    );\n    event ChangedValidatorStatus(uint256 indexed validatorID, uint256 status);\n    event AnnouncedRedirection(address indexed from, address indexed to);\n\n    function currentSealedEpoch() external view returns (uint256);\n\n    function getEpochSnapshot(uint256 epoch)\n        external\n        view\n        returns (\n            uint256 endTime,\n            uint256 endBlock,\n            uint256 epochFee,\n            uint256 baseRewardPerSecond,\n            uint256 totalStake,\n            uint256 totalSupply\n        );\n\n    function getStake(address delegator, uint256 validatorID)\n        external\n        view\n        returns (uint256);\n\n    function getValidator(uint256 validatorID)\n        external\n        view\n        returns (\n            uint256 status,\n            uint256 receivedStake,\n            address auth,\n            uint256 createdEpoch,\n            uint256 createdTime,\n            uint256 deactivatedTime,\n            uint256 deactivatedEpoch\n        );\n\n    function getValidatorID(address auth) external view returns (uint256);\n\n    function getValidatorPubkey(uint256 validatorID)\n        external\n        view\n        returns (bytes memory);\n\n    function pubkeyAddressvalidatorID(address pubkeyAddress)\n        external\n        view\n        returns (uint256);\n\n    function getWithdrawalRequest(\n        address delegator,\n        uint256 validatorID,\n        uint256 wrID\n    )\n        external\n        view\n        returns (\n            uint256 epoch,\n            uint256 time,\n            uint256 amount\n        );\n\n    function isOwner() external view returns (bool);\n\n    function lastValidatorID() external view returns (uint256);\n\n    function minGasPrice() external view returns (uint256);\n\n    function owner() external view returns (address);\n\n    function renounceOwnership() external;\n\n    function slashingRefundRatio(uint256 validatorID)\n        external\n        view\n        returns (uint256);\n\n    function stashedRewardsUntilEpoch(address delegator, uint256 validatorID)\n        external\n        view\n        returns (uint256);\n\n    function totalActiveStake() external view returns (uint256);\n\n    function totalStake() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function transferOwnership(address newOwner) external;\n\n    function treasuryAddress() external view returns (address);\n\n    function version() external pure returns (bytes3);\n\n    function currentEpoch() external view returns (uint256);\n\n    function updateConstsAddress(address v) external;\n\n    function constsAddress() external view returns (address);\n\n    function getEpochValidatorIDs(uint256 epoch)\n        external\n        view\n        returns (uint256[] memory);\n\n    function getEpochReceivedStake(uint256 epoch, uint256 validatorID)\n        external\n        view\n        returns (uint256);\n\n    function getEpochAccumulatedRewardPerToken(\n        uint256 epoch,\n        uint256 validatorID\n    ) external view returns (uint256);\n\n    function getEpochAccumulatedUptime(uint256 epoch, uint256 validatorID)\n        external\n        view\n        returns (uint256);\n\n    function getEpochAverageUptime(uint256 epoch, uint256 validatorID)\n        external\n        view\n        returns (uint32);\n\n    function getEpochAccumulatedOriginatedTxsFee(\n        uint256 epoch,\n        uint256 validatorID\n    ) external view returns (uint256);\n\n    function getEpochOfflineTime(uint256 epoch, uint256 validatorID)\n        external\n        view\n        returns (uint256);\n\n    function getEpochOfflineBlocks(uint256 epoch, uint256 validatorID)\n        external\n        view\n        returns (uint256);\n\n    function getEpochEndBlock(uint256 epoch) external view returns (uint256);\n\n    function rewardsStash(address delegator, uint256 validatorID)\n        external\n        view\n        returns (uint256);\n\n    function createValidator(bytes calldata pubkey) external payable;\n\n    function getSelfStake(uint256 validatorID) external view returns (uint256);\n\n    function delegate(uint256 validatorID) external payable;\n\n    function undelegate(\n        uint256 validatorID,\n        uint256 wrID,\n        uint256 amount\n    ) external;\n\n    function isSlashed(uint256 validatorID) external view returns (bool);\n\n    function withdraw(uint256 validatorID, uint256 wrID) external;\n\n    function deactivateValidator(uint256 validatorID, uint256 status) external;\n\n    function pendingRewards(address delegator, uint256 validatorID)\n        external\n        view\n        returns (uint256);\n\n    function stashRewards(address delegator, uint256 validatorID) external;\n\n    function claimRewards(uint256 validatorID) external;\n\n    function restakeRewards(uint256 validatorID) external;\n\n    function updateSlashingRefundRatio(uint256 validatorID, uint256 refundRatio)\n        external;\n\n    function updateTreasuryAddress(address v) external;\n\n    function burnFTM(uint256 amount) external;\n\n    function sealEpoch(\n        uint256[] calldata offlineTime,\n        uint256[] calldata offlineBlocks,\n        uint256[] calldata uptimes,\n        uint256[] calldata originatedTxsFee\n    ) external;\n\n    function sealEpochValidators(uint256[] calldata nextValidatorIDs) external;\n\n    function initialize(\n        uint256 sealedEpoch,\n        uint256 _totalSupply,\n        address nodeDriver,\n        address consts,\n        address _owner\n    ) external;\n\n    function setGenesisValidator(\n        address auth,\n        uint256 validatorID,\n        bytes calldata pubkey,\n        uint256 createdTime\n    ) external;\n\n    function setGenesisDelegation(\n        address delegator,\n        uint256 validatorID,\n        uint256 stake\n    ) external;\n\n    function updateStakeSubscriberAddress(address v) external;\n\n    function stakeSubscriberAddress() external view returns (address);\n\n    function setRedirectionAuthorizer(address v) external;\n\n    function announceRedirection(address to) external;\n\n    function initiateRedirection(address from, address to) external;\n\n    function redirect(address to) external;\n}\n"
    },
    "contracts/interfaces/sonic/ISwapXGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IGauge {\n    function owner() external view returns (address);\n\n    function TOKEN() external view returns (address);\n\n    function DISTRIBUTION() external view returns (address);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function claimFees() external returns (uint256 claimed0, uint256 claimed1);\n\n    function deposit(uint256 amount) external;\n\n    function depositAll() external;\n\n    function earned(address account) external view returns (uint256);\n\n    function getReward() external;\n\n    function getReward(address _user) external;\n\n    function isForPair() external view returns (bool);\n\n    function lastTimeRewardApplicable() external view returns (uint256);\n\n    function lastUpdateTime() external view returns (uint256);\n\n    function notifyRewardAmount(address token, uint256 reward) external;\n\n    function periodFinish() external view returns (uint256);\n\n    function rewardForDuration() external view returns (uint256);\n\n    function rewardPerToken() external view returns (uint256);\n\n    function rewardPerTokenStored() external view returns (uint256);\n\n    function rewardRate() external view returns (uint256);\n\n    function rewardToken() external view returns (address);\n\n    function rewards(address) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function userRewardPerTokenPaid(address) external view returns (uint256);\n\n    function withdraw(uint256 amount) external;\n\n    function withdrawAll() external;\n\n    function withdrawAllAndHarvest() external;\n\n    function withdrawExcess(address token, uint256 amount) external;\n\n    function emergency() external returns (bool);\n\n    function emergencyWithdraw() external;\n\n    function activateEmergencyMode() external;\n\n    function stopEmergencyMode() external;\n}\n"
    },
    "contracts/interfaces/sonic/ISwapXPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPair {\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Claim(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    function metadata()\n        external\n        view\n        returns (\n            uint256 dec0,\n            uint256 dec1,\n            uint256 r0,\n            uint256 r1,\n            bool st,\n            address t0,\n            address t1\n        );\n\n    function claimFees() external returns (uint256, uint256);\n\n    function tokens() external view returns (address, address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function burn(address to)\n        external\n        returns (uint256 amount0, uint256 amount1);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint256 _reserve0,\n            uint256 _reserve1,\n            uint256 _blockTimestampLast\n        );\n\n    function getAmountOut(uint256, address) external view returns (uint256);\n\n    // ERC20 methods\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function claimable0(address _user) external view returns (uint256);\n\n    function claimable1(address _user) external view returns (uint256);\n\n    function isStable() external view returns (bool);\n\n    function skim(address to) external;\n\n    function sync() external;\n}\n"
    },
    "contracts/interfaces/sonic/IWrappedSonic.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWrappedSonic {\n    event Deposit(address indexed account, uint256 value);\n    event Withdrawal(address indexed account, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function deposit() external payable;\n\n    function depositFor(address account) external payable returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function withdraw(uint256 value) external;\n\n    function withdrawTo(address account, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/interfaces/uniswap/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Router {\n    function WETH() external pure returns (address);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n}\n"
    },
    "contracts/interfaces/uniswap/IUniswapV3Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// -- Solididy v0.5.x compatible interface\ninterface IUniswapV3Router {\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n}\n"
    },
    "contracts/mocks/crosschain/CCTPMessageTransmitterMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ICCTPMessageTransmitter } from \"../../interfaces/cctp/ICCTP.sol\";\nimport { IERC20 } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { BytesHelper } from \"../../utils/BytesHelper.sol\";\nimport { AbstractCCTPIntegrator } from \"../../strategies/crosschain/AbstractCCTPIntegrator.sol\";\n\n/**\n * @title Mock conctract simulating the functionality of the CCTPTokenMessenger contract\n *        for the porposes of unit testing.\n * @author Origin Protocol Inc\n */\n\ncontract CCTPMessageTransmitterMock is ICCTPMessageTransmitter {\n    using BytesHelper for bytes;\n\n    IERC20 public usdc;\n    uint256 public nonce = 0;\n    // Sender index in the burn message v2\n    // Ref: https://github.com/circlefin/evm-cctp-contracts/blob/master/src/messages/v2/BurnMessageV2.sol\n    uint8 constant BURN_MESSAGE_V2_MESSAGE_SENDER_INDEX = 100;\n    uint8 constant BURN_MESSAGE_V2_HOOK_DATA_INDEX = 228;\n\n    uint16 public messageFinality = 2000;\n    address public messageSender;\n    uint32 public sourceDomain = 4294967295; // 0xFFFFFFFF\n\n    // Full message with header\n    struct Message {\n        uint32 version;\n        uint32 sourceDomain;\n        uint32 destinationDomain;\n        bytes32 recipient;\n        bytes32 messageHeaderRecipient;\n        bytes32 sender;\n        bytes32 destinationCaller;\n        uint32 minFinalityThreshold;\n        bool isTokenTransfer;\n        uint256 tokenAmount;\n        bytes messageBody;\n    }\n\n    Message[] public messages;\n    // map of encoded messages to the corresponding message structs\n    mapping(bytes32 => Message) public encodedMessages;\n\n    constructor(address _usdc) {\n        usdc = IERC20(_usdc);\n    }\n\n    // @dev for the porposes of unit tests queues the message to be mock-sent using\n    // the cctp bridge.\n    function sendMessage(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        uint32 minFinalityThreshold,\n        bytes memory messageBody\n    ) external virtual override {\n        bytes32 nonceHash = keccak256(abi.encodePacked(nonce));\n        nonce++;\n\n        // If destination is mainnet, source is base and vice versa\n        uint32 sourceDomain = destinationDomain == 0 ? 6 : 0;\n\n        Message memory message = Message({\n            version: 1,\n            sourceDomain: sourceDomain,\n            destinationDomain: destinationDomain,\n            recipient: recipient,\n            messageHeaderRecipient: recipient,\n            sender: bytes32(uint256(uint160(msg.sender))),\n            destinationCaller: destinationCaller,\n            minFinalityThreshold: minFinalityThreshold,\n            isTokenTransfer: false,\n            tokenAmount: 0,\n            messageBody: messageBody\n        });\n\n        messages.push(message);\n    }\n\n    // @dev for the porposes of unit tests queues the USDC burn/mint to be executed\n    // using the cctp bridge.\n    function sendTokenTransferMessage(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        uint32 minFinalityThreshold,\n        uint256 tokenAmount,\n        bytes memory messageBody\n    ) external {\n        bytes32 nonceHash = keccak256(abi.encodePacked(nonce));\n        nonce++;\n\n        // If destination is mainnet, source is base and vice versa\n        uint32 sourceDomain = destinationDomain == 0 ? 6 : 0;\n\n        Message memory message = Message({\n            version: 1,\n            sourceDomain: sourceDomain,\n            destinationDomain: destinationDomain,\n            recipient: recipient,\n            messageHeaderRecipient: recipient,\n            sender: bytes32(uint256(uint160(msg.sender))),\n            destinationCaller: destinationCaller,\n            minFinalityThreshold: minFinalityThreshold,\n            isTokenTransfer: true,\n            tokenAmount: tokenAmount,\n            messageBody: messageBody\n        });\n\n        messages.push(message);\n    }\n\n    function receiveMessage(bytes memory message, bytes memory attestation)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        Message memory storedMsg = encodedMessages[keccak256(message)];\n        AbstractCCTPIntegrator recipient = AbstractCCTPIntegrator(\n            address(uint160(uint256(storedMsg.recipient)))\n        );\n\n        bytes32 sender = storedMsg.sender;\n        bytes memory messageBody = storedMsg.messageBody;\n\n        // Credit USDC in this step as it is done in the live cctp contracts\n        if (storedMsg.isTokenTransfer) {\n            usdc.transfer(address(recipient), storedMsg.tokenAmount);\n            // override the sender with the one stored in the Burn message as the sender int he\n            // message header is the TokenMessenger.\n            sender = bytes32(\n                uint256(\n                    uint160(\n                        storedMsg.messageBody.extractAddress(\n                            BURN_MESSAGE_V2_MESSAGE_SENDER_INDEX\n                        )\n                    )\n                )\n            );\n            messageBody = storedMsg.messageBody.extractSlice(\n                BURN_MESSAGE_V2_HOOK_DATA_INDEX,\n                storedMsg.messageBody.length\n            );\n        } else {\n            bytes32 overrideSenderBytes = bytes32(\n                uint256(uint160(messageSender))\n            );\n            if (messageFinality >= 2000) {\n                recipient.handleReceiveFinalizedMessage(\n                    sourceDomain == 4294967295\n                        ? storedMsg.sourceDomain\n                        : sourceDomain,\n                    messageSender == address(0) ? sender : overrideSenderBytes,\n                    messageFinality,\n                    messageBody\n                );\n            } else {\n                recipient.handleReceiveUnfinalizedMessage(\n                    sourceDomain == 4294967295\n                        ? storedMsg.sourceDomain\n                        : sourceDomain,\n                    messageSender == address(0) ? sender : overrideSenderBytes,\n                    messageFinality,\n                    messageBody\n                );\n            }\n        }\n\n        return true;\n    }\n\n    function addMessage(Message memory storedMsg) external {\n        messages.push(storedMsg);\n    }\n\n    function _encodeMessageHeader(\n        uint32 version,\n        uint32 sourceDomain,\n        bytes32 sender,\n        bytes32 recipient,\n        bytes memory messageBody\n    ) internal pure returns (bytes memory) {\n        bytes memory header = abi.encodePacked(\n            version, // 0-3\n            sourceDomain, // 4-7\n            bytes32(0), // 8-39 destinationDomain\n            bytes4(0), // 40-43 nonce\n            sender, // 44-75 sender\n            recipient, // 76-107 recipient\n            bytes32(0), // other stuff\n            bytes8(0) // other stuff\n        );\n        return abi.encodePacked(header, messageBody);\n    }\n\n    function _removeFront() internal returns (Message memory) {\n        require(messages.length > 0, \"No messages\");\n        Message memory removed = messages[0];\n        // Shift array\n        for (uint256 i = 0; i < messages.length - 1; i++) {\n            messages[i] = messages[i + 1];\n        }\n        messages.pop();\n        return removed;\n    }\n\n    function _processMessage(Message memory storedMsg) internal {\n        bytes memory encodedMessage = _encodeMessageHeader(\n            storedMsg.version,\n            storedMsg.sourceDomain,\n            storedMsg.sender,\n            storedMsg.messageHeaderRecipient,\n            storedMsg.messageBody\n        );\n\n        encodedMessages[keccak256(encodedMessage)] = storedMsg;\n\n        address recipient = address(uint160(uint256(storedMsg.recipient)));\n\n        AbstractCCTPIntegrator(recipient).relay(encodedMessage, bytes(\"\"));\n    }\n\n    function _removeBack() internal returns (Message memory) {\n        require(messages.length > 0, \"No messages\");\n        Message memory last = messages[messages.length - 1];\n        messages.pop();\n        return last;\n    }\n\n    function messagesInQueue() external view returns (uint256) {\n        return messages.length;\n    }\n\n    function processFrontOverrideHeader(bytes4 customHeader) external {\n        Message memory storedMsg = _removeFront();\n\n        bytes memory modifiedBody = abi.encodePacked(\n            customHeader,\n            storedMsg.messageBody.extractSlice(4, storedMsg.messageBody.length)\n        );\n\n        storedMsg.messageBody = modifiedBody;\n\n        _processMessage(storedMsg);\n    }\n\n    function processFrontOverrideVersion(uint32 customVersion) external {\n        Message memory storedMsg = _removeFront();\n        storedMsg.version = customVersion;\n        _processMessage(storedMsg);\n    }\n\n    function processFrontOverrideSender(address customSender) external {\n        Message memory storedMsg = _removeFront();\n        storedMsg.sender = bytes32(uint256(uint160(customSender)));\n        _processMessage(storedMsg);\n    }\n\n    function processFrontOverrideRecipient(address customRecipient) external {\n        Message memory storedMsg = _removeFront();\n        storedMsg.messageHeaderRecipient = bytes32(\n            uint256(uint160(customRecipient))\n        );\n        _processMessage(storedMsg);\n    }\n\n    function processFrontOverrideMessageBody(bytes memory customMessageBody)\n        external\n    {\n        Message memory storedMsg = _removeFront();\n        storedMsg.messageBody = customMessageBody;\n        _processMessage(storedMsg);\n    }\n\n    function processFront() external {\n        Message memory storedMsg = _removeFront();\n        _processMessage(storedMsg);\n    }\n\n    function processBack() external {\n        Message memory storedMsg = _removeBack();\n        _processMessage(storedMsg);\n    }\n\n    function getMessagesLength() external view returns (uint256) {\n        return messages.length;\n    }\n\n    function overrideMessageFinality(uint16 _finality) external {\n        messageFinality = _finality;\n    }\n\n    function overrideSender(address _sender) external {\n        messageSender = _sender;\n    }\n\n    function overrideSourceDomain(uint32 _sourceDomain) external {\n        sourceDomain = _sourceDomain;\n    }\n}\n"
    },
    "contracts/mocks/crosschain/CCTPMessageTransmitterMock2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IMessageHandlerV2 } from \"../../interfaces/cctp/ICCTP.sol\";\nimport { BytesHelper } from \"../../utils/BytesHelper.sol\";\nimport { CCTPMessageTransmitterMock } from \"./CCTPMessageTransmitterMock.sol\";\n\nuint8 constant SOURCE_DOMAIN_INDEX = 4;\nuint8 constant RECIPIENT_INDEX = 76;\nuint8 constant SENDER_INDEX = 44;\nuint8 constant MESSAGE_BODY_INDEX = 148;\n\n/**\n * @title Mock conctract simulating the functionality of the CCTPTokenMessenger contract\n *        for the porposes of unit testing.\n * @author Origin Protocol Inc\n */\n\ncontract CCTPMessageTransmitterMock2 is CCTPMessageTransmitterMock {\n    using BytesHelper for bytes;\n\n    address public cctpTokenMessenger;\n\n    event MessageReceivedInMockTransmitter(bytes message);\n    event MessageSent(bytes message);\n\n    constructor(address _usdc) CCTPMessageTransmitterMock(_usdc) {}\n\n    function setCCTPTokenMessenger(address _cctpTokenMessenger) external {\n        cctpTokenMessenger = _cctpTokenMessenger;\n    }\n\n    function sendMessage(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        uint32 minFinalityThreshold,\n        bytes memory messageBody\n    ) external virtual override {\n        bytes memory message = abi.encodePacked(\n            uint32(1), // version\n            uint32(destinationDomain == 0 ? 6 : 0), // source domain\n            uint32(destinationDomain), // destination domain\n            uint256(0),\n            bytes32(uint256(uint160(msg.sender))), // sender\n            recipient, // recipient\n            destinationCaller, // destination caller\n            minFinalityThreshold, // min finality threshold\n            uint32(0),\n            messageBody // message body\n        );\n        emit MessageSent(message);\n    }\n\n    function receiveMessage(bytes memory message, bytes memory attestation)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        uint32 sourceDomain = message.extractUint32(SOURCE_DOMAIN_INDEX);\n        address recipient = message.extractAddress(RECIPIENT_INDEX);\n        address sender = message.extractAddress(SENDER_INDEX);\n\n        bytes memory messageBody = message.extractSlice(\n            MESSAGE_BODY_INDEX,\n            message.length\n        );\n\n        bool isBurnMessage = recipient == cctpTokenMessenger;\n\n        if (isBurnMessage) {\n            // recipient = messageBody.extractAddress(BURN_MESSAGE_V2_RECIPIENT_INDEX);\n            // This step won't mint USDC, transfer it to the recipient address\n            // in your tests\n        } else {\n            IMessageHandlerV2(recipient).handleReceiveFinalizedMessage(\n                sourceDomain,\n                bytes32(uint256(uint160(sender))),\n                2000,\n                messageBody\n            );\n        }\n\n        // This step won't mint USDC, transfer it to the recipient address\n        // in your tests\n        emit MessageReceivedInMockTransmitter(message);\n\n        return true;\n    }\n}\n"
    },
    "contracts/mocks/crosschain/CCTPTokenMessengerMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ICCTPTokenMessenger } from \"../../interfaces/cctp/ICCTP.sol\";\nimport { CCTPMessageTransmitterMock } from \"./CCTPMessageTransmitterMock.sol\";\nimport { IERC20 } from \"../../utils/InitializableAbstractStrategy.sol\";\n\n/**\n * @title Mock conctract simulating the functionality of the CCTPTokenMessenger contract\n *        for the porposes of unit testing.\n * @author Origin Protocol Inc\n */\n\ncontract CCTPTokenMessengerMock is ICCTPTokenMessenger {\n    IERC20 public usdc;\n    CCTPMessageTransmitterMock public cctpMessageTransmitterMock;\n\n    constructor(address _usdc, address _cctpMessageTransmitterMock) {\n        usdc = IERC20(_usdc);\n        cctpMessageTransmitterMock = CCTPMessageTransmitterMock(\n            _cctpMessageTransmitterMock\n        );\n    }\n\n    function depositForBurn(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller,\n        uint256 maxFee,\n        uint32 minFinalityThreshold\n    ) external override {\n        revert(\"Not implemented\");\n    }\n\n    /**\n     * @dev mocks the depositForBurnWithHook function by sending the USDC to the CCTPMessageTransmitterMock\n     *      called by the AbstractCCTPIntegrator contract.\n     */\n    function depositForBurnWithHook(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller,\n        uint256 maxFee,\n        uint32 minFinalityThreshold,\n        bytes memory hookData\n    ) external override {\n        require(burnToken == address(usdc), \"Invalid burn token\");\n\n        usdc.transferFrom(msg.sender, address(this), maxFee);\n        uint256 destinationAmount = amount - maxFee;\n        usdc.transferFrom(\n            msg.sender,\n            address(cctpMessageTransmitterMock),\n            destinationAmount\n        );\n\n        bytes memory burnMessage = _encodeBurnMessageV2(\n            mintRecipient,\n            amount,\n            msg.sender,\n            maxFee,\n            maxFee,\n            hookData\n        );\n\n        cctpMessageTransmitterMock.sendTokenTransferMessage(\n            destinationDomain,\n            mintRecipient,\n            destinationCaller,\n            minFinalityThreshold,\n            destinationAmount,\n            burnMessage\n        );\n    }\n\n    function _encodeBurnMessageV2(\n        bytes32 mintRecipient,\n        uint256 amount,\n        address messageSender,\n        uint256 maxFee,\n        uint256 feeExecuted,\n        bytes memory hookData\n    ) internal view returns (bytes memory) {\n        bytes32 burnTokenBytes32 = bytes32(\n            abi.encodePacked(bytes12(0), bytes20(uint160(address(usdc))))\n        );\n        bytes32 messageSenderBytes32 = bytes32(\n            abi.encodePacked(bytes12(0), bytes20(uint160(messageSender)))\n        );\n        bytes32 expirationBlock = bytes32(0);\n\n        // Ref: https://developers.circle.com/cctp/technical-guide#message-body\n        return\n            abi.encodePacked(\n                uint32(1), // 0-3: version\n                burnTokenBytes32, // 4-35: burnToken (bytes32 left-padded address)\n                mintRecipient, // 36-67: mintRecipient (bytes32 left-padded address)\n                amount, // 68-99: uint256 amount\n                messageSenderBytes32, // 100-131: messageSender (bytes32 left-padded address)\n                maxFee, // 132-163: uint256 maxFee\n                feeExecuted, // 164-195: uint256 feeExecuted\n                expirationBlock, // 196-227: bytes32 expirationBlock\n                hookData // 228+: dynamic hookData\n            );\n    }\n\n    function getMinFeeAmount(uint256 amount)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return 0;\n    }\n}\n"
    },
    "contracts/mocks/MintableERC20.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IMintableERC20 {\n    function mint(uint256 value) external;\n\n    function mintTo(address to, uint256 value) external;\n}\n\n/**\n * @title MintableERC20\n * @dev Exposes the mint function of ERC20 for tests\n */\nabstract contract MintableERC20 is IMintableERC20, ERC20 {\n    /**\n     * @dev Function to mint tokens\n     * @param _value The amount of tokens to mint.\n     */\n    function mint(uint256 _value) public virtual override {\n        _mint(msg.sender, _value);\n    }\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to Address to mint to.\n     * @param _value The amount of tokens to mint.\n     */\n    function mintTo(address _to, uint256 _value) public virtual override {\n        _mint(_to, _value);\n    }\n}\n"
    },
    "contracts/mocks/MockBalancerVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IBalancerVault } from \"../interfaces/balancer/IBalancerVault.sol\";\nimport { MintableERC20 } from \"./MintableERC20.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\n// import \"hardhat/console.sol\";\n\ncontract MockBalancerVault {\n    using StableMath for uint256;\n    uint256 public slippage = 1 ether;\n    bool public transferDisabled = false;\n    bool public slippageErrorDisabled = false;\n\n    function swap(\n        IBalancerVault.SingleSwap calldata singleSwap,\n        IBalancerVault.FundManagement calldata funds,\n        uint256 minAmountOut,\n        uint256\n    ) external returns (uint256 amountCalculated) {\n        amountCalculated = (minAmountOut * slippage) / 1 ether;\n        if (!slippageErrorDisabled) {\n            require(amountCalculated >= minAmountOut, \"Slippage error\");\n        }\n        IERC20(singleSwap.assetIn).transferFrom(\n            funds.sender,\n            address(this),\n            singleSwap.amount\n        );\n        if (!transferDisabled) {\n            MintableERC20(singleSwap.assetOut).mintTo(\n                funds.recipient,\n                amountCalculated\n            );\n        }\n    }\n\n    function setSlippage(uint256 _slippage) external {\n        slippage = _slippage;\n    }\n\n    function getPoolTokenInfo(bytes32 poolId, address token)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            address\n        )\n    {}\n\n    function disableTransfer() external {\n        transferDisabled = true;\n    }\n\n    function disableSlippageError() external {\n        slippageErrorDisabled = true;\n    }\n}\n"
    },
    "contracts/mocks/MockERC4626Vault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC4626 } from \"../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract MockERC4626Vault is IERC4626, ERC20 {\n    using SafeERC20 for IERC20;\n\n    address public asset;\n    uint8 public constant DECIMALS = 18;\n\n    constructor(address _asset) ERC20(\"Mock Vault Share\", \"MVS\") {\n        asset = _asset;\n    }\n\n    // ERC20 totalSupply is inherited\n\n    // ERC20 balanceOf is inherited\n\n    function deposit(uint256 assets, address receiver)\n        public\n        override\n        returns (uint256 shares)\n    {\n        shares = previewDeposit(assets);\n        IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);\n        _mint(receiver, shares);\n        return shares;\n    }\n\n    function mint(uint256 shares, address receiver)\n        public\n        override\n        returns (uint256 assets)\n    {\n        assets = previewMint(shares);\n        IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);\n        _mint(receiver, shares);\n        return assets;\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256 shares) {\n        shares = previewWithdraw(assets);\n        if (msg.sender != owner) {\n            // No approval check for mock\n        }\n        _burn(owner, shares);\n        IERC20(asset).safeTransfer(receiver, assets);\n        return shares;\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256 assets) {\n        assets = previewRedeem(shares);\n        if (msg.sender != owner) {\n            // No approval check for mock\n        }\n        _burn(owner, shares);\n        IERC20(asset).safeTransfer(receiver, assets);\n        return assets;\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        return IERC20(asset).balanceOf(address(this));\n    }\n\n    function convertToShares(uint256 assets)\n        public\n        view\n        override\n        returns (uint256 shares)\n    {\n        uint256 supply = totalSupply(); // Use ERC20 totalSupply\n        return\n            supply == 0 || assets == 0\n                ? assets\n                : (assets * supply) / totalAssets();\n    }\n\n    function convertToAssets(uint256 shares)\n        public\n        view\n        override\n        returns (uint256 assets)\n    {\n        uint256 supply = totalSupply(); // Use ERC20 totalSupply\n        return supply == 0 ? shares : (shares * totalAssets()) / supply;\n    }\n\n    function maxDeposit(address receiver)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return type(uint256).max;\n    }\n\n    function maxMint(address receiver) public view override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view override returns (uint256) {\n        return convertToAssets(balanceOf(owner));\n    }\n\n    function maxRedeem(address owner) public view override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    function previewDeposit(uint256 assets)\n        public\n        view\n        override\n        returns (uint256 shares)\n    {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares)\n        public\n        view\n        override\n        returns (uint256 assets)\n    {\n        return convertToAssets(shares);\n    }\n\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        override\n        returns (uint256 shares)\n    {\n        return convertToShares(assets);\n    }\n\n    function previewRedeem(uint256 shares)\n        public\n        view\n        override\n        returns (uint256 assets)\n    {\n        return convertToAssets(shares);\n    }\n\n    function _mint(address account, uint256 amount) internal override {\n        super._mint(account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal override {\n        super._burn(account, amount);\n    }\n\n    // Inherited from ERC20\n}\n"
    },
    "contracts/mocks/MockEvilDAI.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract MockEvilDAI is MintableERC20 {\n    address host;\n    address realCoin;\n\n    constructor(address _host, address _realCoin) ERC20(\"DAI\", \"DAI\") {\n        host = _host;\n        realCoin = _realCoin;\n    }\n\n    function transferFrom(\n        // solhint-disable-next-line no-unused-vars\n        address _from,\n        // solhint-disable-next-line no-unused-vars\n        address _to,\n        uint256 _amount\n    ) public override returns (bool) {\n        // call mint again!\n        if (_amount != 69) {\n            IVault(host).mint(address(this), 69, 0);\n        }\n        return true;\n    }\n}\n"
    },
    "contracts/mocks/MockEvilReentrantContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { IRateProvider } from \"../interfaces/balancer/IRateProvider.sol\";\n\nimport { IBalancerVault } from \"../interfaces/balancer/IBalancerVault.sol\";\nimport { IERC20 } from \"../utils/InitializableAbstractStrategy.sol\";\n\nimport { StableMath } from \"../utils/StableMath.sol\";\n\ncontract MockEvilReentrantContract {\n    using StableMath for uint256;\n\n    IBalancerVault public immutable balancerVault;\n    IERC20 public immutable reth;\n    IERC20 public immutable weth;\n    IVault public immutable oethVault;\n    address public immutable poolAddress;\n    bytes32 public immutable balancerPoolId;\n    address public immutable priceProvider;\n\n    constructor(\n        address _balancerVault,\n        address _oethVault,\n        address _reth,\n        address _weth,\n        address _poolAddress,\n        bytes32 _poolId\n    ) {\n        balancerVault = IBalancerVault(_balancerVault);\n        oethVault = IVault(_oethVault);\n        reth = IERC20(_reth);\n        weth = IERC20(_weth);\n        poolAddress = _poolAddress;\n        balancerPoolId = _poolId;\n    }\n\n    function doEvilStuff() public {\n        uint256 rethPrice = IOracle(priceProvider).price(address(reth));\n\n        // 1. Join pool\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = uint256(10 ether);\n        amounts[1] = rethPrice * 10;\n\n        address[] memory assets = new address[](2);\n        assets[0] = address(reth);\n        assets[1] = address(weth);\n\n        uint256 minBPT = getBPTExpected(assets, amounts).mulTruncate(\n            0.99 ether\n        );\n\n        bytes memory joinUserData = abi.encode(\n            IBalancerVault.WeightedPoolJoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n            amounts,\n            minBPT\n        );\n\n        IBalancerVault.JoinPoolRequest memory joinRequest = IBalancerVault\n            .JoinPoolRequest(assets, amounts, joinUserData, false);\n\n        balancerVault.joinPool(\n            balancerPoolId,\n            address(this),\n            address(this),\n            joinRequest\n        );\n\n        uint256 bptTokenBalance = IERC20(poolAddress).balanceOf(address(this));\n\n        // 2. Redeem as ETH\n        bytes memory exitUserData = abi.encode(\n            IBalancerVault.WeightedPoolExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n            bptTokenBalance,\n            1\n        );\n\n        assets[1] = address(0); // Receive ETH instead of WETH\n        uint256[] memory exitAmounts = new uint256[](2);\n        exitAmounts[1] = 15 ether;\n        IBalancerVault.ExitPoolRequest memory exitRequest = IBalancerVault\n            .ExitPoolRequest(assets, exitAmounts, exitUserData, false);\n\n        balancerVault.exitPool(\n            balancerPoolId,\n            address(this),\n            payable(address(this)),\n            exitRequest\n        );\n        bptTokenBalance = IERC20(poolAddress).balanceOf(address(this));\n    }\n\n    function getBPTExpected(address[] memory _assets, uint256[] memory _amounts)\n        internal\n        view\n        virtual\n        returns (uint256 bptExpected)\n    {\n        for (uint256 i = 0; i < _assets.length; ++i) {\n            uint256 strategyAssetMarketPrice = IOracle(priceProvider).price(\n                _assets[i]\n            );\n            // convert asset amount to ETH amount\n            bptExpected =\n                bptExpected +\n                _amounts[i].mulTruncate(strategyAssetMarketPrice);\n        }\n\n        uint256 bptRate = IRateProvider(poolAddress).getRate();\n        // Convert ETH amount to BPT amount\n        bptExpected = bptExpected.divPrecisely(bptRate);\n    }\n\n    function approveAllTokens() public {\n        // Approve all tokens\n        weth.approve(address(oethVault), type(uint256).max);\n        reth.approve(poolAddress, type(uint256).max);\n        weth.approve(poolAddress, type(uint256).max);\n        reth.approve(address(balancerVault), type(uint256).max);\n        weth.approve(address(balancerVault), type(uint256).max);\n    }\n\n    receive() external payable {\n        // 3. Try to mint OETH\n        oethVault.mint(address(weth), 1 ether, 0.9 ether);\n    }\n}\n"
    },
    "contracts/mocks/MockLimitedWrappedOusd.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { WrappedOusd } from \"../token/WrappedOusd.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockLimitedWrappedOusd is WrappedOusd {\n    constructor(ERC20 underlying_) WrappedOusd(underlying_) {}\n\n    function maxDeposit(address)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return 1e18;\n    }\n}\n"
    },
    "contracts/mocks/MockNonRebasing.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IVault } from \"../interfaces/IVault.sol\";\n\nimport { OUSD } from \"../token/OUSD.sol\";\n\ncontract MockNonRebasing {\n    OUSD oUSD;\n\n    function setOUSD(address _oUSDAddress) public {\n        oUSD = OUSD(_oUSDAddress);\n    }\n\n    function rebaseOptIn() public {\n        oUSD.rebaseOptIn();\n    }\n\n    function rebaseOptOut() public {\n        oUSD.rebaseOptOut();\n    }\n\n    function transfer(address _to, uint256 _value) public {\n        oUSD.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public {\n        oUSD.transferFrom(_from, _to, _value);\n    }\n\n    function approve(address _spender, uint256 _addedValue) public {\n        oUSD.approve(_spender, _addedValue);\n    }\n\n    function mintOusd(\n        address _vaultContract,\n        address _asset,\n        uint256 _amount\n    ) public {\n        IVault(_vaultContract).mint(_asset, _amount, 0);\n    }\n\n    function redeemOusd(address _vaultContract, uint256 _amount) public {\n        IVault(_vaultContract).requestWithdrawal(_amount);\n    }\n\n    function approveFor(\n        address _contract,\n        address _spender,\n        uint256 _addedValue\n    ) public {\n        IERC20(_contract).approve(_spender, _addedValue);\n    }\n}\n"
    },
    "contracts/mocks/MockOETHVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { OETHVault } from \"../vault/OETHVault.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport \"../utils/Helpers.sol\";\n\ncontract MockOETHVault is OETHVault {\n    using StableMath for uint256;\n\n    constructor(address _weth) OETHVault(_weth) {\n        _setGovernor(msg.sender);\n    }\n\n    function supportAsset(address asset) external {\n        require(asset == asset, \"Only asset supported\");\n    }\n}\n"
    },
    "contracts/mocks/MockOETHVaultAdmin.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { OETHVault } from \"../vault/OETHVault.sol\";\n\ncontract MockOETHVault is OETHVault {\n    constructor(address _weth) OETHVault(_weth) {}\n\n    // fetches the WETH amount in outstanding withdrawals\n    function outstandingWithdrawalsAmount()\n        external\n        view\n        returns (uint256 wethAmount)\n    {\n        WithdrawalQueueMetadata memory queue = withdrawalQueueMetadata;\n\n        // The amount of WETH that is still to be claimed in the withdrawal queue\n        wethAmount = queue.queued - queue.claimed;\n    }\n\n    function wethAvailable() external view returns (uint256) {\n        return _assetAvailable();\n    }\n}\n"
    },
    "contracts/mocks/MockRebornMinter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n// solhint-disable-next-line no-console\nimport \"hardhat/console.sol\";\n\ncontract Sanctum {\n    address public asset;\n    address public vault;\n    address public reborner;\n    bool public shouldAttack = false;\n    // should selfdestruct in the constructor\n    bool public shouldDestruct = false;\n    uint256 public targetMethod;\n    address public ousdContract;\n\n    constructor(address _asset, address _vault) {\n        asset = _asset;\n        vault = _vault;\n    }\n\n    function deploy(uint256 salt, bytes memory bytecode)\n        public\n        returns (address addr)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n    }\n\n    function computeAddress(uint256 salt, bytes memory bytecode)\n        public\n        view\n        returns (address)\n    {\n        bytes32 bytecodeHashHash = keccak256(bytecode);\n        bytes32 _data = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                salt,\n                bytecodeHashHash\n            )\n        );\n        return address(bytes20(_data << 96));\n    }\n\n    function setShouldAttack(bool _shouldAttack) public {\n        shouldAttack = _shouldAttack;\n    }\n\n    // should call selfdestruct in the constructor\n    function setShouldDesctruct(bool _shouldDestruct) public {\n        shouldDestruct = _shouldDestruct;\n    }\n\n    function setTargetMethod(uint256 target) public {\n        targetMethod = target;\n    }\n\n    function setOUSDAddress(address _ousdContract) public {\n        ousdContract = _ousdContract;\n    }\n}\n\ncontract Reborner {\n    Sanctum sanctum;\n    bool logging = false;\n\n    constructor(address _sanctum) {\n        log(\"We are created...\");\n        sanctum = Sanctum(_sanctum);\n        if (sanctum.shouldAttack()) {\n            log(\"We are attacking now...\");\n\n            uint256 target = sanctum.targetMethod();\n\n            if (target == 1) {\n                redeem();\n            } else if (target == 2) {\n                transfer();\n            } else {\n                mint();\n            }\n        }\n\n        if (sanctum.shouldDestruct()) {\n            bye();\n        }\n    }\n\n    function mint() public {\n        log(\"We are attempting to mint..\");\n        address asset = sanctum.asset();\n        address vault = sanctum.vault();\n        IERC20(asset).approve(vault, 1e6);\n        IVault(vault).mint(asset, 1e6, 0);\n        log(\"We are now minting..\");\n    }\n\n    function redeem() public {\n        log(\"We are attempting to redeem..\");\n        address vault = sanctum.vault();\n        IVault(vault).redeem(1e18, 1e18);\n        log(\"We are now redeeming..\");\n    }\n\n    function transfer() public {\n        log(\"We are attempting to transfer..\");\n        address ousd = sanctum.ousdContract();\n        require(IERC20(ousd).transfer(address(1), 1e18), \"transfer failed\");\n        log(\"We are now transfering..\");\n    }\n\n    function bye() public {\n        log(\"We are now destructing..\");\n        selfdestruct(payable(msg.sender));\n    }\n\n    function log(string memory message) internal view {\n        if (logging) {\n            // solhint-disable-next-line no-console\n            console.log(message);\n        }\n    }\n}\n"
    },
    "contracts/mocks/MockRoosterAMOStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Rooster AMO strategy exposing extra functionality\n * @author Origin Protocol Inc\n */\n\nimport { RoosterAMOStrategy } from \"../strategies/plume/RoosterAMOStrategy.sol\";\nimport { IMaverickV2Pool } from \"../interfaces/plume/IMaverickV2Pool.sol\";\n\ncontract MockRoosterAMOStrategy is RoosterAMOStrategy {\n    constructor(\n        BaseStrategyConfig memory _stratConfig,\n        address _wethAddress,\n        address _oethpAddress,\n        address _liquidityManager,\n        address _poolLens,\n        address _maverickPosition,\n        address _maverickQuoter,\n        address _mPool,\n        bool _upperTickAtParity,\n        address _votingDistributor,\n        address _poolDistributor\n    )\n        RoosterAMOStrategy(\n            _stratConfig,\n            _wethAddress,\n            _oethpAddress,\n            _liquidityManager,\n            _poolLens,\n            _maverickPosition,\n            _maverickQuoter,\n            _mPool,\n            _upperTickAtParity,\n            _votingDistributor,\n            _poolDistributor\n        )\n    {}\n\n    function getCurrentWethShare() external view returns (uint256) {\n        uint256 _currentPrice = getPoolSqrtPrice();\n\n        return _getWethShare(_currentPrice);\n    }\n}\n"
    },
    "contracts/mocks/MockStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockStrategy {\n    address[] public assets;\n\n    address public withdrawAllAsset;\n    address public withdrawAllRecipient;\n\n    bool public shouldSupportAsset;\n\n    constructor() {\n        shouldSupportAsset = true;\n    }\n\n    function deposit(address asset, uint256 amount) external {}\n\n    function depositAll() external {}\n\n    function withdraw(\n        address recipient,\n        address asset,\n        uint256 amount\n    ) external {\n        IERC20(asset).transfer(recipient, amount);\n    }\n\n    function withdrawAll() external {\n        IERC20(withdrawAllAsset).transfer(\n            withdrawAllRecipient,\n            IERC20(withdrawAllAsset).balanceOf(address(this))\n        );\n    }\n\n    function checkBalance(address asset)\n        external\n        view\n        returns (uint256 balance)\n    {\n        balance = IERC20(asset).balanceOf(address(this));\n    }\n\n    function supportsAsset(address) external view returns (bool) {\n        return shouldSupportAsset;\n    }\n\n    function setShouldSupportAsset(bool _shouldSupportAsset) external {\n        shouldSupportAsset = _shouldSupportAsset;\n    }\n\n    function collectRewardTokens() external {}\n\n    function getRewardTokenAddresses()\n        external\n        view\n        returns (address[] memory)\n    {\n        return new address[](0);\n    }\n\n    function setWithdrawAll(address asset, address recipient) external {\n        withdrawAllAsset = asset;\n        withdrawAllRecipient = recipient;\n    }\n}\n"
    },
    "contracts/mocks/MockVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { VaultAdmin } from \"../vault/VaultAdmin.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport \"../utils/Helpers.sol\";\n\ncontract MockVault is VaultAdmin {\n    using StableMath for uint256;\n\n    uint256 storedTotalValue;\n\n    constructor(address _asset) VaultAdmin(_asset) {}\n\n    function setTotalValue(uint256 _value) public {\n        storedTotalValue = _value;\n    }\n\n    function totalValue() external view override returns (uint256) {\n        return storedTotalValue;\n    }\n\n    function _totalValue() internal view override returns (uint256) {\n        return storedTotalValue;\n    }\n\n    function _checkBalance(address _asset)\n        internal\n        view\n        override\n        returns (uint256 balance)\n    {\n        // Avoids rounding errors by returning the total value\n        // in a single currency\n        if (asset == _asset) {\n            uint256 decimals = Helpers.getDecimals(_asset);\n            return storedTotalValue.scaleBy(decimals, 18);\n        } else {\n            return 0;\n        }\n    }\n}\n"
    },
    "contracts/mocks/MockVaultCoreInstantRebase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { VaultCore } from \"../vault/VaultCore.sol\";\n\ncontract MockVaultCoreInstantRebase is VaultCore {\n    constructor(address _asset) VaultCore(_asset) {}\n\n    function _nextYield(uint256 supply, uint256 vaultValue)\n        internal\n        view\n        override\n        returns (uint256 yield, uint256 targetRate)\n    {\n        if (vaultValue <= supply) {\n            return (0, 0);\n        }\n        yield = vaultValue - supply;\n        return (yield, 0);\n    }\n}\n"
    },
    "contracts/mocks/TestUpgradedOUSD.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../token/OUSD.sol\";\n\n// used to alter internal state of OUSD contract\ncontract TestUpgradedOUSD is OUSD {\n    constructor() OUSD() {}\n\n    function overwriteCreditBalances(address _account, uint256 _creditBalance)\n        public\n    {\n        creditBalances[_account] = _creditBalance;\n    }\n\n    function overwriteAlternativeCPT(address _account, uint256 _acpt) public {\n        alternativeCreditsPerToken[_account] = _acpt;\n    }\n\n    function overwriteRebaseState(address _account, RebaseOptions _rebaseOption)\n        public\n    {\n        rebaseState[_account] = _rebaseOption;\n    }\n}\n"
    },
    "contracts/poolBooster/curve/CurvePoolBooster.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Initializable } from \"../../utils/Initializable.sol\";\nimport { Strategizable } from \"../../governance/Strategizable.sol\";\nimport { ICampaignRemoteManager } from \"../../interfaces/ICampaignRemoteManager.sol\";\n\n/// @title CurvePoolBooster\n/// @author Origin Protocol\n/// @notice Contract to manage interactions with VotemarketV2 for a dedicated Curve pool/gauge.\ncontract CurvePoolBooster is Initializable, Strategizable {\n    using SafeERC20 for IERC20;\n\n    ////////////////////////////////////////////////////\n    /// --- CONSTANTS && IMMUTABLES\n    ////////////////////////////////////////////////////\n    /// @notice Base fee for the contract, 100%\n    uint16 public constant FEE_BASE = 10_000;\n\n    /// @notice Arbitrum where the votemarket is running\n    uint256 public constant targetChainId = 42161;\n\n    /// @notice Address of the gauge to manage\n    address public immutable gauge;\n\n    /// @notice Address of the reward token\n    address public immutable rewardToken;\n\n    ////////////////////////////////////////////////////\n    /// --- STORAGE\n    ////////////////////////////////////////////////////\n\n    /// @notice Fee in FEE_BASE unit payed when managing campaign.\n    uint16 public fee;\n\n    /// @notice Address of the fee collector\n    address public feeCollector;\n\n    /// @notice Address of the campaignRemoteManager linked to VotemarketV2\n    address public campaignRemoteManager;\n\n    /// @notice Address of votemarket in L2\n    address public votemarket;\n\n    /// @notice Id of the campaign created\n    uint256 public campaignId;\n\n    ////////////////////////////////////////////////////\n    /// --- EVENTS\n    ////////////////////////////////////////////////////\n    event FeeUpdated(uint16 newFee);\n    event FeeCollected(address feeCollector, uint256 feeAmount);\n    event FeeCollectorUpdated(address newFeeCollector);\n    event VotemarketUpdated(address newVotemarket);\n    event CampaignRemoteManagerUpdated(address newCampaignRemoteManager);\n    event CampaignCreated(\n        address gauge,\n        address rewardToken,\n        uint256 maxRewardPerVote,\n        uint256 totalRewardAmount\n    );\n    event CampaignIdUpdated(uint256 newId);\n    event CampaignClosed(uint256 campaignId);\n    event TotalRewardAmountUpdated(uint256 extraTotalRewardAmount);\n    event NumberOfPeriodsUpdated(uint8 extraNumberOfPeriods);\n    event RewardPerVoteUpdated(uint256 newMaxRewardPerVote);\n    event TokensRescued(address token, uint256 amount, address receiver);\n\n    ////////////////////////////////////////////////////\n    /// --- CONSTRUCTOR && INITIALIZATION\n    ////////////////////////////////////////////////////\n    constructor(address _rewardToken, address _gauge) {\n        rewardToken = _rewardToken;\n        gauge = _gauge;\n\n        // Prevent implementation contract to be governed\n        _setGovernor(address(0));\n    }\n\n    /// @notice initialize function, to set up initial internal state\n    /// @param _strategist Address of the strategist\n    /// @param _fee Fee in FEE_BASE unit payed when managing campaign\n    /// @param _feeCollector Address of the fee collector\n    function initialize(\n        address _strategist,\n        uint16 _fee,\n        address _feeCollector,\n        address _campaignRemoteManager,\n        address _votemarket\n    ) external onlyGovernor initializer {\n        _setStrategistAddr(_strategist);\n        _setFee(_fee);\n        _setFeeCollector(_feeCollector);\n        _setCampaignRemoteManager(_campaignRemoteManager);\n        _setVotemarket(_votemarket);\n    }\n\n    ////////////////////////////////////////////////////\n    /// --- MUTATIVE FUNCTIONS\n    ////////////////////////////////////////////////////\n    /// @notice Create a new campaign on VotemarketV2\n    /// @dev This will use all token available in this contract\n    /// @dev Caller must send ETH to pay for the bridge fee\n    /// @param numberOfPeriods Duration of the campaign in weeks\n    /// @param maxRewardPerVote Maximum reward per vote to distribute, to avoid overspending\n    /// @param blacklist  List of addresses to exclude from the campaign\n    /// @param additionalGasLimit Additional gas limit for the bridge\n    function createCampaign(\n        uint8 numberOfPeriods,\n        uint256 maxRewardPerVote,\n        address[] calldata blacklist,\n        uint256 additionalGasLimit\n    ) external payable nonReentrant onlyGovernorOrStrategist {\n        require(campaignId == 0, \"Campaign already created\");\n        require(numberOfPeriods > 1, \"Invalid number of periods\");\n        require(maxRewardPerVote > 0, \"Invalid reward per vote\");\n\n        // Handle fee (if any)\n        uint256 balanceSubFee = _handleFee();\n\n        // Approve the balanceSubFee to the campaign manager\n        IERC20(rewardToken).safeApprove(campaignRemoteManager, 0);\n        IERC20(rewardToken).safeApprove(campaignRemoteManager, balanceSubFee);\n\n        // Create a new campaign\n        ICampaignRemoteManager(campaignRemoteManager).createCampaign{\n            value: msg.value\n        }(\n            ICampaignRemoteManager.CampaignCreationParams({\n                chainId: targetChainId,\n                gauge: gauge,\n                manager: address(this),\n                rewardToken: rewardToken,\n                numberOfPeriods: numberOfPeriods,\n                maxRewardPerVote: maxRewardPerVote,\n                totalRewardAmount: balanceSubFee,\n                addresses: blacklist,\n                hook: address(0),\n                isWhitelist: false\n            }),\n            targetChainId,\n            additionalGasLimit,\n            votemarket\n        );\n\n        emit CampaignCreated(\n            gauge,\n            rewardToken,\n            maxRewardPerVote,\n            balanceSubFee\n        );\n    }\n\n    /// @notice Manage campaign parameters in a single call\n    /// @dev This function should be called after the campaign is created\n    /// @dev Caller must send ETH to pay for the bridge fee\n    /// @param totalRewardAmount Amount of reward tokens to add:\n    ///        - 0: no update\n    ///        - type(uint256).max: use all tokens in contract\n    ///        - other: use specific amount\n    /// @param numberOfPeriods Number of additional periods (0 = no update)\n    /// @param maxRewardPerVote New maximum reward per vote (0 = no update)\n    /// @param additionalGasLimit Additional gas limit for the bridge\n    function manageCampaign(\n        uint256 totalRewardAmount,\n        uint8 numberOfPeriods,\n        uint256 maxRewardPerVote,\n        uint256 additionalGasLimit\n    ) external payable nonReentrant onlyGovernorOrStrategist {\n        require(campaignId != 0, \"Campaign not created\");\n\n        uint256 rewardAmount;\n\n        if (totalRewardAmount != 0) {\n            uint256 amount = min(\n                IERC20(rewardToken).balanceOf(address(this)),\n                totalRewardAmount\n            );\n\n            // Handle fee\n            rewardAmount = _handleFee(amount);\n            require(rewardAmount > 0, \"No reward to add\");\n\n            // Approve the reward amount to the campaign manager\n            IERC20(rewardToken).safeApprove(campaignRemoteManager, 0);\n            IERC20(rewardToken).safeApprove(\n                campaignRemoteManager,\n                rewardAmount\n            );\n        }\n\n        // Call remote manager\n        ICampaignRemoteManager(campaignRemoteManager).manageCampaign{\n            value: msg.value\n        }(\n            ICampaignRemoteManager.CampaignManagementParams({\n                campaignId: campaignId,\n                rewardToken: rewardToken,\n                numberOfPeriods: numberOfPeriods,\n                totalRewardAmount: rewardAmount,\n                maxRewardPerVote: maxRewardPerVote\n            }),\n            targetChainId,\n            additionalGasLimit,\n            votemarket\n        );\n\n        // Emit relevant events\n        if (rewardAmount > 0) {\n            emit TotalRewardAmountUpdated(rewardAmount);\n        }\n        if (numberOfPeriods > 0) {\n            emit NumberOfPeriodsUpdated(numberOfPeriods);\n        }\n        if (maxRewardPerVote > 0) {\n            emit RewardPerVoteUpdated(maxRewardPerVote);\n        }\n    }\n\n    /// @notice Close the campaign.\n    /// @dev This function only work on the L2 chain. Not on mainnet.\n    /// @dev Caller must send ETH to pay for the bridge fee\n    /// @dev The _campaignId parameter is not related to the campaignId of this contract, allowing greater flexibility.\n    /// @param _campaignId Id of the campaign to close\n    /// @param additionalGasLimit Additional gas limit for the bridge\n    // slither-disable-start reentrancy-eth\n    function closeCampaign(uint256 _campaignId, uint256 additionalGasLimit)\n        external\n        payable\n        nonReentrant\n        onlyGovernorOrStrategist\n    {\n        ICampaignRemoteManager(campaignRemoteManager).closeCampaign{\n            value: msg.value\n        }(\n            ICampaignRemoteManager.CampaignClosingParams({\n                campaignId: campaignId\n            }),\n            targetChainId,\n            additionalGasLimit,\n            votemarket\n        );\n        campaignId = 0;\n        emit CampaignClosed(_campaignId);\n    }\n\n    // slither-disable-end reentrancy-eth\n\n    /// @notice Calculate the fee amount and transfer it to the feeCollector\n    /// @dev Uses full contract balance\n    /// @return Balance after fee\n    function _handleFee() internal returns (uint256) {\n        uint256 balance = IERC20(rewardToken).balanceOf(address(this));\n\n        // This is not a problem if balance is 0, feeAmount will be 0 as well\n        // We don't want to make the whole function revert just because of that.\n        return _handleFee(balance);\n    }\n\n    /// @notice Calculate the fee amount and transfer it to the feeCollector\n    /// @param amount Amount to take fee from\n    /// @return Amount after fee\n    function _handleFee(uint256 amount) internal returns (uint256) {\n        uint256 feeAmount = (amount * fee) / FEE_BASE;\n\n        // If there is a fee, transfer it to the feeCollector\n        if (feeAmount > 0) {\n            IERC20(rewardToken).safeTransfer(feeCollector, feeAmount);\n            emit FeeCollected(feeCollector, feeAmount);\n        }\n\n        // Fetch balance again to avoid rounding issues\n        return IERC20(rewardToken).balanceOf(address(this));\n    }\n\n    ////////////////////////////////////////////////////\n    /// --- GOVERNANCE && OPERATION\n    ////////////////////////////////////////////////////\n    /// @notice Set the campaign id\n    /// @dev Only callable by the governor or strategist\n    /// @param _campaignId New campaign id\n    function setCampaignId(uint256 _campaignId)\n        external\n        onlyGovernorOrStrategist\n    {\n        campaignId = _campaignId;\n        emit CampaignIdUpdated(_campaignId);\n    }\n\n    /// @notice Rescue ETH from the contract\n    /// @dev Only callable by the governor or strategist\n    /// @param receiver Address to receive the ETH\n    function rescueETH(address receiver)\n        external\n        nonReentrant\n        onlyGovernorOrStrategist\n    {\n        require(receiver != address(0), \"Invalid receiver\");\n        uint256 balance = address(this).balance;\n        (bool success, ) = receiver.call{ value: balance }(\"\");\n        require(success, \"Transfer failed\");\n        emit TokensRescued(address(0), balance, receiver);\n    }\n\n    /// @notice Rescue ERC20 tokens from the contract\n    /// @dev Only callable by the governor or strategist\n    /// @param token Address of the token to rescue\n    function rescueToken(address token, address receiver)\n        external\n        nonReentrant\n        onlyGovernor\n    {\n        require(receiver != address(0), \"Invalid receiver\");\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n        emit TokensRescued(token, balance, receiver);\n    }\n\n    /// @notice Set the fee\n    /// @dev Only callable by the governor\n    /// @param _fee New fee\n    function setFee(uint16 _fee) external onlyGovernor {\n        _setFee(_fee);\n    }\n\n    /// @notice Internal logic to set the fee\n    function _setFee(uint16 _fee) internal {\n        require(_fee <= FEE_BASE / 2, \"Fee too high\");\n        fee = _fee;\n        emit FeeUpdated(_fee);\n    }\n\n    /// @notice Set the fee collector\n    /// @dev Only callable by the governor\n    /// @param _feeCollector New fee collector\n    function setFeeCollector(address _feeCollector) external onlyGovernor {\n        _setFeeCollector(_feeCollector);\n    }\n\n    /// @notice Internal logic to set the fee collector\n    function _setFeeCollector(address _feeCollector) internal {\n        require(_feeCollector != address(0), \"Invalid fee collector\");\n        feeCollector = _feeCollector;\n        emit FeeCollectorUpdated(_feeCollector);\n    }\n\n    /// @notice Set the campaignRemoteManager\n    /// @param _campaignRemoteManager New campaignRemoteManager address\n    function setCampaignRemoteManager(address _campaignRemoteManager)\n        external\n        onlyGovernor\n    {\n        _setCampaignRemoteManager(_campaignRemoteManager);\n    }\n\n    /// @notice Internal logic to set the campaignRemoteManager\n    /// @param _campaignRemoteManager New campaignRemoteManager address\n    function _setCampaignRemoteManager(address _campaignRemoteManager)\n        internal\n    {\n        require(\n            _campaignRemoteManager != address(0),\n            \"Invalid campaignRemoteManager\"\n        );\n        campaignRemoteManager = _campaignRemoteManager;\n        emit CampaignRemoteManagerUpdated(_campaignRemoteManager);\n    }\n\n    /// @notice Set the votemarket address\n    /// @param _votemarket New votemarket address\n    function setVotemarket(address _votemarket) external onlyGovernor {\n        _setVotemarket(_votemarket);\n    }\n\n    /// @notice Internal logic to set the votemarket address\n    function _setVotemarket(address _votemarket) internal {\n        require(_votemarket != address(0), \"Invalid votemarket\");\n        votemarket = _votemarket;\n        emit VotemarketUpdated(_votemarket);\n    }\n\n    /// @notice Return the minimum of two uint256 numbers\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/poolBooster/curve/CurvePoolBoosterFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ICreateX } from \"../../interfaces/ICreateX.sol\";\nimport { Initializable } from \"../../utils/Initializable.sol\";\nimport { Strategizable } from \"../../governance/Strategizable.sol\";\nimport { CurvePoolBoosterPlain } from \"./CurvePoolBoosterPlain.sol\";\nimport { IPoolBoostCentralRegistry } from \"../../interfaces/poolBooster/IPoolBoostCentralRegistry.sol\";\n\n/// @title CurvePoolBoosterFactory\n/// @author Origin Protocol\n/// @notice Factory contract to create CurvePoolBoosterPlain instances\ncontract CurvePoolBoosterFactory is Initializable, Strategizable {\n    ////////////////////////////////////////////////////\n    /// --- Structs\n    ////////////////////////////////////////////////////\n    struct PoolBoosterEntry {\n        address boosterAddress;\n        address ammPoolAddress;\n        IPoolBoostCentralRegistry.PoolBoosterType boosterType;\n    }\n\n    ////////////////////////////////////////////////////\n    /// --- Constants\n    ////////////////////////////////////////////////////\n\n    /// @notice Address of the CreateX contract\n    ICreateX public constant CREATEX =\n        ICreateX(0xba5Ed099633D3B313e4D5F7bdc1305d3c28ba5Ed);\n\n    ////////////////////////////////////////////////////\n    /// --- Storage\n    ////////////////////////////////////////////////////\n\n    /// @notice list of all the pool boosters created by this factory\n    PoolBoosterEntry[] public poolBoosters;\n    /// @notice Central registry contract\n    IPoolBoostCentralRegistry public centralRegistry;\n    /// @notice mapping of AMM pool to pool booster\n    mapping(address => PoolBoosterEntry) public poolBoosterFromPool;\n\n    ////////////////////////////////////////////////////\n    /// --- Initialize\n    ////////////////////////////////////////////////////\n\n    /// @notice Initialize the contract. Normally we'd rather have the governor and strategist set in the constructor,\n    ///         but since this contract is deployed by CreateX we need to set them in the initialize function because\n    ///         the constructor's parameters influence the address of the contract when deployed using CreateX.\n    ///         And having different governor and strategist on the same address on different chains would\n    ///         cause issues.\n    /// @param _governor Address of the governor\n    /// @param _strategist Address of the strategist\n    /// @param _centralRegistry Address of the central registry\n    function initialize(\n        address _governor,\n        address _strategist,\n        address _centralRegistry\n    ) external initializer {\n        _setGovernor(_governor);\n        _setStrategistAddr(_strategist);\n        centralRegistry = IPoolBoostCentralRegistry(_centralRegistry);\n    }\n\n    ////////////////////////////////////////////////////\n    /// --- External Mutative Functions\n    ////////////////////////////////////////////////////\n\n    /// @notice Create a new CurvePoolBoosterPlain instance\n    /// @param _rewardToken Address of the reward token (OETH or OUSD)\n    /// @param _gauge Address of the gauge (e.g. Curve OETH/WETH Gauge)\n    /// @param _feeCollector Address of the fee collector (e.g. MultichainStrategist)\n    /// @param _fee Fee in FEE_BASE unit payed when managing campaign\n    /// @param _campaignRemoteManager Address of the campaign remote manager\n    /// @param _votemarket Address of the votemarket\n    /// @param _salt A unique number that affects the address of the pool booster created. Note: this number\n    ///        should match the one from `computePoolBoosterAddress` in order for the final deployed address\n    ///        and pre-computed address to match\n    /// @param _expectedAddress The expected address of the pool booster. This is used to verify that the pool booster\n    ///        was deployed at the expected address, otherwise the transaction batch will revert. If set to 0 then the\n    ///        address verification is skipped.\n    function createCurvePoolBoosterPlain(\n        address _rewardToken,\n        address _gauge,\n        address _feeCollector,\n        uint16 _fee,\n        address _campaignRemoteManager,\n        address _votemarket,\n        bytes32 _salt,\n        address _expectedAddress\n    ) external onlyGovernorOrStrategist returns (address) {\n        require(governor() != address(0), \"Governor not set\");\n        require(strategistAddr != address(0), \"Strategist not set\");\n        // salt encoded sender\n        address senderAddress = address(bytes20(_salt));\n        // the contract that calls the CreateX should be encoded in the salt to protect against front-running\n        require(senderAddress == address(this), \"Front-run protection failed\");\n\n        address poolBoosterAddress = CREATEX.deployCreate2(\n            _salt,\n            _getInitCode(_rewardToken, _gauge)\n        );\n\n        require(\n            _expectedAddress == address(0) ||\n                poolBoosterAddress == _expectedAddress,\n            \"Pool booster deployed at unexpected address\"\n        );\n\n        CurvePoolBoosterPlain(payable(poolBoosterAddress)).initialize(\n            governor(),\n            strategistAddr,\n            _fee,\n            _feeCollector,\n            _campaignRemoteManager,\n            _votemarket\n        );\n\n        _storePoolBoosterEntry(poolBoosterAddress, _gauge);\n        return poolBoosterAddress;\n    }\n\n    /// @notice Removes the pool booster from the internal list of pool boosters.\n    /// @dev This action does not destroy the pool booster contract nor does it\n    ///      stop the yield delegation to it.\n    /// @param _poolBoosterAddress address of the pool booster\n    function removePoolBooster(address _poolBoosterAddress)\n        external\n        onlyGovernor\n    {\n        uint256 boostersLen = poolBoosters.length;\n        for (uint256 i = 0; i < boostersLen; ++i) {\n            if (poolBoosters[i].boosterAddress == _poolBoosterAddress) {\n                // erase mapping\n                delete poolBoosterFromPool[poolBoosters[i].ammPoolAddress];\n\n                // overwrite current pool booster with the last entry in the list\n                poolBoosters[i] = poolBoosters[boostersLen - 1];\n                // drop the last entry\n                poolBoosters.pop();\n\n                // centralRegistry can be address(0) on some chains\n                if (address(centralRegistry) != address(0)) {\n                    centralRegistry.emitPoolBoosterRemoved(_poolBoosterAddress);\n                }\n                break;\n            }\n        }\n    }\n\n    ////////////////////////////////////////////////////\n    /// --- Internal Mutative Functions\n    ////////////////////////////////////////////////////\n\n    /// @notice Stores the pool booster entry in the internal list and mapping\n    /// @param _poolBoosterAddress address of the pool booster\n    /// @param _ammPoolAddress address of the AMM pool\n    function _storePoolBoosterEntry(\n        address _poolBoosterAddress,\n        address _ammPoolAddress\n    ) internal {\n        IPoolBoostCentralRegistry.PoolBoosterType _boosterType = IPoolBoostCentralRegistry\n                .PoolBoosterType\n                .CurvePoolBoosterPlain;\n        PoolBoosterEntry memory entry = PoolBoosterEntry(\n            _poolBoosterAddress,\n            _ammPoolAddress,\n            _boosterType\n        );\n\n        poolBoosters.push(entry);\n        poolBoosterFromPool[_ammPoolAddress] = entry;\n\n        // emit the events of the pool booster created\n        // centralRegistry can be address(0) on some chains\n        if (address(centralRegistry) != address(0)) {\n            centralRegistry.emitPoolBoosterCreated(\n                _poolBoosterAddress,\n                _ammPoolAddress,\n                _boosterType\n            );\n        }\n    }\n\n    ////////////////////////////////////////////////////\n    /// --- External View Functions\n    ////////////////////////////////////////////////////\n\n    /// @notice Create a new CurvePoolBoosterPlain instance (address computation version)\n    /// @param _rewardToken Address of the reward token (OETH or OUSD)\n    /// @param _gauge Address of the gauge (e.g. Curve OETH/WETH Gauge)\n    /// @param _salt A unique number that affects the address of the pool booster created. Note: this number\n    ///        should match the one from `createCurvePoolBoosterPlain` in order for the final deployed address\n    ///        and pre-computed address to match\n    function computePoolBoosterAddress(\n        address _rewardToken,\n        address _gauge,\n        bytes32 _salt\n    ) external view returns (address) {\n        bytes32 guardedSalt = _computeGuardedSalt(_salt);\n        return\n            CREATEX.computeCreate2Address(\n                guardedSalt,\n                keccak256(_getInitCode(_rewardToken, _gauge)),\n                address(CREATEX)\n            );\n    }\n\n    /// @notice Encodes a salt for CreateX by concatenating deployer address (bytes20), cross-chain protection flag\n    /// (bytes1), and the first 11 bytes of the provided salt (most significant bytes). This function is exposed\n    /// for easier operations. For the salt value itself just use the epoch time when the operation is performed.\n    /// @param salt The raw salt as uint256; converted to bytes32, then only the first 11 bytes (MSB) are used.\n    /// @return encodedSalt The resulting 32-byte encoded salt.\n    function encodeSaltForCreateX(uint256 salt)\n        external\n        view\n        returns (bytes32 encodedSalt)\n    {\n        // only the right most 11 bytes are considered when encoding salt. Which is limited by the number in the below\n        // require. If salt were higher, the higher bytes would need to be set to 0 to not affect the \"or\" way of\n        // encoding the salt.\n        require(salt <= 309485009821345068724781055, \"Invalid salt\");\n\n        // prepare encoded salt guarded by this factory address. When the deployer part of the salt is the same as the\n        // caller of CreateX the salt is re-hashed and thus guarded from front-running.\n        address deployer = address(this);\n\n        // Flag as uint8 (0)\n        uint8 flag = 0;\n\n        // Precompute parts\n        uint256 deployerPart = uint256(uint160(deployer)) << 96; // 20 bytes shifted left 96 bits (12 bytes)\n        uint256 flagPart = uint256(flag) << 88; // 1 byte shifted left 88 bits (11 bytes)\n\n        // Concat via nested OR\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            encodedSalt := or(or(deployerPart, flagPart), salt)\n        }\n    }\n\n    /// @notice Get the number of pool boosters created by this factory\n    function poolBoosterLength() external view returns (uint256) {\n        return poolBoosters.length;\n    }\n\n    /// @notice Get the list of all pool boosters created by this factory\n    function getPoolBoosters()\n        external\n        view\n        returns (PoolBoosterEntry[] memory)\n    {\n        return poolBoosters;\n    }\n\n    ////////////////////////////////////////////////////\n    /// --- Internal View/Pure Functions\n    ////////////////////////////////////////////////////\n\n    /// @notice Get the init code for the CurvePoolBoosterPlain contract\n    function _getInitCode(address _rewardToken, address _gauge)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return\n            abi.encodePacked(\n                type(CurvePoolBoosterPlain).creationCode,\n                abi.encode(_rewardToken, _gauge)\n            );\n    }\n\n    /// @notice Compute the guarded salt for CreateX protections. This version of guarded\n    ///         salt expects that this factory contract is the one doing calls to the CreateX contract.\n    function _computeGuardedSalt(bytes32 _salt)\n        internal\n        view\n        returns (bytes32)\n    {\n        return\n            _efficientHash({\n                a: bytes32(uint256(uint160(address(this)))),\n                b: _salt\n            });\n    }\n\n    /// @notice Efficiently hash two bytes32 values together\n    function _efficientHash(bytes32 a, bytes32 b)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            hash := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "contracts/poolBooster/curve/CurvePoolBoosterPlain.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { CurvePoolBooster } from \"./CurvePoolBooster.sol\";\n\n/// @title CurvePoolBoosterPlain\n/// @author Origin Protocol\n/// @notice Contract to manage interactions with VotemarketV2 for a dedicated Curve pool/gauge. It differs from the\n///         CurvePoolBooster in that it is not proxied.\n/// @dev    Governor is not set in the constructor so that the same contract can be deployed on the same address on\n///         multiple chains. Governor is set in the initialize function.\ncontract CurvePoolBoosterPlain is CurvePoolBooster {\n    constructor(address _rewardToken, address _gauge)\n        CurvePoolBooster(_rewardToken, _gauge)\n    {\n        rewardToken = _rewardToken;\n        gauge = _gauge;\n    }\n\n    /// @notice initialize function, to set up initial internal state\n    /// @param _strategist Address of the strategist\n    /// @param _fee Fee in FEE_BASE unit payed when managing campaign\n    /// @param _feeCollector Address of the fee collector\n    /// @dev   Since this function is initialized in the same transaction as it is created the initialize function\n    ///        doesn't need role protection.\n    ///        Because the governor is only set in the initialisation function the base class initialize can not be\n    ///        called as it is not the governor who is issueing this call.\n    function initialize(\n        address _govenor,\n        address _strategist,\n        uint16 _fee,\n        address _feeCollector,\n        address _campaignRemoteManager,\n        address _votemarket\n    ) external initializer {\n        _setStrategistAddr(_strategist);\n        _setFee(_fee);\n        _setFeeCollector(_feeCollector);\n        _setCampaignRemoteManager(_campaignRemoteManager);\n        _setVotemarket(_votemarket);\n\n        // Set the governor to the provided governor\n        _setGovernor(_govenor);\n    }\n}\n"
    },
    "contracts/proxies/create2/CrossChainStrategyProxy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { InitializeGovernedUpgradeabilityProxy2 } from \"../InitializeGovernedUpgradeabilityProxy2.sol\";\n\n// ********************************************************\n// ********************************************************\n// IMPORTANT: DO NOT CHANGE ANYTHING IN THIS FILE.\n// Any changes to this file (even whitespaces) will\n// affect the create2 address of the proxy\n// ********************************************************\n// ********************************************************\n\n/**\n * @notice CrossChainStrategyProxy delegates calls to a\n * CrossChainMasterStrategy or CrossChainRemoteStrategy\n * implementation contract.\n */\ncontract CrossChainStrategyProxy is InitializeGovernedUpgradeabilityProxy2 {\n    constructor(address governor)\n        InitializeGovernedUpgradeabilityProxy2(governor)\n    {}\n}\n"
    },
    "contracts/proxies/InitializeGovernedUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { Governable } from \"../governance/Governable.sol\";\n\n/**\n * @title BaseGovernedUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with our governor system.\n * It is based on an older version of OpenZeppelins BaseUpgradeabilityProxy\n * with Solidity ^0.8.0.\n * @author Origin Protocol Inc\n */\ncontract InitializeGovernedUpgradeabilityProxy is Governable {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     * @param implementation Address of the new implementation.\n     */\n    event Upgraded(address indexed implementation);\n\n    constructor() {\n        _setGovernor(msg.sender);\n    }\n\n    /**\n     * @dev Contract initializer with Governor enforcement\n     * @param _logic Address of the initial implementation.\n     * @param _initGovernor Address of the initial Governor.\n     * @param _data Data to send as msg.data to the implementation to initialize\n     * the proxied contract.\n     * It should include the signature and the parameters of the function to be\n     * called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     * This parameter is optional, if no data is given the initialization call\n     * to proxied contract will be skipped.\n     */\n    function initialize(\n        address _logic,\n        address _initGovernor,\n        bytes calldata _data\n    ) public payable onlyGovernor {\n        require(_implementation() == address(0));\n        require(_logic != address(0), \"Implementation not set\");\n        assert(\n            IMPLEMENTATION_SLOT ==\n                bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1)\n        );\n        _setImplementation(_logic);\n        if (_data.length > 0) {\n            (bool success, ) = _logic.delegatecall(_data);\n            require(success);\n        }\n        _changeGovernor(_initGovernor);\n    }\n\n    /**\n     * @return The address of the proxy admin/it's also the governor.\n     */\n    function admin() external view returns (address) {\n        return _governor();\n    }\n\n    /**\n     * @return The address of the implementation.\n     */\n    function implementation() external view returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @dev Upgrade the backing implementation of the proxy.\n     * Only the admin can call this function.\n     * @param _newImplementation Address of the new implementation.\n     */\n    function upgradeTo(address _newImplementation) external onlyGovernor {\n        _upgradeTo(_newImplementation);\n    }\n\n    /**\n     * @dev Upgrade the backing implementation of the proxy and call a function\n     * on the new implementation.\n     * This is useful to initialize the proxied contract.\n     * @param newImplementation Address of the new implementation.\n     * @param data Data to send as msg.data in the low level call.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\n        external\n        payable\n        onlyGovernor\n    {\n        _upgradeTo(newImplementation);\n        (bool success, ) = newImplementation.delegatecall(data);\n        require(success);\n    }\n\n    /**\n     * @dev Fallback function.\n     * Implemented entirely in `_fallback`.\n     */\n    fallback() external payable {\n        _fallback();\n    }\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * This is a low level function that doesn't return to its internal call site.\n     * It will return to the external caller whatever the implementation returns.\n     * @param _impl Address to delegate.\n     */\n    function _delegate(address _impl) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev Function that is run as the first thing in the fallback function.\n     * Can be redefined in derived contracts to add functionality.\n     * Redefinitions must call super._willFallback().\n     */\n    function _willFallback() internal {}\n\n    /**\n     * @dev fallback implementation.\n     * Extracted to enable manual triggering.\n     */\n    function _fallback() internal {\n        _willFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation.\n     * @return impl Address of the current implementation\n     */\n    function _implementation() internal view returns (address impl) {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Upgrades the proxy to a new implementation.\n     * @param newImplementation Address of the new implementation.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation address of the proxy.\n     * @param newImplementation Address of the new implementation.\n     */\n    function _setImplementation(address newImplementation) internal {\n        require(\n            Address.isContract(newImplementation),\n            \"Cannot set a proxy implementation to a non-contract address\"\n        );\n\n        bytes32 slot = IMPLEMENTATION_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n}\n"
    },
    "contracts/proxies/InitializeGovernedUpgradeabilityProxy2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { InitializeGovernedUpgradeabilityProxy } from \"./InitializeGovernedUpgradeabilityProxy.sol\";\n\n/**\n * @title BaseGovernedUpgradeabilityProxy2\n * @dev This is the same as InitializeGovernedUpgradeabilityProxy except that the\n *      governor is defined in the constructor.\n * @author Origin Protocol Inc\n */\ncontract InitializeGovernedUpgradeabilityProxy2 is\n    InitializeGovernedUpgradeabilityProxy\n{\n    /**\n     * This is used when the msg.sender can not be the governor. E.g. when the proxy is\n     * deployed via CreateX\n     */\n    constructor(address governor) InitializeGovernedUpgradeabilityProxy() {\n        _setGovernor(governor);\n    }\n}\n"
    },
    "contracts/proxies/Proxies.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { InitializeGovernedUpgradeabilityProxy } from \"./InitializeGovernedUpgradeabilityProxy.sol\";\nimport { InitializeGovernedUpgradeabilityProxy2 } from \"./InitializeGovernedUpgradeabilityProxy2.sol\";\n\n/**\n * @notice OUSDProxy delegates calls to an OUSD implementation\n */\ncontract OUSDProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice WrappedOUSDProxy delegates calls to a WrappedOUSD implementation\n */\ncontract WrappedOUSDProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice VaultProxy delegates calls to a Vault implementation\n */\ncontract VaultProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice CompoundStrategyProxy delegates calls to a CompoundStrategy implementation\n */\ncontract CompoundStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice AaveStrategyProxy delegates calls to a AaveStrategy implementation\n */\ncontract AaveStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice ConvexStrategyProxy delegates calls to a ConvexStrategy implementation\n */\ncontract ConvexStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice HarvesterProxy delegates calls to a Harvester implementation\n */\ncontract HarvesterProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice DripperProxy delegates calls to a Dripper implementation\n */\ncontract DripperProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice MorphoCompoundStrategyProxy delegates calls to a MorphoCompoundStrategy implementation\n */\ncontract MorphoCompoundStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice ConvexOUSDMetaStrategyProxy delegates calls to a ConvexOUSDMetaStrategy implementation\n */\ncontract ConvexOUSDMetaStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice MorphoAaveStrategyProxy delegates calls to a MorphoCompoundStrategy implementation\n */\ncontract MorphoAaveStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHProxy delegates calls to nowhere for now\n */\ncontract OETHProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice WOETHProxy delegates calls to nowhere for now\n */\ncontract WOETHProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHVaultProxy delegates calls to a Vault implementation\n */\ncontract OETHVaultProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHDripperProxy delegates calls to a OETHDripper implementation\n */\ncontract OETHDripperProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHHarvesterProxy delegates calls to a Harvester implementation\n */\ncontract OETHHarvesterProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice CurveEthStrategyProxy delegates calls to a CurveEthStrategy implementation\n */\ncontract ConvexEthMetaStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice BuybackProxy delegates calls to Buyback implementation\n */\ncontract BuybackProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHMorphoAaveStrategyProxy delegates calls to a MorphoAaveStrategy implementation\n */\ncontract OETHMorphoAaveStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHBalancerMetaPoolrEthStrategyProxy delegates calls to a BalancerMetaPoolStrategy implementation\n */\ncontract OETHBalancerMetaPoolrEthStrategyProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice OETHBalancerMetaPoolwstEthStrategyProxy delegates calls to a BalancerMetaPoolStrategy implementation\n */\ncontract OETHBalancerMetaPoolwstEthStrategyProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice MakerDsrStrategyProxy delegates calls to a Generalized4626Strategy implementation\n */\ncontract MakerDsrStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHBuybackProxy delegates calls to Buyback implementation\n */\ncontract OETHBuybackProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice BridgedWOETHProxy delegates calls to BridgedWOETH implementation\n */\ncontract BridgedWOETHProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice NativeStakingSSVStrategyProxy delegates calls to NativeStakingSSVStrategy implementation\n */\ncontract NativeStakingSSVStrategyProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice NativeStakingFeeAccumulatorProxy delegates calls to FeeAccumulator implementation\n */\ncontract NativeStakingFeeAccumulatorProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice NativeStakingSSVStrategy2Proxy delegates calls to NativeStakingSSVStrategy implementation\n */\ncontract NativeStakingSSVStrategy2Proxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice NativeStakingFeeAccumulator2Proxy delegates calls to FeeAccumulator implementation\n */\ncontract NativeStakingFeeAccumulator2Proxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice NativeStakingSSVStrategy3Proxy delegates calls to NativeStakingSSVStrategy implementation\n */\ncontract NativeStakingSSVStrategy3Proxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice NativeStakingFeeAccumulator3Proxy delegates calls to FeeAccumulator implementation\n */\ncontract NativeStakingFeeAccumulator3Proxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice MetaMorphoStrategyProxy delegates calls to a Generalized4626Strategy implementation\n */\ncontract MetaMorphoStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice ARMBuybackProxy delegates calls to Buyback implementation\n */\ncontract ARMBuybackProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice MorphoGauntletPrimeUSDCStrategyProxy delegates calls to a Generalized4626Strategy implementation\n */\ncontract MorphoGauntletPrimeUSDCStrategyProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice MorphoGauntletPrimeUSDTStrategyProxy delegates calls to a Generalized4626USDTStrategy implementation\n */\ncontract MorphoGauntletPrimeUSDTStrategyProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice CurvePoolBoosterProxy delegates calls to a CurvePoolBooster implementation\n */\ncontract CurvePoolBoosterProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHFixedRateDripperProxy delegates calls to a OETHFixedRateDripper implementation\n */\ncontract OETHFixedRateDripperProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHSimpleHarvesterProxy delegates calls to a OETHSimpleHarvester implementation\n */\ncontract OETHSimpleHarvesterProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice PoolBoostCentralRegistryProxy delegates calls to the PoolBoostCentralRegistry implementation\n */\ncontract PoolBoostCentralRegistryProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice MakerSSRStrategyProxy delegates calls to a Generalized4626Strategy implementation\n */\ncontract MakerSSRStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OUSDCurveAMOProxy delegates calls to a CurveAMOStrategy implementation\n */\ncontract OUSDCurveAMOProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice OETHCurveAMOProxy delegates calls to a CurveAMOStrategy implementation\n */\ncontract OETHCurveAMOProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice CompoundingStakingSSVStrategyProxy delegates calls to a CompoundingStakingSSVStrategy implementation\n */\ncontract CompoundingStakingSSVStrategyProxy is\n    InitializeGovernedUpgradeabilityProxy\n{\n\n}\n\n/**\n * @notice OUSDMorphoV2StrategyProxy delegates calls to a Generalized4626Strategy implementation\n */\ncontract OUSDMorphoV2StrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n"
    },
    "contracts/strategies/AaveStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD Aave Strategy\n * @notice Investment strategy for investing stablecoins via Aave\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./IAave.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\n\nimport { IAaveStakedToken } from \"./IAaveStakeToken.sol\";\nimport { IAaveIncentivesController } from \"./IAaveIncentivesController.sol\";\n\ncontract AaveStrategy is InitializableAbstractStrategy {\n    using SafeERC20 for IERC20;\n\n    uint16 constant referralCode = 92;\n\n    IAaveIncentivesController public incentivesController;\n    IAaveStakedToken public stkAave;\n\n    /**\n     * @param _stratConfig The platform and OToken vault addresses\n     */\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as AAVE needs several extra\n     * addresses for the rewards program.\n     * @param _rewardTokenAddresses Address of the AAVE token\n     * @param _assets Addresses of supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     * @param _incentivesAddress Address of the AAVE incentives controller\n     * @param _stkAaveAddress Address of the stkAave contract\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // AAVE\n        address[] calldata _assets,\n        address[] calldata _pTokens,\n        address _incentivesAddress,\n        address _stkAaveAddress\n    ) external onlyGovernor initializer {\n        incentivesController = IAaveIncentivesController(_incentivesAddress);\n        stkAave = IAaveStakedToken(_stkAaveAddress);\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n    }\n\n    /**\n     * @dev Deposit asset into Aave\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @dev Deposit asset into Aave\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_amount > 0, \"Must deposit something\");\n        // Following line also doubles as a check that we are depositing\n        // an asset that we support.\n        emit Deposit(_asset, _getATokenFor(_asset), _amount);\n        _getLendingPool().deposit(_asset, _amount, address(this), referralCode);\n    }\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into Aave\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            uint256 balance = IERC20(assetsMapped[i]).balanceOf(address(this));\n            if (balance > 0) {\n                _deposit(assetsMapped[i], balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw asset from Aave\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        emit Withdrawal(_asset, _getATokenFor(_asset), _amount);\n        uint256 actual = _getLendingPool().withdraw(\n            _asset,\n            _amount,\n            address(this)\n        );\n        require(actual == _amount, \"Did not withdraw enough\");\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            // Redeem entire balance of aToken\n            IERC20 asset = IERC20(assetsMapped[i]);\n            address aToken = _getATokenFor(assetsMapped[i]);\n            uint256 balance = IERC20(aToken).balanceOf(address(this));\n            if (balance > 0) {\n                uint256 actual = _getLendingPool().withdraw(\n                    address(asset),\n                    balance,\n                    address(this)\n                );\n                require(actual == balance, \"Did not withdraw enough\");\n\n                uint256 assetBalance = asset.balanceOf(address(this));\n                // Transfer entire balance to Vault\n                asset.safeTransfer(vaultAddress, assetBalance);\n\n                emit Withdrawal(address(asset), aToken, assetBalance);\n            }\n        }\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        // Balance is always with token aToken decimals\n        address aToken = _getATokenFor(_asset);\n        balance = IERC20(aToken).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @dev Approve the spending of all assets by their corresponding aToken,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        address lendingPool = address(_getLendingPool());\n        // approve the pool to spend the Asset\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            address asset = assetsMapped[i];\n            // Safe approval\n            IERC20(asset).safeApprove(lendingPool, 0);\n            IERC20(asset).safeApprove(lendingPool, type(uint256).max);\n        }\n    }\n\n    /**\n     * @dev Internal method to respond to the addition of new asset / aTokens\n            We need to give the AAVE lending pool approval to transfer the\n            asset.\n     * @param _asset Address of the asset to approve\n     * @param _aToken Address of the aToken\n     */\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address _aToken)\n        internal\n        override\n    {\n        address lendingPool = address(_getLendingPool());\n        IERC20(_asset).safeApprove(lendingPool, 0);\n        IERC20(_asset).safeApprove(lendingPool, type(uint256).max);\n    }\n\n    /**\n     * @dev Get the aToken wrapped in the IERC20 interface for this asset.\n     *      Fails if the pToken doesn't exist in our mappings.\n     * @param _asset Address of the asset\n     * @return Corresponding aToken to this asset\n     */\n    function _getATokenFor(address _asset) internal view returns (address) {\n        address aToken = assetToPToken[_asset];\n        require(aToken != address(0), \"aToken does not exist\");\n        return aToken;\n    }\n\n    /**\n     * @dev Get the current address of the Aave lending pool, which is the gateway to\n     *      depositing.\n     * @return Current lending pool implementation\n     */\n    function _getLendingPool() internal view returns (IAaveLendingPool) {\n        address lendingPool = ILendingPoolAddressesProvider(platformAddress)\n            .getLendingPool();\n        require(lendingPool != address(0), \"Lending pool does not exist\");\n        return IAaveLendingPool(lendingPool);\n    }\n\n    /**\n     * @dev Collect stkAave, convert it to AAVE send to Vault.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        if (address(stkAave) == address(0)) {\n            return;\n        }\n\n        // Check staked AAVE cooldown timer\n        uint256 cooldown = stkAave.stakersCooldowns(address(this));\n        uint256 windowStart = cooldown + stkAave.COOLDOWN_SECONDS();\n        uint256 windowEnd = windowStart + stkAave.UNSTAKE_WINDOW();\n\n        // If inside the unlock window, then we can redeem stkAave\n        // for AAVE and send it to the vault.\n        if (block.timestamp > windowStart && block.timestamp <= windowEnd) {\n            // Redeem to AAVE\n            uint256 stkAaveBalance = stkAave.balanceOf(address(this));\n            stkAave.redeem(address(this), stkAaveBalance);\n\n            // Transfer AAVE to harvesterAddress\n            uint256 aaveBalance = IERC20(rewardTokenAddresses[0]).balanceOf(\n                address(this)\n            );\n            if (aaveBalance > 0) {\n                IERC20(rewardTokenAddresses[0]).safeTransfer(\n                    harvesterAddress,\n                    aaveBalance\n                );\n            }\n        }\n\n        // Collect available rewards and restart the cooldown timer, if either of\n        // those should be run.\n        if (block.timestamp > windowStart || cooldown == 0) {\n            uint256 assetsLen = assetsMapped.length;\n            // aToken addresses for incentives controller\n            address[] memory aTokens = new address[](assetsLen);\n            for (uint256 i = 0; i < assetsLen; ++i) {\n                aTokens[i] = _getATokenFor(assetsMapped[i]);\n            }\n\n            // 1. If we have rewards availabile, collect them\n            uint256 pendingRewards = incentivesController.getRewardsBalance(\n                aTokens,\n                address(this)\n            );\n            if (pendingRewards > 0) {\n                // Because getting more stkAAVE from the incentives controller\n                // with claimRewards() may push the stkAAVE cooldown time\n                // forward, it is called after stakedAAVE has been turned into\n                // AAVE.\n                uint256 collected = incentivesController.claimRewards(\n                    aTokens,\n                    pendingRewards,\n                    address(this)\n                );\n                require(collected == pendingRewards, \"AAVE reward difference\");\n            }\n\n            // 2. Start cooldown counting down.\n            if (stkAave.balanceOf(address(this)) > 0) {\n                // Protected with if since cooldown call would revert\n                // if no stkAave balance.\n                stkAave.cooldown();\n            }\n        }\n    }\n}\n"
    },
    "contracts/strategies/AbstractCompoundStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Base Compound Abstract Strategy\n * @author Origin Protocol Inc\n */\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ICERC20 } from \"./ICompound.sol\";\nimport { IComptroller } from \"../interfaces/IComptroller.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\n\nabstract contract AbstractCompoundStrategy is InitializableAbstractStrategy {\n    using SafeERC20 for IERC20;\n\n    int256[50] private __reserved;\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @dev Get the cToken wrapped in the ICERC20 interface for this asset.\n     *      Fails if the pToken doesn't exist in our mappings.\n     * @param _asset Address of the asset\n     * @return Corresponding cToken to this asset\n     */\n    function _getCTokenFor(address _asset) internal view returns (ICERC20) {\n        address cToken = assetToPToken[_asset];\n        require(cToken != address(0), \"cToken does not exist\");\n        return ICERC20(cToken);\n    }\n\n    /**\n     * @dev Converts an underlying amount into cToken amount\n     *      cTokenAmt = (underlying * 1e18) / exchangeRate\n     * @param _cToken     cToken for which to change\n     * @param _underlying Amount of underlying to convert\n     * @return amount     Equivalent amount of cTokens\n     */\n    function _convertUnderlyingToCToken(ICERC20 _cToken, uint256 _underlying)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // e.g. 1e18*1e18 / 205316390724364402565641705 = 50e8\n        // e.g. 1e8*1e18 / 205316390724364402565641705 = 0.45 or 0\n        amount = (_underlying * 1e18) / _cToken.exchangeRateStored();\n    }\n}\n"
    },
    "contracts/strategies/AbstractConvexMetaStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Curve Convex Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IRewardStaking } from \"./IRewardStaking.sol\";\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { ICurveMetaPool } from \"./ICurveMetaPool.sol\";\nimport { IERC20, AbstractCurveStrategy, InitializableAbstractStrategy } from \"./AbstractCurveStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\n\nabstract contract AbstractConvexMetaStrategy is AbstractCurveStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    event MaxWithdrawalSlippageUpdated(\n        uint256 _prevMaxSlippagePercentage,\n        uint256 _newMaxSlippagePercentage\n    );\n\n    // used to circumvent the stack too deep issue\n    struct InitConfig {\n        address cvxDepositorAddress; //Address of the Convex depositor(AKA booster) for this pool\n        address metapoolAddress; //Address of the Curve MetaPool\n        address metapoolMainToken; //Address of Main metapool token\n        address cvxRewardStakerAddress; //Address of the CVX rewards staker\n        address metapoolLPToken; //Address of metapool LP token\n        uint256 cvxDepositorPTokenId; //Pid of the pool referred to by Depositor and staker\n    }\n\n    address internal cvxDepositorAddress;\n    address internal cvxRewardStakerAddress;\n    uint256 internal cvxDepositorPTokenId;\n    ICurveMetaPool internal metapool;\n    IERC20 internal metapoolMainToken;\n    IERC20 internal metapoolLPToken;\n    // Ordered list of metapool assets\n    address[] internal metapoolAssets;\n    // Max withdrawal slippage denominated in 1e18 (1e18 == 100%)\n    uint256 public maxWithdrawalSlippage;\n    uint128 internal crvCoinIndex;\n    uint128 internal mainCoinIndex;\n\n    int256[41] private ___reserved;\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Curve strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Address of CRV & CVX\n     * @param _assets Addresses of supported assets. MUST be passed in the same\n     *                order as returned by coins on the pool contract, i.e.\n     *                DAI, USDC, USDT\n     * @param _pTokens Platform Token corresponding addresses\n     * @param initConfig Various addresses and info for initialization state\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // CRV + CVX\n        address[] calldata _assets,\n        address[] calldata _pTokens,\n        InitConfig calldata initConfig\n    ) external onlyGovernor initializer {\n        require(_assets.length == 3, \"Must have exactly three assets\");\n        // Should be set prior to abstract initialize call otherwise\n        // abstractSetPToken calls will fail\n        cvxDepositorAddress = initConfig.cvxDepositorAddress;\n        pTokenAddress = _pTokens[0];\n        metapool = ICurveMetaPool(initConfig.metapoolAddress);\n        metapoolMainToken = IERC20(initConfig.metapoolMainToken);\n        cvxRewardStakerAddress = initConfig.cvxRewardStakerAddress;\n        metapoolLPToken = IERC20(initConfig.metapoolLPToken);\n        cvxDepositorPTokenId = initConfig.cvxDepositorPTokenId;\n        maxWithdrawalSlippage = 1e16;\n\n        metapoolAssets = [metapool.coins(0), metapool.coins(1)];\n        crvCoinIndex = _getMetapoolCoinIndex(pTokenAddress);\n        mainCoinIndex = _getMetapoolCoinIndex(initConfig.metapoolMainToken);\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n        _approveBase();\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        virtual\n        override\n        returns (uint256 balance)\n    {\n        require(assetToPToken[_asset] != address(0), \"Unsupported asset\");\n        balance = 0;\n\n        // LP tokens in this contract. This should generally be nothing as we\n        // should always stake the full balance in the Gauge, but include for\n        // safety\n        uint256 contractPTokens = IERC20(pTokenAddress).balanceOf(\n            address(this)\n        );\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        if (contractPTokens > 0) {\n            uint256 virtual_price = curvePool.get_virtual_price();\n            uint256 value = contractPTokens.mulTruncate(virtual_price);\n            balance += value;\n        }\n\n        /* We intentionally omit the metapoolLp tokens held by the metastrategyContract\n         * since the contract should never (except in the middle of deposit/withdrawal\n         * transaction) hold any amount of those tokens in normal operation. There\n         * could be tokens sent to it by a 3rd party and we decide to actively ignore\n         * those.\n         */\n        uint256 metapoolGaugePTokens = IRewardStaking(cvxRewardStakerAddress)\n            .balanceOf(address(this));\n\n        if (metapoolGaugePTokens > 0) {\n            uint256 value = metapoolGaugePTokens.mulTruncate(\n                metapool.get_virtual_price()\n            );\n            balance += value;\n        }\n\n        uint256 assetDecimals = Helpers.getDecimals(_asset);\n        balance = balance.scaleBy(assetDecimals, 18) / THREEPOOL_ASSET_COUNT;\n    }\n\n    /**\n     * @dev This function is completely analogous to _calcCurveTokenAmount[AbstractCurveStrategy]\n     * and just utilizes different Curve (meta)pool API\n     */\n    function _calcCurveMetaTokenAmount(uint128 _coinIndex, uint256 _amount)\n        internal\n        returns (uint256 requiredMetapoolLP)\n    {\n        uint256[2] memory _amounts = [uint256(0), uint256(0)];\n        _amounts[uint256(_coinIndex)] = _amount;\n\n        // LP required when removing required asset ignoring fees\n        uint256 lpRequiredNoFees = metapool.calc_token_amount(_amounts, false);\n        /* LP required if fees would apply to entirety of removed amount\n         *\n         * fee is 1e10 denominated number: https://curve.readthedocs.io/exchange-pools.html#StableSwap.fee\n         */\n        uint256 lpRequiredFullFees = lpRequiredNoFees.mulTruncateScale(\n            1e10 + metapool.fee(),\n            1e10\n        );\n\n        /* asset received when withdrawing full fee applicable LP accounting for\n         * slippage and fees\n         */\n        uint256 assetReceivedForFullLPFees = metapool.calc_withdraw_one_coin(\n            lpRequiredFullFees,\n            int128(_coinIndex)\n        );\n\n        // exact amount of LP required\n        requiredMetapoolLP =\n            (lpRequiredFullFees * _amount) /\n            assetReceivedForFullLPFees;\n    }\n\n    function _approveBase() internal override {\n        IERC20 pToken = IERC20(pTokenAddress);\n        // 3Pool for LP token (required for removing liquidity)\n        pToken.safeApprove(platformAddress, 0);\n        pToken.safeApprove(platformAddress, type(uint256).max);\n        // Gauge for LP token\n        metapoolLPToken.safeApprove(cvxDepositorAddress, 0);\n        metapoolLPToken.safeApprove(cvxDepositorAddress, type(uint256).max);\n        // Metapool for LP token\n        pToken.safeApprove(address(metapool), 0);\n        pToken.safeApprove(address(metapool), type(uint256).max);\n        // Metapool for Metapool main token\n        metapoolMainToken.safeApprove(address(metapool), 0);\n        metapoolMainToken.safeApprove(address(metapool), type(uint256).max);\n    }\n\n    /**\n     * @dev Get the index of the coin\n     */\n    function _getMetapoolCoinIndex(address _asset)\n        internal\n        view\n        returns (uint128)\n    {\n        for (uint128 i = 0; i < 2; i++) {\n            if (metapoolAssets[i] == _asset) return i;\n        }\n        revert(\"Invalid Metapool asset\");\n    }\n\n    /**\n     * @dev Sets max withdrawal slippage that is considered when removing\n     * liquidity from Metapools.\n     * @param _maxWithdrawalSlippage Max withdrawal slippage denominated in\n     *        wad (number with 18 decimals): 1e18 == 100%, 1e16 == 1%\n     *\n     * IMPORTANT Minimum maxWithdrawalSlippage should actually be 0.1% (1e15)\n     * for production usage. Contract allows as low value as 0% for confirming\n     * correct behavior in test suite.\n     */\n    function setMaxWithdrawalSlippage(uint256 _maxWithdrawalSlippage)\n        external\n        onlyVaultOrGovernorOrStrategist\n    {\n        require(\n            _maxWithdrawalSlippage <= 1e18,\n            \"Max withdrawal slippage needs to be between 0% - 100%\"\n        );\n        emit MaxWithdrawalSlippageUpdated(\n            maxWithdrawalSlippage,\n            _maxWithdrawalSlippage\n        );\n        maxWithdrawalSlippage = _maxWithdrawalSlippage;\n    }\n\n    /**\n     * @dev Collect accumulated CRV and CVX and send to Harvester.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Collect CRV and CVX\n        IRewardStaking(cvxRewardStakerAddress).getReward();\n        _collectRewardTokens();\n    }\n\n    /**\n     * @dev Returns the largest of two numbers int256 version\n     */\n    function _max(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n}\n"
    },
    "contracts/strategies/AbstractCurveStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Curve 3Pool Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\n\nabstract contract AbstractCurveStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant MAX_SLIPPAGE = 1e16; // 1%, same as the Curve UI\n    // number of assets in Curve 3Pool (USDC, DAI, USDT)\n    uint256 internal constant THREEPOOL_ASSET_COUNT = 3;\n    address internal pTokenAddress;\n\n    int256[49] private __reserved;\n\n    /**\n     * @dev Deposit asset into the Curve 3Pool\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        require(_amount > 0, \"Must deposit something\");\n        emit Deposit(_asset, pTokenAddress, _amount);\n\n        // 3Pool requires passing deposit amounts for all 3 assets, set to 0 for\n        // all\n        uint256[3] memory _amounts;\n        uint256 poolCoinIndex = _getCoinIndex(_asset);\n        // Set the amount on the asset we want to deposit\n        _amounts[poolCoinIndex] = _amount;\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        uint256 assetDecimals = Helpers.getDecimals(_asset);\n        uint256 depositValue = _amount.scaleBy(18, assetDecimals).divPrecisely(\n            curvePool.get_virtual_price()\n        );\n        uint256 minMintAmount = depositValue.mulTruncate(\n            uint256(1e18) - MAX_SLIPPAGE\n        );\n        // Do the deposit to 3pool\n        curvePool.add_liquidity(_amounts, minMintAmount);\n        _lpDepositAll();\n    }\n\n    function _lpDepositAll() internal virtual;\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into the Curve 3pool\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256[3] memory _amounts = [uint256(0), uint256(0), uint256(0)];\n        uint256 depositValue = 0;\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        uint256 curveVirtualPrice = curvePool.get_virtual_price();\n\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; i++) {\n            address assetAddress = assetsMapped[i];\n            uint256 balance = IERC20(assetAddress).balanceOf(address(this));\n            if (balance > 0) {\n                uint256 poolCoinIndex = _getCoinIndex(assetAddress);\n                // Set the amount on the asset we want to deposit\n                _amounts[poolCoinIndex] = balance;\n                uint256 assetDecimals = Helpers.getDecimals(assetAddress);\n                // Get value of deposit in Curve LP token to later determine\n                // the minMintAmount argument for add_liquidity\n                depositValue =\n                    depositValue +\n                    balance.scaleBy(18, assetDecimals).divPrecisely(\n                        curveVirtualPrice\n                    );\n                emit Deposit(assetAddress, pTokenAddress, balance);\n            }\n        }\n\n        uint256 minMintAmount = depositValue.mulTruncate(\n            uint256(1e18) - MAX_SLIPPAGE\n        );\n        // Do the deposit to 3pool\n        curvePool.add_liquidity(_amounts, minMintAmount);\n\n        /* In case of Curve Strategy all assets are mapped to the same pToken (3CrvLP). Let\n         * descendants further handle the pToken. By either deploying it to the metapool and\n         * resulting tokens in Gauge. Or deploying pTokens directly to the Gauge.\n         */\n        _lpDepositAll();\n    }\n\n    function _lpWithdraw(uint256 numCrvTokens) internal virtual;\n\n    function _lpWithdrawAll() internal virtual;\n\n    /**\n     * @dev Withdraw asset from Curve 3Pool\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_amount > 0, \"Invalid amount\");\n\n        emit Withdrawal(_asset, pTokenAddress, _amount);\n\n        uint256 contractCrv3Tokens = IERC20(pTokenAddress).balanceOf(\n            address(this)\n        );\n\n        uint256 coinIndex = _getCoinIndex(_asset);\n        ICurvePool curvePool = ICurvePool(platformAddress);\n\n        uint256 requiredCrv3Tokens = _calcCurveTokenAmount(coinIndex, _amount);\n\n        // We have enough LP tokens, make sure they are all on this contract\n        if (contractCrv3Tokens < requiredCrv3Tokens) {\n            _lpWithdraw(requiredCrv3Tokens - contractCrv3Tokens);\n        }\n\n        uint256[3] memory _amounts = [uint256(0), uint256(0), uint256(0)];\n        _amounts[coinIndex] = _amount;\n\n        curvePool.remove_liquidity_imbalance(_amounts, requiredCrv3Tokens);\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Calculate amount of LP required when withdrawing specific amount of one\n     * of the underlying assets accounting for fees and slippage.\n     *\n     * Curve pools unfortunately do not contain a calculation function for\n     * amount of LP required when withdrawing a specific amount of one of the\n     * underlying tokens and also accounting for fees (Curve's calc_token_amount\n     * does account for slippage but not fees).\n     *\n     * Steps taken to calculate the metric:\n     *  - get amount of LP required if fees wouldn't apply\n     *  - increase the LP amount as if fees would apply to the entirety of the underlying\n     *    asset withdrawal. (when withdrawing only one coin fees apply only to amounts\n     *    of other assets pool would return in case of balanced removal - since those need\n     *    to be swapped for the single underlying asset being withdrawn)\n     *  - get amount of underlying asset withdrawn (this Curve function does consider slippage\n     *    and fees) when using the increased LP amount. As LP amount is slightly over-increased\n     *    so is amount of underlying assets returned.\n     *  - since we know exactly how much asset we require take the rate of LP required for asset\n     *    withdrawn to get the exact amount of LP.\n     */\n    function _calcCurveTokenAmount(uint256 _coinIndex, uint256 _amount)\n        internal\n        returns (uint256 required3Crv)\n    {\n        ICurvePool curvePool = ICurvePool(platformAddress);\n\n        uint256[3] memory _amounts = [uint256(0), uint256(0), uint256(0)];\n        _amounts[_coinIndex] = _amount;\n\n        // LP required when removing required asset ignoring fees\n        uint256 lpRequiredNoFees = curvePool.calc_token_amount(_amounts, false);\n        /* LP required if fees would apply to entirety of removed amount\n         *\n         * fee is 1e10 denominated number: https://curve.readthedocs.io/exchange-pools.html#StableSwap.fee\n         */\n        uint256 lpRequiredFullFees = lpRequiredNoFees.mulTruncateScale(\n            1e10 + curvePool.fee(),\n            1e10\n        );\n\n        /* asset received when withdrawing full fee applicable LP accounting for\n         * slippage and fees\n         */\n        uint256 assetReceivedForFullLPFees = curvePool.calc_withdraw_one_coin(\n            lpRequiredFullFees,\n            int128(uint128(_coinIndex))\n        );\n\n        // exact amount of LP required\n        required3Crv =\n            (lpRequiredFullFees * _amount) /\n            assetReceivedForFullLPFees;\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        _lpWithdrawAll();\n        // Withdraws are proportional to assets held by 3Pool\n        uint256[3] memory minWithdrawAmounts = [\n            uint256(0),\n            uint256(0),\n            uint256(0)\n        ];\n\n        // Remove liquidity\n        ICurvePool threePool = ICurvePool(platformAddress);\n        threePool.remove_liquidity(\n            IERC20(pTokenAddress).balanceOf(address(this)),\n            minWithdrawAmounts\n        );\n        // Transfer assets out of Vault\n        // Note that Curve will provide all 3 of the assets in 3pool even if\n        // we have not set PToken addresses for all of them in this strategy\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            IERC20 asset = IERC20(threePool.coins(i));\n            asset.safeTransfer(vaultAddress, asset.balanceOf(address(this)));\n        }\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        virtual\n        override\n        returns (uint256 balance)\n    {\n        require(assetToPToken[_asset] != address(0), \"Unsupported asset\");\n        // LP tokens in this contract. This should generally be nothing as we\n        // should always stake the full balance in the Gauge, but include for\n        // safety\n        uint256 totalPTokens = IERC20(pTokenAddress).balanceOf(address(this));\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        if (totalPTokens > 0) {\n            uint256 virtual_price = curvePool.get_virtual_price();\n            uint256 value = (totalPTokens * virtual_price) / 1e18;\n            uint256 assetDecimals = Helpers.getDecimals(_asset);\n            balance = value.scaleBy(assetDecimals, 18) / THREEPOOL_ASSET_COUNT;\n        }\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @dev Approve the spending of all assets by their corresponding pool tokens,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        _approveBase();\n        // This strategy is a special case since it only supports one asset\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            _approveAsset(assetsMapped[i]);\n        }\n    }\n\n    /**\n     * @dev Call the necessary approvals for the Curve pool and gauge\n     * @param _asset Address of the asset\n     */\n    function _abstractSetPToken(address _asset, address) internal override {\n        _approveAsset(_asset);\n    }\n\n    function _approveAsset(address _asset) internal {\n        IERC20 asset = IERC20(_asset);\n        // 3Pool for asset (required for adding liquidity)\n        asset.safeApprove(platformAddress, 0);\n        asset.safeApprove(platformAddress, type(uint256).max);\n    }\n\n    function _approveBase() internal virtual;\n\n    /**\n     * @dev Get the index of the coin\n     */\n    function _getCoinIndex(address _asset) internal view returns (uint256) {\n        for (uint256 i = 0; i < 3; i++) {\n            if (assetsMapped[i] == _asset) return i;\n        }\n        revert(\"Invalid 3pool asset\");\n    }\n}\n"
    },
    "contracts/strategies/aerodrome/AerodromeAMOStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Aerodrome AMO strategy\n * @author Origin Protocol Inc\n */\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { IERC20, InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\n\nimport { ISugarHelper } from \"../../interfaces/aerodrome/ISugarHelper.sol\";\nimport { INonfungiblePositionManager } from \"../../interfaces/aerodrome/INonfungiblePositionManager.sol\";\nimport { ISwapRouter } from \"../../interfaces/aerodrome/ISwapRouter.sol\";\nimport { ICLPool } from \"../../interfaces/aerodrome/ICLPool.sol\";\nimport { ICLGauge } from \"../../interfaces/aerodrome/ICLGauge.sol\";\nimport { IVault } from \"../../interfaces/IVault.sol\";\n\ncontract AerodromeAMOStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    /************************************************\n            Important (!) setup configuration\n    *************************************************/\n\n    /**\n     * In order to be able to remove a reasonable amount of complexity from the contract one of the\n     * preconditions for this contract to function correctly is to have an outside account mint a small\n     * amount of liquidity in the tick space where the contract will deploy's its liquidity and then send\n     * that NFT LP position to a dead address (transfer to zero address not allowed.) See example of such\n     * NFT LP token:\n     * https://basescan.org/token/0x827922686190790b37229fd06084350e74485b72?a=413296#inventory\n     */\n\n    /***************************************\n            Storage slot members\n    ****************************************/\n\n    /// @notice tokenId of the liquidity position\n    uint256 public tokenId;\n    /// @dev Minimum amount of tokens the strategy would be able to withdraw from the pool.\n    ///      minimum amount of tokens are withdrawn at a 1:1 price\n    uint256 public underlyingAssets;\n    /// @notice Marks the start of the interval that defines the allowed range of WETH share in\n    /// the pre-configured pool's liquidity ticker\n    uint256 public allowedWethShareStart;\n    /// @notice Marks the end of the interval that defines the allowed range of WETH share in\n    /// the pre-configured pool's liquidity ticker\n    uint256 public allowedWethShareEnd;\n    /// @dev reserved for inheritance\n    int256[46] private __reserved;\n\n    /***************************************\n          Constants, structs and events\n    ****************************************/\n\n    /// @notice The address of the Wrapped ETH (WETH) token contract\n    address public immutable WETH;\n    /// @notice The address of the OETHb token contract\n    address public immutable OETHb;\n    /// @notice lower tick set to -1 representing the price of 1.0001 of WETH for 1 OETHb.\n    int24 public immutable lowerTick;\n    /// @notice lower tick set to 0 representing the price of 1.0000 of WETH for 1 OETHb.\n    int24 public immutable upperTick;\n    /// @notice tick spacing of the pool (set to 1)\n    int24 public immutable tickSpacing;\n    /// @notice the swapRouter for performing swaps\n    ISwapRouter public immutable swapRouter;\n    /// @notice the underlying AMO Slipstream pool\n    ICLPool public immutable clPool;\n    /// @notice the gauge for the corresponding Slipstream pool (clPool)\n    /// @dev can become an immutable once the gauge is created on the base main-net\n    ICLGauge public immutable clGauge;\n    /// @notice the Position manager contract that is used to manage the pool's position\n    INonfungiblePositionManager public immutable positionManager;\n    /// @notice helper contract for liquidity and ticker math\n    ISugarHelper public immutable helper;\n    /// @notice sqrtRatioX96TickLower\n    /// @dev tick lower has value -1 and represents the lowest price of WETH priced in OETHb. Meaning the pool\n    /// offers less than 1 OETHb for 1 WETH. In other terms to get 1 OETHB the swap needs to offer 1.0001 WETH\n    /// this is where purchasing OETHb with WETH within the liquidity position is most expensive\n    uint160 public immutable sqrtRatioX96TickLower;\n    /// @notice sqrtRatioX96TickHigher\n    /// @dev tick higher has value 0 and represents 1:1 price parity of WETH to OETHb\n    uint160 public immutable sqrtRatioX96TickHigher;\n    /// @dev tick closest to 1:1 price parity\n    ///      Correctly assessing which tick is closer to 1:1 price parity is important since it affects\n    ///      the way we calculate the underlying assets in check Balance. The underlying aerodrome pool\n    ///      orders the tokens depending on the values of their addresses. If OETH token is token0 in the pool\n    ///      then sqrtRatioX96TickClosestToParity=sqrtRatioX96TickLower. If it is token1 in the pool then\n    ///      sqrtRatioX96TickClosestToParity=sqrtRatioX96TickHigher\n    uint160 public immutable sqrtRatioX96TickClosestToParity;\n\n    /// @dev a threshold under which the contract no longer allows for the protocol to rebalance. Guarding\n    ///      against a strategist / guardian being taken over and with multiple transactions draining the\n    ///      protocol funds.\n    uint256 public constant SOLVENCY_THRESHOLD = 0.998 ether;\n\n    error NotEnoughWethForSwap(uint256 wethBalance, uint256 requiredWeth); // 0x989e5ca8\n    error NotEnoughWethLiquidity(uint256 wethBalance, uint256 requiredWeth); // 0xa6737d87\n    error PoolRebalanceOutOfBounds(\n        uint256 currentPoolWethShare,\n        uint256 allowedWethShareStart,\n        uint256 allowedWethShareEnd\n    ); // 0x3681e8e0\n    error OutsideExpectedTickRange(int24 currentTick); // 0x5a2eba75\n\n    event PoolRebalanced(uint256 currentPoolWethShare);\n\n    event PoolWethShareIntervalUpdated(\n        uint256 allowedWethShareStart,\n        uint256 allowedWethShareEnd\n    );\n\n    event LiquidityRemoved(\n        uint256 withdrawLiquidityShare,\n        uint256 removedWETHAmount,\n        uint256 removedOETHbAmount,\n        uint256 wethAmountCollected,\n        uint256 oethbAmountCollected,\n        uint256 underlyingAssets\n    );\n\n    event LiquidityAdded(\n        uint256 wethAmountDesired,\n        uint256 oethbAmountDesired,\n        uint256 wethAmountSupplied,\n        uint256 oethbAmountSupplied,\n        uint256 tokenId,\n        uint256 underlyingAssets\n    );\n\n    event UnderlyingAssetsUpdated(uint256 underlyingAssets);\n\n    /**\n     * @dev Un-stakes the token from the gauge for the execution duration of\n     * the function and after that re-stakes it back in.\n     *\n     * It is important that the token is unstaked and owned by the strategy contract\n     * during any liquidity altering operations and that it is re-staked back into the\n     * gauge after liquidity changes. If the token fails to re-stake back to the\n     * gauge it is not earning incentives.\n     */\n    // all functions using this modifier are used by functions with reentrancy check\n    // slither-disable-start reentrancy-no-eth\n    modifier gaugeUnstakeAndRestake() {\n        // because of solidity short-circuit _isLpTokenStakedInGauge doesn't get called\n        // when tokenId == 0\n        if (tokenId != 0 && _isLpTokenStakedInGauge()) {\n            clGauge.withdraw(tokenId);\n        }\n        _;\n        // because of solidity short-circuit _isLpTokenStakedInGauge doesn't get called\n        // when tokenId == 0\n        if (tokenId != 0 && !_isLpTokenStakedInGauge()) {\n            /**\n             * It can happen that a withdrawal (or a full withdrawal) transactions would\n             * remove all of the liquidity from the token with a NFT token still existing.\n             * In that case the token can not be staked into the gauge, as some liquidity\n             * needs to be added to it first.\n             */\n            if (_getLiquidity() > 0) {\n                // if token liquidity changes the positionManager requires re-approval.\n                // to any contract pre-approved to handle the token.\n                positionManager.approve(address(clGauge), tokenId);\n                clGauge.deposit(tokenId);\n            }\n        }\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice the constructor\n    /// @dev This contract is intended to be used as a proxy. To prevent the\n    ///      potential confusion of having a functional implementation contract\n    ///      the constructor has the `initializer` modifier. This way the\n    ///      `initialize` function can not be called on the implementation contract.\n    ///      For the same reason the implementation contract also has the governor\n    ///      set to a zero address.\n    /// @param _stratConfig the basic strategy configuration\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\n    /// @param _oethbAddress Address of the Erc20 OETHb Token contract\n    /// @param _swapRouter Address of the Aerodrome Universal Swap Router\n    /// @param _nonfungiblePositionManager Address of position manager to add/remove\n    ///         the liquidity\n    /// @param _clPool Address of the Aerodrome concentrated liquidity pool\n    /// @param _clGauge Address of the Aerodrome slipstream pool gauge\n    /// @param _sugarHelper Address of the Aerodrome Sugar helper contract\n    /// @param _lowerBoundingTick Smaller bounding tick of our liquidity position\n    /// @param _upperBoundingTick Larger bounding tick of our liquidity position\n    /// @param _tickClosestToParity Tick that is closer to 1:1 price parity\n    constructor(\n        BaseStrategyConfig memory _stratConfig,\n        address _wethAddress,\n        address _oethbAddress,\n        address _swapRouter,\n        address _nonfungiblePositionManager,\n        address _clPool,\n        address _clGauge,\n        address _sugarHelper,\n        int24 _lowerBoundingTick,\n        int24 _upperBoundingTick,\n        int24 _tickClosestToParity\n    ) initializer InitializableAbstractStrategy(_stratConfig) {\n        require(\n            _lowerBoundingTick == _tickClosestToParity ||\n                _upperBoundingTick == _tickClosestToParity,\n            \"Misconfigured tickClosestToParity\"\n        );\n        require(\n            ICLPool(_clPool).token0() == _wethAddress,\n            \"Only WETH supported as token0\"\n        );\n        require(\n            ICLPool(_clPool).token1() == _oethbAddress,\n            \"Only OETHb supported as token1\"\n        );\n        int24 _tickSpacing = ICLPool(_clPool).tickSpacing();\n        // when we generalize AMO we might support other tick spacings\n        require(_tickSpacing == 1, \"Unsupported tickSpacing\");\n\n        WETH = _wethAddress;\n        OETHb = _oethbAddress;\n        swapRouter = ISwapRouter(_swapRouter);\n        positionManager = INonfungiblePositionManager(\n            _nonfungiblePositionManager\n        );\n        clPool = ICLPool(_clPool);\n        clGauge = ICLGauge(_clGauge);\n        helper = ISugarHelper(_sugarHelper);\n        sqrtRatioX96TickLower = ISugarHelper(_sugarHelper).getSqrtRatioAtTick(\n            _lowerBoundingTick\n        );\n        sqrtRatioX96TickHigher = ISugarHelper(_sugarHelper).getSqrtRatioAtTick(\n            _upperBoundingTick\n        );\n        sqrtRatioX96TickClosestToParity = ISugarHelper(_sugarHelper)\n            .getSqrtRatioAtTick(_tickClosestToParity);\n\n        lowerTick = _lowerBoundingTick;\n        upperTick = _upperBoundingTick;\n        tickSpacing = _tickSpacing;\n\n        // prevent implementation contract to be governed\n        _setGovernor(address(0));\n    }\n\n    /**\n     * @notice initialize function, to set up initial internal state\n     * @param _rewardTokenAddresses Address of reward token for platform\n     */\n    function initialize(address[] memory _rewardTokenAddresses)\n        external\n        onlyGovernor\n        initializer\n    {\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            new address[](0),\n            new address[](0)\n        );\n    }\n\n    /***************************************\n                  Configuration \n    ****************************************/\n\n    /**\n     * @notice Set allowed pool weth share interval. After the rebalance happens\n     * the share of WETH token in the ticker needs to be withing the specifications\n     * of the interval.\n     *\n     * @param _allowedWethShareStart Start of WETH share interval expressed as 18 decimal amount\n     * @param _allowedWethShareEnd End of WETH share interval expressed as 18 decimal amount\n     */\n    function setAllowedPoolWethShareInterval(\n        uint256 _allowedWethShareStart,\n        uint256 _allowedWethShareEnd\n    ) external onlyGovernor {\n        require(\n            _allowedWethShareStart < _allowedWethShareEnd,\n            \"Invalid interval\"\n        );\n        // can not go below 1% weth share\n        require(_allowedWethShareStart > 0.01 ether, \"Invalid interval start\");\n        // can not go above 95% weth share\n        require(_allowedWethShareEnd < 0.95 ether, \"Invalid interval end\");\n\n        allowedWethShareStart = _allowedWethShareStart;\n        allowedWethShareEnd = _allowedWethShareEnd;\n        emit PoolWethShareIntervalUpdated(\n            allowedWethShareStart,\n            allowedWethShareEnd\n        );\n    }\n\n    /***************************************\n                Periphery utils\n    ****************************************/\n\n    function _isLpTokenStakedInGauge() internal view returns (bool) {\n        require(tokenId != 0, \"Missing NFT LP token\");\n\n        address owner = positionManager.ownerOf(tokenId);\n        require(\n            owner == address(clGauge) || owner == address(this),\n            \"Unexpected token owner\"\n        );\n        return owner == address(clGauge);\n    }\n\n    /***************************************\n               Strategy overrides \n    ****************************************/\n\n    /**\n     * @notice Deposit an amount of assets into the strategy contract. Calling deposit doesn't\n     *         automatically deposit funds into the underlying Aerodrome pool\n     * @param _asset   Address for the asset\n     * @param _amount  Units of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @notice Deposit WETH to the strategy contract. This function does not add liquidity to the\n     *         underlying Aerodrome pool.\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        if (_wethBalance > 1e12) {\n            _deposit(WETH, _wethBalance);\n        }\n    }\n\n    /**\n     * @dev Deposit WETH to the contract. This function doesn't deposit the liquidity to the\n     *      pool, that is done via the rebalance call.\n     * @param _asset Address of the asset to deposit\n     * @param _amount Amount of assets to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_asset == WETH, \"Unsupported asset\");\n        require(_amount > 0, \"Must deposit something\");\n        emit Deposit(_asset, address(0), _amount);\n\n        // if the pool price is not within the expected interval leave the WETH on the contract\n        // as to not break the mints\n        (bool _isExpectedRange, ) = _checkForExpectedPoolPrice(false);\n        if (_isExpectedRange) {\n            // deposit funds into the underlying pool\n            _rebalance(0, false, 0);\n        }\n    }\n\n    /**\n     * @notice Rebalance the pool to the desired token split and Deposit any WETH on the contract to the\n     * underlying aerodrome pool. Print the required amount of corresponding OETHb. After the rebalancing is\n     * done burn any potentially remaining OETHb tokens still on the strategy contract.\n     *\n     * This function has a slightly different behaviour depending on the status of the underlying Aerodrome\n     * slipstream pool. The function consists of the following 3 steps:\n     * 1. withdrawPartialLiquidity -> so that moving the activeTrading price via  a swap is cheaper\n     * 2. swapToDesiredPosition   -> move active trading price in the pool to be able to deposit WETH & OETHb\n     *                               tokens with the desired pre-configured shares\n     * 3. addLiquidity            -> add liquidity into the pool respecting share split configuration\n     *\n     * Scenario 1: When there is no liquidity in the pool from the strategy but there is from other LPs then\n     *             only step 1 is skipped. (It is important to note that liquidity needs to exist in the configured\n     *             strategy tick ranges in order for the swap to be possible) Step 3 mints new liquidity position\n     *             instead of adding to an existing one.\n     * Scenario 2: When there is strategy's liquidity in the pool all 3 steps are taken\n     *\n     *\n     * Exact _amountToSwap, _swapWeth & _minTokenReceived parameters shall be determined by simulating the\n     * transaction off-chain. The strategy checks that after the swap the share of the tokens is in the\n     * expected ranges.\n     *\n     * @param _amountToSwap The amount of the token to swap\n     * @param _swapWeth Swap using WETH when true, use OETHb when false\n     * @param _minTokenReceived Slippage check -> minimum amount of token expected in return\n     */\n    function rebalance(\n        uint256 _amountToSwap,\n        bool _swapWeth,\n        uint256 _minTokenReceived\n    ) external nonReentrant onlyGovernorOrStrategist {\n        _rebalance(_amountToSwap, _swapWeth, _minTokenReceived);\n    }\n\n    function _rebalance(\n        uint256 _amountToSwap,\n        bool _swapWeth,\n        uint256 _minTokenReceived\n    ) internal {\n        /**\n         * Would be nice to check if there is any total liquidity in the pool before performing this swap\n         * but there is no easy way to do that in UniswapV3:\n         * - clPool.liquidity() -> only liquidity in the active tick\n         * - asset[1&2].balanceOf(address(clPool)) -> will include uncollected tokens of LP providers\n         *   after their liquidity position has been decreased\n         */\n\n        /**\n         * When rebalance is called for the first time there is no strategy\n         * liquidity in the pool yet. The liquidity removal is thus skipped.\n         * Also execute this function when WETH is required for the swap.\n         */\n        if (tokenId != 0 && _swapWeth && _amountToSwap > 0) {\n            _ensureWETHBalance(_amountToSwap);\n        }\n\n        // in some cases we will just want to add liquidity and not issue a swap to move the\n        // active trading position within the pool\n        if (_amountToSwap > 0) {\n            _swapToDesiredPosition(_amountToSwap, _swapWeth, _minTokenReceived);\n        }\n        // calling check liquidity early so we don't get unexpected errors when adding liquidity\n        // in the later stages of this function\n        _checkForExpectedPoolPrice(true);\n\n        _addLiquidity();\n\n        // this call shouldn't be necessary, since adding liquidity shouldn't affect the active\n        // trading price. It is a defensive programming measure.\n        (, uint256 _wethSharePct) = _checkForExpectedPoolPrice(true);\n\n        // revert if protocol insolvent\n        _solvencyAssert();\n\n        emit PoolRebalanced(_wethSharePct);\n    }\n\n    /**\n     * Checks that the protocol is solvent, protecting from a rogue Strategist / Guardian that can\n     * keep rebalancing the pool in both directions making the protocol lose a tiny amount of\n     * funds each time.\n     *\n     * Protocol must be at least SOLVENCY_THRESHOLD (99,8 %) backed in order for the rebalances to\n     * function.\n     */\n    function _solvencyAssert() internal view {\n        uint256 _totalVaultValue = IVault(vaultAddress).totalValue();\n        uint256 _totalOethbSupply = IERC20(OETHb).totalSupply();\n\n        if (\n            _totalVaultValue.divPrecisely(_totalOethbSupply) <\n            SOLVENCY_THRESHOLD\n        ) {\n            revert(\"Protocol insolvent\");\n        }\n    }\n\n    /**\n     * @dev Decrease partial or all liquidity from the pool.\n     * @param _liquidityToDecrease The amount of liquidity to remove expressed in 18 decimal point\n     */\n    function _removeLiquidity(uint256 _liquidityToDecrease)\n        internal\n        gaugeUnstakeAndRestake\n    {\n        require(_liquidityToDecrease > 0, \"Must remove some liquidity\");\n\n        uint128 _liquidity = _getLiquidity();\n        // need to convert to uint256 since intermittent result is to big for uint128 to handle\n        uint128 _liquidityToRemove = uint256(_liquidity)\n            .mulTruncate(_liquidityToDecrease)\n            .toUint128();\n\n        /**\n         * There is no liquidity to remove -> exit function early. This can happen after a\n         * withdraw/withdrawAll removes all of the liquidity while retaining the NFT token.\n         */\n        if (_liquidity == 0 || _liquidityToRemove == 0) {\n            return;\n        }\n\n        (uint256 _amountWeth, uint256 _amountOethb) = positionManager\n            .decreaseLiquidity(\n                // Both expected amounts can be 0 since we don't really care if any swaps\n                // happen just before the liquidity removal.\n                INonfungiblePositionManager.DecreaseLiquidityParams({\n                    tokenId: tokenId,\n                    liquidity: _liquidityToRemove,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    deadline: block.timestamp\n                })\n            );\n\n        (\n            uint256 _amountWethCollected,\n            uint256 _amountOethbCollected\n        ) = positionManager.collect(\n                INonfungiblePositionManager.CollectParams({\n                    tokenId: tokenId,\n                    recipient: address(this),\n                    amount0Max: type(uint128).max, // defaults to all tokens owed\n                    amount1Max: type(uint128).max // defaults to all tokens owed\n                })\n            );\n\n        _updateUnderlyingAssets();\n\n        emit LiquidityRemoved(\n            _liquidityToDecrease,\n            _amountWeth, //removedWethAmount\n            _amountOethb, //removedOethbAmount\n            _amountWethCollected,\n            _amountOethbCollected,\n            underlyingAssets\n        );\n\n        _burnOethbOnTheContract();\n    }\n\n    /**\n     * @dev Perform a swap so that after the swap the ticker has the desired WETH to OETHb token share.\n     */\n    function _swapToDesiredPosition(\n        uint256 _amountToSwap,\n        bool _swapWeth,\n        uint256 _minTokenReceived\n    ) internal {\n        IERC20 _tokenToSwap = IERC20(_swapWeth ? WETH : OETHb);\n        uint256 _balance = _tokenToSwap.balanceOf(address(this));\n\n        if (_balance < _amountToSwap) {\n            // This should never trigger since _ensureWETHBalance will already\n            // throw an error if there is not enough WETH\n            if (_swapWeth) {\n                revert NotEnoughWethForSwap(_balance, _amountToSwap);\n            }\n            // if swapping OETHb\n            uint256 mintForSwap = _amountToSwap - _balance;\n            IVault(vaultAddress).mintForStrategy(mintForSwap);\n        }\n\n        // approve the specific amount of WETH required\n        if (_swapWeth) {\n            IERC20(WETH).approve(address(swapRouter), _amountToSwap);\n        }\n\n        // Swap it\n        swapRouter.exactInputSingle(\n            // sqrtPriceLimitX96 is just a rough sanity check that we are within 0 -> 1 tick\n            // a more fine check is performed in _checkForExpectedPoolPrice\n            // Note: this needs further work if we want to generalize this approach\n            ISwapRouter.ExactInputSingleParams({\n                tokenIn: address(_tokenToSwap),\n                tokenOut: _swapWeth ? OETHb : WETH,\n                tickSpacing: tickSpacing, // set to 1\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountIn: _amountToSwap,\n                amountOutMinimum: _minTokenReceived, // slippage check\n                sqrtPriceLimitX96: _swapWeth\n                    ? sqrtRatioX96TickLower\n                    : sqrtRatioX96TickHigher\n            })\n        );\n\n        /**\n         * In the interest of each function in _rebalance to leave the contract state as\n         * clean as possible the OETHb tokens here are burned. This decreases the\n         * dependence where `_swapToDesiredPosition` function relies on later functions\n         * (`addLiquidity`) to burn the OETHb. Reducing the risk of error introduction.\n         */\n        _burnOethbOnTheContract();\n    }\n\n    /**\n     * @dev Add liquidity into the pool in the pre-configured WETH to OETHb share ratios\n     * defined by the allowedPoolWethShareStart|End interval. This function will respect\n     * liquidity ratios when there is no liquidity yet in the pool. If liquidity is already\n     * present then it relies on the `_swapToDesiredPosition` function in a step before\n     * to already move the trading price to desired position (with some tolerance).\n     */\n    // rebalance already has re-entrency checks\n    // slither-disable-start reentrancy-no-eth\n    function _addLiquidity() internal gaugeUnstakeAndRestake {\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        uint256 _oethbBalance = IERC20(OETHb).balanceOf(address(this));\n        // don't deposit small liquidity amounts\n        if (_wethBalance <= 1e12) {\n            return;\n        }\n\n        uint160 _currentPrice = getPoolX96Price();\n        /**\n         * Sanity check active trading price is positioned within our desired tick.\n         *\n         * We revert when price is equal to the lower tick even though that is still\n         * a valid amount in regards to ticker position by Sugar.estimateAmount call.\n         * Current price equaling tick bound at the 1:1 price parity results in\n         * uint overfow when calculating the OETHb balance to deposit.\n         */\n        if (\n            _currentPrice <= sqrtRatioX96TickLower ||\n            _currentPrice >= sqrtRatioX96TickHigher\n        ) {\n            revert OutsideExpectedTickRange(getCurrentTradingTick());\n        }\n\n        /**\n         * If estimateAmount1 call fails it could be due to _currentPrice being really\n         * close to a tick and amount1 is a larger number than the sugar helper is able\n         * to compute.\n         *\n         * If token addresses were reversed estimateAmount0 would be required here\n         */\n        uint256 _oethbRequired = helper.estimateAmount1(\n            _wethBalance,\n            address(0), // no need to pass pool address when current price is specified\n            _currentPrice,\n            lowerTick,\n            upperTick\n        );\n\n        if (_oethbRequired > _oethbBalance) {\n            IVault(vaultAddress).mintForStrategy(\n                _oethbRequired - _oethbBalance\n            );\n        }\n\n        // approve the specific amount of WETH required\n        IERC20(WETH).approve(address(positionManager), _wethBalance);\n\n        uint256 _wethAmountSupplied;\n        uint256 _oethbAmountSupplied;\n        if (tokenId == 0) {\n            (\n                tokenId,\n                ,\n                _wethAmountSupplied,\n                _oethbAmountSupplied\n            ) = positionManager.mint(\n                /** amount0Min & amount1Min are left at 0 because slippage protection is ensured by the\n                 * _checkForExpectedPoolPrice\n                 *\n                 * Also sqrtPriceX96 is 0 because the pool is already created\n                 * non zero amount attempts to create a new instance of the pool\n                 */\n                INonfungiblePositionManager.MintParams({\n                    token0: WETH,\n                    token1: OETHb,\n                    tickSpacing: tickSpacing,\n                    tickLower: lowerTick,\n                    tickUpper: upperTick,\n                    amount0Desired: _wethBalance,\n                    amount1Desired: _oethbRequired,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    recipient: address(this),\n                    deadline: block.timestamp,\n                    sqrtPriceX96: 0\n                })\n            );\n        } else {\n            (, _wethAmountSupplied, _oethbAmountSupplied) = positionManager\n                .increaseLiquidity(\n                    /** amount0Min & amount1Min are left at 0 because slippage protection is ensured by the\n                     * _checkForExpectedPoolPrice\n                     */\n                    INonfungiblePositionManager.IncreaseLiquidityParams({\n                        tokenId: tokenId,\n                        amount0Desired: _wethBalance,\n                        amount1Desired: _oethbRequired,\n                        amount0Min: 0,\n                        amount1Min: 0,\n                        deadline: block.timestamp\n                    })\n                );\n        }\n\n        _updateUnderlyingAssets();\n        emit LiquidityAdded(\n            _wethBalance, // wethAmountDesired\n            _oethbRequired, // oethbAmountDesired\n            _wethAmountSupplied, // wethAmountSupplied\n            _oethbAmountSupplied, // oethbAmountSupplied\n            tokenId, // tokenId\n            underlyingAssets\n        );\n\n        // burn remaining OETHb\n        _burnOethbOnTheContract();\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /**\n     * @dev Check that the Aerodrome pool price is within the expected\n     *      parameters.\n     *      This function works whether the strategy contract has liquidity\n     *      position in the pool or not. The function returns _wethSharePct\n     *      as a gas optimization measure.\n     * @param throwException  when set to true the function throws an exception\n     *        when pool's price is not within expected range.\n     * @return _isExpectedRange  Bool expressing price is within expected range\n     * @return _wethSharePct  Share of WETH owned by this strategy contract in the\n     *         configured ticker.\n     */\n    function _checkForExpectedPoolPrice(bool throwException)\n        internal\n        view\n        returns (bool _isExpectedRange, uint256 _wethSharePct)\n    {\n        require(\n            allowedWethShareStart != 0 && allowedWethShareEnd != 0,\n            \"Weth share interval not set\"\n        );\n\n        uint160 _currentPrice = getPoolX96Price();\n\n        /**\n         * First check we are in expected tick range\n         *\n         * We revert even though price being equal to the lower tick would still\n         * count being within lower tick for the purpose of Sugar.estimateAmount calls\n         */\n        if (\n            _currentPrice <= sqrtRatioX96TickLower ||\n            _currentPrice >= sqrtRatioX96TickHigher\n        ) {\n            if (throwException) {\n                revert OutsideExpectedTickRange(getCurrentTradingTick());\n            }\n            return (false, 0);\n        }\n\n        // 18 decimal number expressed WETH tick share\n        _wethSharePct = _getWethShare(_currentPrice);\n\n        if (\n            _wethSharePct < allowedWethShareStart ||\n            _wethSharePct > allowedWethShareEnd\n        ) {\n            if (throwException) {\n                revert PoolRebalanceOutOfBounds(\n                    _wethSharePct,\n                    allowedWethShareStart,\n                    allowedWethShareEnd\n                );\n            }\n            return (false, _wethSharePct);\n        }\n\n        return (true, _wethSharePct);\n    }\n\n    /**\n     * Burns any OETHb tokens remaining on the strategy contract\n     */\n    function _burnOethbOnTheContract() internal {\n        uint256 _oethbBalance = IERC20(OETHb).balanceOf(address(this));\n        if (_oethbBalance > 1e12) {\n            IVault(vaultAddress).burnForStrategy(_oethbBalance);\n        }\n    }\n\n    /// @dev This function assumes there are no uncollected tokens in the clPool owned by the strategy contract.\n    ///      For that reason any liquidity withdrawals must also collect the tokens.\n    function _updateUnderlyingAssets() internal {\n        if (tokenId == 0) {\n            underlyingAssets = 0;\n            emit UnderlyingAssetsUpdated(underlyingAssets);\n            return;\n        }\n\n        uint128 _liquidity = _getLiquidity();\n\n        /**\n         * Our net value represent the smallest amount of tokens we are able to extract from the position\n         * given our liquidity.\n         *\n         * The least amount of tokens extraditable from the position is where the active trading price is\n         * at the ticker 0 meaning the pool is offering 1:1 trades between WETH & OETHb. At that moment the pool\n         * consists completely of OETHb and no WETH.\n         *\n         * The more swaps from WETH -> OETHb happen on the pool the more the price starts to move towards the -1\n         * ticker making OETHb (priced in WETH) more expensive.\n         *\n         * An additional note: when liquidity is 0 then the helper returns 0 for both token amounts. And the\n         * function set underlying assets to 0.\n         */\n        (uint256 _wethAmount, uint256 _oethbAmount) = helper\n            .getAmountsForLiquidity(\n                sqrtRatioX96TickClosestToParity, // sqrtRatioX96\n                sqrtRatioX96TickLower, // sqrtRatioAX96\n                sqrtRatioX96TickHigher, // sqrtRatioBX96\n                _liquidity\n            );\n\n        require(_wethAmount == 0, \"Non zero wethAmount\");\n        underlyingAssets = _oethbAmount;\n        emit UnderlyingAssetsUpdated(underlyingAssets);\n    }\n\n    /**\n     * @dev This function removes the appropriate amount of liquidity to assure that the required\n     * amount of WETH is available on the contract\n     *\n     * @param _amount  WETH balance required on the contract\n     */\n    function _ensureWETHBalance(uint256 _amount) internal {\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        if (_wethBalance >= _amount) {\n            return;\n        }\n\n        require(tokenId != 0, \"No liquidity available\");\n        uint256 _additionalWethRequired = _amount - _wethBalance;\n        (uint256 _wethInThePool, ) = getPositionPrincipal();\n\n        if (_wethInThePool < _additionalWethRequired) {\n            revert NotEnoughWethLiquidity(\n                _wethInThePool,\n                _additionalWethRequired\n            );\n        }\n\n        uint256 shareOfWethToRemove = Math.min(\n            _additionalWethRequired.divPrecisely(_wethInThePool) + 1,\n            1e18\n        );\n        _removeLiquidity(shareOfWethToRemove);\n    }\n\n    /**\n     * @notice Withdraw an `amount` of assets from the platform and\n     *         send to the `_recipient`.\n     * @param _recipient  Address to which the asset should be sent\n     * @param _asset      WETH address\n     * @param _amount     Amount of WETH to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_asset == WETH, \"Unsupported asset\");\n        require(_recipient == vaultAddress, \"Only withdraw to vault allowed\");\n\n        _ensureWETHBalance(_amount);\n\n        _withdraw(_recipient, _amount);\n    }\n\n    /**\n     * @notice Withdraw WETH and sends it to the Vault.\n     */\n    function withdrawAll() external override onlyVault nonReentrant {\n        if (tokenId != 0) {\n            _removeLiquidity(1e18);\n        }\n\n        uint256 _balance = IERC20(WETH).balanceOf(address(this));\n        if (_balance > 0) {\n            _withdraw(vaultAddress, _balance);\n        }\n    }\n\n    function _withdraw(address _recipient, uint256 _amount) internal {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient == vaultAddress, \"Only withdraw to vault allowed\");\n\n        IERC20(WETH).safeTransfer(_recipient, _amount);\n        emit Withdrawal(WETH, address(0), _amount);\n    }\n\n    /**\n     * @dev Collect the AERO token from the gauge\n     */\n    function _collectRewardTokens() internal override {\n        if (tokenId != 0 && _isLpTokenStakedInGauge()) {\n            clGauge.getReward(tokenId);\n        }\n        super._collectRewardTokens();\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == WETH;\n    }\n\n    /**\n     * @dev Approve the spending of all assets\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        // to add liquidity to the clPool\n        IERC20(OETHb).approve(address(positionManager), type(uint256).max);\n        // to be able to rebalance using the swapRouter\n        IERC20(OETHb).approve(address(swapRouter), type(uint256).max);\n\n        /* the behaviour of this strategy has slightly changed and WETH could be\n         * present on the contract between the transactions. For that reason we are\n         * un-approving WETH to the swapRouter & positionManager and only approving\n         * the required amount before a transaction\n         */\n        IERC20(WETH).approve(address(swapRouter), 0);\n        IERC20(WETH).approve(address(positionManager), 0);\n    }\n\n    /***************************************\n            Balances and Fees\n    ****************************************/\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(_asset == WETH, \"Only WETH supported\");\n\n        // we could in theory deposit to the strategy and forget to call rebalance in the same\n        // governance transaction batch. In that case the WETH that is on the strategy contract\n        // also needs to be accounted for.\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        // just paranoia check, in case there is OETHb in the strategy that for some reason hasn't\n        // been burned yet.\n        uint256 _oethbBalance = IERC20(OETHb).balanceOf(address(this));\n        return underlyingAssets + _wethBalance + _oethbBalance;\n    }\n\n    /**\n     * @dev Returns the balance of both tokens in a given position (excluding fees)\n     * @return _amountWeth Amount of WETH in position\n     * @return _amountOethb Amount of OETHb in position\n     */\n    function getPositionPrincipal()\n        public\n        view\n        returns (uint256 _amountWeth, uint256 _amountOethb)\n    {\n        if (tokenId == 0) {\n            return (0, 0);\n        }\n\n        uint160 _sqrtRatioX96 = getPoolX96Price();\n        (_amountWeth, _amountOethb) = helper.principal(\n            positionManager,\n            tokenId,\n            _sqrtRatioX96\n        );\n    }\n\n    /**\n     * @notice Returns the current pool price in X96 format\n     * @return _sqrtRatioX96 Pool price\n     */\n    function getPoolX96Price() public view returns (uint160 _sqrtRatioX96) {\n        (_sqrtRatioX96, , , , , ) = clPool.slot0();\n    }\n\n    /**\n     * @notice Returns the current active trading tick of the underlying pool\n     * @return _currentTick Current pool trading tick\n     */\n    function getCurrentTradingTick() public view returns (int24 _currentTick) {\n        (, _currentTick, , , , ) = clPool.slot0();\n    }\n\n    /**\n     * @notice Returns the percentage of WETH liquidity in the configured ticker\n     *         owned by this strategy contract.\n     * @return uint256 1e18 denominated percentage expressing the share\n     */\n    function getWETHShare() external view returns (uint256) {\n        uint160 _currentPrice = getPoolX96Price();\n        return _getWethShare(_currentPrice);\n    }\n\n    /**\n     * @notice Returns the amount of liquidity in the contract's LP position\n     * @return _liquidity Amount of liquidity in the position\n     */\n    function _getLiquidity() internal view returns (uint128 _liquidity) {\n        if (tokenId == 0) {\n            revert(\"No LP position\");\n        }\n\n        (, , , , , , , _liquidity, , , , ) = positionManager.positions(tokenId);\n    }\n\n    function _getWethShare(uint160 _currentPrice)\n        internal\n        view\n        returns (uint256)\n    {\n        /**\n         * If estimateAmount1 call fails it could be due to _currentPrice being really\n         * close to a tick and amount1 too big to compute.\n         *\n         * If token addresses were reversed estimateAmount0 would be required here\n         */\n        uint256 _normalizedWethAmount = 1 ether;\n        uint256 _correspondingOethAmount = helper.estimateAmount1(\n            _normalizedWethAmount,\n            address(0), // no need to pass pool address when current price is specified\n            _currentPrice,\n            lowerTick,\n            upperTick\n        );\n\n        // 18 decimal number expressed weth tick share\n        return\n            _normalizedWethAmount.divPrecisely(\n                _normalizedWethAmount + _correspondingOethAmount\n            );\n    }\n\n    /***************************************\n            Hidden functions\n    ****************************************/\n    /// @inheritdoc InitializableAbstractStrategy\n    function setPTokenAddress(address, address) external override {\n        // The pool tokens can never change.\n        revert(\"Unsupported method\");\n    }\n\n    /// @inheritdoc InitializableAbstractStrategy\n    function removePToken(uint256) external override {\n        // The pool tokens can never change.\n        revert(\"Unsupported method\");\n    }\n\n    /**\n     * @dev Not supported\n     */\n    function _abstractSetPToken(address, address) internal override {\n        // the deployer shall call safeApproveAllTokens() to set necessary approvals\n        revert(\"Unsupported method\");\n    }\n\n    /***************************************\n            ERC721 management\n    ****************************************/\n\n    /// @notice Callback function for whenever a NFT is transferred to this contract\n    //  solhint-disable-next-line max-line-length\n    /// Ref: https://docs.openzeppelin.com/contracts/3.x/api/token/erc721#IERC721Receiver-onERC721Received-address-address-uint256-bytes-\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/strategies/balancer/AbstractAuraStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OETH Base Balancer Abstract Strategy\n * @author Origin Protocol Inc\n */\n\nimport { AbstractBalancerStrategy } from \"./AbstractBalancerStrategy.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { IERC4626 } from \"../../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\nimport { IRewardStaking } from \"../IRewardStaking.sol\";\n\nabstract contract AbstractAuraStrategy is AbstractBalancerStrategy {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    /// @notice Address of the Aura rewards pool\n    address public immutable auraRewardPoolAddress;\n\n    // renamed from __reserved to not shadow AbstractBalancerStrategy.__reserved,\n    int256[50] private __reserved_baseAuraStrategy;\n\n    constructor(address _auraRewardPoolAddress) {\n        auraRewardPoolAddress = _auraRewardPoolAddress;\n    }\n\n    /**\n     * @dev Deposit all Balancer Pool Tokens (BPT) in this strategy contract\n     * to the Aura rewards pool.\n     */\n    function _lpDepositAll() internal virtual override {\n        uint256 bptBalance = IERC20(platformAddress).balanceOf(address(this));\n        uint256 auraLp = IERC4626(auraRewardPoolAddress).deposit(\n            bptBalance,\n            address(this)\n        );\n        require(bptBalance == auraLp, \"Aura LP != BPT\");\n    }\n\n    /**\n     * @dev Withdraw `numBPTTokens` Balancer Pool Tokens (BPT) from\n     * the Aura rewards pool to this strategy contract.\n     * @param numBPTTokens Number of Balancer Pool Tokens (BPT) to withdraw\n     */\n    function _lpWithdraw(uint256 numBPTTokens) internal virtual override {\n        IRewardStaking(auraRewardPoolAddress).withdrawAndUnwrap(\n            numBPTTokens,\n            true // also claim reward tokens\n        );\n    }\n\n    /**\n     * @dev Withdraw all Balancer Pool Tokens (BPT) from\n     * the Aura rewards pool to this strategy contract.\n     */\n    function _lpWithdrawAll() internal virtual override {\n        // Get all the strategy's BPTs in Aura\n        // maxRedeem is implemented as balanceOf(address) in Aura\n        uint256 bptBalance = IERC4626(auraRewardPoolAddress).maxRedeem(\n            address(this)\n        );\n\n        IRewardStaking(auraRewardPoolAddress).withdrawAndUnwrap(\n            bptBalance,\n            true // also claim reward tokens\n        );\n    }\n\n    /**\n     * @notice Collects BAL and AURA tokens from the rewards pool.\n     */\n    function collectRewardTokens()\n        external\n        virtual\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        /* Similar to Convex, calling this function collects both of the\n         * accrued BAL and AURA tokens.\n         */\n        IRewardStaking(auraRewardPoolAddress).getReward();\n        _collectRewardTokens();\n    }\n\n    /// @notice Balancer Pool Tokens (BPT) in the Balancer pool and the Aura rewards pool.\n    function _getBalancerPoolTokens()\n        internal\n        view\n        override\n        returns (uint256 balancerPoolTokens)\n    {\n        balancerPoolTokens =\n            IERC20(platformAddress).balanceOf(address(this)) +\n            // maxRedeem is implemented as balanceOf(address) in Aura\n            IERC4626(auraRewardPoolAddress).maxRedeem(address(this));\n    }\n\n    function _approveBase() internal virtual override {\n        super._approveBase();\n\n        IERC20 pToken = IERC20(platformAddress);\n        pToken.safeApprove(auraRewardPoolAddress, type(uint256).max);\n    }\n}\n"
    },
    "contracts/strategies/balancer/AbstractBalancerStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OETH Balancer Abstract Strategy\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { IBalancerVault } from \"../../interfaces/balancer/IBalancerVault.sol\";\nimport { IRateProvider } from \"../../interfaces/balancer/IRateProvider.sol\";\nimport { VaultReentrancyLib } from \"./VaultReentrancyLib.sol\";\nimport { IOracle } from \"../../interfaces/IOracle.sol\";\nimport { IWstETH } from \"../../interfaces/IWstETH.sol\";\nimport { IERC4626 } from \"../../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\n\nabstract contract AbstractBalancerStrategy is InitializableAbstractStrategy {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    address public immutable rETH;\n    address public immutable stETH;\n    address public immutable wstETH;\n    address public immutable frxETH;\n    address public immutable sfrxETH;\n\n    /// @notice Address of the Balancer vault\n    IBalancerVault public immutable balancerVault;\n    /// @notice Balancer pool identifier\n    bytes32 public immutable balancerPoolId;\n\n    // Max withdrawal deviation denominated in 1e18 (1e18 == 100%)\n    uint256 public maxWithdrawalDeviation;\n    // Max deposit deviation denominated in 1e18 (1e18 == 100%)\n    uint256 public maxDepositDeviation;\n\n    int256[48] private __reserved;\n\n    struct BaseBalancerConfig {\n        address rEthAddress; // Address of the rETH token\n        address stEthAddress; // Address of the stETH token\n        address wstEthAddress; // Address of the wstETH token\n        address frxEthAddress; // Address of the frxEth token\n        address sfrxEthAddress; // Address of the sfrxEth token\n        address balancerVaultAddress; // Address of the Balancer vault\n        bytes32 balancerPoolId; // Balancer pool identifier\n    }\n\n    event MaxWithdrawalDeviationUpdated(\n        uint256 _prevMaxDeviationPercentage,\n        uint256 _newMaxDeviationPercentage\n    );\n    event MaxDepositDeviationUpdated(\n        uint256 _prevMaxDeviationPercentage,\n        uint256 _newMaxDeviationPercentage\n    );\n\n    /**\n     * @dev Ensure we are not in a Vault context when this function is called, by attempting a no-op internal\n     * balance operation. If we are already in a Vault transaction (e.g., a swap, join, or exit), the Vault's\n     * reentrancy protection will cause this function to revert.\n     *\n     * Use this modifier with any function that can cause a state change in a pool and is either public itself,\n     * or called by a public function *outside* a Vault operation (e.g., join, exit, or swap).\n     *\n     * This is to protect against Balancer's read-only re-entrancy vulnerability:\n     * https://www.notion.so/originprotocol/Balancer-read-only-reentrancy-c686e72c82414ef18fa34312bb02e11b\n     */\n    modifier whenNotInBalancerVaultContext() {\n        VaultReentrancyLib.ensureNotInVaultContext(balancerVault);\n        _;\n    }\n\n    constructor(BaseBalancerConfig memory _balancerConfig) {\n        rETH = _balancerConfig.rEthAddress;\n        stETH = _balancerConfig.stEthAddress;\n        wstETH = _balancerConfig.wstEthAddress;\n        frxETH = _balancerConfig.frxEthAddress;\n        sfrxETH = _balancerConfig.sfrxEthAddress;\n\n        balancerVault = IBalancerVault(_balancerConfig.balancerVaultAddress);\n        balancerPoolId = _balancerConfig.balancerPoolId;\n    }\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Balancer's strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Address of BAL & AURA\n     * @param _assets Addresses of supported assets. MUST be passed in the same\n     *                order as returned by coins on the pool contract, i.e.\n     *                WETH, stETH\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // BAL & AURA\n        address[] calldata _assets,\n        address[] calldata _pTokens\n    ) external onlyGovernor initializer {\n        maxWithdrawalDeviation = 1e16;\n        maxDepositDeviation = 1e16;\n\n        emit MaxWithdrawalDeviationUpdated(0, maxWithdrawalDeviation);\n        emit MaxDepositDeviationUpdated(0, maxDepositDeviation);\n\n        IERC20[] memory poolAssets = _getPoolAssets();\n        require(\n            poolAssets.length == _assets.length,\n            \"Pool assets length mismatch\"\n        );\n        for (uint256 i = 0; i < _assets.length; ++i) {\n            address asset = _fromPoolAsset(address(poolAssets[i]));\n            require(_assets[i] == asset, \"Pool assets mismatch\");\n        }\n\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n        _approveBase();\n    }\n\n    /**\n     * @notice Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @notice Get strategy's share of an assets in the Balancer pool.\n     * This is not denominated in OUSD/ETH value of the assets in the Balancer pool.\n     * @param _asset  Address of the Vault collateral asset\n     * @return amount  the amount of vault collateral assets\n     *\n     * IMPORTANT if this function is overridden it needs to have a whenNotInBalancerVaultContext\n     * modifier on it or it is susceptible to read-only re-entrancy attack\n     *\n     * @dev it is important that this function is not affected by reporting inflated\n     * values of assets in case of any pool manipulation. Such a manipulation could easily\n     * exploit the protocol by:\n     *  - minting OETH\n     *  - tilting Balancer pool to report higher balances of assets\n     *  - rebasing() -> all that extra token balances get distributed to OETH holders\n     *  - tilting pool back\n     *  - redeeming OETH\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        virtual\n        override\n        whenNotInBalancerVaultContext\n        returns (uint256 amount)\n    {\n        require(assetToPToken[_asset] != address(0), \"Unsupported asset\");\n\n        uint256 bptBalance = _getBalancerPoolTokens();\n\n        /* To calculate the worth of queried asset:\n         *  - assume that all tokens normalized to their ETH value have an equal split balance\n         *    in the pool when it is balanced\n         *  - multiply the BPT amount with the bpt rate to get the ETH denominated amount\n         *    of strategy's holdings\n         *  - divide that by the number of tokens we support in the pool to get ETH denominated\n         *    amount that is applicable to each supported token in the pool.\n         *\n         *    It would be possible to support only 1 asset in the pool (and be exposed to all\n         *    the assets while holding BPT tokens) and deposit/withdraw/checkBalance using only\n         *    that asset. TBD: changes to other functions still required if we ever decide to\n         *    go with such configuration.\n         */\n        amount = (bptBalance.mulTruncate(\n            IRateProvider(platformAddress).getRate()\n        ) / assetsMapped.length);\n\n        /* If the pool asset is equal to (strategy )_asset it means that a rate\n         * provider for that asset exists and that asset is not necessarily\n         * pegged to a unit (ETH).\n         *\n         * Because this function returns the balance of the asset and is not denominated in\n         * ETH units we need to convert the ETH denominated amount to asset amount.\n         */\n        if (_toPoolAsset(_asset) == _asset) {\n            amount = amount.divPrecisely(_getRateProviderRate(_asset));\n        }\n    }\n\n    /**\n     * @notice Returns the value of all assets managed by this strategy.\n     * Uses the Balancer pool's rate (virtual price) to convert the strategy's\n     * Balancer Pool Tokens (BPT) to ETH value.\n     * @return value The ETH value\n     *\n     * IMPORTANT if this function is overridden it needs to have a whenNotInBalancerVaultContext\n     * modifier on it or it is susceptible to read-only re-entrancy attack\n     */\n    function checkBalance()\n        external\n        view\n        virtual\n        whenNotInBalancerVaultContext\n        returns (uint256 value)\n    {\n        uint256 bptBalance = _getBalancerPoolTokens();\n\n        // Convert BPT to ETH value\n        value = bptBalance.mulTruncate(\n            IRateProvider(platformAddress).getRate()\n        );\n    }\n\n    /// @notice Balancer Pool Tokens (BPT) in the Balancer pool.\n    function _getBalancerPoolTokens()\n        internal\n        view\n        virtual\n        returns (uint256 balancerPoolTokens)\n    {\n        balancerPoolTokens = IERC20(platformAddress).balanceOf(address(this));\n    }\n\n    /* solhint-disable max-line-length */\n    /**\n     * @notice BPT price is calculated by taking the rate from the rateProvider of the asset in\n     * question. If one does not exist it defaults to 1e18. To get the final BPT expected that\n     * is multiplied by the underlying asset amount divided by BPT token rate. BPT token rate is\n     * similar to Curve's virtual_price and expresses how much has the price of BPT appreciated\n     * (e.g. due to swap fees) in relation to the underlying assets\n     *\n     * Using the above approach makes the strategy vulnerable to a possible MEV attack using\n     * flash loan to manipulate the pool before a deposit/withdrawal since the function ignores\n     * market values of the assets being priced in BPT.\n     *\n     * At the time of writing there is no safe on-chain approach to pricing BPT in a way that it\n     * would make it invulnerable to MEV pool manipulation. See recent Balancer exploit:\n     * https://www.notion.so/originprotocol/Balancer-OETH-strategy-9becdea132704e588782a919d7d471eb?pvs=4#1cf07de12fc64f1888072321e0644348\n     *\n     * To mitigate MEV possibilities during deposits and withdraws, the VaultValueChecker will use checkBalance before and after the move\n     * to ensure the expected changes took place.\n     *\n     * @param _asset Address of the Balancer pool asset\n     * @param _amount Amount of the Balancer pool asset\n     * @return bptExpected of BPT expected in exchange for the asset\n     *\n     * @dev\n     * bptAssetPrice = 1e18 (asset peg) * pool_asset_rate\n     *\n     * bptExpected = bptAssetPrice * asset_amount / BPT_token_rate\n     *\n     * bptExpected = 1e18 (asset peg) * pool_asset_rate * asset_amount / BPT_token_rate\n     * bptExpected = asset_amount * pool_asset_rate / BPT_token_rate\n     *\n     * further information available here:\n     * https://www.notion.so/originprotocol/Balancer-OETH-strategy-9becdea132704e588782a919d7d471eb?pvs=4#ce01495ae70346d8971f5dced809fb83\n     */\n    /* solhint-enable max-line-length */\n    function _getBPTExpected(address _asset, uint256 _amount)\n        internal\n        view\n        virtual\n        returns (uint256 bptExpected)\n    {\n        uint256 bptRate = IRateProvider(platformAddress).getRate();\n        uint256 poolAssetRate = _getRateProviderRate(_asset);\n        bptExpected = _amount.mulTruncate(poolAssetRate).divPrecisely(bptRate);\n    }\n\n    function _getBPTExpected(\n        address[] memory _assets,\n        uint256[] memory _amounts\n    ) internal view virtual returns (uint256 bptExpected) {\n        require(_assets.length == _amounts.length, \"Assets & amounts mismatch\");\n\n        for (uint256 i = 0; i < _assets.length; ++i) {\n            uint256 poolAssetRate = _getRateProviderRate(_assets[i]);\n            // convert asset amount to ETH amount\n            bptExpected += _amounts[i].mulTruncate(poolAssetRate);\n        }\n\n        uint256 bptRate = IRateProvider(platformAddress).getRate();\n        // Convert ETH amount to BPT amount\n        bptExpected = bptExpected.divPrecisely(bptRate);\n    }\n\n    function _lpDepositAll() internal virtual;\n\n    function _lpWithdraw(uint256 numBPTTokens) internal virtual;\n\n    function _lpWithdrawAll() internal virtual;\n\n    /**\n     * @notice Balancer returns assets and rateProviders for corresponding assets ordered\n     * by numerical order.\n     */\n    function _getPoolAssets() internal view returns (IERC20[] memory assets) {\n        // slither-disable-next-line unused-return\n        (assets, , ) = balancerVault.getPoolTokens(balancerPoolId);\n    }\n\n    /**\n     * @dev If an asset is rebasing the Balancer pools have a wrapped versions of assets\n     * that the strategy supports. This function converts the pool(wrapped) asset\n     * and corresponding amount to strategy asset.\n     */\n    function _toPoolAsset(address asset, uint256 amount)\n        internal\n        view\n        returns (address poolAsset, uint256 poolAmount)\n    {\n        if (asset == stETH) {\n            poolAsset = wstETH;\n            if (amount > 0) {\n                poolAmount = IWstETH(wstETH).getWstETHByStETH(amount);\n            }\n        } else if (asset == frxETH) {\n            poolAsset = sfrxETH;\n            if (amount > 0) {\n                poolAmount = IERC4626(sfrxETH).convertToShares(amount);\n            }\n        } else {\n            poolAsset = asset;\n            poolAmount = amount;\n        }\n    }\n\n    /**\n     * @dev Converts a Vault collateral asset to a Balancer pool asset.\n     * stETH becomes wstETH, frxETH becomes sfrxETH and everything else stays the same.\n     * @param asset Address of the Vault collateral asset.\n     * @return Address of the Balancer pool asset.\n     */\n    function _toPoolAsset(address asset) internal view returns (address) {\n        if (asset == stETH) {\n            return wstETH;\n        } else if (asset == frxETH) {\n            return sfrxETH;\n        }\n        return asset;\n    }\n\n    /**\n     * @dev Converts rebasing asset to its wrapped counterpart.\n     */\n    function _wrapPoolAsset(address asset, uint256 amount)\n        internal\n        returns (address wrappedAsset, uint256 wrappedAmount)\n    {\n        if (asset == stETH) {\n            wrappedAsset = wstETH;\n            if (amount > 0) {\n                wrappedAmount = IWstETH(wstETH).wrap(amount);\n            }\n        } else if (asset == frxETH) {\n            wrappedAsset = sfrxETH;\n            if (amount > 0) {\n                wrappedAmount = IERC4626(sfrxETH).deposit(\n                    amount,\n                    address(this)\n                );\n            }\n        } else {\n            wrappedAsset = asset;\n            wrappedAmount = amount;\n        }\n    }\n\n    /**\n     * @dev Converts wrapped asset to its rebasing counterpart.\n     */\n    function _unwrapPoolAsset(address asset, uint256 amount)\n        internal\n        returns (uint256 unwrappedAmount)\n    {\n        if (asset == stETH) {\n            unwrappedAmount = IWstETH(wstETH).unwrap(amount);\n        } else if (asset == frxETH) {\n            unwrappedAmount = IERC4626(sfrxETH).withdraw(\n                amount,\n                address(this),\n                address(this)\n            );\n        } else {\n            unwrappedAmount = amount;\n        }\n    }\n\n    /**\n     * @dev If an asset is rebasing the Balancer pools have a wrapped versions of assets\n     * that the strategy supports. This function converts the rebasing strategy asset\n     * and corresponding amount to wrapped(pool) asset.\n     */\n    function _fromPoolAsset(address poolAsset, uint256 poolAmount)\n        internal\n        view\n        returns (address asset, uint256 amount)\n    {\n        if (poolAsset == wstETH) {\n            asset = stETH;\n            if (poolAmount > 0) {\n                amount = IWstETH(wstETH).getStETHByWstETH(poolAmount);\n            }\n        } else if (poolAsset == sfrxETH) {\n            asset = frxETH;\n            if (poolAmount > 0) {\n                amount = IERC4626(sfrxETH).convertToAssets(poolAmount);\n            }\n        } else {\n            asset = poolAsset;\n            amount = poolAmount;\n        }\n    }\n\n    function _fromPoolAsset(address poolAsset)\n        internal\n        view\n        returns (address asset)\n    {\n        if (poolAsset == wstETH) {\n            asset = stETH;\n        } else if (poolAsset == sfrxETH) {\n            asset = frxETH;\n        } else {\n            asset = poolAsset;\n        }\n    }\n\n    /**\n     * @notice Sets max withdrawal deviation that is considered when removing\n     * liquidity from Balancer pools.\n     * @param _maxWithdrawalDeviation Max withdrawal deviation denominated in\n     *        wad (number with 18 decimals): 1e18 == 100%, 1e16 == 1%\n     *\n     * IMPORTANT Minimum maxWithdrawalDeviation will be 1% (1e16) for production\n     * usage. Vault value checker in combination with checkBalance will\n     * catch any unexpected manipulation.\n     */\n    function setMaxWithdrawalDeviation(uint256 _maxWithdrawalDeviation)\n        external\n        onlyVaultOrGovernorOrStrategist\n    {\n        require(\n            _maxWithdrawalDeviation <= 1e18,\n            \"Withdrawal dev. out of bounds\"\n        );\n        emit MaxWithdrawalDeviationUpdated(\n            maxWithdrawalDeviation,\n            _maxWithdrawalDeviation\n        );\n        maxWithdrawalDeviation = _maxWithdrawalDeviation;\n    }\n\n    /**\n     * @notice Sets max deposit deviation that is considered when adding\n     * liquidity to Balancer pools.\n     * @param _maxDepositDeviation Max deposit deviation denominated in\n     *        wad (number with 18 decimals): 1e18 == 100%, 1e16 == 1%\n     *\n     * IMPORTANT Minimum maxDepositDeviation will default to 1% (1e16)\n     * for production usage. Vault value checker in combination with\n     * checkBalance will catch any unexpected manipulation.\n     */\n    function setMaxDepositDeviation(uint256 _maxDepositDeviation)\n        external\n        onlyVaultOrGovernorOrStrategist\n    {\n        require(_maxDepositDeviation <= 1e18, \"Deposit dev. out of bounds\");\n        emit MaxDepositDeviationUpdated(\n            maxDepositDeviation,\n            _maxDepositDeviation\n        );\n        maxDepositDeviation = _maxDepositDeviation;\n    }\n\n    function _approveBase() internal virtual {\n        IERC20 pToken = IERC20(platformAddress);\n        // Balancer vault for BPT token (required for removing liquidity)\n        pToken.safeApprove(address(balancerVault), type(uint256).max);\n    }\n\n    function _getRateProviderRate(address _asset)\n        internal\n        view\n        virtual\n        returns (uint256);\n}\n"
    },
    "contracts/strategies/balancer/BalancerMetaPoolStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OETH Balancer MetaStablePool Strategy\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { AbstractAuraStrategy, AbstractBalancerStrategy } from \"./AbstractAuraStrategy.sol\";\nimport { IBalancerVault } from \"../../interfaces/balancer/IBalancerVault.sol\";\nimport { IRateProvider } from \"../../interfaces/balancer/IRateProvider.sol\";\nimport { IMetaStablePool } from \"../../interfaces/balancer/IMetaStablePool.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\n\ncontract BalancerMetaPoolStrategy is AbstractAuraStrategy {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    constructor(\n        BaseStrategyConfig memory _stratConfig,\n        BaseBalancerConfig memory _balancerConfig,\n        address _auraRewardPoolAddress\n    )\n        InitializableAbstractStrategy(_stratConfig)\n        AbstractBalancerStrategy(_balancerConfig)\n        AbstractAuraStrategy(_auraRewardPoolAddress)\n    {}\n\n    /**\n     * @notice There are no plans to configure BalancerMetaPool as a default\n     * asset strategy. For that reason there is no need to support this\n     * functionality.\n     */\n    function deposit(address, uint256)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        revert(\"Not supported\");\n    }\n\n    /**\n     * @notice There are no plans to configure BalancerMetaPool as a default\n     * asset strategy. For that reason there is no need to support this\n     * functionality.\n     */\n    function deposit(address[] calldata, uint256[] calldata)\n        external\n        onlyVault\n        nonReentrant\n    {\n        revert(\"Not supported\");\n    }\n\n    /**\n     * @notice Deposits all supported assets in this strategy contract to the Balancer pool.\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 assetsLength = assetsMapped.length;\n        address[] memory strategyAssets = new address[](assetsLength);\n        uint256[] memory strategyAmounts = new uint256[](assetsLength);\n\n        // For each vault collateral asset\n        for (uint256 i = 0; i < assetsLength; ++i) {\n            strategyAssets[i] = assetsMapped[i];\n            // Get the asset balance in this strategy contract\n            strategyAmounts[i] = IERC20(strategyAssets[i]).balanceOf(\n                address(this)\n            );\n        }\n        _deposit(strategyAssets, strategyAmounts);\n    }\n\n    /*\n     * _deposit doesn't require a read-only re-entrancy protection since during the deposit\n     * the function enters the Balancer Vault Context. If this function were called as part of\n     * the attacking contract (while intercepting execution flow upon receiving ETH) the read-only\n     * protection of the Balancer Vault would be triggered. Since the attacking contract would\n     * already be in the Balancer Vault context and wouldn't be able to enter it again.\n     */\n    function _deposit(\n        address[] memory _strategyAssets,\n        uint256[] memory _strategyAmounts\n    ) internal {\n        require(\n            _strategyAssets.length == _strategyAmounts.length,\n            \"Array length missmatch\"\n        );\n\n        (IERC20[] memory tokens, , ) = balancerVault.getPoolTokens(\n            balancerPoolId\n        );\n\n        uint256[] memory strategyAssetAmountsToPoolAssetAmounts = new uint256[](\n            _strategyAssets.length\n        );\n        address[] memory strategyAssetsToPoolAssets = new address[](\n            _strategyAssets.length\n        );\n\n        for (uint256 i = 0; i < _strategyAssets.length; ++i) {\n            address strategyAsset = _strategyAssets[i];\n            uint256 strategyAmount = _strategyAmounts[i];\n\n            require(\n                assetToPToken[strategyAsset] != address(0),\n                \"Unsupported asset\"\n            );\n            strategyAssetsToPoolAssets[i] = _toPoolAsset(strategyAsset);\n\n            if (strategyAmount > 0) {\n                emit Deposit(strategyAsset, platformAddress, strategyAmount);\n\n                // wrap rebasing assets like stETH and frxETH to wstETH and sfrxETH\n                (, strategyAssetAmountsToPoolAssetAmounts[i]) = _wrapPoolAsset(\n                    strategyAsset,\n                    strategyAmount\n                );\n            }\n        }\n\n        uint256[] memory amountsIn = new uint256[](tokens.length);\n        address[] memory poolAssets = new address[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            // Convert IERC20 type to address\n            poolAssets[i] = address(tokens[i]);\n\n            // For each of the mapped assets\n            for (uint256 j = 0; j < strategyAssetsToPoolAssets.length; ++j) {\n                // If the pool asset is the same as the mapped asset\n                if (poolAssets[i] == strategyAssetsToPoolAssets[j]) {\n                    amountsIn[i] = strategyAssetAmountsToPoolAssetAmounts[j];\n                }\n            }\n        }\n\n        uint256 minBPT = _getBPTExpected(\n            strategyAssetsToPoolAssets,\n            strategyAssetAmountsToPoolAssetAmounts\n        );\n        uint256 minBPTwDeviation = minBPT.mulTruncate(\n            1e18 - maxDepositDeviation\n        );\n\n        /* EXACT_TOKENS_IN_FOR_BPT_OUT:\n         * User sends precise quantities of tokens, and receives an\n         * estimated but unknown (computed at run time) quantity of BPT.\n         *\n         * ['uint256', 'uint256[]', 'uint256']\n         * [EXACT_TOKENS_IN_FOR_BPT_OUT, amountsIn, minimumBPT]\n         */\n        bytes memory userData = abi.encode(\n            IBalancerVault.WeightedPoolJoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n            amountsIn,\n            minBPTwDeviation\n        );\n\n        IBalancerVault.JoinPoolRequest memory request = IBalancerVault\n            .JoinPoolRequest(poolAssets, amountsIn, userData, false);\n\n        // Add the pool assets in this strategy to the balancer pool\n        balancerVault.joinPool(\n            balancerPoolId,\n            address(this),\n            address(this),\n            request\n        );\n\n        // Deposit the Balancer Pool Tokens (BPT) into Aura\n        _lpDepositAll();\n    }\n\n    /**\n     * @notice Withdraw a Vault collateral asset from the Balancer pool.\n     * @param _recipient Address to receive the Vault collateral assets. Typically is the Vault.\n     * @param _strategyAsset Address of the Vault collateral asset\n     * @param _strategyAmount The amount of Vault collateral assets to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _strategyAsset,\n        uint256 _strategyAmount\n    ) external override onlyVault nonReentrant {\n        address[] memory strategyAssets = new address[](1);\n        uint256[] memory strategyAmounts = new uint256[](1);\n        strategyAssets[0] = _strategyAsset;\n        strategyAmounts[0] = _strategyAmount;\n\n        _withdraw(_recipient, strategyAssets, strategyAmounts);\n    }\n\n    /**\n     * @notice Withdraw multiple Vault collateral asset from the Balancer pool.\n     * @param _recipient Address to receive the Vault collateral assets. Typically is the Vault.\n     * @param _strategyAssets Addresses of the Vault collateral assets\n     * @param _strategyAmounts The amounts of Vault collateral assets to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address[] calldata _strategyAssets,\n        uint256[] calldata _strategyAmounts\n    ) external onlyVault nonReentrant {\n        _withdraw(_recipient, _strategyAssets, _strategyAmounts);\n    }\n\n    /**\n     * @dev Withdraw multiple Vault collateral asset from the Balancer pool.\n     * @param _recipient Address to receive the Vault collateral assets. Typically is the Vault.\n     * @param _strategyAssets Addresses of the Vault collateral assets\n     * @param _strategyAmounts The amounts of Vault collateral assets to withdraw\n     *\n     * _withdrawal doesn't require a read-only re-entrancy protection since during the withdrawal\n     * the function enters the Balancer Vault Context. If this function were called as part of\n     * the attacking contract (while intercepting execution flow upon receiving ETH) the read-only\n     * protection of the Balancer Vault would be triggered. Since the attacking contract would\n     * already be in the Balancer Vault context and wouldn't be able to enter it again.\n     */\n    function _withdraw(\n        address _recipient,\n        address[] memory _strategyAssets,\n        uint256[] memory _strategyAmounts\n    ) internal {\n        require(\n            _strategyAssets.length == _strategyAmounts.length,\n            \"Invalid input arrays\"\n        );\n\n        for (uint256 i = 0; i < _strategyAssets.length; ++i) {\n            require(\n                assetToPToken[_strategyAssets[i]] != address(0),\n                \"Unsupported asset\"\n            );\n        }\n\n        // STEP 1 - Calculate the Balancer pool assets and amounts from the vault collateral assets\n\n        // Get all the supported balancer pool assets\n        (IERC20[] memory tokens, , ) = balancerVault.getPoolTokens(\n            balancerPoolId\n        );\n        // Calculate the balancer pool assets and amounts to withdraw\n        uint256[] memory poolAssetsAmountsOut = new uint256[](tokens.length);\n        address[] memory poolAssets = new address[](tokens.length);\n        // Is the wrapped asset amount indexed by the assets array, not the order of the Balancer pool tokens\n        // eg wstETH and sfrxETH amounts, not the stETH and frxETH amounts\n        uint256[] memory strategyAssetsToPoolAssetsAmounts = new uint256[](\n            _strategyAssets.length\n        );\n\n        // For each of the Balancer pool assets\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            poolAssets[i] = address(tokens[i]);\n\n            // Convert the Balancer pool asset back to a vault collateral asset\n            address strategyAsset = _fromPoolAsset(poolAssets[i]);\n\n            // for each of the vault assets\n            for (uint256 j = 0; j < _strategyAssets.length; ++j) {\n                // If the vault asset equals the vault asset mapped from the Balancer pool asset\n                if (_strategyAssets[j] == strategyAsset) {\n                    (, poolAssetsAmountsOut[i]) = _toPoolAsset(\n                        strategyAsset,\n                        _strategyAmounts[j]\n                    );\n                    strategyAssetsToPoolAssetsAmounts[j] = poolAssetsAmountsOut[\n                        i\n                    ];\n\n                    /* Because of the potential Balancer rounding error mentioned below\n                     * the contract might receive 1-2 WEI smaller amount than required\n                     * in the withdraw user data encoding. If slightly lesser token amount\n                     * is received the strategy can not unwrap the pool asset as it is\n                     * smaller than expected.\n                     *\n                     * For that reason we `overshoot` the required tokens expected to\n                     * circumvent the error\n                     */\n                    if (poolAssetsAmountsOut[i] > 0) {\n                        poolAssetsAmountsOut[i] += 2;\n                    }\n                }\n            }\n        }\n\n        // STEP 2 - Calculate the max about of Balancer Pool Tokens (BPT) to withdraw\n\n        // Estimate the required amount of Balancer Pool Tokens (BPT) for the assets\n        uint256 maxBPTtoWithdraw = _getBPTExpected(\n            poolAssets,\n            /* all non 0 values are overshot by 2 WEI and with the expected mainnet\n             * ~1% withdrawal deviation, the 2 WEI aren't important\n             */\n            poolAssetsAmountsOut\n        );\n        // Increase BPTs by the max allowed deviation\n        // Any excess BPTs will be left in this strategy contract\n        maxBPTtoWithdraw = maxBPTtoWithdraw.mulTruncate(\n            1e18 + maxWithdrawalDeviation\n        );\n\n        // STEP 3  - Withdraw the Balancer Pool Tokens (BPT) from Aura to this strategy contract\n\n        // Withdraw BPT from Aura allowing for BPTs left in this strategy contract from previous withdrawals\n        _lpWithdraw(\n            maxBPTtoWithdraw - IERC20(platformAddress).balanceOf(address(this))\n        );\n\n        // STEP 4 - Withdraw the balancer pool assets from the pool\n\n        /* Custom asset exit: BPT_IN_FOR_EXACT_TOKENS_OUT:\n         * User sends an estimated but unknown (computed at run time) quantity of BPT,\n         * and receives precise quantities of specified tokens.\n         *\n         * ['uint256', 'uint256[]', 'uint256']\n         * [BPT_IN_FOR_EXACT_TOKENS_OUT, amountsOut, maxBPTAmountIn]\n         */\n        bytes memory userData = abi.encode(\n            IBalancerVault.WeightedPoolExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT,\n            poolAssetsAmountsOut,\n            maxBPTtoWithdraw\n        );\n\n        IBalancerVault.ExitPoolRequest memory request = IBalancerVault\n            .ExitPoolRequest(\n                poolAssets,\n                /* We specify the exact amount of a tokens we are expecting in the encoded\n                 * userData, for that reason we don't need to specify the amountsOut here.\n                 *\n                 * Also Balancer has a rounding issue that can make a transaction fail:\n                 * https://github.com/balancer/balancer-v2-monorepo/issues/2541\n                 * which is an extra reason why this field is empty.\n                 */\n                new uint256[](tokens.length),\n                userData,\n                false\n            );\n\n        balancerVault.exitPool(\n            balancerPoolId,\n            address(this),\n            /* Payable keyword is required because of the IBalancerVault interface even though\n             * this strategy shall never be receiving native ETH\n             */\n            payable(address(this)),\n            request\n        );\n\n        // STEP 5 - Re-deposit any left over BPT tokens back into Aura\n        /* When concluding how much of BPT we need to withdraw from Aura we overshoot by\n         * roughly around 1% (initial mainnet setting of maxWithdrawalDeviation). After exiting\n         * the pool strategy could have left over BPT tokens that are not earning boosted yield.\n         * We re-deploy those back in.\n         */\n        _lpDepositAll();\n\n        // STEP 6 - Unswap balancer pool assets to vault collateral assets and send to the vault.\n\n        // For each of the specified assets\n        for (uint256 i = 0; i < _strategyAssets.length; ++i) {\n            // Unwrap assets like wstETH and sfrxETH to rebasing assets stETH and frxETH\n            if (strategyAssetsToPoolAssetsAmounts[i] > 0) {\n                _unwrapPoolAsset(\n                    _strategyAssets[i],\n                    strategyAssetsToPoolAssetsAmounts[i]\n                );\n            }\n\n            // Transfer the vault collateral assets to the recipient, which is typically the vault\n            if (_strategyAmounts[i] > 0) {\n                IERC20(_strategyAssets[i]).safeTransfer(\n                    _recipient,\n                    _strategyAmounts[i]\n                );\n\n                emit Withdrawal(\n                    _strategyAssets[i],\n                    platformAddress,\n                    _strategyAmounts[i]\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraws all supported Vault collateral assets from the Balancer pool\n     * and send to the OToken's Vault.\n     *\n     * Is only executable by the OToken's Vault or the Governor.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        // STEP 1 - Withdraw all Balancer Pool Tokens (BPT) from Aura to this strategy contract\n\n        _lpWithdrawAll();\n        // Get the BPTs withdrawn from Aura plus any that were already in this strategy contract\n        uint256 BPTtoWithdraw = IERC20(platformAddress).balanceOf(\n            address(this)\n        );\n        // Get the balancer pool assets and their total balances\n        (IERC20[] memory tokens, , ) = balancerVault.getPoolTokens(\n            balancerPoolId\n        );\n        uint256[] memory minAmountsOut = new uint256[](tokens.length);\n        address[] memory poolAssets = new address[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            poolAssets[i] = address(tokens[i]);\n        }\n\n        // STEP 2 - Withdraw the Balancer pool assets from the pool\n        /* Proportional exit: EXACT_BPT_IN_FOR_TOKENS_OUT:\n         * User sends a precise quantity of BPT, and receives an estimated but unknown\n         * (computed at run time) quantity of a single token\n         *\n         * ['uint256', 'uint256']\n         * [EXACT_BPT_IN_FOR_TOKENS_OUT, bptAmountIn]\n         *\n         * It is ok to pass an empty minAmountsOut since tilting the pool in any direction\n         * when doing a proportional exit can only be beneficial to the strategy. Since\n         * it will receive more of the underlying tokens for the BPT traded in.\n         */\n        bytes memory userData = abi.encode(\n            IBalancerVault.WeightedPoolExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT,\n            BPTtoWithdraw\n        );\n\n        IBalancerVault.ExitPoolRequest memory request = IBalancerVault\n            .ExitPoolRequest(poolAssets, minAmountsOut, userData, false);\n\n        balancerVault.exitPool(\n            balancerPoolId,\n            address(this),\n            /* Payable keyword is required because of the IBalancerVault interface even though\n             * this strategy shall never be receiving native ETH\n             */\n            payable(address(this)),\n            request\n        );\n\n        // STEP 3 - Convert the balancer pool assets to the vault collateral assets and send to the vault\n        // For each of the Balancer pool assets\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            address poolAsset = address(tokens[i]);\n            // Convert the balancer pool asset to the strategy asset\n            address strategyAsset = _fromPoolAsset(poolAsset);\n            // Get the balancer pool assets withdraw from the pool plus any that were already in this strategy contract\n            uint256 poolAssetAmount = IERC20(poolAsset).balanceOf(\n                address(this)\n            );\n\n            // Unwrap assets like wstETH and sfrxETH to rebasing assets stETH and frxETH\n            uint256 unwrappedAmount = 0;\n            if (poolAssetAmount > 0) {\n                unwrappedAmount = _unwrapPoolAsset(\n                    strategyAsset,\n                    poolAssetAmount\n                );\n            }\n\n            // Transfer the vault collateral assets to the vault\n            if (unwrappedAmount > 0) {\n                IERC20(strategyAsset).safeTransfer(\n                    vaultAddress,\n                    unwrappedAmount\n                );\n                emit Withdrawal(\n                    strategyAsset,\n                    platformAddress,\n                    unwrappedAmount\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Approves the Balancer Vault to transfer poolAsset counterparts\n     * of all of the supported assets from this strategy. E.g. stETH is a supported\n     * strategy and Balancer Vault gets unlimited approval to transfer wstETH.\n     *\n     * If Balancer pool uses a wrapped version of a supported asset then also approve\n     * unlimited usage of an asset to the contract responsible for wrapping.\n     *\n     * Approve unlimited spending by Balancer Vault and Aura reward pool of the\n     * pool BPT tokens.\n     *\n     * Is only executable by the Governor.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            _abstractSetPToken(assetsMapped[i], platformAddress);\n        }\n        _approveBase();\n    }\n\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address) internal override {\n        address poolAsset = _toPoolAsset(_asset);\n        if (_asset == stETH) {\n            // slither-disable-next-line unused-return\n            IERC20(stETH).approve(wstETH, type(uint256).max);\n        } else if (_asset == frxETH) {\n            // slither-disable-next-line unused-return\n            IERC20(frxETH).approve(sfrxETH, type(uint256).max);\n        }\n        _approveAsset(poolAsset);\n    }\n\n    /**\n     * @dev Approves the Balancer Vault to transfer an asset from\n     * this strategy. The assets could be a Vault collateral asset\n     * like WETH or rETH; or a Balancer pool asset that wraps the vault asset\n     * like wstETH or sfrxETH.\n     */\n    function _approveAsset(address _asset) internal {\n        IERC20 asset = IERC20(_asset);\n        // slither-disable-next-line unused-return\n        asset.approve(address(balancerVault), type(uint256).max);\n    }\n\n    /**\n     * @notice Returns the rate supplied by the Balancer configured rate\n     * provider. Rate is used to normalize the token to common underlying\n     * pool denominator. (ETH for ETH Liquid staking derivatives)\n     *\n     * @param _asset Address of the Balancer pool asset\n     * @return rate of the corresponding asset\n     */\n    function _getRateProviderRate(address _asset)\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        IMetaStablePool pool = IMetaStablePool(platformAddress);\n        IRateProvider[] memory providers = pool.getRateProviders();\n        (IERC20[] memory tokens, , ) = balancerVault.getPoolTokens(\n            balancerPoolId\n        );\n\n        uint256 providersLength = providers.length;\n        for (uint256 i = 0; i < providersLength; ++i) {\n            // _assets and corresponding rate providers are all in the same order\n            if (address(tokens[i]) == _asset) {\n                // rate provider doesn't exist, defaults to 1e18\n                if (address(providers[i]) == address(0)) {\n                    return 1e18;\n                }\n                return providers[i].getRate();\n            }\n        }\n\n        // should never happen\n        assert(false);\n    }\n}\n"
    },
    "contracts/strategies/balancer/VaultReentrancyLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../../utils/BalancerErrors.sol\";\nimport { IBalancerVault } from \"../../interfaces/balancer/IBalancerVault.sol\";\n\nlibrary VaultReentrancyLib {\n    /**\n     * @dev Ensure we are not in a Vault context when this function is called, by attempting a no-op internal\n     * balance operation. If we are already in a Vault transaction (e.g., a swap, join, or exit), the Vault's\n     * reentrancy protection will cause this function to revert.\n     *\n     * The exact function call doesn't really matter: we're just trying to trigger the Vault reentrancy check\n     * (and not hurt anything in case it works). An empty operation array with no specific operation at all works\n     * for that purpose, and is also the least expensive in terms of gas and bytecode size.\n     *\n     * Call this at the top of any function that can cause a state change in a pool and is either public itself,\n     * or called by a public function *outside* a Vault operation (e.g., join, exit, or swap).\n     *\n     * If this is *not* called in functions that are vulnerable to the read-only reentrancy issue described\n     * here (https://forum.balancer.fi/t/reentrancy-vulnerability-scope-expanded/4345), those functions are unsafe,\n     * and subject to manipulation that may result in loss of funds.\n     */\n    function ensureNotInVaultContext(IBalancerVault vault) internal view {\n        // Perform the following operation to trigger the Vault's reentrancy guard:\n        //\n        // IBalancerVault.UserBalanceOp[] memory noop = new IBalancerVault.UserBalanceOp[](0);\n        // _vault.manageUserBalance(noop);\n        //\n        // However, use a static call so that it can be a view function (even though the function is non-view).\n        // This allows the library to be used more widely, as some functions that need to be protected might be\n        // view.\n        //\n        // This staticcall always reverts, but we need to make sure it doesn't fail due to a re-entrancy attack.\n        // Staticcalls consume all gas forwarded to them on a revert caused by storage modification.\n        // By default, almost the entire available gas is forwarded to the staticcall,\n        // causing the entire call to revert with an 'out of gas' error.\n        //\n        // We set the gas limit to 10k for the staticcall to\n        // avoid wasting gas when it reverts due to storage modification.\n        // `manageUserBalance` is a non-reentrant function in the Vault, so calling it invokes `_enterNonReentrant`\n        // in the `ReentrancyGuard` contract, reproduced here:\n        //\n        //    function _enterNonReentrant() private {\n        //        // If the Vault is actually being reentered, it will revert in the first line, at the `_require` that\n        //        // checks the reentrancy flag, with \"BAL#400\" (corresponding to Errors.REENTRANCY) in the revertData.\n        //        // The full revertData will be: `abi.encodeWithSignature(\"Error(string)\", \"BAL#400\")`.\n        //        _require(_status != _ENTERED, Errors.REENTRANCY);\n        //\n        //        // If the Vault is not being reentered, the check above will pass: but it will *still* revert,\n        //        // because the next line attempts to modify storage during a staticcall. However, this type of\n        //        // failure results in empty revertData.\n        //        _status = _ENTERED;\n        //    }\n        //\n        // So based on this analysis, there are only two possible revertData values: empty, or abi.encoded BAL#400.\n        //\n        // It is of course much more bytecode and gas efficient to check for zero-length revertData than to compare it\n        // to the encoded REENTRANCY revertData.\n        //\n        // While it should be impossible for the call to fail in any other way (especially since it reverts before\n        // `manageUserBalance` even gets called), any other error would generate non-zero revertData, so checking for\n        // empty data guards against this case too.\n\n        (, bytes memory revertData) = address(vault).staticcall{ gas: 10_000 }(\n            abi.encodeWithSelector(vault.manageUserBalance.selector, 0)\n        );\n\n        _require(revertData.length == 0, Errors.REENTRANCY);\n    }\n}\n"
    },
    "contracts/strategies/BaseCurveAMOStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Curve Automated Market Maker (AMO) Strategy\n * @notice AMO strategy for the Curve OETH/WETH pool\n * @author Origin Protocol Inc\n */\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { ICurveStableSwapNG } from \"../interfaces/ICurveStableSwapNG.sol\";\nimport { ICurveXChainLiquidityGauge } from \"../interfaces/ICurveXChainLiquidityGauge.sol\";\nimport { IChildLiquidityGaugeFactory } from \"../interfaces/IChildLiquidityGaugeFactory.sol\";\n\ncontract BaseCurveAMOStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n    using SafeCast for uint256;\n\n    /**\n     * @dev a threshold under which the contract no longer allows for the protocol to manually rebalance.\n     *      Guarding against a strategist / guardian being taken over and with multiple transactions\n     *      draining the protocol funds.\n     */\n    uint256 public constant SOLVENCY_THRESHOLD = 0.998 ether;\n\n    // New immutable variables that must be set in the constructor\n    /**\n     * @notice Address of the Wrapped ETH (WETH) contract.\n     */\n    IWETH9 public immutable weth;\n\n    /**\n     * @notice Address of the OETH token contract.\n     */\n    IERC20 public immutable oeth;\n\n    /**\n     * @notice Address of the LP (Liquidity Provider) token contract.\n     */\n    IERC20 public immutable lpToken;\n\n    /**\n     * @notice Address of the Curve StableSwap NG pool contract.\n     */\n    ICurveStableSwapNG public immutable curvePool;\n\n    /**\n     * @notice Address of the Curve X-Chain Liquidity Gauge contract.\n     */\n    ICurveXChainLiquidityGauge public immutable gauge;\n\n    /**\n     * @notice Address of the Child Liquidity Gauge Factory contract.\n     */\n    IChildLiquidityGaugeFactory public immutable gaugeFactory;\n\n    // Ordered list of pool assets\n    uint128 public immutable oethCoinIndex;\n    uint128 public immutable wethCoinIndex;\n\n    /**\n     * @notice Maximum slippage allowed for adding/removing liquidity from the Curve pool.\n     */\n    uint256 public maxSlippage;\n\n    event MaxSlippageUpdated(uint256 newMaxSlippage);\n\n    /**\n     * @dev Verifies that the caller is the Strategist.\n     */\n    modifier onlyStrategist() {\n        require(\n            msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Strategist\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Checks the Curve pool's balances have improved and the balances\n     * have not tipped to the other side.\n     * This modifier is only applied to functions that do a single sided add or remove.\n     * The standard deposit function adds to both sides of the pool in a way that\n     * the pool's balance is not worsened.\n     * Withdrawals are proportional so doesn't change the pools asset balance.\n     */\n    modifier improvePoolBalance() {\n        // Get the asset and OToken balances in the Curve pool\n        uint256[] memory balancesBefore = curvePool.get_balances();\n        // diff = ETH balance - OETH balance\n        int256 diffBefore = balancesBefore[wethCoinIndex].toInt256() -\n            balancesBefore[oethCoinIndex].toInt256();\n\n        _;\n\n        // Get the asset and OToken balances in the Curve pool\n        uint256[] memory balancesAfter = curvePool.get_balances();\n        // diff = ETH balance - OETH balance\n        int256 diffAfter = balancesAfter[wethCoinIndex].toInt256() -\n            balancesAfter[oethCoinIndex].toInt256();\n\n        if (diffBefore == 0) {\n            require(diffAfter == 0, \"Position balance is worsened\");\n        } else if (diffBefore < 0) {\n            // If the pool was originally imbalanced in favor of OETH, then\n            // we want to check that the pool is now more balanced\n            require(diffAfter <= 0, \"OTokens overshot peg\");\n            require(diffBefore < diffAfter, \"OTokens balance worse\");\n        } else if (diffBefore > 0) {\n            // If the pool was originally imbalanced in favor of ETH, then\n            // we want to check that the pool is now more balanced\n            require(diffAfter >= 0, \"Assets overshot peg\");\n            require(diffAfter < diffBefore, \"Assets balance worse\");\n        }\n    }\n\n    constructor(\n        BaseStrategyConfig memory _baseConfig,\n        address _oeth,\n        address _weth,\n        address _gauge,\n        address _gaugeFactory,\n        uint128 _oethCoinIndex,\n        uint128 _wethCoinIndex\n    ) InitializableAbstractStrategy(_baseConfig) {\n        oethCoinIndex = _oethCoinIndex;\n        wethCoinIndex = _wethCoinIndex;\n\n        lpToken = IERC20(_baseConfig.platformAddress);\n        curvePool = ICurveStableSwapNG(_baseConfig.platformAddress);\n\n        oeth = IERC20(_oeth);\n        weth = IWETH9(_weth);\n        gauge = ICurveXChainLiquidityGauge(_gauge);\n        gaugeFactory = IChildLiquidityGaugeFactory(_gaugeFactory);\n\n        _setGovernor(address(0));\n    }\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Curve strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Address of CRV\n     * @param _maxSlippage Maximum slippage allowed for adding/removing liquidity from the Curve pool.\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // CRV\n        uint256 _maxSlippage\n    ) external onlyGovernor initializer {\n        address[] memory pTokens = new address[](1);\n        pTokens[0] = address(curvePool);\n\n        address[] memory _assets = new address[](1);\n        _assets[0] = address(weth);\n\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            pTokens\n        );\n\n        _approveBase();\n        _setMaxSlippage(_maxSlippage);\n    }\n\n    /***************************************\n                    Deposit\n    ****************************************/\n\n    /**\n     * @notice Deposit WETH into the Curve pool\n     * @param _weth Address of Wrapped ETH (WETH) contract.\n     * @param _amount Amount of WETH to deposit.\n     */\n    function deposit(address _weth, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_weth, _amount);\n    }\n\n    function _deposit(address _weth, uint256 _wethAmount) internal {\n        require(_wethAmount > 0, \"Must deposit something\");\n        require(_weth == address(weth), \"Can only deposit WETH\");\n\n        emit Deposit(_weth, address(lpToken), _wethAmount);\n\n        // Get the asset and OToken balances in the Curve pool\n        uint256[] memory balances = curvePool.get_balances();\n        // safe to cast since min value is at least 0\n        uint256 oethToAdd = uint256(\n            _max(\n                0,\n                balances[wethCoinIndex].toInt256() +\n                    _wethAmount.toInt256() -\n                    balances[oethCoinIndex].toInt256()\n            )\n        );\n\n        /* Add so much OETH so that the pool ends up being balanced. And at minimum\n         * add as much OETH as WETH and at maximum twice as much OETH.\n         */\n        oethToAdd = Math.max(oethToAdd, _wethAmount);\n        oethToAdd = Math.min(oethToAdd, _wethAmount * 2);\n\n        /* Mint OETH with a strategy that attempts to contribute to stability of OETH/WETH pool. Try\n         * to mint so much OETH that after deployment of liquidity pool ends up being balanced.\n         *\n         * To manage unpredictability minimal OETH minted will always be at least equal or greater\n         * to WETH amount deployed. And never larger than twice the WETH amount deployed even if\n         * it would have a further beneficial effect on pool stability.\n         */\n        IVault(vaultAddress).mintForStrategy(oethToAdd);\n\n        emit Deposit(address(oeth), address(lpToken), oethToAdd);\n\n        uint256[] memory _amounts = new uint256[](2);\n        _amounts[wethCoinIndex] = _wethAmount;\n        _amounts[oethCoinIndex] = oethToAdd;\n\n        uint256 valueInLpTokens = (_wethAmount + oethToAdd).divPrecisely(\n            curvePool.get_virtual_price()\n        );\n        uint256 minMintAmount = valueInLpTokens.mulTruncate(\n            uint256(1e18) - maxSlippage\n        );\n\n        // Do the deposit to the Curve pool\n        uint256 lpDeposited = curvePool.add_liquidity(_amounts, minMintAmount);\n        require(lpDeposited >= minMintAmount, \"Min LP amount error\");\n\n        // Deposit the Curve pool's LP tokens into the Curve gauge\n        gauge.deposit(lpDeposited);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n    }\n\n    /**\n     * @notice Deposit the strategy's entire balance of WETH into the Curve pool\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 balance = weth.balanceOf(address(this));\n        if (balance > 0) {\n            _deposit(address(weth), balance);\n        }\n    }\n\n    /***************************************\n                    Withdraw\n    ****************************************/\n\n    /**\n     * @notice Withdraw ETH and OETH from the Curve pool, burn the OETH,\n     * convert the ETH to WETH and transfer to the recipient.\n     * @param _recipient Address to receive withdrawn asset which is normally the Vault.\n     * @param _weth Address of the Wrapped ETH (WETH) contract.\n     * @param _amount Amount of WETH to withdraw.\n     */\n    function withdraw(\n        address _recipient,\n        address _weth,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_weth == address(weth), \"Can only withdraw WETH\");\n\n        emit Withdrawal(_weth, address(lpToken), _amount);\n\n        uint256 requiredLpTokens = calcTokenToBurn(_amount);\n\n        _lpWithdraw(requiredLpTokens);\n\n        /* math in requiredLpTokens should correctly calculate the amount of LP to remove\n         * in that the strategy receives enough WETH on balanced removal\n         */\n        uint256[] memory _minWithdrawalAmounts = new uint256[](2);\n        _minWithdrawalAmounts[wethCoinIndex] = _amount;\n        // slither-disable-next-line unused-return\n        curvePool.remove_liquidity(requiredLpTokens, _minWithdrawalAmounts);\n\n        // Burn all the removed OETH and any that was left in the strategy\n        uint256 oethToBurn = oeth.balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(oethToBurn);\n\n        emit Withdrawal(address(oeth), address(lpToken), oethToBurn);\n\n        // Transfer WETH to the recipient\n        require(\n            weth.transfer(_recipient, _amount),\n            \"Transfer of WETH not successful\"\n        );\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n    }\n\n    function calcTokenToBurn(uint256 _wethAmount)\n        internal\n        view\n        returns (uint256 lpToBurn)\n    {\n        /* The rate between coins in the pool determines the rate at which pool returns\n         * tokens when doing balanced removal (remove_liquidity call). And by knowing how much WETH\n         * we want we can determine how much of OETH we receive by removing liquidity.\n         *\n         * Because we are doing balanced removal we should be making profit when removing liquidity in a\n         * pool tilted to either side.\n         *\n         * Important: A downside is that the Strategist / Governor needs to be\n         * cognisant of not removing too much liquidity. And while the proposal to remove liquidity\n         * is being voted on the pool tilt might change so much that the proposal that has been valid while\n         * created is no longer valid.\n         */\n\n        uint256 poolWETHBalance = curvePool.balances(wethCoinIndex);\n        /* K is multiplied by 1e36 which is used for higher precision calculation of required\n         * pool LP tokens. Without it the end value can have rounding errors up to precision of\n         * 10 digits. This way we move the decimal point by 36 places when doing the calculation\n         * and again by 36 places when we are done with it.\n         */\n        uint256 k = (1e36 * lpToken.totalSupply()) / poolWETHBalance;\n        // prettier-ignore\n        // slither-disable-next-line divide-before-multiply\n        uint256 diff = (_wethAmount + 1) * k;\n        lpToBurn = diff / 1e36;\n    }\n\n    /**\n     * @notice Remove all ETH and OETH from the Curve pool, burn the OETH,\n     * convert the ETH to WETH and transfer to the Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        uint256 gaugeTokens = gauge.balanceOf(address(this));\n        // Can not withdraw zero LP tokens from the gauge\n        if (gaugeTokens == 0) return;\n        _lpWithdraw(gaugeTokens);\n\n        // Withdraws are proportional to assets held by 3Pool\n        uint256[] memory minWithdrawAmounts = new uint256[](2);\n\n        // Remove liquidity\n        // slither-disable-next-line unused-return\n        curvePool.remove_liquidity(\n            lpToken.balanceOf(address(this)),\n            minWithdrawAmounts\n        );\n\n        // Burn all OETH\n        uint256 oethToBurn = oeth.balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(oethToBurn);\n\n        // Get the strategy contract's WETH balance.\n        // This includes all that was removed from the Curve pool and\n        // any ether that was sitting in the strategy contract before the removal.\n        uint256 ethBalance = weth.balanceOf(address(this));\n        require(\n            weth.transfer(vaultAddress, ethBalance),\n            \"Transfer of WETH not successful\"\n        );\n\n        emit Withdrawal(address(weth), address(lpToken), ethBalance);\n        emit Withdrawal(address(oeth), address(lpToken), oethToBurn);\n    }\n\n    /***************************************\n            Curve pool Rebalancing\n    ****************************************/\n\n    /**\n     * @notice Mint OTokens and one-sided add to the Curve pool.\n     * This is used when the Curve pool does not have enough OTokens and too many ETH.\n     * The OToken/Asset, eg OETH/ETH, price with increase.\n     * The amount of assets in the vault is unchanged.\n     * The total supply of OTokens is increased.\n     * The asset value of the strategy and vault is increased.\n     * @param _oTokens The amount of OTokens to be minted and added to the pool.\n     */\n    function mintAndAddOTokens(uint256 _oTokens)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n    {\n        IVault(vaultAddress).mintForStrategy(_oTokens);\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[oethCoinIndex] = _oTokens;\n\n        // Convert OETH to Curve pool LP tokens\n        uint256 valueInLpTokens = (_oTokens).divPrecisely(\n            curvePool.get_virtual_price()\n        );\n        // Apply slippage to LP tokens\n        uint256 minMintAmount = valueInLpTokens.mulTruncate(\n            uint256(1e18) - maxSlippage\n        );\n\n        // Add the minted OTokens to the Curve pool\n        uint256 lpDeposited = curvePool.add_liquidity(amounts, minMintAmount);\n        require(lpDeposited >= minMintAmount, \"Min LP amount error\");\n\n        // Deposit the Curve pool LP tokens to the Curve gauge\n        gauge.deposit(lpDeposited);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n\n        emit Deposit(address(oeth), address(lpToken), _oTokens);\n    }\n\n    /**\n     * @notice One-sided remove of OTokens from the Curve pool which are then burned.\n     * This is used when the Curve pool has too many OTokens and not enough ETH.\n     * The amount of assets in the vault is unchanged.\n     * The total supply of OTokens is reduced.\n     * The asset value of the strategy and vault is reduced.\n     * @param _lpTokens The amount of Curve pool LP tokens to be burned for OTokens.\n     */\n    function removeAndBurnOTokens(uint256 _lpTokens)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n    {\n        // Withdraw Curve pool LP tokens from Convex and remove OTokens from the Curve pool\n        uint256 oethToBurn = _withdrawAndRemoveFromPool(\n            _lpTokens,\n            oethCoinIndex\n        );\n\n        // The vault burns the OTokens from this strategy\n        IVault(vaultAddress).burnForStrategy(oethToBurn);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n\n        emit Withdrawal(address(oeth), address(lpToken), oethToBurn);\n    }\n\n    /**\n     * @notice One-sided remove of ETH from the Curve pool, convert to WETH\n     * and transfer to the vault.\n     * This is used when the Curve pool does not have enough OTokens and too many ETH.\n     * The OToken/Asset, eg OETH/ETH, price with decrease.\n     * The amount of assets in the vault increases.\n     * The total supply of OTokens does not change.\n     * The asset value of the strategy reduces.\n     * The asset value of the vault should be close to the same.\n     * @param _lpTokens The amount of Curve pool LP tokens to be burned for ETH.\n     * @dev Curve pool LP tokens is used rather than WETH assets as Curve does not\n     * have a way to accurately calculate the amount of LP tokens for a required\n     * amount of ETH. Curve's `calc_token_amount` functioun does not include fees.\n     * A 3rd party libary can be used that takes into account the fees, but this\n     * is a gas intensive process. It's easier for the trusted strategist to\n     * caclulate the amount of Curve pool LP tokens required off-chain.\n     */\n    function removeOnlyAssets(uint256 _lpTokens)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n    {\n        // Withdraw Curve pool LP tokens from Curve gauge and remove ETH from the Curve pool\n        uint256 ethAmount = _withdrawAndRemoveFromPool(\n            _lpTokens,\n            wethCoinIndex\n        );\n\n        // Transfer WETH to the vault\n        require(\n            weth.transfer(vaultAddress, ethAmount),\n            \"Transfer of WETH not successful\"\n        );\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n\n        emit Withdrawal(address(weth), address(lpToken), ethAmount);\n    }\n\n    /**\n     * @dev Remove Curve pool LP tokens from the Convex pool and\n     * do a one-sided remove of ETH or OETH from the Curve pool.\n     * @param _lpTokens The amount of Curve pool LP tokens to be removed from the Convex pool.\n     * @param coinIndex The index of the coin to be removed from the Curve pool. 0 = ETH, 1 = OETH.\n     * @return coinsRemoved The amount of ETH or OETH removed from the Curve pool.\n     */\n    function _withdrawAndRemoveFromPool(uint256 _lpTokens, uint128 coinIndex)\n        internal\n        returns (uint256 coinsRemoved)\n    {\n        // Withdraw Curve pool LP tokens from Curve gauge\n        _lpWithdraw(_lpTokens);\n\n        // Convert Curve pool LP tokens to ETH value\n        uint256 valueInEth = _lpTokens.mulTruncate(\n            curvePool.get_virtual_price()\n        );\n        // Apply slippage to ETH value\n        uint256 minAmount = valueInEth.mulTruncate(uint256(1e18) - maxSlippage);\n\n        // Remove just the ETH from the Curve pool\n        coinsRemoved = curvePool.remove_liquidity_one_coin(\n            _lpTokens,\n            int128(coinIndex),\n            minAmount,\n            address(this)\n        );\n    }\n\n    /**\n     * Checks that the protocol is solvent, protecting from a rogue Strategist / Guardian that can\n     * keep rebalancing the pool in both directions making the protocol lose a tiny amount of\n     * funds each time.\n     *\n     * Protocol must be at least SOLVENCY_THRESHOLD (99,8 %) backed in order for the rebalances to\n     * function.\n     */\n    function _solvencyAssert() internal view {\n        uint256 _totalVaultValue = IVault(vaultAddress).totalValue();\n        uint256 _totalOethbSupply = oeth.totalSupply();\n\n        if (\n            _totalVaultValue.divPrecisely(_totalOethbSupply) <\n            SOLVENCY_THRESHOLD\n        ) {\n            revert(\"Protocol insolvent\");\n        }\n    }\n\n    /***************************************\n                Assets and Rewards\n    ****************************************/\n\n    /**\n     * @notice Collect accumulated CRV (and other) rewards and send to the Harvester.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // CRV rewards flow.\n        //---\n        // CRV inflation:\n        // Gauge receive CRV rewards from inflation.\n        // Each checkpoint on the gauge send this CRV inflation to gauge factory.\n        // This strategy should call mint on the gauge factory to collect the CRV rewards.\n        // ---\n        // Extra rewards:\n        // Calling claim_rewards on the gauge will only claim extra rewards (outside of CRV).\n        // ---\n\n        // Mint CRV on Child Liquidity gauge factory\n        gaugeFactory.mint(address(gauge));\n        // Collect extra gauge rewards (outside of CRV)\n        gauge.claim_rewards();\n\n        _collectRewardTokens();\n    }\n\n    function _lpWithdraw(uint256 _lpAmount) internal {\n        // withdraw lp tokens from the gauge without claiming rewards\n        gauge.withdraw(_lpAmount);\n    }\n\n    /**\n     * @notice Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == address(weth), \"Unsupported asset\");\n\n        // WETH balance needed here for the balance check that happens from vault during depositing.\n        balance = weth.balanceOf(address(this));\n        uint256 lpTokens = gauge.balanceOf(address(this));\n        if (lpTokens > 0) {\n            balance += (lpTokens * curvePool.get_virtual_price()) / 1e18;\n        }\n    }\n\n    /**\n     * @notice Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == address(weth);\n    }\n\n    /***************************************\n                    Approvals\n    ****************************************/\n\n    /**\n     * @notice Sets the maximum slippage allowed for any swap/liquidity operation\n     * @param _maxSlippage Maximum slippage allowed, 1e18 = 100%.\n     */\n    function setMaxSlippage(uint256 _maxSlippage) external onlyGovernor {\n        _setMaxSlippage(_maxSlippage);\n    }\n\n    function _setMaxSlippage(uint256 _maxSlippage) internal {\n        require(_maxSlippage <= 5e16, \"Slippage must be less than 100%\");\n        maxSlippage = _maxSlippage;\n        emit MaxSlippageUpdated(_maxSlippage);\n    }\n\n    /**\n     * @notice Approve the spending of all assets by their corresponding pool tokens,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        _approveBase();\n    }\n\n    /**\n     * @dev Since we are unwrapping WETH before depositing it to Curve\n     *      there is no need to set an approval for WETH on the Curve\n     *      pool\n     * @param _asset Address of the asset\n     * @param _pToken Address of the Curve LP token\n     */\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        override\n    {}\n\n    function _approveBase() internal {\n        // Approve Curve pool for OETH (required for adding liquidity)\n        // slither-disable-next-line unused-return\n        oeth.approve(platformAddress, type(uint256).max);\n\n        // Approve Curve pool for WETH (required for adding liquidity)\n        // slither-disable-next-line unused-return\n        weth.approve(platformAddress, type(uint256).max);\n\n        // Approve Curve gauge contract to transfer Curve pool LP tokens\n        // This is needed for deposits if Curve pool LP tokens into the Curve gauge.\n        // slither-disable-next-line unused-return\n        lpToken.approve(address(gauge), type(uint256).max);\n    }\n\n    /**\n     * @dev Returns the largest of two numbers int256 version\n     */\n    function _max(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n}\n"
    },
    "contracts/strategies/BridgedWOETHStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20, SafeERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { AggregatorV3Interface } from \"../interfaces/chainlink/AggregatorV3Interface.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\n\ncontract BridgedWOETHStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n    using StableMath for uint128;\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n\n    event MaxPriceDiffBpsUpdated(uint128 oldValue, uint128 newValue);\n    event WOETHPriceUpdated(uint128 oldValue, uint128 newValue);\n\n    IWETH9 public immutable weth;\n    IERC20 public immutable bridgedWOETH;\n    IERC20 public immutable oethb;\n    IOracle public immutable oracle;\n\n    uint128 public lastOraclePrice;\n    uint128 public maxPriceDiffBps;\n\n    constructor(\n        BaseStrategyConfig memory _stratConfig,\n        address _weth,\n        address _bridgedWOETH,\n        address _oethb,\n        address _oracle\n    ) InitializableAbstractStrategy(_stratConfig) {\n        weth = IWETH9(_weth);\n        bridgedWOETH = IERC20(_bridgedWOETH);\n        oethb = IERC20(_oethb);\n        oracle = IOracle(_oracle);\n    }\n\n    function initialize(uint128 _maxPriceDiffBps)\n        external\n        onlyGovernor\n        initializer\n    {\n        InitializableAbstractStrategy._initialize(\n            new address[](0), // No reward tokens\n            new address[](0), // No assets\n            new address[](0) // No pTokens\n        );\n\n        _setMaxPriceDiffBps(_maxPriceDiffBps);\n    }\n\n    /**\n     * @dev Sets the max price diff bps for the wOETH value appreciation\n     * @param _maxPriceDiffBps Bps value, 10k == 100%\n     */\n    function setMaxPriceDiffBps(uint128 _maxPriceDiffBps)\n        external\n        onlyGovernor\n    {\n        _setMaxPriceDiffBps(_maxPriceDiffBps);\n    }\n\n    /**\n     * @dev Sets the max price diff bps for the wOETH value appreciation\n     * @param _maxPriceDiffBps Bps value, 10k == 100%\n     */\n    function _setMaxPriceDiffBps(uint128 _maxPriceDiffBps) internal {\n        require(\n            _maxPriceDiffBps > 0 && _maxPriceDiffBps <= 10000,\n            \"Invalid bps value\"\n        );\n\n        emit MaxPriceDiffBpsUpdated(maxPriceDiffBps, _maxPriceDiffBps);\n\n        maxPriceDiffBps = _maxPriceDiffBps;\n    }\n\n    /**\n     * @dev Wrapper for _updateWOETHOraclePrice with nonReentrant flag\n     * @return The latest price of wOETH from Oracle\n     */\n    function updateWOETHOraclePrice() external nonReentrant returns (uint256) {\n        return _updateWOETHOraclePrice();\n    }\n\n    /**\n     * @dev Finds the value of bridged wOETH from the Oracle.\n     *      Ensures that it's within the bounds and reasonable.\n     *      And stores it.\n     *\n     *      NOTE: Intentionally not caching `Vault.priceProvider` here,\n     *      since doing so would mean that we also have to update this\n     *      strategy every time there's a change in oracle router.\n     *      Besides on L2, the gas is considerably cheaper than mainnet.\n     *\n     * @return Latest price from oracle\n     */\n    function _updateWOETHOraclePrice() internal returns (uint256) {\n        // WETH price per unit of bridged wOETH\n        uint256 oraclePrice = oracle.price(address(bridgedWOETH));\n\n        // 1 wOETH > 1 WETH, always\n        require(oraclePrice > 1 ether, \"Invalid wOETH value\");\n\n        uint128 oraclePrice128 = oraclePrice.toUint128();\n\n        // Do some checks\n        if (lastOraclePrice > 0) {\n            // Make sure the value only goes up\n            require(oraclePrice128 >= lastOraclePrice, \"Negative wOETH yield\");\n\n            // lastOraclePrice * (1 + maxPriceDiffBps)\n            uint256 maxPrice = (lastOraclePrice * (1e4 + maxPriceDiffBps)) /\n                1e4;\n\n            // And that it's within the bounds.\n            require(oraclePrice128 <= maxPrice, \"Price diff beyond threshold\");\n        }\n\n        emit WOETHPriceUpdated(lastOraclePrice, oraclePrice128);\n\n        // Store the price\n        lastOraclePrice = oraclePrice128;\n\n        return oraclePrice;\n    }\n\n    /**\n     * @dev Computes & returns the value of given wOETH in WETH\n     * @param woethAmount Amount of wOETH\n     * @return Value of wOETH in WETH (using the last stored oracle price)\n     */\n    function getBridgedWOETHValue(uint256 woethAmount)\n        public\n        view\n        returns (uint256)\n    {\n        return (woethAmount * lastOraclePrice) / 1 ether;\n    }\n\n    /**\n     * @dev Takes in bridged wOETH and mints & returns\n     *      equivalent amount of OETHb.\n     * @param woethAmount Amount of bridged wOETH to transfer in\n     */\n    function depositBridgedWOETH(uint256 woethAmount)\n        external\n        onlyGovernorOrStrategist\n        nonReentrant\n    {\n        // Update wOETH price\n        uint256 oraclePrice = _updateWOETHOraclePrice();\n\n        // Figure out how much they are worth\n        uint256 oethToMint = (woethAmount * oraclePrice) / 1 ether;\n\n        require(oethToMint > 0, \"Invalid deposit amount\");\n\n        // There's no pToken, however, it just uses WOETH address in the event\n        emit Deposit(address(weth), address(bridgedWOETH), oethToMint);\n\n        // Mint OETHb tokens and transfer it to the caller\n        IVault(vaultAddress).mintForStrategy(oethToMint);\n\n        // Transfer out minted OETHb\n        // slither-disable-next-line unchecked-transfer unused-return\n        oethb.transfer(msg.sender, oethToMint);\n\n        // Transfer in all bridged wOETH tokens\n        // slither-disable-next-line unchecked-transfer unused-return\n        bridgedWOETH.transferFrom(msg.sender, address(this), woethAmount);\n    }\n\n    /**\n     * @dev Takes in OETHb and burns it and returns\n     *      equivalent amount of bridged wOETH.\n     * @param oethToBurn Amount of OETHb to burn\n     */\n    function withdrawBridgedWOETH(uint256 oethToBurn)\n        external\n        onlyGovernorOrStrategist\n        nonReentrant\n    {\n        // Update wOETH price\n        uint256 oraclePrice = _updateWOETHOraclePrice();\n\n        // Figure out how much they are worth\n        uint256 woethAmount = (oethToBurn * 1 ether) / oraclePrice;\n\n        require(woethAmount > 0, \"Invalid withdraw amount\");\n\n        // There's no pToken, however, it just uses WOETH address in the event\n        emit Withdrawal(address(weth), address(bridgedWOETH), oethToBurn);\n\n        // Transfer WOETH back\n        // slither-disable-next-line unchecked-transfer unused-return\n        bridgedWOETH.transfer(msg.sender, woethAmount);\n\n        // Transfer in OETHb\n        // slither-disable-next-line unchecked-transfer unused-return\n        oethb.transferFrom(msg.sender, address(this), oethToBurn);\n\n        // Burn OETHb\n        IVault(vaultAddress).burnForStrategy(oethToBurn);\n    }\n\n    /**\n     * @notice Returns the amount of backing WETH the strategy holds\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == address(weth), \"Unsupported asset\");\n\n        // Figure out how much wOETH is worth at the time.\n        // Always uses the last stored oracle price.\n        // Call updateWOETHOraclePrice manually to pull in latest yields.\n\n        // NOTE: If the contract has been deployed but the call to\n        // `updateWOETHOraclePrice()` has never been made, then this\n        // will return zero. It should be fine because the strategy\n        // should update the price whenever a deposit/withdraw happens.\n\n        // If `updateWOETHOraclePrice()` hasn't been called in a while,\n        // the strategy will underreport its holdings but never overreport it.\n\n        balance =\n            (bridgedWOETH.balanceOf(address(this)) * lastOraclePrice) /\n            1 ether;\n    }\n\n    /**\n     * @notice Check if an asset is supported.\n     * @param _asset    Address of the asset\n     * @return bool     Whether asset is supported\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        // Strategist deposits bridged wOETH but the contract only\n        // reports the balance in WETH. As far as Vault is concerned,\n        // it isn't aware of bridged wOETH token\n        return _asset == address(weth);\n    }\n\n    /***************************************\n               Overridden methods\n    ****************************************/\n    /**\n     * @inheritdoc InitializableAbstractStrategy\n     */\n    function transferToken(address _asset, uint256 _amount)\n        public\n        override\n        onlyGovernor\n    {\n        require(\n            _asset != address(bridgedWOETH) && _asset != address(weth),\n            \"Cannot transfer supported asset\"\n        );\n        // Use SafeERC20 only for rescuing unknown assets; core tokens are standard.\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /**\n     * @notice deposit() function not used for this strategy\n     */\n    function deposit(address, uint256)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        // Use depositBridgedWOETH() instead\n        require(false, \"Deposit disabled\");\n    }\n\n    /**\n     * @notice depositAll() function not used for this strategy\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        // Use depositBridgedWOETH() instead\n        require(false, \"Deposit disabled\");\n    }\n\n    /**\n     * @notice withdraw() function not used for this strategy\n     */\n    function withdraw(\n        // solhint-disable-next-line no-unused-vars\n        address _recipient,\n        // solhint-disable-next-line no-unused-vars\n        address _asset,\n        // solhint-disable-next-line no-unused-vars\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(false, \"Withdrawal disabled\");\n    }\n\n    /**\n     * @notice withdrawAll() function not used for this strategy\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        // Withdrawal disabled\n    }\n\n    function _abstractSetPToken(address, address) internal override {\n        revert(\"No pTokens are used\");\n    }\n\n    function safeApproveAllTokens() external override {}\n\n    /**\n     * @inheritdoc InitializableAbstractStrategy\n     */\n    function removePToken(uint256) external override {\n        revert(\"No pTokens are used\");\n    }\n\n    /**\n     * @inheritdoc InitializableAbstractStrategy\n     */\n    function collectRewardTokens() external override {}\n}\n"
    },
    "contracts/strategies/CompoundStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Compound Strategy\n * @notice Investment strategy for Compound like lending platforms. eg Compound and Flux\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ICERC20 } from \"./ICompound.sol\";\nimport { AbstractCompoundStrategy, InitializableAbstractStrategy } from \"./AbstractCompoundStrategy.sol\";\nimport { IComptroller } from \"../interfaces/IComptroller.sol\";\nimport { IERC20 } from \"../utils/InitializableAbstractStrategy.sol\";\n\ncontract CompoundStrategy is AbstractCompoundStrategy {\n    using SafeERC20 for IERC20;\n    event SkippedWithdrawal(address asset, uint256 amount);\n\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /**\n     * @notice initialize function, to set up initial internal state\n     * @param _rewardTokenAddresses Address of reward token for platform\n     * @param _assets Addresses of initial supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function initialize(\n        address[] memory _rewardTokenAddresses,\n        address[] memory _assets,\n        address[] memory _pTokens\n    ) external onlyGovernor initializer {\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n    }\n\n    /**\n     * @notice Collect accumulated COMP and send to Harvester.\n     */\n    function collectRewardTokens()\n        external\n        virtual\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Claim COMP from Comptroller\n        ICERC20 cToken = _getCTokenFor(assetsMapped[0]);\n        IComptroller comptroller = IComptroller(cToken.comptroller());\n        // Only collect from active cTokens, saves gas\n        address[] memory ctokensToCollect = new address[](assetsMapped.length);\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            ctokensToCollect[i] = address(_getCTokenFor(assetsMapped[i]));\n        }\n        // Claim only for this strategy\n        address[] memory claimers = new address[](1);\n        claimers[0] = address(this);\n        // Claim COMP from Comptroller. Only collect for supply, saves gas\n        comptroller.claimComp(claimers, ctokensToCollect, false, true);\n        // Transfer COMP to Harvester\n        IERC20 rewardToken = IERC20(rewardTokenAddresses[0]);\n        uint256 balance = rewardToken.balanceOf(address(this));\n        emit RewardTokenCollected(\n            harvesterAddress,\n            rewardTokenAddresses[0],\n            balance\n        );\n        rewardToken.safeTransfer(harvesterAddress, balance);\n    }\n\n    /**\n     * @notice Deposit asset into the underlying platform\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of assets to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @dev Deposit an asset into the underlying platform\n     * @param _asset Address of the asset to deposit\n     * @param _amount Amount of assets to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_amount > 0, \"Must deposit something\");\n        ICERC20 cToken = _getCTokenFor(_asset);\n        emit Deposit(_asset, address(cToken), _amount);\n        require(cToken.mint(_amount) == 0, \"cToken mint failed\");\n    }\n\n    /**\n     * @notice Deposit the entire balance of any supported asset in the strategy into the underlying platform\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            IERC20 asset = IERC20(assetsMapped[i]);\n            uint256 assetBalance = asset.balanceOf(address(this));\n            if (assetBalance > 0) {\n                _deposit(address(asset), assetBalance);\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraw an asset from the underlying platform\n     * @param _recipient Address to receive withdrawn assets\n     * @param _asset Address of the asset to withdraw\n     * @param _amount Amount of assets to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        ICERC20 cToken = _getCTokenFor(_asset);\n        // If redeeming 0 cTokens, just skip, else COMP will revert\n        uint256 cTokensToRedeem = _convertUnderlyingToCToken(cToken, _amount);\n        if (cTokensToRedeem == 0) {\n            emit SkippedWithdrawal(_asset, _amount);\n            return;\n        }\n\n        emit Withdrawal(_asset, address(cToken), _amount);\n        require(cToken.redeemUnderlying(_amount) == 0, \"Redeem failed\");\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Internal method to respond to the addition of new asset / cTokens\n     *      We need to approve the cToken and give it permission to spend the asset\n     * @param _asset Address of the asset to approve. eg DAI\n     * @param _pToken The pToken for the approval. eg cDAI or fDAI\n     */\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        override\n    {\n        // Safe approval\n        IERC20(_asset).safeApprove(_pToken, 0);\n        IERC20(_asset).safeApprove(_pToken, type(uint256).max);\n    }\n\n    /**\n     * @notice Remove all supported assets from the underlying platform and send them to Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            IERC20 asset = IERC20(assetsMapped[i]);\n            // Redeem entire balance of cToken\n            ICERC20 cToken = _getCTokenFor(address(asset));\n            uint256 cTokenBalance = cToken.balanceOf(address(this));\n            if (cTokenBalance > 0) {\n                require(cToken.redeem(cTokenBalance) == 0, \"Redeem failed\");\n                uint256 assetBalance = asset.balanceOf(address(this));\n                // Transfer entire balance to Vault\n                asset.safeTransfer(vaultAddress, assetBalance);\n\n                emit Withdrawal(address(asset), address(cToken), assetBalance);\n            }\n        }\n    }\n\n    /**\n     * @notice Get the total asset value held in the underlying platform\n     *      This includes any interest that was generated since depositing.\n     *      The exchange rate between the cToken and asset gradually increases,\n     *      causing the cToken to be worth more corresponding asset.\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        // Balance is always with token cToken decimals\n        ICERC20 cToken = _getCTokenFor(_asset);\n        balance = _checkBalance(cToken);\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     *      underlying = (cTokenAmt * exchangeRate) / 1e18\n     * @param _cToken     cToken for which to check balance\n     * @return balance    Total value of the asset in the platform\n     */\n    function _checkBalance(ICERC20 _cToken)\n        internal\n        view\n        returns (uint256 balance)\n    {\n        // e.g. 50e8*205316390724364402565641705 / 1e18 = 1.0265..e18\n        balance =\n            (_cToken.balanceOf(address(this)) * _cToken.exchangeRateStored()) /\n            1e18;\n    }\n\n    /**\n     * @notice Approve the spending of all assets by their corresponding cToken,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens() external override {\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            IERC20 asset = IERC20(assetsMapped[i]);\n            address cToken = assetToPToken[address(asset)];\n            // Safe approval\n            asset.safeApprove(cToken, 0);\n            asset.safeApprove(cToken, type(uint256).max);\n        }\n    }\n}\n"
    },
    "contracts/strategies/ConvexEthMetaStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Convex Automated Market Maker (AMO) Strategy\n * @notice AMO strategy for the Curve OETH/ETH pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { ICurveETHPoolV1 } from \"./ICurveETHPoolV1.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { IConvexDeposits } from \"./IConvexDeposits.sol\";\nimport { IRewardStaking } from \"./IRewardStaking.sol\";\n\ncontract ConvexEthMetaStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant MAX_SLIPPAGE = 1e16; // 1%, same as the Curve UI\n    address public constant ETH_ADDRESS =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    // The following slots have been deprecated with immutable variables\n    // slither-disable-next-line constable-states\n    address private _deprecated_cvxDepositorAddress;\n    // slither-disable-next-line constable-states\n    address private _deprecated_cvxRewardStaker;\n    // slither-disable-next-line constable-states\n    uint256 private _deprecated_cvxDepositorPTokenId;\n    // slither-disable-next-line constable-states\n    address private _deprecated_curvePool;\n    // slither-disable-next-line constable-states\n    address private _deprecated_lpToken;\n    // slither-disable-next-line constable-states\n    address private _deprecated_oeth;\n    // slither-disable-next-line constable-states\n    address private _deprecated_weth;\n\n    // Ordered list of pool assets\n    // slither-disable-next-line constable-states\n    uint128 private _deprecated_oethCoinIndex;\n    // slither-disable-next-line constable-states\n    uint128 private _deprecated_ethCoinIndex;\n\n    // New immutable variables that must be set in the constructor\n    address public immutable cvxDepositorAddress;\n    IRewardStaking public immutable cvxRewardStaker;\n    uint256 public immutable cvxDepositorPTokenId;\n    ICurveETHPoolV1 public immutable curvePool;\n    IERC20 public immutable lpToken;\n    IERC20 public immutable oeth;\n    IWETH9 public immutable weth;\n\n    // Ordered list of pool assets\n    uint128 public constant oethCoinIndex = 1;\n    uint128 public constant ethCoinIndex = 0;\n\n    /**\n     * @dev Verifies that the caller is the Strategist.\n     */\n    modifier onlyStrategist() {\n        require(\n            msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Strategist\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Checks the Curve pool's balances have improved and the balances\n     * have not tipped to the other side.\n     * This modifier only works on functions that do a single sided add or remove.\n     * The standard deposit function adds to both sides of the pool in a way that\n     * the pool's balance is not worsened.\n     * Withdrawals are proportional so doesn't change the pools asset balance.\n     */\n    modifier improvePoolBalance() {\n        // Get the asset and OToken balances in the Curve pool\n        uint256[2] memory balancesBefore = curvePool.get_balances();\n        // diff = ETH balance - OETH balance\n        int256 diffBefore = int256(balancesBefore[ethCoinIndex]) -\n            int256(balancesBefore[oethCoinIndex]);\n\n        _;\n\n        // Get the asset and OToken balances in the Curve pool\n        uint256[2] memory balancesAfter = curvePool.get_balances();\n        // diff = ETH balance - OETH balance\n        int256 diffAfter = int256(balancesAfter[ethCoinIndex]) -\n            int256(balancesAfter[oethCoinIndex]);\n\n        if (diffBefore <= 0) {\n            // If the pool was originally imbalanced in favor of OETH, then\n            // we want to check that the pool is now more balanced\n            require(diffAfter <= 0, \"OTokens overshot peg\");\n            require(diffBefore < diffAfter, \"OTokens balance worse\");\n        }\n        if (diffBefore >= 0) {\n            // If the pool was originally imbalanced in favor of ETH, then\n            // we want to check that the pool is now more balanced\n            require(diffAfter >= 0, \"Assets overshot peg\");\n            require(diffAfter < diffBefore, \"Assets balance worse\");\n        }\n    }\n\n    // Used to circumvent the stack too deep issue\n    struct ConvexEthMetaConfig {\n        address cvxDepositorAddress; //Address of the Convex depositor(AKA booster) for this pool\n        address cvxRewardStakerAddress; //Address of the CVX rewards staker\n        uint256 cvxDepositorPTokenId; //Pid of the pool referred to by Depositor and staker\n        address oethAddress; //Address of OETH token\n        address wethAddress; //Address of WETH\n    }\n\n    constructor(\n        BaseStrategyConfig memory _baseConfig,\n        ConvexEthMetaConfig memory _convexConfig\n    ) InitializableAbstractStrategy(_baseConfig) {\n        lpToken = IERC20(_baseConfig.platformAddress);\n        curvePool = ICurveETHPoolV1(_baseConfig.platformAddress);\n\n        cvxDepositorAddress = _convexConfig.cvxDepositorAddress;\n        cvxRewardStaker = IRewardStaking(_convexConfig.cvxRewardStakerAddress);\n        cvxDepositorPTokenId = _convexConfig.cvxDepositorPTokenId;\n        oeth = IERC20(_convexConfig.oethAddress);\n        weth = IWETH9(_convexConfig.wethAddress);\n    }\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Curve strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Address of CRV & CVX\n     * @param _assets Addresses of supported assets. eg WETH\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // CRV + CVX\n        address[] calldata _assets // WETH\n    ) external onlyGovernor initializer {\n        require(_assets.length == 1, \"Must have exactly one asset\");\n        require(_assets[0] == address(weth), \"Asset not WETH\");\n\n        address[] memory pTokens = new address[](1);\n        pTokens[0] = address(curvePool);\n\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            pTokens\n        );\n\n        _approveBase();\n    }\n\n    /***************************************\n                    Deposit\n    ****************************************/\n\n    /**\n     * @notice Deposit WETH into the Curve pool\n     * @param _weth Address of Wrapped ETH (WETH) contract.\n     * @param _amount Amount of WETH to deposit.\n     */\n    function deposit(address _weth, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_weth, _amount);\n    }\n\n    function _deposit(address _weth, uint256 _wethAmount) internal {\n        require(_wethAmount > 0, \"Must deposit something\");\n        require(_weth == address(weth), \"Can only deposit WETH\");\n        weth.withdraw(_wethAmount);\n\n        emit Deposit(_weth, address(lpToken), _wethAmount);\n\n        // Get the asset and OToken balances in the Curve pool\n        uint256[2] memory balances = curvePool.get_balances();\n        // safe to cast since min value is at least 0\n        uint256 oethToAdd = uint256(\n            _max(\n                0,\n                int256(balances[ethCoinIndex]) +\n                    int256(_wethAmount) -\n                    int256(balances[oethCoinIndex])\n            )\n        );\n\n        /* Add so much OETH so that the pool ends up being balanced. And at minimum\n         * add as much OETH as WETH and at maximum twice as much OETH.\n         */\n        oethToAdd = Math.max(oethToAdd, _wethAmount);\n        oethToAdd = Math.min(oethToAdd, _wethAmount * 2);\n\n        /* Mint OETH with a strategy that attempts to contribute to stability of OETH/WETH pool. Try\n         * to mint so much OETH that after deployment of liquidity pool ends up being balanced.\n         *\n         * To manage unpredictability minimal OETH minted will always be at least equal or greater\n         * to WETH amount deployed. And never larger than twice the WETH amount deployed even if\n         * it would have a further beneficial effect on pool stability.\n         */\n        IVault(vaultAddress).mintForStrategy(oethToAdd);\n\n        emit Deposit(address(oeth), address(lpToken), oethToAdd);\n\n        uint256[2] memory _amounts;\n        _amounts[ethCoinIndex] = _wethAmount;\n        _amounts[oethCoinIndex] = oethToAdd;\n\n        uint256 valueInLpTokens = (_wethAmount + oethToAdd).divPrecisely(\n            curvePool.get_virtual_price()\n        );\n        uint256 minMintAmount = valueInLpTokens.mulTruncate(\n            uint256(1e18) - MAX_SLIPPAGE\n        );\n\n        // Do the deposit to the Curve pool\n        // slither-disable-next-line arbitrary-send\n        uint256 lpDeposited = curvePool.add_liquidity{ value: _wethAmount }(\n            _amounts,\n            minMintAmount\n        );\n\n        // Deposit the Curve pool's LP tokens into the Convex rewards pool\n        require(\n            IConvexDeposits(cvxDepositorAddress).deposit(\n                cvxDepositorPTokenId,\n                lpDeposited,\n                true // Deposit with staking\n            ),\n            \"Depositing LP to Convex not successful\"\n        );\n    }\n\n    /**\n     * @notice Deposit the strategy's entire balance of WETH into the Curve pool\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 balance = weth.balanceOf(address(this));\n        if (balance > 0) {\n            _deposit(address(weth), balance);\n        }\n    }\n\n    /***************************************\n                    Withdraw\n    ****************************************/\n\n    /**\n     * @notice Withdraw ETH and OETH from the Curve pool, burn the OETH,\n     * convert the ETH to WETH and transfer to the recipient.\n     * @param _recipient Address to receive withdrawn asset which is normally the Vault.\n     * @param _weth Address of the Wrapped ETH (WETH) contract.\n     * @param _amount Amount of WETH to withdraw.\n     */\n    function withdraw(\n        address _recipient,\n        address _weth,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_amount > 0, \"Invalid amount\");\n        require(_weth == address(weth), \"Can only withdraw WETH\");\n\n        emit Withdrawal(_weth, address(lpToken), _amount);\n\n        uint256 requiredLpTokens = calcTokenToBurn(_amount);\n\n        _lpWithdraw(requiredLpTokens);\n\n        /* math in requiredLpTokens should correctly calculate the amount of LP to remove\n         * in that the strategy receives enough WETH on balanced removal\n         */\n        uint256[2] memory _minWithdrawalAmounts = [uint256(0), uint256(0)];\n        _minWithdrawalAmounts[ethCoinIndex] = _amount;\n        // slither-disable-next-line unused-return\n        curvePool.remove_liquidity(requiredLpTokens, _minWithdrawalAmounts);\n\n        // Burn all the removed OETH and any that was left in the strategy\n        uint256 oethToBurn = oeth.balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(oethToBurn);\n\n        emit Withdrawal(address(oeth), address(lpToken), oethToBurn);\n\n        // Transfer WETH to the recipient\n        weth.deposit{ value: _amount }();\n        require(\n            weth.transfer(_recipient, _amount),\n            \"Transfer of WETH not successful\"\n        );\n    }\n\n    function calcTokenToBurn(uint256 _wethAmount)\n        internal\n        view\n        returns (uint256 lpToBurn)\n    {\n        /* The rate between coins in the pool determines the rate at which pool returns\n         * tokens when doing balanced removal (remove_liquidity call). And by knowing how much WETH\n         * we want we can determine how much of OETH we receive by removing liquidity.\n         *\n         * Because we are doing balanced removal we should be making profit when removing liquidity in a\n         * pool tilted to either side.\n         *\n         * Important: A downside is that the Strategist / Governor needs to be\n         * cognisant of not removing too much liquidity. And while the proposal to remove liquidity\n         * is being voted on the pool tilt might change so much that the proposal that has been valid while\n         * created is no longer valid.\n         */\n\n        uint256 poolWETHBalance = curvePool.balances(ethCoinIndex);\n        /* K is multiplied by 1e36 which is used for higher precision calculation of required\n         * pool LP tokens. Without it the end value can have rounding errors up to precision of\n         * 10 digits. This way we move the decimal point by 36 places when doing the calculation\n         * and again by 36 places when we are done with it.\n         */\n        uint256 k = (1e36 * lpToken.totalSupply()) / poolWETHBalance;\n        // prettier-ignore\n        // slither-disable-next-line divide-before-multiply\n        uint256 diff = (_wethAmount + 1) * k;\n        lpToBurn = diff / 1e36;\n    }\n\n    /**\n     * @notice Remove all ETH and OETH from the Curve pool, burn the OETH,\n     * convert the ETH to WETH and transfer to the Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        uint256 gaugeTokens = cvxRewardStaker.balanceOf(address(this));\n        _lpWithdraw(gaugeTokens);\n\n        // Withdraws are proportional to assets held by 3Pool\n        uint256[2] memory minWithdrawAmounts = [uint256(0), uint256(0)];\n\n        // Remove liquidity\n        // slither-disable-next-line unused-return\n        curvePool.remove_liquidity(\n            lpToken.balanceOf(address(this)),\n            minWithdrawAmounts\n        );\n\n        // Burn all OETH\n        uint256 oethToBurn = oeth.balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(oethToBurn);\n\n        // Get the strategy contract's ether balance.\n        // This includes all that was removed from the Curve pool and\n        // any ether that was sitting in the strategy contract before the removal.\n        uint256 ethBalance = address(this).balance;\n        // Convert all the strategy contract's ether to WETH and transfer to the vault.\n        weth.deposit{ value: ethBalance }();\n        require(\n            weth.transfer(vaultAddress, ethBalance),\n            \"Transfer of WETH not successful\"\n        );\n\n        emit Withdrawal(address(weth), address(lpToken), ethBalance);\n        emit Withdrawal(address(oeth), address(lpToken), oethToBurn);\n    }\n\n    /***************************************\n            Curve pool Rebalancing\n    ****************************************/\n\n    /**\n     * @notice Mint OTokens and one-sided add to the Curve pool.\n     * This is used when the Curve pool does not have enough OTokens and too many ETH.\n     * The OToken/Asset, eg OETH/ETH, price with increase.\n     * The amount of assets in the vault is unchanged.\n     * The total supply of OTokens is increased.\n     * The asset value of the strategy and vault is increased.\n     * @param _oTokens The amount of OTokens to be minted and added to the pool.\n     */\n    function mintAndAddOTokens(uint256 _oTokens)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n    {\n        IVault(vaultAddress).mintForStrategy(_oTokens);\n\n        uint256[2] memory amounts = [uint256(0), uint256(0)];\n        amounts[oethCoinIndex] = _oTokens;\n\n        // Convert OETH to Curve pool LP tokens\n        uint256 valueInLpTokens = (_oTokens).divPrecisely(\n            curvePool.get_virtual_price()\n        );\n        // Apply slippage to LP tokens\n        uint256 minMintAmount = valueInLpTokens.mulTruncate(\n            uint256(1e18) - MAX_SLIPPAGE\n        );\n\n        // Add the minted OTokens to the Curve pool\n        uint256 lpDeposited = curvePool.add_liquidity(amounts, minMintAmount);\n\n        // Deposit the Curve pool LP tokens to the Convex rewards pool\n        require(\n            IConvexDeposits(cvxDepositorAddress).deposit(\n                cvxDepositorPTokenId,\n                lpDeposited,\n                true // Deposit with staking\n            ),\n            \"Failed to Deposit LP to Convex\"\n        );\n\n        emit Deposit(address(oeth), address(lpToken), _oTokens);\n    }\n\n    /**\n     * @notice One-sided remove of OTokens from the Curve pool which are then burned.\n     * This is used when the Curve pool has too many OTokens and not enough ETH.\n     * The amount of assets in the vault is unchanged.\n     * The total supply of OTokens is reduced.\n     * The asset value of the strategy and vault is reduced.\n     * @param _lpTokens The amount of Curve pool LP tokens to be burned for OTokens.\n     */\n    function removeAndBurnOTokens(uint256 _lpTokens)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n    {\n        // Withdraw Curve pool LP tokens from Convex and remove OTokens from the Curve pool\n        uint256 oethToBurn = _withdrawAndRemoveFromPool(\n            _lpTokens,\n            oethCoinIndex\n        );\n\n        // The vault burns the OTokens from this strategy\n        IVault(vaultAddress).burnForStrategy(oethToBurn);\n\n        emit Withdrawal(address(oeth), address(lpToken), oethToBurn);\n    }\n\n    /**\n     * @notice One-sided remove of ETH from the Curve pool, convert to WETH\n     * and transfer to the vault.\n     * This is used when the Curve pool does not have enough OTokens and too many ETH.\n     * The OToken/Asset, eg OETH/ETH, price with decrease.\n     * The amount of assets in the vault increases.\n     * The total supply of OTokens does not change.\n     * The asset value of the strategy reduces.\n     * The asset value of the vault should be close to the same.\n     * @param _lpTokens The amount of Curve pool LP tokens to be burned for ETH.\n     * @dev Curve pool LP tokens is used rather than WETH assets as Curve does not\n     * have a way to accurately calculate the amount of LP tokens for a required\n     * amount of ETH. Curve's `calc_token_amount` functioun does not include fees.\n     * A 3rd party libary can be used that takes into account the fees, but this\n     * is a gas intensive process. It's easier for the trusted strategist to\n     * caclulate the amount of Curve pool LP tokens required off-chain.\n     */\n    function removeOnlyAssets(uint256 _lpTokens)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n    {\n        // Withdraw Curve pool LP tokens from Convex and remove ETH from the Curve pool\n        uint256 ethAmount = _withdrawAndRemoveFromPool(_lpTokens, ethCoinIndex);\n\n        // Convert ETH to WETH and transfer to the vault\n        weth.deposit{ value: ethAmount }();\n        require(\n            weth.transfer(vaultAddress, ethAmount),\n            \"Transfer of WETH not successful\"\n        );\n\n        emit Withdrawal(address(weth), address(lpToken), ethAmount);\n    }\n\n    /**\n     * @dev Remove Curve pool LP tokens from the Convex pool and\n     * do a one-sided remove of ETH or OETH from the Curve pool.\n     * @param _lpTokens The amount of Curve pool LP tokens to be removed from the Convex pool.\n     * @param coinIndex The index of the coin to be removed from the Curve pool. 0 = ETH, 1 = OETH.\n     * @return coinsRemoved The amount of ETH or OETH removed from the Curve pool.\n     */\n    function _withdrawAndRemoveFromPool(uint256 _lpTokens, uint128 coinIndex)\n        internal\n        returns (uint256 coinsRemoved)\n    {\n        // Withdraw Curve pool LP tokens from Convex pool\n        _lpWithdraw(_lpTokens);\n\n        // Convert Curve pool LP tokens to ETH value\n        uint256 valueInEth = _lpTokens.mulTruncate(\n            curvePool.get_virtual_price()\n        );\n        // Apply slippage to ETH value\n        uint256 minAmount = valueInEth.mulTruncate(\n            uint256(1e18) - MAX_SLIPPAGE\n        );\n\n        // Remove just the ETH from the Curve pool\n        coinsRemoved = curvePool.remove_liquidity_one_coin(\n            _lpTokens,\n            int128(coinIndex),\n            minAmount,\n            address(this)\n        );\n    }\n\n    /***************************************\n                Assets and Rewards\n    ****************************************/\n\n    /**\n     * @notice Collect accumulated CRV and CVX rewards and send to the Harvester.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Collect CRV and CVX\n        cvxRewardStaker.getReward();\n        _collectRewardTokens();\n    }\n\n    function _lpWithdraw(uint256 _wethAmount) internal {\n        // withdraw and unwrap with claim takes back the lpTokens\n        // and also collects the rewards for deposit\n        cvxRewardStaker.withdrawAndUnwrap(_wethAmount, true);\n    }\n\n    /**\n     * @notice Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == address(weth), \"Unsupported asset\");\n\n        // Eth balance needed here for the balance check that happens from vault during depositing.\n        balance = address(this).balance;\n        uint256 lpTokens = cvxRewardStaker.balanceOf(address(this));\n        if (lpTokens > 0) {\n            balance += (lpTokens * curvePool.get_virtual_price()) / 1e18;\n        }\n    }\n\n    /**\n     * @notice Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == address(weth);\n    }\n\n    /***************************************\n                    Approvals\n    ****************************************/\n\n    /**\n     * @notice Approve the spending of all assets by their corresponding pool tokens,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        _approveBase();\n    }\n\n    /**\n     * @notice Accept unwrapped WETH\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Since we are unwrapping WETH before depositing it to Curve\n     *      there is no need to set an approval for WETH on the Curve\n     *      pool\n     * @param _asset Address of the asset\n     * @param _pToken Address of the Curve LP token\n     */\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        override\n    {}\n\n    function _approveBase() internal {\n        // Approve Curve pool for OETH (required for adding liquidity)\n        // No approval is needed for ETH\n        // slither-disable-next-line unused-return\n        oeth.approve(platformAddress, type(uint256).max);\n\n        // Approve Convex deposit contract to transfer Curve pool LP tokens\n        // This is needed for deposits if Curve pool LP tokens into the Convex rewards pool\n        // slither-disable-next-line unused-return\n        lpToken.approve(cvxDepositorAddress, type(uint256).max);\n    }\n\n    /**\n     * @dev Returns the largest of two numbers int256 version\n     */\n    function _max(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n}\n"
    },
    "contracts/strategies/ConvexGeneralizedMetaStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Curve Convex Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport { IRewardStaking } from \"./IRewardStaking.sol\";\nimport { IConvexDeposits } from \"./IConvexDeposits.sol\";\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"./AbstractCurveStrategy.sol\";\nimport { AbstractConvexMetaStrategy } from \"./AbstractConvexMetaStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\ncontract ConvexGeneralizedMetaStrategy is AbstractConvexMetaStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /* Take 3pool LP and deposit it to metapool. Take the LP from metapool\n     * and deposit them to Convex.\n     */\n    function _lpDepositAll() internal override {\n        IERC20 threePoolLp = IERC20(pTokenAddress);\n        ICurvePool curvePool = ICurvePool(platformAddress);\n\n        uint256 threePoolLpBalance = threePoolLp.balanceOf(address(this));\n        uint256 curve3PoolVirtualPrice = curvePool.get_virtual_price();\n        uint256 threePoolLpDollarValue = threePoolLpBalance.mulTruncate(\n            curve3PoolVirtualPrice\n        );\n\n        uint256[2] memory _amounts = [0, threePoolLpBalance];\n\n        uint256 metapoolVirtualPrice = metapool.get_virtual_price();\n        /**\n         * First convert all the deposited tokens to dollar values,\n         * then divide by virtual price to convert to metapool LP tokens\n         * and apply the max slippage\n         */\n        uint256 minReceived = threePoolLpDollarValue\n            .divPrecisely(metapoolVirtualPrice)\n            .mulTruncate(uint256(1e18) - MAX_SLIPPAGE);\n\n        uint256 metapoolLp = metapool.add_liquidity(_amounts, minReceived);\n\n        bool success = IConvexDeposits(cvxDepositorAddress).deposit(\n            cvxDepositorPTokenId,\n            metapoolLp,\n            true // Deposit with staking\n        );\n\n        require(success, \"Failed to deposit to Convex\");\n    }\n\n    /**\n     * Withdraw the specified amount of tokens from the gauge. And use all the resulting tokens\n     * to remove liquidity from metapool\n     * @param num3CrvTokens Number of Convex 3pool LP tokens to withdraw from metapool\n     */\n    function _lpWithdraw(uint256 num3CrvTokens) internal override {\n        uint256 gaugeTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n\n        uint256 requiredMetapoolLpTokens = _calcCurveMetaTokenAmount(\n            crvCoinIndex,\n            num3CrvTokens\n        );\n\n        require(\n            requiredMetapoolLpTokens <= gaugeTokens,\n            string(\n                bytes.concat(\n                    bytes(\"Attempting to withdraw \"),\n                    bytes(Strings.toString(requiredMetapoolLpTokens)),\n                    bytes(\", metapoolLP but only \"),\n                    bytes(Strings.toString(gaugeTokens)),\n                    bytes(\" available.\")\n                )\n            )\n        );\n\n        // withdraw and unwrap with claim takes back the lpTokens and also collects the rewards for deposit\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            requiredMetapoolLpTokens,\n            true\n        );\n\n        if (requiredMetapoolLpTokens > 0) {\n            // slither-disable-next-line unused-return\n            metapool.remove_liquidity_one_coin(\n                requiredMetapoolLpTokens,\n                int128(crvCoinIndex),\n                num3CrvTokens\n            );\n        }\n    }\n\n    function _lpWithdrawAll() internal override {\n        uint256 gaugeTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            gaugeTokens,\n            true\n        );\n\n        if (gaugeTokens > 0) {\n            uint256 burnDollarAmount = gaugeTokens.mulTruncate(\n                metapool.get_virtual_price()\n            );\n            uint256 curve3PoolExpected = burnDollarAmount.divPrecisely(\n                ICurvePool(platformAddress).get_virtual_price()\n            );\n\n            // Always withdraw all of the available metapool LP tokens (similar to how we always deposit all)\n            // slither-disable-next-line unused-return\n            metapool.remove_liquidity_one_coin(\n                gaugeTokens,\n                int128(crvCoinIndex),\n                curve3PoolExpected -\n                    curve3PoolExpected.mulTruncate(maxWithdrawalSlippage)\n            );\n        }\n    }\n}\n"
    },
    "contracts/strategies/ConvexOUSDMetaStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Curve Convex Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { IRewardStaking } from \"./IRewardStaking.sol\";\nimport { IConvexDeposits } from \"./IConvexDeposits.sol\";\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"./AbstractCurveStrategy.sol\";\nimport { AbstractConvexMetaStrategy } from \"./AbstractConvexMetaStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract ConvexOUSDMetaStrategy is AbstractConvexMetaStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /* Take 3pool LP and mint the corresponding amount of ousd. Deposit and stake that to\n     * ousd Curve Metapool. Take the LP from metapool and deposit them to Convex.\n     */\n    function _lpDepositAll() internal override {\n        ICurvePool curvePool = ICurvePool(platformAddress);\n\n        uint256 threePoolLpBalance = IERC20(pTokenAddress).balanceOf(\n            address(this)\n        );\n        uint256 curve3PoolVirtualPrice = curvePool.get_virtual_price();\n        uint256 threePoolLpDollarValue = threePoolLpBalance.mulTruncate(\n            curve3PoolVirtualPrice\n        );\n\n        // safe to cast since min value is at least 0\n        uint256 ousdToAdd = uint256(\n            _max(\n                0,\n                int256(\n                    metapool.balances(crvCoinIndex).mulTruncate(\n                        curve3PoolVirtualPrice\n                    )\n                ) -\n                    int256(metapool.balances(mainCoinIndex)) +\n                    int256(threePoolLpDollarValue)\n            )\n        );\n\n        /* Add so much OUSD so that the pool ends up being balanced. And at minimum\n         * add twice as much OUSD as 3poolLP and at maximum at twice as\n         * much OUSD.\n         */\n        ousdToAdd = Math.max(ousdToAdd, threePoolLpDollarValue);\n        ousdToAdd = Math.min(ousdToAdd, threePoolLpDollarValue * 2);\n\n        /* Mint OUSD with a strategy that attempts to contribute to stability of OUSD metapool. Try\n         * to mint so much OUSD that after deployment of liquidity pool ends up being balanced.\n         *\n         * To manage unpredictability minimal OUSD minted will always be at least equal or greater\n         * to stablecoin(DAI, USDC, USDT) amount of 3CRVLP deployed. And never larger than twice the\n         * stablecoin amount of 3CRVLP deployed even if it would have a further beneficial effect\n         * on pool stability.\n         */\n        if (ousdToAdd > 0) {\n            IVault(vaultAddress).mintForStrategy(ousdToAdd);\n        }\n\n        uint256[2] memory _amounts = [ousdToAdd, threePoolLpBalance];\n\n        uint256 metapoolVirtualPrice = metapool.get_virtual_price();\n        /**\n         * First convert all the deposited tokens to dollar values,\n         * then divide by virtual price to convert to metapool LP tokens\n         * and apply the max slippage\n         */\n        uint256 minReceived = (ousdToAdd + threePoolLpDollarValue)\n            .divPrecisely(metapoolVirtualPrice)\n            .mulTruncate(uint256(1e18) - MAX_SLIPPAGE);\n\n        uint256 metapoolLp = metapool.add_liquidity(_amounts, minReceived);\n\n        bool success = IConvexDeposits(cvxDepositorAddress).deposit(\n            cvxDepositorPTokenId,\n            metapoolLp,\n            true // Deposit with staking\n        );\n\n        require(success, \"Failed to deposit to Convex\");\n    }\n\n    /**\n     * Withdraw the specified amount of tokens from the gauge. And use all the resulting tokens\n     * to remove liquidity from metapool\n     * @param num3CrvTokens Number of 3CRV tokens to withdraw from metapool\n     */\n    function _lpWithdraw(uint256 num3CrvTokens) internal override {\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        /* The rate between coins in the metapool determines the rate at which metapool returns\n         * tokens when doing balanced removal (remove_liquidity call). And by knowing how much 3crvLp\n         * we want we can determine how much of OUSD we receive by removing liquidity.\n         *\n         * Because we are doing balanced removal we should be making profit when removing liquidity in a\n         * pool tilted to either side.\n         *\n         * Important: A downside is that the Strategist / Governor needs to be\n         * cognisant of not removing too much liquidity. And while the proposal to remove liquidity\n         * is being voted on the pool tilt might change so much that the proposal that has been valid while\n         * created is no longer valid.\n         */\n\n        uint256 crvPoolBalance = metapool.balances(crvCoinIndex);\n        /* K is multiplied by 1e36 which is used for higher precision calculation of required\n         * metapool LP tokens. Without it the end value can have rounding errors up to precision of\n         * 10 digits. This way we move the decimal point by 36 places when doing the calculation\n         * and again by 36 places when we are done with it.\n         */\n        uint256 k = (1e36 * metapoolLPToken.totalSupply()) / crvPoolBalance;\n        // simplifying below to: `uint256 diff = (num3CrvTokens - 1) * k` causes loss of precision\n        // prettier-ignore\n        // slither-disable-next-line divide-before-multiply\n        uint256 diff = crvPoolBalance * k -\n            (crvPoolBalance - num3CrvTokens - 1) * k;\n        uint256 lpToBurn = diff / 1e36;\n\n        uint256 gaugeTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n\n        require(\n            lpToBurn <= gaugeTokens,\n            string(\n                bytes.concat(\n                    bytes(\"Attempting to withdraw \"),\n                    bytes(Strings.toString(lpToBurn)),\n                    bytes(\", metapoolLP but only \"),\n                    bytes(Strings.toString(gaugeTokens)),\n                    bytes(\" available.\")\n                )\n            )\n        );\n\n        // withdraw and unwrap with claim takes back the lpTokens and also collects the rewards for deposit\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            lpToBurn,\n            true\n        );\n\n        // calculate the min amount of OUSD expected for the specified amount of LP tokens\n        uint256 minOUSDAmount = lpToBurn.mulTruncate(\n            metapool.get_virtual_price()\n        ) -\n            num3CrvTokens.mulTruncate(curvePool.get_virtual_price()) -\n            1;\n\n        // withdraw the liquidity from metapool\n        uint256[2] memory _removedAmounts = metapool.remove_liquidity(\n            lpToBurn,\n            [minOUSDAmount, num3CrvTokens]\n        );\n\n        IVault(vaultAddress).burnForStrategy(_removedAmounts[mainCoinIndex]);\n    }\n\n    function _lpWithdrawAll() internal override {\n        IERC20 metapoolErc20 = IERC20(address(metapool));\n        uint256 gaugeTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            gaugeTokens,\n            true\n        );\n\n        uint256[2] memory _minAmounts = [uint256(0), uint256(0)];\n        uint256[2] memory _removedAmounts = metapool.remove_liquidity(\n            metapoolErc20.balanceOf(address(this)),\n            _minAmounts\n        );\n\n        IVault(vaultAddress).burnForStrategy(_removedAmounts[mainCoinIndex]);\n    }\n}\n"
    },
    "contracts/strategies/ConvexStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Curve Convex Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { IRewardStaking } from \"./IRewardStaking.sol\";\nimport { IConvexDeposits } from \"./IConvexDeposits.sol\";\nimport { IERC20, AbstractCurveStrategy, InitializableAbstractStrategy } from \"./AbstractCurveStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\n\n/*\n * IMPORTANT(!) If ConvexStrategy needs to be re-deployed, it requires new\n * proxy contract with fresh storage slots. Changes in `AbstractCurveStrategy`\n * storage slots would break existing implementation.\n *\n * Remove this notice if ConvexStrategy is re-deployed\n */\ncontract ConvexStrategy is AbstractCurveStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address internal cvxDepositorAddress;\n    address internal cvxRewardStakerAddress;\n    // slither-disable-next-line constable-states\n    address private _deprecated_cvxRewardTokenAddress;\n    uint256 internal cvxDepositorPTokenId;\n\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Curve strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Address of CRV & CVX\n     * @param _assets Addresses of supported assets. MUST be passed in the same\n     *                order as returned by coins on the pool contract, i.e.\n     *                DAI, USDC, USDT\n     * @param _pTokens Platform Token corresponding addresses\n     * @param _cvxDepositorAddress Address of the Convex depositor(AKA booster) for this pool\n     * @param _cvxRewardStakerAddress Address of the CVX rewards staker\n     * @param _cvxDepositorPTokenId Pid of the pool referred to by Depositor and staker\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // CRV + CVX\n        address[] calldata _assets,\n        address[] calldata _pTokens,\n        address _cvxDepositorAddress,\n        address _cvxRewardStakerAddress,\n        uint256 _cvxDepositorPTokenId\n    ) external onlyGovernor initializer {\n        require(_assets.length == 3, \"Must have exactly three assets\");\n        // Should be set prior to abstract initialize call otherwise\n        // abstractSetPToken calls will fail\n        cvxDepositorAddress = _cvxDepositorAddress;\n        cvxRewardStakerAddress = _cvxRewardStakerAddress;\n        cvxDepositorPTokenId = _cvxDepositorPTokenId;\n        pTokenAddress = _pTokens[0];\n\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n        _approveBase();\n    }\n\n    function _lpDepositAll() internal override {\n        IERC20 pToken = IERC20(pTokenAddress);\n        // Deposit with staking\n        bool success = IConvexDeposits(cvxDepositorAddress).deposit(\n            cvxDepositorPTokenId,\n            pToken.balanceOf(address(this)),\n            true\n        );\n        require(success, \"Failed to deposit to Convex\");\n    }\n\n    function _lpWithdraw(uint256 numCrvTokens) internal override {\n        uint256 gaugePTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n\n        // Not enough in this contract or in the Gauge, can't proceed\n        require(numCrvTokens > gaugePTokens, \"Insufficient 3CRV balance\");\n\n        // withdraw and unwrap with claim takes back the lpTokens and also collects the rewards to this\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            numCrvTokens,\n            true\n        );\n    }\n\n    function _lpWithdrawAll() internal override {\n        // withdraw and unwrap with claim takes back the lpTokens and also collects the rewards to this\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            IRewardStaking(cvxRewardStakerAddress).balanceOf(address(this)),\n            true\n        );\n    }\n\n    function _approveBase() internal override {\n        IERC20 pToken = IERC20(pTokenAddress);\n        // 3Pool for LP token (required for removing liquidity)\n        pToken.safeApprove(platformAddress, 0);\n        pToken.safeApprove(platformAddress, type(uint256).max);\n        // Gauge for LP token\n        pToken.safeApprove(cvxDepositorAddress, 0);\n        pToken.safeApprove(cvxDepositorAddress, type(uint256).max);\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(assetToPToken[_asset] != address(0), \"Unsupported asset\");\n        // LP tokens in this contract. This should generally be nothing as we\n        // should always stake the full balance in the Gauge, but include for\n        // safety\n        uint256 contractPTokens = IERC20(pTokenAddress).balanceOf(\n            address(this)\n        );\n        uint256 gaugePTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n        uint256 totalPTokens = contractPTokens + gaugePTokens;\n\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        if (totalPTokens > 0) {\n            uint256 virtual_price = curvePool.get_virtual_price();\n            uint256 value = (totalPTokens * virtual_price) / 1e18;\n            uint256 assetDecimals = Helpers.getDecimals(_asset);\n            balance = value.scaleBy(assetDecimals, 18) / 3;\n        }\n    }\n\n    /**\n     * @dev Collect accumulated CRV and CVX and send to Vault.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Collect CRV and CVX\n        IRewardStaking(cvxRewardStakerAddress).getReward();\n        _collectRewardTokens();\n    }\n}\n"
    },
    "contracts/strategies/crosschain/AbstractCCTPIntegrator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title AbstractCCTPIntegrator\n * @author Origin Protocol Inc\n *\n * @dev Abstract contract that contains all the logic used to integrate with CCTP.\n */\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"../../utils/InitializableAbstractStrategy.sol\";\n\nimport { ICCTPTokenMessenger, ICCTPMessageTransmitter, IMessageHandlerV2 } from \"../../interfaces/cctp/ICCTP.sol\";\n\nimport { CrossChainStrategyHelper } from \"./CrossChainStrategyHelper.sol\";\nimport { Governable } from \"../../governance/Governable.sol\";\nimport { BytesHelper } from \"../../utils/BytesHelper.sol\";\nimport \"../../utils/Helpers.sol\";\n\nabstract contract AbstractCCTPIntegrator is Governable, IMessageHandlerV2 {\n    using SafeERC20 for IERC20;\n\n    using BytesHelper for bytes;\n    using CrossChainStrategyHelper for bytes;\n\n    event LastTransferNonceUpdated(uint64 lastTransferNonce);\n    event NonceProcessed(uint64 nonce);\n\n    event CCTPMinFinalityThresholdSet(uint16 minFinalityThreshold);\n    event CCTPFeePremiumBpsSet(uint16 feePremiumBps);\n    event OperatorChanged(address operator);\n    event TokensBridged(\n        uint32 destinationDomain,\n        address peerStrategy,\n        address tokenAddress,\n        uint256 tokenAmount,\n        uint256 maxFee,\n        uint32 minFinalityThreshold,\n        bytes hookData\n    );\n    event MessageTransmitted(\n        uint32 destinationDomain,\n        address peerStrategy,\n        uint32 minFinalityThreshold,\n        bytes message\n    );\n\n    // Message body V2 fields\n    // Ref: https://developers.circle.com/cctp/technical-guide#message-body\n    // Ref: https://github.com/circlefin/evm-cctp-contracts/blob/master/src/messages/v2/BurnMessageV2.sol\n    uint8 private constant BURN_MESSAGE_V2_VERSION_INDEX = 0;\n    uint8 private constant BURN_MESSAGE_V2_BURN_TOKEN_INDEX = 4;\n    uint8 private constant BURN_MESSAGE_V2_RECIPIENT_INDEX = 36;\n    uint8 private constant BURN_MESSAGE_V2_AMOUNT_INDEX = 68;\n    uint8 private constant BURN_MESSAGE_V2_MESSAGE_SENDER_INDEX = 100;\n    uint8 private constant BURN_MESSAGE_V2_FEE_EXECUTED_INDEX = 164;\n    uint8 private constant BURN_MESSAGE_V2_HOOK_DATA_INDEX = 228;\n\n    /**\n     * @notice  Max transfer threshold imposed by the CCTP\n     *          Ref: https://developers.circle.com/cctp/evm-smart-contracts#depositforburn\n     * @dev     10M USDC limit applies to both standard and fast transfer modes. The fast transfer mode has\n     *          an additional limitation that is not present on-chain and Circle may alter that amount off-chain\n     *          at their preference. The amount available for fast transfer can be queried here:\n     *          https://iris-api.circle.com/v2/fastBurn/USDC/allowance .\n     *          If a fast transfer token transaction has been issued and there is not enough allowance for it\n     *          the off-chain Iris component will re-attempt the transaction and if it fails it will fallback\n     *          to a standard transfer. Reference section 4.3 in the whitepaper:\n     *          https://6778953.fs1.hubspotusercontent-na1.net/hubfs/6778953/PDFs/Whitepapers/CCTPV2_White_Paper.pdf\n     */\n    uint256 public constant MAX_TRANSFER_AMOUNT = 10_000_000 * 10**6; // 10M USDC\n\n    /// @notice Minimum transfer amount to avoid zero or dust transfers\n    uint256 public constant MIN_TRANSFER_AMOUNT = 10**6;\n\n    // CCTP contracts\n    // This implementation assumes that remote and local chains have these contracts\n    // deployed on the same addresses.\n    /// @notice CCTP message transmitter contract\n    ICCTPMessageTransmitter public immutable cctpMessageTransmitter;\n    /// @notice CCTP token messenger contract\n    ICCTPTokenMessenger public immutable cctpTokenMessenger;\n\n    /// @notice USDC address on local chain\n    address public immutable usdcToken;\n\n    /// @notice USDC address on remote chain\n    address public immutable peerUsdcToken;\n\n    /// @notice Domain ID of the chain from which messages are accepted\n    uint32 public immutable peerDomainID;\n\n    /// @notice Strategy address on other chain\n    address public immutable peerStrategy;\n\n    /**\n     * @notice Minimum finality threshold\n     *         Can be 1000 (safe, after 1 epoch) or 2000 (finalized, after 2 epochs).\n     *         Ref: https://developers.circle.com/cctp/technical-guide#finality-thresholds\n     * @dev    When configuring the contract for fast transfer we should check the available\n     *         allowance of USDC that can be bridged using fast mode:\n     *         wget https://iris-api.circle.com/v2/fastBurn/USDC/allowance\n     */\n    uint16 public minFinalityThreshold;\n\n    /// @notice Fee premium in basis points\n    uint16 public feePremiumBps;\n\n    /// @notice Nonce of the last known deposit or withdrawal\n    uint64 public lastTransferNonce;\n\n    /// @notice Operator address: Can relay CCTP messages\n    address public operator;\n\n    /// @notice Mapping of processed nonces\n    mapping(uint64 => bool) private nonceProcessed;\n\n    // For future use\n    uint256[48] private __gap;\n\n    modifier onlyCCTPMessageTransmitter() {\n        require(\n            msg.sender == address(cctpMessageTransmitter),\n            \"Caller is not CCTP transmitter\"\n        );\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(msg.sender == operator, \"Caller is not the Operator\");\n        _;\n    }\n\n    /**\n     * @notice Configuration for CCTP integration\n     * @param cctpTokenMessenger Address of the CCTP token messenger contract\n     * @param cctpMessageTransmitter Address of the CCTP message transmitter contract\n     * @param peerDomainID Domain ID of the chain from which messages are accepted.\n     *         0 for Ethereum, 6 for Base, etc.\n     *         Ref: https://developers.circle.com/cctp/cctp-supported-blockchains\n     * @param peerStrategy Address of the master or remote strategy on the other chain\n     * @param usdcToken USDC address on local chain\n     */\n    struct CCTPIntegrationConfig {\n        address cctpTokenMessenger;\n        address cctpMessageTransmitter;\n        uint32 peerDomainID;\n        address peerStrategy;\n        address usdcToken;\n        address peerUsdcToken;\n    }\n\n    constructor(CCTPIntegrationConfig memory _config) {\n        require(_config.usdcToken != address(0), \"Invalid USDC address\");\n        require(\n            _config.peerUsdcToken != address(0),\n            \"Invalid peer USDC address\"\n        );\n        require(\n            _config.cctpTokenMessenger != address(0),\n            \"Invalid CCTP config\"\n        );\n        require(\n            _config.cctpMessageTransmitter != address(0),\n            \"Invalid CCTP config\"\n        );\n        require(\n            _config.peerStrategy != address(0),\n            \"Invalid peer strategy address\"\n        );\n\n        cctpMessageTransmitter = ICCTPMessageTransmitter(\n            _config.cctpMessageTransmitter\n        );\n        cctpTokenMessenger = ICCTPTokenMessenger(_config.cctpTokenMessenger);\n\n        // Domain ID of the chain from which messages are accepted\n        peerDomainID = _config.peerDomainID;\n\n        // Strategy address on other chain, should\n        // always be same as the proxy of this strategy\n        peerStrategy = _config.peerStrategy;\n\n        // USDC address on local chain\n        usdcToken = _config.usdcToken;\n\n        // Just a sanity check to ensure the base token is USDC\n        uint256 _usdcTokenDecimals = Helpers.getDecimals(_config.usdcToken);\n        string memory _usdcTokenSymbol = Helpers.getSymbol(_config.usdcToken);\n        require(_usdcTokenDecimals == 6, \"Base token decimals must be 6\");\n        require(\n            keccak256(abi.encodePacked(_usdcTokenSymbol)) ==\n                keccak256(abi.encodePacked(\"USDC\")),\n            \"Token symbol must be USDC\"\n        );\n\n        // USDC address on remote chain\n        peerUsdcToken = _config.peerUsdcToken;\n    }\n\n    /**\n     * @dev Initialize the implementation contract\n     * @param _operator Operator address\n     * @param _minFinalityThreshold Minimum finality threshold\n     * @param _feePremiumBps Fee premium in basis points\n     */\n    function _initialize(\n        address _operator,\n        uint16 _minFinalityThreshold,\n        uint16 _feePremiumBps\n    ) internal {\n        _setOperator(_operator);\n        _setMinFinalityThreshold(_minFinalityThreshold);\n        _setFeePremiumBps(_feePremiumBps);\n\n        // Nonce starts at 1, so assume nonce 0 as processed.\n        // NOTE: This will cause the deposit/withdraw to fail if the\n        // strategy is not initialized properly (which is expected).\n        nonceProcessed[0] = true;\n    }\n\n    /***************************************\n                    Settings\n    ****************************************/\n    /**\n     * @dev Set the operator address\n     * @param _operator Operator address\n     */\n    function setOperator(address _operator) external onlyGovernor {\n        _setOperator(_operator);\n    }\n\n    /**\n     * @dev Set the operator address\n     * @param _operator Operator address\n     */\n    function _setOperator(address _operator) internal {\n        operator = _operator;\n        emit OperatorChanged(_operator);\n    }\n\n    /**\n     * @dev Set the minimum finality threshold at which\n     *      the message is considered to be finalized to relay.\n     *      Only accepts a value of 1000 (Safe, after 1 epoch) or\n     *      2000 (Finalized, after 2 epochs).\n     * @param _minFinalityThreshold Minimum finality threshold\n     */\n    function setMinFinalityThreshold(uint16 _minFinalityThreshold)\n        external\n        onlyGovernor\n    {\n        _setMinFinalityThreshold(_minFinalityThreshold);\n    }\n\n    /**\n     * @dev Set the minimum finality threshold\n     * @param _minFinalityThreshold Minimum finality threshold\n     */\n    function _setMinFinalityThreshold(uint16 _minFinalityThreshold) internal {\n        // 1000 for fast transfer and 2000 for standard transfer\n        require(\n            _minFinalityThreshold == 1000 || _minFinalityThreshold == 2000,\n            \"Invalid threshold\"\n        );\n\n        minFinalityThreshold = _minFinalityThreshold;\n        emit CCTPMinFinalityThresholdSet(_minFinalityThreshold);\n    }\n\n    /**\n     * @dev Set the fee premium in basis points.\n     *      Cannot be higher than 30% (3000 basis points).\n     * @param _feePremiumBps Fee premium in basis points\n     */\n    function setFeePremiumBps(uint16 _feePremiumBps) external onlyGovernor {\n        _setFeePremiumBps(_feePremiumBps);\n    }\n\n    /**\n     * @dev Set the fee premium in basis points\n     *      Cannot be higher than 30% (3000 basis points).\n     *      Ref: https://developers.circle.com/cctp/technical-guide#fees\n     * @param _feePremiumBps Fee premium in basis points\n     */\n    function _setFeePremiumBps(uint16 _feePremiumBps) internal {\n        require(_feePremiumBps <= 3000, \"Fee premium too high\"); // 30%\n\n        feePremiumBps = _feePremiumBps;\n        emit CCTPFeePremiumBpsSet(_feePremiumBps);\n    }\n\n    /***************************************\n             CCTP message handling\n    ****************************************/\n\n    /**\n     * @dev Handles a finalized CCTP message\n     * @param sourceDomain Source domain of the message\n     * @param sender Sender of the message\n     * @param finalityThresholdExecuted Fidelity threshold executed\n     * @param messageBody Message body\n     */\n    function handleReceiveFinalizedMessage(\n        uint32 sourceDomain,\n        bytes32 sender,\n        uint32 finalityThresholdExecuted,\n        bytes memory messageBody\n    ) external override onlyCCTPMessageTransmitter returns (bool) {\n        // Make sure the finality threshold at execution is at least 2000\n        require(\n            finalityThresholdExecuted >= 2000,\n            \"Finality threshold too low\"\n        );\n\n        return _handleReceivedMessage(sourceDomain, sender, messageBody);\n    }\n\n    /**\n     * @dev Handles an unfinalized but safe CCTP message\n     * @param sourceDomain Source domain of the message\n     * @param sender Sender of the message\n     * @param finalityThresholdExecuted Fidelity threshold executed\n     * @param messageBody Message body\n     */\n    function handleReceiveUnfinalizedMessage(\n        uint32 sourceDomain,\n        bytes32 sender,\n        uint32 finalityThresholdExecuted,\n        bytes memory messageBody\n    ) external override onlyCCTPMessageTransmitter returns (bool) {\n        // Make sure the contract is configured to handle unfinalized messages\n        require(\n            minFinalityThreshold == 1000,\n            \"Unfinalized messages are not supported\"\n        );\n        // Make sure the finality threshold at execution is at least 1000\n        require(\n            finalityThresholdExecuted >= 1000,\n            \"Finality threshold too low\"\n        );\n\n        return _handleReceivedMessage(sourceDomain, sender, messageBody);\n    }\n\n    /**\n     * @dev Handles a CCTP message\n     * @param sourceDomain Source domain of the message\n     * @param sender Sender of the message\n     * @param messageBody Message body\n     */\n    function _handleReceivedMessage(\n        uint32 sourceDomain,\n        bytes32 sender,\n        bytes memory messageBody\n    ) internal returns (bool) {\n        require(sourceDomain == peerDomainID, \"Unknown Source Domain\");\n\n        // Extract address from bytes32 (CCTP stores addresses as right-padded bytes32)\n        address senderAddress = address(uint160(uint256(sender)));\n        require(senderAddress == peerStrategy, \"Unknown Sender\");\n\n        _onMessageReceived(messageBody);\n\n        return true;\n    }\n\n    /**\n     * @dev Sends tokens to the peer strategy using CCTP Token Messenger\n     * @param tokenAmount Amount of tokens to send\n     * @param hookData Hook data\n     */\n    function _sendTokens(uint256 tokenAmount, bytes memory hookData)\n        internal\n        virtual\n    {\n        // CCTP has a maximum transfer amount of 10M USDC per tx\n        require(tokenAmount <= MAX_TRANSFER_AMOUNT, \"Token amount too high\");\n\n        // Approve only what needs to be transferred\n        IERC20(usdcToken).safeApprove(address(cctpTokenMessenger), tokenAmount);\n\n        // Compute the max fee to be paid.\n        // Ref: https://developers.circle.com/cctp/evm-smart-contracts#getminfeeamount\n        // The right way to compute fees would be to use CCTP's getMinFeeAmount function.\n        // The issue is that the getMinFeeAmount is not present on v2.0 contracts, but is on\n        // v2.1. Some of CCTP's deployed contracts are v2.0, some are v2.1.\n        // We will only be using standard transfers and fee on those is 0 for now. If they\n        // ever start implementing fee for standard transfers or if we decide to use fast\n        // trasnfer, we can use feePremiumBps as a workaround.\n        uint256 maxFee = feePremiumBps > 0\n            ? (tokenAmount * feePremiumBps) / 10000\n            : 0;\n\n        // Send tokens to the peer strategy using CCTP Token Messenger\n        cctpTokenMessenger.depositForBurnWithHook(\n            tokenAmount,\n            peerDomainID,\n            bytes32(uint256(uint160(peerStrategy))),\n            address(usdcToken),\n            bytes32(uint256(uint160(peerStrategy))),\n            maxFee,\n            uint32(minFinalityThreshold),\n            hookData\n        );\n\n        emit TokensBridged(\n            peerDomainID,\n            peerStrategy,\n            usdcToken,\n            tokenAmount,\n            maxFee,\n            uint32(minFinalityThreshold),\n            hookData\n        );\n    }\n\n    /**\n     * @dev Sends a message to the peer strategy using CCTP Message Transmitter\n     * @param message Payload of the message to send\n     */\n    function _sendMessage(bytes memory message) internal virtual {\n        cctpMessageTransmitter.sendMessage(\n            peerDomainID,\n            bytes32(uint256(uint160(peerStrategy))),\n            bytes32(uint256(uint160(peerStrategy))),\n            uint32(minFinalityThreshold),\n            message\n        );\n\n        emit MessageTransmitted(\n            peerDomainID,\n            peerStrategy,\n            uint32(minFinalityThreshold),\n            message\n        );\n    }\n\n    /**\n     * @dev Receives a message from the peer strategy on the other chain,\n     *      does some basic checks and relays it to the local MessageTransmitterV2.\n     *      If the message is a burn message, it will also handle the hook data\n     *      and call the _onTokenReceived function.\n     * @param message Payload of the message to send\n     * @param attestation Attestation of the message\n     */\n    function relay(bytes memory message, bytes memory attestation)\n        external\n        onlyOperator\n    {\n        (\n            uint32 version,\n            uint32 sourceDomainID,\n            address sender,\n            address recipient,\n            bytes memory messageBody\n        ) = message.decodeMessageHeader();\n\n        // Ensure that it's a CCTP message\n        require(\n            version == CrossChainStrategyHelper.CCTP_MESSAGE_VERSION,\n            \"Invalid CCTP message version\"\n        );\n\n        // Ensure that the source domain is the peer domain\n        require(sourceDomainID == peerDomainID, \"Unknown Source Domain\");\n\n        // Ensure message body version\n        version = messageBody.extractUint32(BURN_MESSAGE_V2_VERSION_INDEX);\n\n        // NOTE: There's a possibility that the CCTP Token Messenger might\n        // send other types of messages in future, not just the burn message.\n        // If it ever comes to that, this shouldn't cause us any problems\n        // because it has to still go through the followign checks:\n        // - version check\n        // - message body length check\n        // - sender and recipient (which should be in the same slots and same as address(this))\n        // - hook data handling (which will revert even if all the above checks pass)\n        bool isBurnMessageV1 = sender == address(cctpTokenMessenger);\n\n        if (isBurnMessageV1) {\n            // Handle burn message\n            require(\n                version == 1 &&\n                    messageBody.length >= BURN_MESSAGE_V2_HOOK_DATA_INDEX,\n                \"Invalid burn message\"\n            );\n\n            // Ensure the burn token is USDC\n            address burnToken = messageBody.extractAddress(\n                BURN_MESSAGE_V2_BURN_TOKEN_INDEX\n            );\n            require(burnToken == peerUsdcToken, \"Invalid burn token\");\n\n            // Address of caller of depositForBurn (or depositForBurnWithCaller) on source domain\n            sender = messageBody.extractAddress(\n                BURN_MESSAGE_V2_MESSAGE_SENDER_INDEX\n            );\n\n            recipient = messageBody.extractAddress(\n                BURN_MESSAGE_V2_RECIPIENT_INDEX\n            );\n        } else {\n            // We handle only Burn message or our custom messagee\n            require(\n                version == CrossChainStrategyHelper.ORIGIN_MESSAGE_VERSION,\n                \"Unsupported message version\"\n            );\n        }\n\n        // Ensure the recipient is this contract\n        // Both sender and recipient should be deployed to same address on both chains.\n        require(address(this) == recipient, \"Unexpected recipient address\");\n        require(sender == peerStrategy, \"Incorrect sender/recipient address\");\n\n        // Relay the message\n        // This step also mints USDC and transfers it to the recipient wallet\n        bool relaySuccess = cctpMessageTransmitter.receiveMessage(\n            message,\n            attestation\n        );\n        require(relaySuccess, \"Receive message failed\");\n\n        if (isBurnMessageV1) {\n            // Extract the hook data from the message body\n            bytes memory hookData = messageBody.extractSlice(\n                BURN_MESSAGE_V2_HOOK_DATA_INDEX,\n                messageBody.length\n            );\n\n            // Extract the token amount from the message body\n            uint256 tokenAmount = messageBody.extractUint256(\n                BURN_MESSAGE_V2_AMOUNT_INDEX\n            );\n\n            // Extract the fee executed from the message body\n            uint256 feeExecuted = messageBody.extractUint256(\n                BURN_MESSAGE_V2_FEE_EXECUTED_INDEX\n            );\n\n            // Call the _onTokenReceived function\n            _onTokenReceived(tokenAmount - feeExecuted, feeExecuted, hookData);\n        }\n    }\n\n    /***************************************\n                  Message utils\n    ****************************************/\n\n    /***************************************\n                  Nonce Handling\n    ****************************************/\n    /**\n     * @dev Checks if the last known transfer is pending.\n     *      Nonce starts at 1, so 0 is disregarded.\n     * @return True if a transfer is pending, false otherwise\n     */\n    function isTransferPending() public view returns (bool) {\n        return !nonceProcessed[lastTransferNonce];\n    }\n\n    /**\n     * @dev Checks if a given nonce is processed.\n     *      Nonce starts at 1, so 0 is disregarded.\n     * @param nonce Nonce to check\n     * @return True if the nonce is processed, false otherwise\n     */\n    function isNonceProcessed(uint64 nonce) public view returns (bool) {\n        return nonceProcessed[nonce];\n    }\n\n    /**\n     * @dev Marks a given nonce as processed.\n     *      Can only mark nonce as processed once. New nonce should\n     *      always be greater than the last known nonce. Also updates\n     *      the last known nonce.\n     * @param nonce Nonce to mark as processed\n     */\n    function _markNonceAsProcessed(uint64 nonce) internal {\n        uint64 lastNonce = lastTransferNonce;\n\n        // Can only mark latest nonce as processed\n        // Master strategy when receiving a message from the remote strategy\n        // will have lastNone == nonce, as the nonce is increase at the start\n        // of deposit / withdrawal flow.\n        // Remote strategy will have lastNonce < nonce, as a new nonce initiated\n        // from master will be greater than the last one.\n        require(nonce >= lastNonce, \"Nonce too low\");\n        // Can only mark nonce as processed once\n        require(!nonceProcessed[nonce], \"Nonce already processed\");\n\n        nonceProcessed[nonce] = true;\n        emit NonceProcessed(nonce);\n\n        if (nonce != lastNonce) {\n            // Update last known nonce\n            lastTransferNonce = nonce;\n            emit LastTransferNonceUpdated(nonce);\n        }\n    }\n\n    /**\n     * @dev Gets the next nonce to use.\n     *      Nonce starts at 1, so 0 is disregarded.\n     *      Reverts if last nonce hasn't been processed yet.\n     * @return Next nonce\n     */\n    function _getNextNonce() internal returns (uint64) {\n        uint64 nonce = lastTransferNonce;\n\n        require(nonceProcessed[nonce], \"Pending token transfer\");\n\n        nonce = nonce + 1;\n        lastTransferNonce = nonce;\n        emit LastTransferNonceUpdated(nonce);\n\n        return nonce;\n    }\n\n    /***************************************\n             Inheritence overrides\n    ****************************************/\n\n    /**\n     * @dev Called when the USDC is received from the CCTP\n     * @param tokenAmount The actual amount of USDC received (amount sent - fee executed)\n     * @param feeExecuted The fee executed\n     * @param payload The payload of the message (hook data)\n     */\n    function _onTokenReceived(\n        uint256 tokenAmount,\n        uint256 feeExecuted,\n        bytes memory payload\n    ) internal virtual;\n\n    /**\n     * @dev Called when the message is received\n     * @param payload The payload of the message\n     */\n    function _onMessageReceived(bytes memory payload) internal virtual;\n}\n"
    },
    "contracts/strategies/crosschain/CrossChainMasterStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD Yearn V3 Master Strategy - the Mainnet part\n * @author Origin Protocol Inc\n *\n * @dev This strategy can only perform 1 deposit or withdrawal at a time. For that\n *      reason it shouldn't be configured as an asset default strategy.\n */\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { AbstractCCTPIntegrator } from \"./AbstractCCTPIntegrator.sol\";\nimport { CrossChainStrategyHelper } from \"./CrossChainStrategyHelper.sol\";\n\ncontract CrossChainMasterStrategy is\n    AbstractCCTPIntegrator,\n    InitializableAbstractStrategy\n{\n    using SafeERC20 for IERC20;\n    using CrossChainStrategyHelper for bytes;\n\n    /**\n     * @notice Remote strategy balance\n     * @dev    The remote balance is cached and might not reflect the actual\n     *         real-time balance of the remote strategy.\n     */\n    uint256 public remoteStrategyBalance;\n\n    /// @notice Amount that's bridged due to a pending Deposit process\n    ///         but with no acknowledgement from the remote strategy yet\n    uint256 public pendingAmount;\n\n    uint256 internal constant MAX_BALANCE_CHECK_AGE = 1 days;\n\n    event RemoteStrategyBalanceUpdated(uint256 balance);\n    event WithdrawRequested(address indexed asset, uint256 amount);\n    event WithdrawAllSkipped();\n    event BalanceCheckIgnored(uint64 nonce, uint256 timestamp, bool isTooOld);\n\n    /**\n     * @param _stratConfig The platform and OToken vault addresses\n     */\n    constructor(\n        BaseStrategyConfig memory _stratConfig,\n        CCTPIntegrationConfig memory _cctpConfig\n    )\n        InitializableAbstractStrategy(_stratConfig)\n        AbstractCCTPIntegrator(_cctpConfig)\n    {\n        require(\n            _stratConfig.platformAddress == address(0),\n            \"Invalid platform address\"\n        );\n        require(\n            _stratConfig.vaultAddress != address(0),\n            \"Invalid Vault address\"\n        );\n    }\n\n    /**\n     * @dev Initialize the strategy implementation\n     * @param _operator Address of the operator\n     * @param _minFinalityThreshold Minimum finality threshold\n     * @param _feePremiumBps Fee premium in basis points\n     */\n    function initialize(\n        address _operator,\n        uint16 _minFinalityThreshold,\n        uint16 _feePremiumBps\n    ) external virtual onlyGovernor initializer {\n        _initialize(_operator, _minFinalityThreshold, _feePremiumBps);\n\n        address[] memory rewardTokens = new address[](0);\n        address[] memory assets = new address[](0);\n        address[] memory pTokens = new address[](0);\n\n        InitializableAbstractStrategy._initialize(\n            rewardTokens,\n            assets,\n            pTokens\n        );\n    }\n\n    /// @inheritdoc InitializableAbstractStrategy\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /// @inheritdoc InitializableAbstractStrategy\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 balance = IERC20(usdcToken).balanceOf(address(this));\n        // Deposit if balance is greater than 1 USDC\n        if (balance >= MIN_TRANSFER_AMOUNT) {\n            _deposit(usdcToken, balance);\n        }\n    }\n\n    /// @inheritdoc InitializableAbstractStrategy\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_recipient == vaultAddress, \"Only Vault can withdraw\");\n        _withdraw(_asset, _amount);\n    }\n\n    /// @inheritdoc InitializableAbstractStrategy\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        if (isTransferPending()) {\n            // Do nothing if there is a pending transfer\n            // Note: We never want withdrawAll to fail, so\n            // emit an event to indicate that the withdrawal was skipped\n            emit WithdrawAllSkipped();\n            return;\n        }\n\n        // Withdraw everything in Remote strategy\n        uint256 _remoteBalance = remoteStrategyBalance;\n        if (_remoteBalance < MIN_TRANSFER_AMOUNT) {\n            // Do nothing if there is less than 1 USDC in the Remote strategy\n            return;\n        }\n\n        _withdraw(\n            usdcToken,\n            _remoteBalance > MAX_TRANSFER_AMOUNT\n                ? MAX_TRANSFER_AMOUNT\n                : _remoteBalance\n        );\n    }\n\n    /**\n     * @notice Check the balance of the strategy that includes\n     *          the balance of the asset on this contract,\n     *          the amount of the asset being bridged,\n     *          and the balance reported by the Remote strategy.\n     * @param _asset Address of the asset to check\n     * @return balance Total balance of the asset\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == usdcToken, \"Unsupported asset\");\n\n        // USDC balance on this contract\n        // + USDC being bridged\n        // + USDC cached in the corresponding Remote part of this contract\n        return\n            IERC20(usdcToken).balanceOf(address(this)) +\n            pendingAmount +\n            remoteStrategyBalance;\n    }\n\n    /// @inheritdoc InitializableAbstractStrategy\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == usdcToken;\n    }\n\n    /// @inheritdoc InitializableAbstractStrategy\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {}\n\n    /// @inheritdoc InitializableAbstractStrategy\n    function _abstractSetPToken(address, address) internal override {}\n\n    /// @inheritdoc InitializableAbstractStrategy\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {}\n\n    /// @inheritdoc AbstractCCTPIntegrator\n    function _onMessageReceived(bytes memory payload) internal override {\n        if (\n            payload.getMessageType() ==\n            CrossChainStrategyHelper.BALANCE_CHECK_MESSAGE\n        ) {\n            // Received when Remote strategy checks the balance\n            _processBalanceCheckMessage(payload);\n            return;\n        }\n\n        revert(\"Unknown message type\");\n    }\n\n    /// @inheritdoc AbstractCCTPIntegrator\n    function _onTokenReceived(\n        uint256 tokenAmount,\n        // solhint-disable-next-line no-unused-vars\n        uint256 feeExecuted,\n        bytes memory payload\n    ) internal override {\n        uint64 _nonce = lastTransferNonce;\n\n        // Should be expecting an acknowledgement\n        require(!isNonceProcessed(_nonce), \"Nonce already processed\");\n\n        // Now relay to the regular flow\n        // NOTE: Calling _onMessageReceived would mean that we are bypassing a\n        // few checks that the regular flow does (like sourceDomainID check\n        // and sender check in `handleReceiveFinalizedMessage`). However,\n        // CCTPMessageRelayer relays the message first (which will go through\n        // all the checks) and not update balance and then finally calls this\n        // `_onTokenReceived` which will update the balance.\n        // So, if any of the checks fail during the first no-balance-update flow,\n        // this won't happen either, since the tx would revert.\n        _onMessageReceived(payload);\n\n        // Send any tokens in the contract to the Vault\n        uint256 usdcBalance = IERC20(usdcToken).balanceOf(address(this));\n        // Should always have enough tokens\n        require(usdcBalance >= tokenAmount, \"Insufficient balance\");\n        // Transfer all tokens to the Vault to not leave any dust\n        IERC20(usdcToken).safeTransfer(vaultAddress, usdcBalance);\n\n        // Emit withdrawal amount\n        emit Withdrawal(usdcToken, usdcToken, usdcBalance);\n    }\n\n    /**\n     * @dev Bridge and deposit asset into the remote strategy\n     * @param _asset Address of the asset to deposit\n     * @param depositAmount Amount of the asset to deposit\n     */\n    function _deposit(address _asset, uint256 depositAmount) internal virtual {\n        require(_asset == usdcToken, \"Unsupported asset\");\n        require(pendingAmount == 0, \"Unexpected pending amount\");\n        // Deposit at least 1 USDC\n        require(\n            depositAmount >= MIN_TRANSFER_AMOUNT,\n            \"Deposit amount too small\"\n        );\n        require(\n            depositAmount <= MAX_TRANSFER_AMOUNT,\n            \"Deposit amount too high\"\n        );\n\n        // Get the next nonce\n        // Note: reverts if a transfer is pending\n        uint64 nonce = _getNextNonce();\n\n        // Set pending amount\n        pendingAmount = depositAmount;\n\n        // Build deposit message payload\n        bytes memory message = CrossChainStrategyHelper.encodeDepositMessage(\n            nonce,\n            depositAmount\n        );\n\n        // Send deposit message to the remote strategy\n        _sendTokens(depositAmount, message);\n\n        // Emit deposit event\n        emit Deposit(_asset, _asset, depositAmount);\n    }\n\n    /**\n     * @dev Send a withdraw request to the remote strategy\n     * @param _asset Address of the asset to withdraw\n     * @param _amount Amount of the asset to withdraw\n     */\n    function _withdraw(address _asset, uint256 _amount) internal virtual {\n        require(_asset == usdcToken, \"Unsupported asset\");\n        // Withdraw at least 1 USDC\n        require(_amount >= MIN_TRANSFER_AMOUNT, \"Withdraw amount too small\");\n        require(\n            _amount <= remoteStrategyBalance,\n            \"Withdraw amount exceeds remote strategy balance\"\n        );\n        require(\n            _amount <= MAX_TRANSFER_AMOUNT,\n            \"Withdraw amount exceeds max transfer amount\"\n        );\n\n        // Get the next nonce\n        // Note: reverts if a transfer is pending\n        uint64 nonce = _getNextNonce();\n\n        // Build and send withdrawal message with payload\n        bytes memory message = CrossChainStrategyHelper.encodeWithdrawMessage(\n            nonce,\n            _amount\n        );\n        _sendMessage(message);\n\n        // Emit WithdrawRequested event here,\n        // Withdraw will be emitted in _onTokenReceived\n        emit WithdrawRequested(usdcToken, _amount);\n    }\n\n    /**\n     * @dev Process balance check:\n     *  - Confirms a deposit to the remote strategy\n     *  - Skips balance update if there's a pending withdrawal\n     *  - Updates the remote strategy balance\n     * @param message The message containing the nonce and balance\n     */\n    function _processBalanceCheckMessage(bytes memory message)\n        internal\n        virtual\n    {\n        // Decode the message\n        // When transferConfirmation is true, it means that the message is a result of a deposit or a withdrawal\n        // process.\n        (\n            uint64 nonce,\n            uint256 balance,\n            bool transferConfirmation,\n            uint256 timestamp\n        ) = message.decodeBalanceCheckMessage();\n        // Get the last cached nonce\n        uint64 _lastCachedNonce = lastTransferNonce;\n\n        if (nonce != _lastCachedNonce) {\n            // If nonce is not the last cached nonce, it is an outdated message\n            // Ignore it\n            return;\n        }\n\n        // A received message nonce not yet processed indicates there is a\n        // deposit or withdrawal in progress.\n        bool transferInProgress = isTransferPending();\n\n        if (transferInProgress) {\n            if (transferConfirmation) {\n                // Apply the effects of the deposit / withdrawal completion\n                _markNonceAsProcessed(nonce);\n                pendingAmount = 0;\n            } else {\n                // A balanceCheck arrived that is not part of the deposit / withdrawal process\n                // that has been generated on the Remote contract after the deposit / withdrawal which is\n                // still pending. This can happen when the CCTP bridge delivers the messages out of order.\n                // Ignore it, since the pending deposit / withdrawal must first be cofirmed.\n                emit BalanceCheckIgnored(nonce, timestamp, false);\n                return;\n            }\n        } else {\n            if (block.timestamp > timestamp + MAX_BALANCE_CHECK_AGE) {\n                // Balance check is too old, ignore it\n                emit BalanceCheckIgnored(nonce, timestamp, true);\n                return;\n            }\n        }\n\n        // At this point update the strategy balance the balanceCheck message is either:\n        // - a confirmation of a deposit / withdrawal\n        // - a message that updates balances when no deposit / withdrawal is in progress\n        remoteStrategyBalance = balance;\n        emit RemoteStrategyBalanceUpdated(balance);\n    }\n}\n"
    },
    "contracts/strategies/crosschain/CrossChainRemoteStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title CrossChainRemoteStrategy\n * @author Origin Protocol Inc\n *\n * @dev Part of the cross-chain strategy that lives on the remote chain.\n *      Handles deposits and withdrawals from the master strategy on peer chain\n *      and locally deposits the funds to a 4626 compatible vault.\n */\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { IERC4626 } from \"../../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { Generalized4626Strategy } from \"../Generalized4626Strategy.sol\";\nimport { AbstractCCTPIntegrator } from \"./AbstractCCTPIntegrator.sol\";\nimport { CrossChainStrategyHelper } from \"./CrossChainStrategyHelper.sol\";\nimport { InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { Strategizable } from \"../../governance/Strategizable.sol\";\n\ncontract CrossChainRemoteStrategy is\n    AbstractCCTPIntegrator,\n    Generalized4626Strategy,\n    Strategizable\n{\n    using SafeERC20 for IERC20;\n    using CrossChainStrategyHelper for bytes;\n\n    event DepositUnderlyingFailed(string reason);\n    event WithdrawalFailed(uint256 amountRequested, uint256 amountAvailable);\n    event WithdrawUnderlyingFailed(string reason);\n\n    modifier onlyOperatorOrStrategistOrGovernor() {\n        require(\n            msg.sender == operator ||\n                msg.sender == strategistAddr ||\n                isGovernor(),\n            \"Caller is not the Operator, Strategist or the Governor\"\n        );\n        _;\n    }\n\n    modifier onlyGovernorOrStrategist()\n        override(InitializableAbstractStrategy, Strategizable) {\n        require(\n            msg.sender == strategistAddr || isGovernor(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    constructor(\n        BaseStrategyConfig memory _baseConfig,\n        CCTPIntegrationConfig memory _cctpConfig\n    )\n        AbstractCCTPIntegrator(_cctpConfig)\n        Generalized4626Strategy(_baseConfig, _cctpConfig.usdcToken)\n    {\n        require(usdcToken == address(assetToken), \"Token mismatch\");\n        require(\n            _baseConfig.platformAddress != address(0),\n            \"Invalid platform address\"\n        );\n        // Vault address must always be address(0) for the remote strategy\n        require(\n            _baseConfig.vaultAddress == address(0),\n            \"Invalid vault address\"\n        );\n    }\n\n    /**\n     * @dev Initialize the strategy implementation\n     * @param _strategist Address of the strategist\n     * @param _operator Address of the operator\n     * @param _minFinalityThreshold Minimum finality threshold\n     * @param _feePremiumBps Fee premium in basis points\n     */\n    function initialize(\n        address _strategist,\n        address _operator,\n        uint16 _minFinalityThreshold,\n        uint16 _feePremiumBps\n    ) external virtual onlyGovernor initializer {\n        _initialize(_operator, _minFinalityThreshold, _feePremiumBps);\n        _setStrategistAddr(_strategist);\n\n        address[] memory rewardTokens = new address[](0);\n        address[] memory assets = new address[](1);\n        address[] memory pTokens = new address[](1);\n\n        assets[0] = address(usdcToken);\n        pTokens[0] = address(platformAddress);\n\n        InitializableAbstractStrategy._initialize(\n            rewardTokens,\n            assets,\n            pTokens\n        );\n    }\n\n    /// @inheritdoc Generalized4626Strategy\n    function deposit(address _asset, uint256 _amount)\n        external\n        virtual\n        override\n        onlyGovernorOrStrategist\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /// @inheritdoc Generalized4626Strategy\n    function depositAll()\n        external\n        virtual\n        override\n        onlyGovernorOrStrategist\n        nonReentrant\n    {\n        _deposit(usdcToken, IERC20(usdcToken).balanceOf(address(this)));\n    }\n\n    /// @inheritdoc Generalized4626Strategy\n    /// @dev Interface requires a recipient, but for compatibility it must be address(this).\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external virtual override onlyGovernorOrStrategist nonReentrant {\n        _withdraw(_recipient, _asset, _amount);\n    }\n\n    /// @inheritdoc Generalized4626Strategy\n    function withdrawAll()\n        external\n        virtual\n        override\n        onlyGovernorOrStrategist\n        nonReentrant\n    {\n        IERC4626 platform = IERC4626(platformAddress);\n        _withdraw(\n            address(this),\n            usdcToken,\n            platform.previewRedeem(platform.balanceOf(address(this)))\n        );\n    }\n\n    /// @inheritdoc AbstractCCTPIntegrator\n    function _onMessageReceived(bytes memory payload) internal override {\n        uint32 messageType = payload.getMessageType();\n        if (messageType == CrossChainStrategyHelper.DEPOSIT_MESSAGE) {\n            // Received when Master strategy sends tokens to the remote strategy\n            // Do nothing because we receive acknowledgement with token transfer,\n            // so _onTokenReceived will handle it\n        } else if (messageType == CrossChainStrategyHelper.WITHDRAW_MESSAGE) {\n            // Received when Master strategy requests a withdrawal\n            _processWithdrawMessage(payload);\n        } else {\n            revert(\"Unknown message type\");\n        }\n    }\n\n    /**\n     * @dev Process deposit message from peer strategy\n     * @param tokenAmount Amount of tokens received\n     * @param feeExecuted Fee executed\n     * @param payload Payload of the message\n     */\n    function _processDepositMessage(\n        // solhint-disable-next-line no-unused-vars\n        uint256 tokenAmount,\n        // solhint-disable-next-line no-unused-vars\n        uint256 feeExecuted,\n        bytes memory payload\n    ) internal virtual {\n        (uint64 nonce, ) = payload.decodeDepositMessage();\n\n        // Replay protection is part of the _markNonceAsProcessed function\n        _markNonceAsProcessed(nonce);\n\n        // Deposit everything we got, not just what was bridged\n        uint256 balance = IERC20(usdcToken).balanceOf(address(this));\n\n        // Underlying call to deposit funds can fail. It mustn't affect the overall\n        // flow as confirmation message should still be sent.\n        if (balance >= MIN_TRANSFER_AMOUNT) {\n            _deposit(usdcToken, balance);\n        }\n\n        // Send balance check message to the peer strategy\n        bytes memory message = CrossChainStrategyHelper\n            .encodeBalanceCheckMessage(\n                lastTransferNonce,\n                checkBalance(usdcToken),\n                true,\n                block.timestamp\n            );\n        _sendMessage(message);\n    }\n\n    /**\n     * @dev Deposit assets by converting them to shares\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal override {\n        // By design, this function should not revert. Otherwise, it'd\n        // not be able to process messages and might freeze the contracts\n        // state. However these two require statements would never fail\n        // in every function invoking this. The same kind of checks should\n        // be enforced in all the calling functions for these two and any\n        // other require statements added to this function.\n        require(_amount > 0, \"Must deposit something\");\n        require(_asset == address(usdcToken), \"Unexpected asset address\");\n\n        // This call can fail, and the failure doesn't need to bubble up to the _processDepositMessage function\n        // as the flow is not affected by the failure.\n\n        try IERC4626(platformAddress).deposit(_amount, address(this)) {\n            emit Deposit(_asset, address(shareToken), _amount);\n        } catch Error(string memory reason) {\n            emit DepositUnderlyingFailed(\n                string(abi.encodePacked(\"Deposit failed: \", reason))\n            );\n        } catch (bytes memory lowLevelData) {\n            emit DepositUnderlyingFailed(\n                string(\n                    abi.encodePacked(\n                        \"Deposit failed: low-level call failed with data \",\n                        lowLevelData\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Process withdrawal message from peer strategy\n     * @param payload Payload of the message\n     */\n    function _processWithdrawMessage(bytes memory payload) internal virtual {\n        (uint64 nonce, uint256 withdrawAmount) = payload\n            .decodeWithdrawMessage();\n\n        // Replay protection is part of the _markNonceAsProcessed function\n        _markNonceAsProcessed(nonce);\n\n        uint256 usdcBalance = IERC20(usdcToken).balanceOf(address(this));\n\n        if (usdcBalance < withdrawAmount) {\n            // Withdraw the missing funds from the remote strategy. This call can fail and\n            // the failure doesn't bubble up to the _processWithdrawMessage function\n            _withdraw(address(this), usdcToken, withdrawAmount - usdcBalance);\n\n            // Update the possible increase in the balance on the contract.\n            usdcBalance = IERC20(usdcToken).balanceOf(address(this));\n        }\n\n        // Check balance after withdrawal\n        uint256 strategyBalance = checkBalance(usdcToken);\n\n        // If there are some tokens to be sent AND the balance is sufficient\n        // to satisfy the withdrawal request then send the funds to the peer strategy.\n        // In case a direct withdraw(All) has previously been called\n        // there is a possibility of USDC funds remaining on the contract.\n        // A separate withdraw to extract or deposit to the Morpho vault needs to be\n        // initiated from the peer Master strategy to utilise USDC funds.\n        if (\n            withdrawAmount >= MIN_TRANSFER_AMOUNT &&\n            usdcBalance >= withdrawAmount\n        ) {\n            // The new balance on the contract needs to have USDC subtracted from it as\n            // that will be withdrawn in the next step\n            bytes memory message = CrossChainStrategyHelper\n                .encodeBalanceCheckMessage(\n                    lastTransferNonce,\n                    strategyBalance - withdrawAmount,\n                    true,\n                    block.timestamp\n                );\n            _sendTokens(withdrawAmount, message);\n        } else {\n            // Contract either:\n            // - only has small dust amount of USDC\n            // - doesn't have sufficient funds to satisfy the withdrawal request\n            // In both cases send the balance update message to the peer strategy.\n            bytes memory message = CrossChainStrategyHelper\n                .encodeBalanceCheckMessage(\n                    lastTransferNonce,\n                    strategyBalance,\n                    true,\n                    block.timestamp\n                );\n            _sendMessage(message);\n            emit WithdrawalFailed(withdrawAmount, usdcBalance);\n        }\n    }\n\n    /**\n     * @dev Withdraw asset by burning shares\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function _withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) internal override {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient == address(this), \"Invalid recipient\");\n        require(_asset == address(usdcToken), \"Unexpected asset address\");\n\n        // This call can fail, and the failure doesn't need to bubble up to the _processWithdrawMessage function\n        // as the flow is not affected by the failure.\n        try\n            // slither-disable-next-line unused-return\n            IERC4626(platformAddress).withdraw(\n                _amount,\n                address(this),\n                address(this)\n            )\n        {\n            emit Withdrawal(_asset, address(shareToken), _amount);\n        } catch Error(string memory reason) {\n            emit WithdrawUnderlyingFailed(\n                string(abi.encodePacked(\"Withdrawal failed: \", reason))\n            );\n        } catch (bytes memory lowLevelData) {\n            emit WithdrawUnderlyingFailed(\n                string(\n                    abi.encodePacked(\n                        \"Withdrawal failed: low-level call failed with data \",\n                        lowLevelData\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Process token received message from peer strategy\n     * @param tokenAmount Amount of tokens received\n     * @param feeExecuted Fee executed\n     * @param payload Payload of the message\n     */\n    function _onTokenReceived(\n        uint256 tokenAmount,\n        uint256 feeExecuted,\n        bytes memory payload\n    ) internal override {\n        uint32 messageType = payload.getMessageType();\n\n        require(\n            messageType == CrossChainStrategyHelper.DEPOSIT_MESSAGE,\n            \"Invalid message type\"\n        );\n\n        _processDepositMessage(tokenAmount, feeExecuted, payload);\n    }\n\n    /**\n     * @dev Send balance update message to the peer strategy\n     */\n    function sendBalanceUpdate()\n        external\n        virtual\n        onlyOperatorOrStrategistOrGovernor\n    {\n        uint256 balance = checkBalance(usdcToken);\n        bytes memory message = CrossChainStrategyHelper\n            .encodeBalanceCheckMessage(\n                lastTransferNonce,\n                balance,\n                false,\n                block.timestamp\n            );\n        _sendMessage(message);\n    }\n\n    /**\n     * @notice Get the total asset value held in the platform and contract\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform and contract\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        require(_asset == usdcToken, \"Unexpected asset address\");\n        /**\n         * Balance of USDC on the contract is counted towards the total balance, since a deposit\n         * to the Morpho V2 might fail and the USDC might remain on this contract as a result of a\n         * bridged transfer.\n         */\n        uint256 balanceOnContract = IERC20(usdcToken).balanceOf(address(this));\n\n        IERC4626 platform = IERC4626(platformAddress);\n        return\n            platform.previewRedeem(platform.balanceOf(address(this))) +\n            balanceOnContract;\n    }\n}\n"
    },
    "contracts/strategies/crosschain/CrossChainStrategyHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title CrossChainStrategyHelper\n * @author Origin Protocol Inc\n * @dev This library is used to encode and decode the messages for the cross-chain strategy.\n *      It is used to ensure that the messages are valid and to get the message version and type.\n */\n\nimport { BytesHelper } from \"../../utils/BytesHelper.sol\";\n\nlibrary CrossChainStrategyHelper {\n    using BytesHelper for bytes;\n\n    uint32 public constant DEPOSIT_MESSAGE = 1;\n    uint32 public constant WITHDRAW_MESSAGE = 2;\n    uint32 public constant BALANCE_CHECK_MESSAGE = 3;\n\n    uint32 public constant CCTP_MESSAGE_VERSION = 1;\n    uint32 public constant ORIGIN_MESSAGE_VERSION = 1010;\n\n    // CCTP Message Header fields\n    // Ref: https://developers.circle.com/cctp/technical-guide#message-header\n    uint8 private constant VERSION_INDEX = 0;\n    uint8 private constant SOURCE_DOMAIN_INDEX = 4;\n    uint8 private constant SENDER_INDEX = 44;\n    uint8 private constant RECIPIENT_INDEX = 76;\n    uint8 private constant MESSAGE_BODY_INDEX = 148;\n\n    /**\n     * @dev Get the message version from the message.\n     *      It should always be 4 bytes long,\n     *      starting from the 0th index.\n     * @param message The message to get the version from\n     * @return The message version\n     */\n    function getMessageVersion(bytes memory message)\n        internal\n        pure\n        returns (uint32)\n    {\n        // uint32 bytes 0 to 4 is Origin message version\n        // uint32 bytes 4 to 8 is Message type\n        return message.extractUint32(0);\n    }\n\n    /**\n     * @dev Get the message type from the message.\n     *      It should always be 4 bytes long,\n     *      starting from the 4th index.\n     * @param message The message to get the type from\n     * @return The message type\n     */\n    function getMessageType(bytes memory message)\n        internal\n        pure\n        returns (uint32)\n    {\n        // uint32 bytes 0 to 4 is Origin message version\n        // uint32 bytes 4 to 8 is Message type\n        return message.extractUint32(4);\n    }\n\n    /**\n     * @dev Verify the message version and type.\n     *      The message version should be the same as the Origin message version,\n     *      and the message type should be the same as the expected message type.\n     * @param _message The message to verify\n     * @param _type The expected message type\n     */\n    function verifyMessageVersionAndType(bytes memory _message, uint32 _type)\n        internal\n        pure\n    {\n        require(\n            getMessageVersion(_message) == ORIGIN_MESSAGE_VERSION,\n            \"Invalid Origin Message Version\"\n        );\n        require(getMessageType(_message) == _type, \"Invalid Message type\");\n    }\n\n    /**\n     * @dev Get the message payload from the message.\n     *      The payload starts at the 8th byte.\n     * @param message The message to get the payload from\n     * @return The message payload\n     */\n    function getMessagePayload(bytes memory message)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        // uint32 bytes 0 to 4 is Origin message version\n        // uint32 bytes 4 to 8 is Message type\n        // Payload starts at byte 8\n        return message.extractSlice(8, message.length);\n    }\n\n    /**\n     * @dev Encode the deposit message.\n     *      The message version and type are always encoded in the message.\n     * @param nonce The nonce of the deposit\n     * @param depositAmount The amount of the deposit\n     * @return The encoded deposit message\n     */\n    function encodeDepositMessage(uint64 nonce, uint256 depositAmount)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return\n            abi.encodePacked(\n                ORIGIN_MESSAGE_VERSION,\n                DEPOSIT_MESSAGE,\n                abi.encode(nonce, depositAmount)\n            );\n    }\n\n    /**\n     * @dev Decode the deposit message.\n     *      The message version and type are verified in the message.\n     * @param message The message to decode\n     * @return The nonce and the amount of the deposit\n     */\n    function decodeDepositMessage(bytes memory message)\n        internal\n        pure\n        returns (uint64, uint256)\n    {\n        verifyMessageVersionAndType(message, DEPOSIT_MESSAGE);\n\n        (uint64 nonce, uint256 depositAmount) = abi.decode(\n            getMessagePayload(message),\n            (uint64, uint256)\n        );\n        return (nonce, depositAmount);\n    }\n\n    /**\n     * @dev Encode the withdrawal message.\n     *      The message version and type are always encoded in the message.\n     * @param nonce The nonce of the withdrawal\n     * @param withdrawAmount The amount of the withdrawal\n     * @return The encoded withdrawal message\n     */\n    function encodeWithdrawMessage(uint64 nonce, uint256 withdrawAmount)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return\n            abi.encodePacked(\n                ORIGIN_MESSAGE_VERSION,\n                WITHDRAW_MESSAGE,\n                abi.encode(nonce, withdrawAmount)\n            );\n    }\n\n    /**\n     * @dev Decode the withdrawal message.\n     *      The message version and type are verified in the message.\n     * @param message The message to decode\n     * @return The nonce and the amount of the withdrawal\n     */\n    function decodeWithdrawMessage(bytes memory message)\n        internal\n        pure\n        returns (uint64, uint256)\n    {\n        verifyMessageVersionAndType(message, WITHDRAW_MESSAGE);\n\n        (uint64 nonce, uint256 withdrawAmount) = abi.decode(\n            getMessagePayload(message),\n            (uint64, uint256)\n        );\n        return (nonce, withdrawAmount);\n    }\n\n    /**\n     * @dev Encode the balance check message.\n     *      The message version and type are always encoded in the message.\n     * @param nonce The nonce of the balance check\n     * @param balance The balance to check\n     * @param transferConfirmation Indicates if the message is a transfer confirmation. This is true\n     *                            when the message is a result of a deposit or a withdrawal.\n     * @return The encoded balance check message\n     */\n    function encodeBalanceCheckMessage(\n        uint64 nonce,\n        uint256 balance,\n        bool transferConfirmation,\n        uint256 timestamp\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                ORIGIN_MESSAGE_VERSION,\n                BALANCE_CHECK_MESSAGE,\n                abi.encode(nonce, balance, transferConfirmation, timestamp)\n            );\n    }\n\n    /**\n     * @dev Decode the balance check message.\n     *      The message version and type are verified in the message.\n     * @param message The message to decode\n     * @return The nonce, the balance and indicates if the message is a transfer confirmation\n     */\n    function decodeBalanceCheckMessage(bytes memory message)\n        internal\n        pure\n        returns (\n            uint64,\n            uint256,\n            bool,\n            uint256\n        )\n    {\n        verifyMessageVersionAndType(message, BALANCE_CHECK_MESSAGE);\n\n        (\n            uint64 nonce,\n            uint256 balance,\n            bool transferConfirmation,\n            uint256 timestamp\n        ) = abi.decode(\n                getMessagePayload(message),\n                (uint64, uint256, bool, uint256)\n            );\n        return (nonce, balance, transferConfirmation, timestamp);\n    }\n\n    /**\n     * @dev Decode the CCTP message header\n     * @param message Message to decode\n     * @return version Version of the message\n     * @return sourceDomainID Source domain ID\n     * @return sender Sender of the message\n     * @return recipient Recipient of the message\n     * @return messageBody Message body\n     */\n    function decodeMessageHeader(bytes memory message)\n        internal\n        pure\n        returns (\n            uint32 version,\n            uint32 sourceDomainID,\n            address sender,\n            address recipient,\n            bytes memory messageBody\n        )\n    {\n        version = message.extractUint32(VERSION_INDEX);\n        sourceDomainID = message.extractUint32(SOURCE_DOMAIN_INDEX);\n        // Address of MessageTransmitterV2 caller on source domain\n        sender = message.extractAddress(SENDER_INDEX);\n        // Address to handle message body on destination domain\n        recipient = message.extractAddress(RECIPIENT_INDEX);\n        messageBody = message.extractSlice(MESSAGE_BODY_INDEX, message.length);\n    }\n}\n"
    },
    "contracts/strategies/CurveAMOStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Curve Automated Market Maker (AMO) Strategy\n * @notice AMO strategy for a Curve pool using an OToken.\n * @author Origin Protocol Inc\n */\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { ICurveStableSwapNG } from \"../interfaces/ICurveStableSwapNG.sol\";\nimport { ICurveLiquidityGaugeV6 } from \"../interfaces/ICurveLiquidityGaugeV6.sol\";\nimport { IBasicToken } from \"../interfaces/IBasicToken.sol\";\nimport { ICurveMinter } from \"../interfaces/ICurveMinter.sol\";\n\ncontract CurveAMOStrategy is InitializableAbstractStrategy {\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    /**\n     * @dev a threshold under which the contract no longer allows for the protocol to manually rebalance.\n     *      Guarding against a strategist / guardian being taken over and with multiple transactions\n     *      draining the protocol funds.\n     */\n    uint256 public constant SOLVENCY_THRESHOLD = 0.998 ether;\n\n    // New immutable variables that must be set in the constructor\n    /**\n     * @notice Address of the hard asset (weth, usdt, usdc).\n     */\n    IERC20 public immutable hardAsset;\n\n    /**\n     * @notice Address of the OTOKEN token contract.\n     */\n    IERC20 public immutable oToken;\n\n    /**\n     * @notice Address of the LP (Liquidity Provider) token contract.\n     */\n    IERC20 public immutable lpToken;\n\n    /**\n     * @notice Address of the Curve StableSwap NG pool contract.\n     */\n    ICurveStableSwapNG public immutable curvePool;\n\n    /**\n     * @notice Address of the Curve X-Chain Liquidity Gauge contract.\n     */\n    ICurveLiquidityGaugeV6 public immutable gauge;\n\n    /**\n     * @notice Address of the Curve Minter contract.\n     */\n    ICurveMinter public immutable minter;\n\n    /**\n     * @notice Index of the OTOKEN and hardAsset in the Curve pool.\n     */\n    uint128 public immutable otokenCoinIndex;\n    uint128 public immutable hardAssetCoinIndex;\n\n    /**\n     * @notice Decimals of the OTOKEN and hardAsset.\n     */\n    uint8 public immutable decimalsOToken;\n    uint8 public immutable decimalsHardAsset;\n\n    /**\n     * @notice Maximum slippage allowed for adding/removing liquidity from the Curve pool.\n     */\n    uint256 public maxSlippage;\n\n    event MaxSlippageUpdated(uint256 newMaxSlippage);\n\n    /**\n     * @dev Verifies that the caller is the Strategist.\n     */\n    modifier onlyStrategist() {\n        require(\n            msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Strategist\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Checks the Curve pool's balances have improved and the balances\n     * have not tipped to the other side.\n     * This modifier is only applied to functions that do a single sided add or remove.\n     * The standard deposit function adds to both sides of the pool in a way that\n     * the pool's balance is not worsened.\n     * Withdrawals are proportional so doesn't change the pools asset balance.\n     */\n    modifier improvePoolBalance() {\n        // Get the hard asset and OToken balances in the Curve pool\n        uint256[] memory balancesBefore = curvePool.get_balances();\n        // diff = hardAsset balance - OTOKEN balance\n        int256 diffBefore = (\n            balancesBefore[hardAssetCoinIndex].scaleBy(\n                decimalsOToken,\n                decimalsHardAsset\n            )\n        ).toInt256() - balancesBefore[otokenCoinIndex].toInt256();\n\n        _;\n\n        // Get the hard asset and OToken balances in the Curve pool\n        uint256[] memory balancesAfter = curvePool.get_balances();\n        // diff = hardAsset balance - OTOKEN balance\n        int256 diffAfter = (\n            balancesAfter[hardAssetCoinIndex].scaleBy(\n                decimalsOToken,\n                decimalsHardAsset\n            )\n        ).toInt256() - balancesAfter[otokenCoinIndex].toInt256();\n\n        if (diffBefore == 0) {\n            require(diffAfter == 0, \"Position balance is worsened\");\n        } else if (diffBefore < 0) {\n            // If the pool was originally imbalanced in favor of OTOKEN, then\n            // we want to check that the pool is now more balanced\n            require(diffAfter <= 0, \"OTokens overshot peg\");\n            require(diffBefore < diffAfter, \"OTokens balance worse\");\n        } else if (diffBefore > 0) {\n            // If the pool was originally imbalanced in favor of hardAsset, then\n            // we want to check that the pool is now more balanced\n            require(diffAfter >= 0, \"Assets overshot peg\");\n            require(diffAfter < diffBefore, \"Assets balance worse\");\n        }\n    }\n\n    constructor(\n        BaseStrategyConfig memory _baseConfig,\n        address _otoken,\n        address _hardAsset,\n        address _gauge,\n        address _minter\n    ) InitializableAbstractStrategy(_baseConfig) {\n        lpToken = IERC20(_baseConfig.platformAddress);\n        curvePool = ICurveStableSwapNG(_baseConfig.platformAddress);\n        minter = ICurveMinter(_minter);\n\n        oToken = IERC20(_otoken);\n        hardAsset = IERC20(_hardAsset);\n        gauge = ICurveLiquidityGaugeV6(_gauge);\n        decimalsHardAsset = IBasicToken(_hardAsset).decimals();\n        decimalsOToken = IBasicToken(_otoken).decimals();\n\n        (hardAssetCoinIndex, otokenCoinIndex) = curvePool.coins(0) == _hardAsset\n            ? (0, 1)\n            : (1, 0);\n        require(\n            curvePool.coins(otokenCoinIndex) == _otoken &&\n                curvePool.coins(hardAssetCoinIndex) == _hardAsset,\n            \"Invalid coin indexes\"\n        );\n        require(gauge.lp_token() == address(curvePool), \"Invalid pool\");\n    }\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Curve strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Address of CRV\n     * @param _maxSlippage Maximum slippage allowed for adding/removing liquidity from the Curve pool.\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // CRV\n        uint256 _maxSlippage\n    ) external onlyGovernor initializer {\n        address[] memory pTokens = new address[](1);\n        pTokens[0] = address(curvePool);\n\n        address[] memory _assets = new address[](1);\n        _assets[0] = address(hardAsset);\n\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            pTokens\n        );\n\n        _approveBase();\n        _setMaxSlippage(_maxSlippage);\n    }\n\n    /***************************************\n                    Deposit\n    ****************************************/\n\n    /**\n     * @notice Deposit hard asset into the Curve pool\n     * @param _hardAsset Address of hard asset contract.\n     * @param _amount Amount of hard asset to deposit.\n     */\n    function deposit(address _hardAsset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_hardAsset, _amount);\n    }\n\n    function _deposit(address _hardAsset, uint256 _hardAssetAmount) internal {\n        require(_hardAssetAmount > 0, \"Must deposit something\");\n        require(_hardAsset == address(hardAsset), \"Unsupported asset\");\n\n        emit Deposit(_hardAsset, address(lpToken), _hardAssetAmount);\n        uint256 scaledHardAssetAmount = _hardAssetAmount.scaleBy(\n            decimalsOToken,\n            decimalsHardAsset\n        );\n\n        // Get the asset and OToken balances in the Curve pool\n        uint256[] memory balances = curvePool.get_balances();\n        // safe to cast since min value is at least 0\n        uint256 otokenToAdd = uint256(\n            _max(\n                0,\n                (\n                    balances[hardAssetCoinIndex].scaleBy(\n                        decimalsOToken,\n                        decimalsHardAsset\n                    )\n                ).toInt256() +\n                    scaledHardAssetAmount.toInt256() -\n                    balances[otokenCoinIndex].toInt256()\n            )\n        );\n\n        /* Add so much OTOKEN so that the pool ends up being balanced. And at minimum\n         * add as much OTOKEN as hard asset and at maximum twice as much OTOKEN.\n         */\n        otokenToAdd = Math.max(otokenToAdd, scaledHardAssetAmount);\n        otokenToAdd = Math.min(otokenToAdd, scaledHardAssetAmount * 2);\n\n        /* Mint OTOKEN with a strategy that attempts to contribute to stability of OTOKEN/hardAsset pool. Try\n         * to mint so much OTOKEN that after deployment of liquidity pool ends up being balanced.\n         *\n         * To manage unpredictability minimal OTOKEN minted will always be at least equal or greater\n         * to hardAsset amount deployed. And never larger than twice the hardAsset amount deployed even if\n         * it would have a further beneficial effect on pool stability.\n         */\n        IVault(vaultAddress).mintForStrategy(otokenToAdd);\n\n        emit Deposit(address(oToken), address(lpToken), otokenToAdd);\n\n        uint256[] memory _amounts = new uint256[](2);\n        _amounts[hardAssetCoinIndex] = _hardAssetAmount;\n        _amounts[otokenCoinIndex] = otokenToAdd;\n\n        uint256 valueInLpTokens = (scaledHardAssetAmount + otokenToAdd)\n            .divPrecisely(curvePool.get_virtual_price());\n        uint256 minMintAmount = valueInLpTokens.mulTruncate(\n            uint256(1e18) - maxSlippage\n        );\n\n        // Do the deposit to the Curve pool\n        uint256 lpDeposited = curvePool.add_liquidity(_amounts, minMintAmount);\n        require(lpDeposited >= minMintAmount, \"Min LP amount error\");\n\n        // Deposit the Curve pool's LP tokens into the Curve gauge\n        gauge.deposit(lpDeposited);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n    }\n\n    /**\n     * @notice Deposit the strategy's entire balance of hardAsset into the Curve pool\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 balance = hardAsset.balanceOf(address(this));\n        if (balance > 0) {\n            _deposit(address(hardAsset), balance);\n        }\n    }\n\n    /***************************************\n                    Withdraw\n    ****************************************/\n\n    /**\n     * @notice Withdraw hardAsset and OTOKEN from the Curve pool, burn the OTOKEN,\n     * transfer hardAsset to the recipient.\n     * @param _recipient Address to receive withdrawn asset which is normally the Vault.\n     * @param _hardAsset Address of the hardAsset contract.\n     * @param _amount Amount of hardAsset to withdraw.\n     */\n    function withdraw(\n        address _recipient,\n        address _hardAsset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_amount > 0, \"Must withdraw something\");\n        require(\n            _hardAsset == address(hardAsset),\n            \"Can only withdraw hard asset\"\n        );\n\n        emit Withdrawal(_hardAsset, address(lpToken), _amount);\n\n        uint256 requiredLpTokens = calcTokenToBurn(\n            _amount.scaleBy(decimalsOToken, decimalsHardAsset)\n        );\n\n        _lpWithdraw(requiredLpTokens);\n\n        /* math in requiredLpTokens should correctly calculate the amount of LP to remove\n         * in that the strategy receives enough hardAsset on balanced removal\n         */\n        uint256[] memory _minWithdrawalAmounts = new uint256[](2);\n        _minWithdrawalAmounts[hardAssetCoinIndex] = _amount;\n        // slither-disable-next-line unused-return\n        curvePool.remove_liquidity(requiredLpTokens, _minWithdrawalAmounts);\n\n        // Burn all the removed OTOKEN and any that was left in the strategy\n        uint256 otokenToBurn = oToken.balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(otokenToBurn);\n\n        emit Withdrawal(address(oToken), address(lpToken), otokenToBurn);\n\n        // Transfer hardAsset to the recipient\n        hardAsset.safeTransfer(_recipient, _amount);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n    }\n\n    function calcTokenToBurn(uint256 _hardAssetAmount)\n        internal\n        view\n        returns (uint256 lpToBurn)\n    {\n        /* The rate between coins in the pool determines the rate at which pool returns\n         * tokens when doing balanced removal (remove_liquidity call). And by knowing how much hardAsset\n         * we want we can determine how much of OTOKEN we receive by removing liquidity.\n         *\n         * Because we are doing balanced removal we should be making profit when removing liquidity in a\n         * pool tilted to either side.\n         *\n         * Important: A downside is that the Strategist / Governor needs to be\n         * cognisant of not removing too much liquidity. And while the proposal to remove liquidity\n         * is being voted on the pool tilt might change so much that the proposal that has been valid while\n         * created is no longer valid.\n         */\n\n        uint256 poolHardAssetBalance = curvePool\n            .balances(hardAssetCoinIndex)\n            .scaleBy(decimalsOToken, decimalsHardAsset);\n        /* K is multiplied by 1e36 which is used for higher precision calculation of required\n         * pool LP tokens. Without it the end value can have rounding errors up to precision of\n         * 10 digits. This way we move the decimal point by 36 places when doing the calculation\n         * and again by 36 places when we are done with it.\n         */\n        uint256 k = (1e36 * lpToken.totalSupply()) / poolHardAssetBalance;\n        // prettier-ignore\n        // slither-disable-next-line divide-before-multiply\n        uint256 diff = (_hardAssetAmount + 1) * k;\n        lpToBurn = diff / 1e36;\n    }\n\n    /**\n     * @notice Remove all hardAsset and OTOKEN from the Curve pool, burn the OTOKEN,\n     * transfer hardAsset to the Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        uint256 gaugeTokens = gauge.balanceOf(address(this));\n        _lpWithdraw(gaugeTokens);\n\n        // Withdraws are proportional to assets held by 3Pool\n        uint256[] memory minWithdrawAmounts = new uint256[](2);\n\n        // Check balance of LP tokens in the strategy, if 0 return\n        uint256 lpBalance = lpToken.balanceOf(address(this));\n\n        // Remove liquidity\n        // slither-disable-next-line unused-return\n        if (lpBalance > 0) {\n            curvePool.remove_liquidity(lpBalance, minWithdrawAmounts);\n        }\n\n        // Burn all OTOKEN\n        uint256 otokenToBurn = oToken.balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(otokenToBurn);\n\n        // Get the strategy contract's hardAsset balance.\n        // This includes all that was removed from the Curve pool and\n        // any hardAsset that was sitting in the strategy contract before the removal.\n        uint256 hardAssetBalance = hardAsset.balanceOf(address(this));\n        hardAsset.safeTransfer(vaultAddress, hardAssetBalance);\n\n        if (hardAssetBalance > 0)\n            emit Withdrawal(\n                address(hardAsset),\n                address(lpToken),\n                hardAssetBalance\n            );\n        if (otokenToBurn > 0)\n            emit Withdrawal(address(oToken), address(lpToken), otokenToBurn);\n    }\n\n    /***************************************\n            Curve pool Rebalancing\n    ****************************************/\n\n    /**\n     * @notice Mint OTokens and one-sided add to the Curve pool.\n     * This is used when the Curve pool does not have enough OTokens and too many hardAsset.\n     * The OToken/Asset, eg OTOKEN/hardAsset, price with increase.\n     * The amount of assets in the vault is unchanged.\n     * The total supply of OTokens is increased.\n     * The asset value of the strategy and vault is increased.\n     * @param _oTokens The amount of OTokens to be minted and added to the pool.\n     */\n    function mintAndAddOTokens(uint256 _oTokens)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n    {\n        IVault(vaultAddress).mintForStrategy(_oTokens);\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[otokenCoinIndex] = _oTokens;\n\n        // Convert OTOKEN to Curve pool LP tokens\n        uint256 valueInLpTokens = (_oTokens).divPrecisely(\n            curvePool.get_virtual_price()\n        );\n        // Apply slippage to LP tokens\n        uint256 minMintAmount = valueInLpTokens.mulTruncate(\n            uint256(1e18) - maxSlippage\n        );\n\n        // Add the minted OTokens to the Curve pool\n        uint256 lpDeposited = curvePool.add_liquidity(amounts, minMintAmount);\n        require(lpDeposited >= minMintAmount, \"Min LP amount error\");\n\n        // Deposit the Curve pool LP tokens to the Curve gauge\n        gauge.deposit(lpDeposited);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n\n        emit Deposit(address(oToken), address(lpToken), _oTokens);\n    }\n\n    /**\n     * @notice One-sided remove of OTokens from the Curve pool which are then burned.\n     * This is used when the Curve pool has too many OTokens and not enough hardAsset.\n     * The amount of assets in the vault is unchanged.\n     * The total supply of OTokens is reduced.\n     * The asset value of the strategy and vault is reduced.\n     * @param _lpTokens The amount of Curve pool LP tokens to be burned for OTokens.\n     */\n    function removeAndBurnOTokens(uint256 _lpTokens)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n    {\n        // Withdraw Curve pool LP tokens from gauge and remove OTokens from the Curve pool\n        uint256 otokenToBurn = _withdrawAndRemoveFromPool(\n            _lpTokens,\n            otokenCoinIndex\n        );\n\n        // The vault burns the OTokens from this strategy\n        IVault(vaultAddress).burnForStrategy(otokenToBurn);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n\n        emit Withdrawal(address(oToken), address(lpToken), otokenToBurn);\n    }\n\n    /**\n     * @notice One-sided remove of hardAsset from the Curve pool and transfer to the vault.\n     * This is used when the Curve pool does not have enough OTokens and too many hardAsset.\n     * The OToken/Asset, eg OTOKEN/hardAsset, price with decrease.\n     * The amount of assets in the vault increases.\n     * The total supply of OTokens does not change.\n     * The asset value of the strategy reduces.\n     * The asset value of the vault should be close to the same.\n     * @param _lpTokens The amount of Curve pool LP tokens to be burned for hardAsset.\n     * @dev Curve pool LP tokens is used rather than hardAsset assets as Curve does not\n     * have a way to accurately calculate the amount of LP tokens for a required\n     * amount of hardAsset. Curve's `calc_token_amount` function does not include fees.\n     * A 3rd party library can be used that takes into account the fees, but this\n     * is a gas intensive process. It's easier for the trusted strategist to\n     * calculate the amount of Curve pool LP tokens required off-chain.\n     */\n    function removeOnlyAssets(uint256 _lpTokens)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n    {\n        // Withdraw Curve pool LP tokens from Curve gauge and remove hardAsset from the Curve pool\n        uint256 hardAssetAmount = _withdrawAndRemoveFromPool(\n            _lpTokens,\n            hardAssetCoinIndex\n        );\n\n        // Transfer hardAsset to the vault\n        hardAsset.safeTransfer(vaultAddress, hardAssetAmount);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n\n        emit Withdrawal(address(hardAsset), address(lpToken), hardAssetAmount);\n    }\n\n    /**\n     * @dev Remove Curve pool LP tokens from the gauge and\n     * do a one-sided remove of hardAsset or OTOKEN from the Curve pool.\n     * @param _lpTokens The amount of Curve pool LP tokens to be removed from the gauge\n     * @param coinIndex The index of the coin to be removed from the Curve pool. 0 = hardAsset, 1 = OTOKEN.\n     * @return coinsRemoved The amount of hardAsset or OTOKEN removed from the Curve pool.\n     */\n    function _withdrawAndRemoveFromPool(uint256 _lpTokens, uint128 coinIndex)\n        internal\n        returns (uint256 coinsRemoved)\n    {\n        // Withdraw Curve pool LP tokens from Curve gauge\n        _lpWithdraw(_lpTokens);\n\n        // Convert Curve pool LP tokens to hardAsset value\n        uint256 valueInEth = _lpTokens.mulTruncate(\n            curvePool.get_virtual_price()\n        );\n\n        if (coinIndex == hardAssetCoinIndex) {\n            valueInEth = valueInEth.scaleBy(decimalsHardAsset, decimalsOToken);\n        }\n\n        // Apply slippage to hardAsset value\n        uint256 minAmount = valueInEth.mulTruncate(uint256(1e18) - maxSlippage);\n\n        // Remove just the hardAsset from the Curve pool\n        coinsRemoved = curvePool.remove_liquidity_one_coin(\n            _lpTokens,\n            int128(coinIndex),\n            minAmount,\n            address(this)\n        );\n    }\n\n    /**\n     * Checks that the protocol is solvent, protecting from a rogue Strategist / Guardian that can\n     * keep rebalancing the pool in both directions making the protocol lose a tiny amount of\n     * funds each time.\n     *\n     * Protocol must be at least SOLVENCY_THRESHOLD (99,8 %) backed in order for the rebalances to\n     * function.\n     */\n    function _solvencyAssert() internal view {\n        uint256 _totalVaultValue = IVault(vaultAddress).totalValue();\n        uint256 _totalOtokenSupply = oToken.totalSupply();\n\n        if (\n            _totalVaultValue.divPrecisely(_totalOtokenSupply) <\n            SOLVENCY_THRESHOLD\n        ) {\n            revert(\"Protocol insolvent\");\n        }\n    }\n\n    /***************************************\n                Assets and Rewards\n    ****************************************/\n\n    /**\n     * @notice Collect accumulated CRV (and other) rewards and send to the Harvester.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Collect CRV rewards from inflation\n        minter.mint(address(gauge));\n\n        // Collect extra gauge rewards (outside of CRV)\n        gauge.claim_rewards();\n\n        _collectRewardTokens();\n    }\n\n    function _lpWithdraw(uint256 _lpAmount) internal {\n        require(\n            gauge.balanceOf(address(this)) >= _lpAmount,\n            \"Insufficient LP tokens\"\n        );\n        // withdraw lp tokens from the gauge without claiming rewards\n        gauge.withdraw(_lpAmount);\n    }\n\n    /**\n     * @notice Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == address(hardAsset), \"Unsupported asset\");\n\n        // hardAsset balance needed here for the balance check that happens from vault during depositing.\n        balance = hardAsset.balanceOf(address(this));\n        uint256 lpTokens = gauge.balanceOf(address(this));\n        if (lpTokens > 0) {\n            balance += ((lpTokens * curvePool.get_virtual_price()) / 1e18)\n                .scaleBy(decimalsHardAsset, decimalsOToken);\n        }\n    }\n\n    /**\n     * @notice Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == address(hardAsset);\n    }\n\n    /***************************************\n                    Approvals\n    ****************************************/\n\n    /**\n     * @notice Sets the maximum slippage allowed for any swap/liquidity operation\n     * @param _maxSlippage Maximum slippage allowed, 1e18 = 100%.\n     */\n    function setMaxSlippage(uint256 _maxSlippage) external onlyGovernor {\n        _setMaxSlippage(_maxSlippage);\n    }\n\n    function _setMaxSlippage(uint256 _maxSlippage) internal {\n        require(_maxSlippage <= 5e16, \"Slippage must be less than 100%\");\n        maxSlippage = _maxSlippage;\n        emit MaxSlippageUpdated(_maxSlippage);\n    }\n\n    /**\n     * @notice Approve the spending of all assets by their corresponding pool tokens,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        _approveBase();\n    }\n\n    /**\n     * @dev Since we are unwrapping WETH before depositing it to Curve\n     *      there is no need to set an approval for WETH on the Curve\n     *      pool\n     * @param _asset Address of the asset\n     * @param _pToken Address of the Curve LP token\n     */\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        override\n    {}\n\n    function _approveBase() internal {\n        // Approve Curve pool for OTOKEN (required for adding liquidity)\n        // slither-disable-next-line unused-return\n        oToken.approve(platformAddress, type(uint256).max);\n\n        // Approve Curve pool for hardAsset (required for adding liquidity)\n        // slither-disable-next-line unused-return\n        hardAsset.safeApprove(platformAddress, type(uint256).max);\n\n        // Approve Curve gauge contract to transfer Curve pool LP tokens\n        // This is needed for deposits if Curve pool LP tokens into the Curve gauge.\n        // slither-disable-next-line unused-return\n        lpToken.approve(address(gauge), type(uint256).max);\n    }\n\n    /**\n     * @dev Returns the largest of two numbers int256 version\n     */\n    function _max(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n}\n"
    },
    "contracts/strategies/Generalized4626Strategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Generalized 4626 Strategy\n * @notice Investment strategy for ERC-4626 Tokenized Vaults\n * @author Origin Protocol Inc\n */\nimport { IERC4626 } from \"../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { IDistributor } from \"../interfaces/IMerkl.sol\";\n\ncontract Generalized4626Strategy is InitializableAbstractStrategy {\n    /// @notice The address of the Merkle Distributor contract.\n    IDistributor public constant merkleDistributor =\n        IDistributor(0x3Ef3D8bA38EBe18DB133cEc108f4D14CE00Dd9Ae);\n\n    /// @dev Replaced with an immutable variable\n    // slither-disable-next-line constable-states\n    address private _deprecate_shareToken;\n    /// @dev Replaced with an immutable variable\n    // slither-disable-next-line constable-states\n    address private _deprecate_assetToken;\n\n    IERC20 public immutable shareToken;\n    IERC20 public immutable assetToken;\n\n    // For future use\n    uint256[50] private __gap;\n\n    event ClaimedRewards(address indexed token, uint256 amount);\n\n    /**\n     * @param _baseConfig Base strategy config with platformAddress (ERC-4626 Vault contract), eg sfrxETH or sDAI,\n     * and vaultAddress (OToken Vault contract), eg VaultProxy or OETHVaultProxy\n     * @param _assetToken Address of the ERC-4626 asset token. eg frxETH or DAI\n     */\n    constructor(BaseStrategyConfig memory _baseConfig, address _assetToken)\n        InitializableAbstractStrategy(_baseConfig)\n    {\n        shareToken = IERC20(_baseConfig.platformAddress);\n        assetToken = IERC20(_assetToken);\n    }\n\n    function initialize() external virtual onlyGovernor initializer {\n        address[] memory rewardTokens = new address[](0);\n        address[] memory assets = new address[](1);\n        address[] memory pTokens = new address[](1);\n\n        assets[0] = address(assetToken);\n        pTokens[0] = address(platformAddress);\n\n        InitializableAbstractStrategy._initialize(\n            rewardTokens,\n            assets,\n            pTokens\n        );\n    }\n\n    /**\n     * @dev Deposit assets by converting them to shares\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        virtual\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @dev Deposit assets by converting them to shares\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal virtual {\n        require(_amount > 0, \"Must deposit something\");\n        require(_asset == address(assetToken), \"Unexpected asset address\");\n\n        // slither-disable-next-line unused-return\n        IERC4626(platformAddress).deposit(_amount, address(this));\n        emit Deposit(_asset, address(shareToken), _amount);\n    }\n\n    /**\n     * @dev Deposit the entire balance of assetToken to gain shareToken\n     */\n    function depositAll() external virtual override onlyVault nonReentrant {\n        uint256 balance = assetToken.balanceOf(address(this));\n        if (balance > 0) {\n            _deposit(address(assetToken), balance);\n        }\n    }\n\n    /**\n     * @dev Withdraw asset by burning shares\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external virtual override onlyVault nonReentrant {\n        _withdraw(_recipient, _asset, _amount);\n    }\n\n    function _withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) internal virtual {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n        require(_asset == address(assetToken), \"Unexpected asset address\");\n\n        // slither-disable-next-line unused-return\n        IERC4626(platformAddress).withdraw(_amount, _recipient, address(this));\n        emit Withdrawal(_asset, address(shareToken), _amount);\n    }\n\n    /**\n     * @dev Internal method to respond to the addition of new asset / share tokens\n     */\n    function _abstractSetPToken(address, address) internal virtual override {\n        _approveBase();\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll()\n        external\n        virtual\n        override\n        onlyVaultOrGovernor\n        nonReentrant\n    {\n        uint256 shareBalance = shareToken.balanceOf(address(this));\n        uint256 assetAmount = 0;\n        if (shareBalance > 0) {\n            assetAmount = IERC4626(platformAddress).redeem(\n                shareBalance,\n                vaultAddress,\n                address(this)\n            );\n            emit Withdrawal(\n                address(assetToken),\n                address(shareToken),\n                assetAmount\n            );\n        }\n    }\n\n    /**\n     * @notice Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        virtual\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == address(assetToken), \"Unexpected asset address\");\n        /* We are intentionally not counting the amount of assetToken parked on the\n         * contract toward the checkBalance. The deposit and withdraw functions\n         * should not result in assetToken being unused and owned by this strategy\n         * contract.\n         */\n        IERC4626 platform = IERC4626(platformAddress);\n        return platform.previewRedeem(platform.balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Governor approves the ERC-4626 Tokenized Vault to spend the asset.\n     */\n    function safeApproveAllTokens() external override onlyGovernor {\n        _approveBase();\n    }\n\n    function _approveBase() internal virtual {\n        // Approval the asset to be transferred to the ERC-4626 Tokenized Vault.\n        // Used by the ERC-4626 deposit() and mint() functions\n        // slither-disable-next-line unused-return\n        assetToken.approve(platformAddress, type(uint256).max);\n    }\n\n    /**\n     * @dev Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _asset == address(assetToken);\n    }\n\n    /**\n     * @notice is not supported for this strategy as the asset and\n     * ERC-4626 Tokenized Vault are set at deploy time.\n     * @dev If the ERC-4626 Tokenized Vault needed to be changed, a new\n     * contract would need to be deployed and the proxy updated.\n     */\n    function setPTokenAddress(address, address) external override onlyGovernor {\n        revert(\"unsupported function\");\n    }\n\n    /**\n     * @notice is not supported for this strategy as the asset and\n     * ERC-4626 Tokenized Vault are set at deploy time.\n     * @dev If the ERC-4626 Tokenized Vault needed to be changed, a new\n     * contract would need to be deployed and the proxy updated.\n     */\n    function removePToken(uint256) external override onlyGovernor {\n        revert(\"unsupported function\");\n    }\n\n    /// @notice Claim tokens from the Merkle Distributor\n    /// @param token The address of the token to claim.\n    /// @param amount The amount of tokens to claim.\n    /// @param proof The Merkle proof to validate the claim.\n    function merkleClaim(\n        address token,\n        uint256 amount,\n        bytes32[] calldata proof\n    ) external {\n        address[] memory users = new address[](1);\n        users[0] = address(this);\n\n        address[] memory tokens = new address[](1);\n        tokens[0] = token;\n\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = amount;\n\n        bytes32[][] memory proofs = new bytes32[][](1);\n        proofs[0] = proof;\n\n        merkleDistributor.claim(users, tokens, amounts, proofs);\n\n        emit ClaimedRewards(token, amount);\n    }\n}\n"
    },
    "contracts/strategies/Generalized4626USDTStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IUSDT {\n    // Tether's approve does not return a bool like standard IERC20 contracts\n    // slither-disable-next-line erc20-interface\n    function approve(address _spender, uint256 _value) external;\n}\n\n/**\n * @title Generalized 4626 Strategy when asset is Tether USD (USDT)\n * @notice Investment strategy for ERC-4626 Tokenized Vaults for the USDT asset.\n * @author Origin Protocol Inc\n */\nimport { Generalized4626Strategy } from \"./Generalized4626Strategy.sol\";\n\ncontract Generalized4626USDTStrategy is Generalized4626Strategy {\n    /**\n     * @param _baseConfig Base strategy config with platformAddress (ERC-4626 Vault contract), eg sfrxETH or sDAI,\n     * and vaultAddress (OToken Vault contract), eg VaultProxy or OETHVaultProxy\n     * @param _assetToken Address of the ERC-4626 asset token. eg frxETH or DAI\n     */\n    constructor(BaseStrategyConfig memory _baseConfig, address _assetToken)\n        Generalized4626Strategy(_baseConfig, _assetToken)\n    {}\n\n    /// @dev Override for Tether as USDT does not return a bool on approve.\n    /// Using assetToken.approve will fail as it expects a bool return value\n    function _approveBase() internal virtual override {\n        // Approval the asset to be transferred to the ERC-4626 Tokenized Vault.\n        // Used by the ERC-4626 deposit() and mint() functions\n        // slither-disable-next-line unused-return\n        IUSDT(address(assetToken)).approve(platformAddress, type(uint256).max);\n    }\n}\n"
    },
    "contracts/strategies/IAave.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface for Aaves Lending Pool\n * Documentation: https://developers.aave.com/#lendingpool\n */\ninterface IAaveLendingPool {\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n}\n\n/**\n * @dev Interface for Aaves Lending Pool\n * Documentation: https://developers.aave.com/#lendingpooladdressesprovider\n */\ninterface ILendingPoolAddressesProvider {\n    /**\n     * @notice Get the current address for Aave LendingPool\n     * @dev Lending pool is the core contract on which to call deposit\n     */\n    function getLendingPool() external view returns (address);\n}\n"
    },
    "contracts/strategies/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IAaveIncentivesController {\n    event RewardsAccrued(address indexed user, uint256 amount);\n\n    event RewardsClaimed(\n        address indexed user,\n        address indexed to,\n        uint256 amount\n    );\n\n    event RewardsClaimed(\n        address indexed user,\n        address indexed to,\n        address indexed claimer,\n        uint256 amount\n    );\n\n    event ClaimerSet(address indexed user, address indexed claimer);\n\n    /*\n     * @dev Returns the configuration of the distribution for a certain asset\n     * @param asset The address of the reference asset of the distribution\n     * @return The asset index, the emission per second and the last updated timestamp\n     **/\n    function getAssetData(address asset)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    /**\n     * @dev Whitelists an address to claim the rewards on behalf of another address\n     * @param user The address of the user\n     * @param claimer The address of the claimer\n     */\n    function setClaimer(address user, address claimer) external;\n\n    /**\n     * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\n     * @param user The address of the user\n     * @return The claimer address\n     */\n    function getClaimer(address user) external view returns (address);\n\n    /**\n     * @dev Configure assets for a certain rewards emission\n     * @param assets The assets to incentivize\n     * @param emissionsPerSecond The emission for each asset\n     */\n    function configureAssets(\n        address[] calldata assets,\n        uint256[] calldata emissionsPerSecond\n    ) external;\n\n    /**\n     * @dev Called by the corresponding asset on any update that affects the rewards distribution\n     * @param asset The address of the user\n     * @param userBalance The balance of the user of the asset in the lending pool\n     * @param totalSupply The total supply of the asset in the lending pool\n     **/\n    function handleAction(\n        address asset,\n        uint256 userBalance,\n        uint256 totalSupply\n    ) external;\n\n    /**\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n     * @param user The address of the user\n     * @return The rewards\n     **/\n    function getRewardsBalance(address[] calldata assets, address user)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Claims reward for an user, on all the assets of the lending pool,\n     * accumulating the pending rewards\n     * @param amount Amount of rewards to claim\n     * @param to Address that will be receiving the rewards\n     * @return Rewards claimed\n     **/\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Claims reward for an user on behalf, on all the assets of the\n     * lending pool, accumulating the pending rewards. The caller must\n     * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n     * @param amount Amount of rewards to claim\n     * @param user Address to check and claim rewards\n     * @param to Address that will be receiving the rewards\n     * @return Rewards claimed\n     **/\n    function claimRewardsOnBehalf(\n        address[] calldata assets,\n        uint256 amount,\n        address user,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev returns the unclaimed rewards of the user\n     * @param user the address of the user\n     * @return the unclaimed user rewards\n     */\n    function getUserUnclaimedRewards(address user)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev returns the unclaimed rewards of the user\n     * @param user the address of the user\n     * @param asset The asset to incentivize\n     * @return the user index for the asset\n     */\n    function getUserAssetData(address user, address asset)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev for backward compatibility with previous implementation of the Incentives controller\n     */\n    function REWARD_TOKEN() external view returns (address);\n\n    /**\n     * @dev for backward compatibility with previous implementation of the Incentives controller\n     */\n    function PRECISION() external view returns (uint8);\n\n    /**\n     * @dev Gets the distribution end timestamp of the emissions\n     */\n    function DISTRIBUTION_END() external view returns (uint256);\n}\n"
    },
    "contracts/strategies/IAaveStakeToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IAaveStakedToken {\n    function COOLDOWN_SECONDS() external returns (uint256);\n\n    function UNSTAKE_WINDOW() external returns (uint256);\n\n    function balanceOf(address addr) external returns (uint256);\n\n    function redeem(address to, uint256 amount) external;\n\n    function stakersCooldowns(address addr) external returns (uint256);\n\n    function cooldown() external;\n}\n"
    },
    "contracts/strategies/ICompound.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @dev Compound C Token interface\n * Documentation: https://compound.finance/developers/ctokens\n */\ninterface ICERC20 {\n    /**\n     * @notice The mint function transfers an asset into the protocol, which begins accumulating\n     * interest based on the current Supply Rate for the asset. The user receives a quantity of\n     * cTokens equal to the underlying tokens supplied, divided by the current Exchange Rate.\n     * @param mintAmount The amount of the asset to be supplied, in units of the underlying asset.\n     * @return 0 on success, otherwise an Error codes\n     */\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise an error code.\n     */\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    /**\n     * @notice The redeem underlying function converts cTokens into a specified quantity of the underlying\n     * asset, and returns them to the user. The amount of cTokens redeemed is equal to the quantity of\n     * underlying tokens received, divided by the current Exchange Rate. The amount redeemed must be less\n     * than the user's Account Liquidity and the market's available liquidity.\n     * @param redeemAmount The amount of underlying to be redeemed.\n     * @return 0 on success, otherwise an error code.\n     */\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    /**\n     * @notice The user's underlying balance, representing their assets in the protocol, is equal to\n     * the user's cToken balance multiplied by the Exchange Rate.\n     * @param owner The account to get the underlying balance of.\n     * @return The amount of underlying currently owned by the account.\n     */\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() external view returns (uint256);\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @notice Get the supply rate per block for supplying the token to Compound.\n     */\n    function supplyRatePerBlock() external view returns (uint256);\n\n    /**\n     * @notice Address of the Compound Comptroller.\n     */\n    function comptroller() external view returns (address);\n}\n"
    },
    "contracts/strategies/IConvexDeposits.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IConvexDeposits {\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool _stake\n    ) external returns (bool);\n\n    function deposit(\n        uint256 _amount,\n        bool _lock,\n        address _stakeAddress\n    ) external;\n}\n"
    },
    "contracts/strategies/ICurveETHPoolV1.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface ICurveETHPoolV1 {\n    event AddLiquidity(\n        address indexed provider,\n        uint256[2] token_amounts,\n        uint256[2] fees,\n        uint256 invariant,\n        uint256 token_supply\n    );\n    event ApplyNewFee(uint256 fee);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event CommitNewFee(uint256 new_fee);\n    event RampA(\n        uint256 old_A,\n        uint256 new_A,\n        uint256 initial_time,\n        uint256 future_time\n    );\n    event RemoveLiquidity(\n        address indexed provider,\n        uint256[2] token_amounts,\n        uint256[2] fees,\n        uint256 token_supply\n    );\n    event RemoveLiquidityImbalance(\n        address indexed provider,\n        uint256[2] token_amounts,\n        uint256[2] fees,\n        uint256 invariant,\n        uint256 token_supply\n    );\n    event RemoveLiquidityOne(\n        address indexed provider,\n        uint256 token_amount,\n        uint256 coin_amount,\n        uint256 token_supply\n    );\n    event StopRampA(uint256 A, uint256 t);\n    event TokenExchange(\n        address indexed buyer,\n        int128 sold_id,\n        uint256 tokens_sold,\n        int128 bought_id,\n        uint256 tokens_bought\n    );\n    event Transfer(\n        address indexed sender,\n        address indexed receiver,\n        uint256 value\n    );\n\n    function A() external view returns (uint256);\n\n    function A_precise() external view returns (uint256);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function add_liquidity(uint256[2] memory _amounts, uint256 _min_mint_amount)\n        external\n        payable\n        returns (uint256);\n\n    function add_liquidity(\n        uint256[2] memory _amounts,\n        uint256 _min_mint_amount,\n        address _receiver\n    ) external payable returns (uint256);\n\n    function admin_action_deadline() external view returns (uint256);\n\n    function admin_balances(uint256 i) external view returns (uint256);\n\n    function admin_fee() external view returns (uint256);\n\n    function allowance(address arg0, address arg1)\n        external\n        view\n        returns (uint256);\n\n    function apply_new_fee() external;\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function balanceOf(address arg0) external view returns (uint256);\n\n    function balances(uint256 arg0) external view returns (uint256);\n\n    function calc_token_amount(uint256[2] memory _amounts, bool _is_deposit)\n        external\n        view\n        returns (uint256);\n\n    function calc_withdraw_one_coin(uint256 _burn_amount, int128 i)\n        external\n        view\n        returns (uint256);\n\n    function coins(uint256 arg0) external view returns (address);\n\n    function commit_new_fee(uint256 _new_fee) external;\n\n    function decimals() external view returns (uint256);\n\n    function ema_price() external view returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy\n    ) external payable returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy,\n        address _receiver\n    ) external payable returns (uint256);\n\n    function fee() external view returns (uint256);\n\n    function future_A() external view returns (uint256);\n\n    function future_A_time() external view returns (uint256);\n\n    function future_fee() external view returns (uint256);\n\n    function get_balances() external view returns (uint256[2] memory);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function get_p() external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function initial_A() external view returns (uint256);\n\n    function initial_A_time() external view returns (uint256);\n\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address[4] memory _coins,\n        uint256[4] memory _rate_multipliers,\n        uint256 _A,\n        uint256 _fee\n    ) external;\n\n    function last_price() external view returns (uint256);\n\n    function ma_exp_time() external view returns (uint256);\n\n    function ma_last_time() external view returns (uint256);\n\n    function name() external view returns (string memory);\n\n    function nonces(address arg0) external view returns (uint256);\n\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (bool);\n\n    function price_oracle() external view returns (uint256);\n\n    function ramp_A(uint256 _future_A, uint256 _future_time) external;\n\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[2] memory _min_amounts\n    ) external returns (uint256[2] memory);\n\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[2] memory _min_amounts,\n        address _receiver\n    ) external returns (uint256[2] memory);\n\n    function remove_liquidity_imbalance(\n        uint256[2] memory _amounts,\n        uint256 _max_burn_amount\n    ) external returns (uint256);\n\n    function remove_liquidity_imbalance(\n        uint256[2] memory _amounts,\n        uint256 _max_burn_amount,\n        address _receiver\n    ) external returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_received\n    ) external returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_received,\n        address _receiver\n    ) external returns (uint256);\n\n    function set_ma_exp_time(uint256 _ma_exp_time) external;\n\n    function stop_ramp_A() external;\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function version() external view returns (string memory);\n\n    function withdraw_admin_fees() external;\n}\n"
    },
    "contracts/strategies/ICurveMetaPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.4;\n\ninterface ICurveMetaPool {\n    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount)\n        external\n        returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function remove_liquidity(uint256 _amount, uint256[2] calldata min_amounts)\n        external\n        returns (uint256[2] calldata);\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 min_amount\n    ) external returns (uint256);\n\n    function remove_liquidity_imbalance(\n        uint256[2] calldata amounts,\n        uint256 max_burn_amount\n    ) external returns (uint256);\n\n    function calc_withdraw_one_coin(uint256 _token_amount, int128 i)\n        external\n        view\n        returns (uint256);\n\n    function balances(uint256 i) external view returns (uint256);\n\n    function calc_token_amount(uint256[2] calldata amounts, bool deposit)\n        external\n        view\n        returns (uint256);\n\n    function base_pool() external view returns (address);\n\n    function fee() external view returns (uint256);\n\n    function coins(uint256 i) external view returns (address);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/strategies/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface ICurvePool {\n    function get_virtual_price() external view returns (uint256);\n\n    function add_liquidity(uint256[3] calldata _amounts, uint256 _min) external;\n\n    function balances(uint256) external view returns (uint256);\n\n    function calc_token_amount(uint256[3] calldata _amounts, bool _deposit)\n        external\n        returns (uint256);\n\n    function fee() external view returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _amount,\n        int128 _index,\n        uint256 _minAmount\n    ) external;\n\n    function remove_liquidity(\n        uint256 _amount,\n        uint256[3] calldata _minWithdrawAmounts\n    ) external;\n\n    function calc_withdraw_one_coin(uint256 _amount, int128 _index)\n        external\n        view\n        returns (uint256);\n\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n\n    function coins(uint256 _index) external view returns (address);\n\n    function remove_liquidity_imbalance(\n        uint256[3] calldata _amounts,\n        uint256 maxBurnAmount\n    ) external;\n}\n"
    },
    "contracts/strategies/IRewardStaking.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IRewardStaking {\n    function stakeFor(address, uint256) external;\n\n    function stake(uint256) external;\n\n    function withdraw(uint256 amount, bool claim) external;\n\n    function withdrawAndUnwrap(uint256 amount, bool claim) external;\n\n    function earned(address account) external view returns (uint256);\n\n    function getReward() external;\n\n    function getReward(address _account, bool _claimExtras) external;\n\n    function extraRewardsLength() external returns (uint256);\n\n    function extraRewards(uint256 _pid) external returns (address);\n\n    function rewardToken() external returns (address);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "contracts/strategies/MorphoAaveStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD Morpho Aave Strategy\n * @notice Investment strategy for investing stablecoins via Morpho (Aave)\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { IMorpho } from \"../interfaces/morpho/IMorpho.sol\";\nimport { ILens } from \"../interfaces/morpho/ILens.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\ncontract MorphoAaveStrategy is InitializableAbstractStrategy {\n    address public constant MORPHO = 0x777777c9898D384F785Ee44Acfe945efDFf5f3E0;\n    address public constant LENS = 0x507fA343d0A90786d86C7cd885f5C49263A91FF4;\n\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /**\n     * @dev Initialize function, to set up initial internal state\n     * @param _rewardTokenAddresses Address of reward token for platform\n     * @param _assets Addresses of initial supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses,\n        address[] calldata _assets,\n        address[] calldata _pTokens\n    ) external onlyGovernor initializer {\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n    }\n\n    /**\n     * @dev Approve the spending of all assets by main Morpho contract,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; i++) {\n            address asset = assetsMapped[i];\n\n            // Safe approval\n            IERC20(asset).safeApprove(MORPHO, 0);\n            IERC20(asset).safeApprove(MORPHO, type(uint256).max);\n        }\n    }\n\n    /**\n     * @dev Internal method to respond to the addition of new asset\n     *      We need to approve and allow Morpho to move them\n     * @param _asset Address of the asset to approve\n     * @param _pToken The pToken for the approval\n     */\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        override\n    {\n        IERC20(_asset).safeApprove(MORPHO, 0);\n        IERC20(_asset).safeApprove(MORPHO, type(uint256).max);\n    }\n\n    /**\n     * @dev Collect accumulated rewards and send them to Harvester.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Morpho Aave-v2 doesn't distribute reward tokens\n        // solhint-disable-next-line max-line-length\n        // Ref: https://developers.morpho.xyz/interact-with-morpho/get-started/interact-with-morpho/claim-rewards#morpho-aave-v2\n    }\n\n    /**\n     * @dev Get the amount of rewards pending to be collected from the protocol\n     */\n    function getPendingRewards() external view returns (uint256 balance) {\n        // Morpho Aave-v2 doesn't distribute reward tokens\n        // solhint-disable-next-line max-line-length\n        // Ref: https://developers.morpho.xyz/interact-with-morpho/get-started/interact-with-morpho/claim-rewards#morpho-aave-v2\n        return 0;\n    }\n\n    /**\n     * @dev Deposit asset into Morpho\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @dev Deposit asset into Morpho\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_amount > 0, \"Must deposit something\");\n\n        address pToken = address(_getPTokenFor(_asset));\n\n        IMorpho(MORPHO).supply(\n            pToken,\n            address(this), // the address of the user you want to supply on behalf of\n            _amount\n        );\n        emit Deposit(_asset, pToken, _amount);\n    }\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into Morpho\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            uint256 balance = IERC20(assetsMapped[i]).balanceOf(address(this));\n            if (balance > 0) {\n                _deposit(assetsMapped[i], balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw asset from Morpho\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        _withdraw(_recipient, _asset, _amount);\n    }\n\n    function _withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) internal {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        address pToken = address(_getPTokenFor(_asset));\n\n        IMorpho(MORPHO).withdraw(pToken, _amount);\n        emit Withdrawal(_asset, pToken, _amount);\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            uint256 balance = _checkBalance(assetsMapped[i]);\n            if (balance > 0) {\n                _withdraw(vaultAddress, assetsMapped[i], balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Return total value of an asset held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        return _checkBalance(_asset);\n    }\n\n    function _checkBalance(address _asset)\n        internal\n        view\n        returns (uint256 balance)\n    {\n        address pToken = address(_getPTokenFor(_asset));\n\n        // Total value represented by decimal position of underlying token\n        (, , balance) = ILens(LENS).getCurrentSupplyBalanceInOf(\n            pToken,\n            address(this)\n        );\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @dev Get the pToken wrapped in the IERC20 interface for this asset.\n     *      Fails if the pToken doesn't exist in our mappings.\n     * @param _asset Address of the asset\n     * @return pToken Corresponding pToken to this asset\n     */\n    function _getPTokenFor(address _asset) internal view returns (IERC20) {\n        address pToken = assetToPToken[_asset];\n        require(pToken != address(0), \"pToken does not exist\");\n        return IERC20(pToken);\n    }\n}\n"
    },
    "contracts/strategies/MorphoCompoundStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD Morpho Compound Strategy\n * @notice Investment strategy for investing stablecoins via Morpho (Compound)\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20, AbstractCompoundStrategy, InitializableAbstractStrategy } from \"./AbstractCompoundStrategy.sol\";\nimport { IMorpho } from \"../interfaces/morpho/IMorpho.sol\";\nimport { ILens } from \"../interfaces/morpho/ILens.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport \"../utils/Helpers.sol\";\n\ncontract MorphoCompoundStrategy is AbstractCompoundStrategy {\n    address public constant MORPHO = 0x8888882f8f843896699869179fB6E4f7e3B58888;\n    address public constant LENS = 0x930f1b46e1D081Ec1524efD95752bE3eCe51EF67;\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    constructor(BaseStrategyConfig memory _stratConfig)\n        InitializableAbstractStrategy(_stratConfig)\n    {}\n\n    /**\n     * @dev Initialize function, to set up initial internal state\n     * @param _rewardTokenAddresses Address of reward token for platform\n     * @param _assets Addresses of initial supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses,\n        address[] calldata _assets,\n        address[] calldata _pTokens\n    ) external onlyGovernor initializer {\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n    }\n\n    /**\n     * @dev Approve the spending of all assets by main Morpho contract,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; i++) {\n            address asset = assetsMapped[i];\n\n            // Safe approval\n            IERC20(asset).safeApprove(MORPHO, 0);\n            IERC20(asset).safeApprove(MORPHO, type(uint256).max);\n        }\n    }\n\n    /**\n     * @dev Internal method to respond to the addition of new asset\n     *      We need to approve and allow Morpho to move them\n     * @param _asset Address of the asset to approve\n     * @param _pToken The pToken for the approval\n     */\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        override\n    {\n        IERC20(_asset).safeApprove(MORPHO, 0);\n        IERC20(_asset).safeApprove(MORPHO, type(uint256).max);\n    }\n\n    /**\n     * @dev Collect accumulated rewards and send them to Harvester.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        /**\n         * Gas considerations. We could query Morpho LENS's `getUserUnclaimedRewards` for each\n         * cToken separately and only claimRewards where it is economically feasible. Each call\n         * (out of 3) costs ~60k gas extra.\n         *\n         * Each extra cToken in the `poolTokens` of `claimRewards` function makes that call\n         * 89-120k more expensive gas wise.\n         *\n         * With Lens query in case where:\n         *  - there is only 1 reward token to collect. Net gas usage in best case would be\n         *    3*60 - 2*120 = -60k -> saving 60k gas\n         *  - there are 2 reward tokens to collect. Net gas usage in best case would be\n         *    3*60 - 120 = 60k -> more expensive for 60k gas\n         *  - there are 3 reward tokens to collect. Net gas usage in best case would be\n         *    3*60 = 180k -> more expensive for 180k gas\n         *\n         * For the above reasoning such \"optimization\" is not implemented\n         */\n\n        address[] memory poolTokens = new address[](assetsMapped.length);\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            poolTokens[i] = assetToPToken[assetsMapped[i]];\n        }\n\n        // slither-disable-next-line unused-return\n        IMorpho(MORPHO).claimRewards(\n            poolTokens, // The addresses of the underlying protocol's pools to claim rewards from\n            false // Whether to trade the accrued rewards for MORPHO token, with a premium\n        );\n\n        // Transfer COMP to Harvester\n        IERC20 rewardToken = IERC20(rewardTokenAddresses[0]);\n        uint256 balance = rewardToken.balanceOf(address(this));\n        emit RewardTokenCollected(\n            harvesterAddress,\n            rewardTokenAddresses[0],\n            balance\n        );\n        rewardToken.safeTransfer(harvesterAddress, balance);\n    }\n\n    /**\n     * @dev Get the amount of rewards pending to be collected from the protocol\n     */\n    function getPendingRewards() external view returns (uint256 balance) {\n        address[] memory poolTokens = new address[](assetsMapped.length);\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            poolTokens[i] = assetToPToken[assetsMapped[i]];\n        }\n\n        return ILens(LENS).getUserUnclaimedRewards(poolTokens, address(this));\n    }\n\n    /**\n     * @dev Deposit asset into Morpho\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @dev Deposit asset into Morpho\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_amount > 0, \"Must deposit something\");\n\n        IMorpho(MORPHO).supply(\n            address(_getCTokenFor(_asset)),\n            address(this), // the address of the user you want to supply on behalf of\n            _amount\n        );\n        emit Deposit(_asset, address(_getCTokenFor(_asset)), _amount);\n    }\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into Morpho\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            uint256 balance = IERC20(assetsMapped[i]).balanceOf(address(this));\n            if (balance > 0) {\n                _deposit(assetsMapped[i], balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw asset from Morpho\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        _withdraw(_recipient, _asset, _amount);\n    }\n\n    function _withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) internal {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        address pToken = assetToPToken[_asset];\n\n        IMorpho(MORPHO).withdraw(pToken, _amount);\n        emit Withdrawal(_asset, address(_getCTokenFor(_asset)), _amount);\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            uint256 balance = _checkBalance(assetsMapped[i]);\n            if (balance > 0) {\n                _withdraw(vaultAddress, assetsMapped[i], balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Return total value of an asset held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        return _checkBalance(_asset);\n    }\n\n    function _checkBalance(address _asset)\n        internal\n        view\n        returns (uint256 balance)\n    {\n        address pToken = assetToPToken[_asset];\n\n        // Total value represented by decimal position of underlying token\n        (, , balance) = ILens(LENS).getCurrentSupplyBalanceInOf(\n            pToken,\n            address(this)\n        );\n    }\n}\n"
    },
    "contracts/strategies/NativeStaking/CompoundingStakingSSVStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { IWETH9 } from \"../../interfaces/IWETH9.sol\";\nimport { CompoundingValidatorManager } from \"./CompoundingValidatorManager.sol\";\n\n/// @title Compounding Staking SSV Strategy\n/// @notice Strategy to deploy funds into DVT validators powered by the SSV Network\n/// @author Origin Protocol Inc\ncontract CompoundingStakingSSVStrategy is\n    CompoundingValidatorManager,\n    InitializableAbstractStrategy\n{\n    /// @notice SSV ERC20 token that serves as a payment for operating SSV validators\n    address public immutable SSV_TOKEN;\n\n    // For future use\n    uint256[50] private __gap;\n\n    /// @param _baseConfig Base strategy config with\n    ///   `platformAddress` not used so empty address\n    ///   `vaultAddress` the address of the OETH Vault contract\n    /// @param _wethAddress Address of the WETH Token contract\n    /// @param _ssvToken Address of the SSV Token contract\n    /// @param _ssvNetwork Address of the SSV Network contract\n    /// @param _beaconChainDepositContract Address of the beacon chain deposit contract\n    /// @param _beaconProofs Address of the Beacon Proofs contract that verifies beacon chain data\n    /// @param _beaconGenesisTimestamp The timestamp of the Beacon chain's genesis.\n    constructor(\n        BaseStrategyConfig memory _baseConfig,\n        address _wethAddress,\n        address _ssvToken,\n        address _ssvNetwork,\n        address _beaconChainDepositContract,\n        address _beaconProofs,\n        uint64 _beaconGenesisTimestamp\n    )\n        InitializableAbstractStrategy(_baseConfig)\n        CompoundingValidatorManager(\n            _wethAddress,\n            _baseConfig.vaultAddress,\n            _beaconChainDepositContract,\n            _ssvNetwork,\n            _beaconProofs,\n            _beaconGenesisTimestamp\n        )\n    {\n        SSV_TOKEN = _ssvToken;\n\n        // Make sure nobody owns the implementation contract\n        _setGovernor(address(0));\n    }\n\n    /// @notice Set up initial internal state including\n    /// 1. approving the SSVNetwork to transfer SSV tokens from this strategy contract\n    /// @param _rewardTokenAddresses Not used so empty array\n    /// @param _assets Not used so empty array\n    /// @param _pTokens Not used so empty array\n    function initialize(\n        address[] memory _rewardTokenAddresses,\n        address[] memory _assets,\n        address[] memory _pTokens\n    ) external onlyGovernor initializer {\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n\n        safeApproveAllTokens();\n    }\n\n    /// @notice Unlike other strategies, this does not deposit assets into the underlying platform.\n    /// It just checks the asset is WETH and emits the Deposit event.\n    /// To deposit WETH into validators, `registerSsvValidator` and `stakeEth` must be used.\n    /// @param _asset Address of the WETH token.\n    /// @param _amount Amount of WETH that was transferred to the strategy by the vault.\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        require(_asset == WETH, \"Unsupported asset\");\n        require(_amount > 0, \"Must deposit something\");\n\n        // Account for the new WETH\n        depositedWethAccountedFor += _amount;\n\n        emit Deposit(_asset, address(0), _amount);\n    }\n\n    /// @notice Unlike other strategies, this does not deposit assets into the underlying platform.\n    /// It just emits the Deposit event.\n    /// To deposit WETH into validators `registerSsvValidator` and `stakeEth` must be used.\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 wethBalance = IERC20(WETH).balanceOf(address(this));\n        uint256 newWeth = wethBalance - depositedWethAccountedFor;\n\n        if (newWeth > 0) {\n            // Account for the new WETH\n            depositedWethAccountedFor = wethBalance;\n\n            emit Deposit(WETH, address(0), newWeth);\n        }\n    }\n\n    /// @notice Withdraw ETH and WETH from this strategy contract.\n    /// @param _recipient Address to receive withdrawn assets.\n    /// @param _asset Address of the WETH token.\n    /// @param _amount Amount of WETH to withdraw.\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override nonReentrant {\n        require(_asset == WETH, \"Unsupported asset\");\n        require(\n            msg.sender == vaultAddress || msg.sender == validatorRegistrator,\n            \"Caller not Vault or Registrator\"\n        );\n\n        _withdraw(_recipient, _amount, address(this).balance);\n    }\n\n    function _withdraw(\n        address _recipient,\n        uint256 _withdrawAmount,\n        uint256 _ethBalance\n    ) internal {\n        require(_withdrawAmount > 0, \"Must withdraw something\");\n        require(_recipient == vaultAddress, \"Recipient not Vault\");\n\n        // Convert any ETH from validator partial withdrawals, exits\n        // or execution rewards to WETH and do the necessary accounting.\n        if (_ethBalance > 0) _convertEthToWeth(_ethBalance);\n\n        // Transfer WETH to the recipient and do the necessary accounting.\n        _transferWeth(_withdrawAmount, _recipient);\n\n        emit Withdrawal(WETH, address(0), _withdrawAmount);\n    }\n\n    /// @notice Transfer all WETH deposits, ETH from validator withdrawals and ETH from\n    /// execution rewards in this strategy to the vault.\n    /// This does not withdraw from the validators. That has to be done separately with the\n    /// `validatorWithdrawal` operation.\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        uint256 ethBalance = address(this).balance;\n        uint256 withdrawAmount = IERC20(WETH).balanceOf(address(this)) +\n            ethBalance;\n\n        if (withdrawAmount > 0) {\n            _withdraw(vaultAddress, withdrawAmount, ethBalance);\n        }\n    }\n\n    /// @notice Accounts for all the assets managed by this strategy which includes:\n    /// 1. The current WETH in this strategy contract\n    /// 2. The last verified ETH balance, total deposits and total validator balances\n    /// @param _asset      Address of WETH asset.\n    /// @return balance    Total value in ETH\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == WETH, \"Unsupported asset\");\n\n        // Load the last verified balance from the storage\n        // and add to the latest WETH balance of this strategy.\n        balance =\n            lastVerifiedEthBalance +\n            IWETH9(WETH).balanceOf(address(this));\n    }\n\n    /// @notice Returns bool indicating whether asset is supported by the strategy.\n    /// @param _asset The address of the WETH token.\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == WETH;\n    }\n\n    /// @notice Approves the SSV Network contract to transfer SSV tokens for validator registration.\n    function safeApproveAllTokens() public override {\n        // Approves the SSV Network contract to transfer SSV tokens when validators are registered\n        IERC20(SSV_TOKEN).approve(SSV_NETWORK, type(uint256).max);\n    }\n\n    /**\n     * @notice We can accept ETH directly to this contract from anyone as it does not impact our accounting\n     * like it did in the legacy NativeStakingStrategy.\n     * The new ETH will be accounted for in `checkBalance` after the next snapBalances and verifyBalances txs.\n     */\n    receive() external payable {}\n\n    /***************************************\n                Internal functions\n    ****************************************/\n\n    /// @notice is not supported for this strategy as there is no platform token.\n    function setPTokenAddress(address, address) external pure override {\n        revert(\"Unsupported function\");\n    }\n\n    /// @notice is not supported for this strategy as there is no platform token.\n    function removePToken(uint256) external pure override {\n        revert(\"Unsupported function\");\n    }\n\n    /// @dev This strategy does not use a platform token like the old Aave and Compound strategies.\n    function _abstractSetPToken(address _asset, address) internal override {}\n\n    /// @dev Consensus rewards are compounded to the validator's balance instead of being\n    /// swept to this strategy contract.\n    /// Execution rewards from MEV and tx priority accumulate as ETH in this strategy contract.\n    /// Withdrawals from validators also accumulate as ETH in this strategy contract.\n    /// It's too complex to separate the rewards from withdrawals so this function is not implemented.\n    /// Besides, ETH rewards are not sent to the Dripper any more. The Vault can now regulate\n    /// the increase in assets.\n    function _collectRewardTokens() internal pure override {\n        revert(\"Unsupported function\");\n    }\n}\n"
    },
    "contracts/strategies/NativeStaking/CompoundingValidatorManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { Governable } from \"../../governance/Governable.sol\";\nimport { IDepositContract } from \"../../interfaces/IDepositContract.sol\";\nimport { IWETH9 } from \"../../interfaces/IWETH9.sol\";\nimport { ISSVNetwork, Cluster } from \"../../interfaces/ISSVNetwork.sol\";\nimport { BeaconRoots } from \"../../beacon/BeaconRoots.sol\";\nimport { PartialWithdrawal } from \"../../beacon/PartialWithdrawal.sol\";\nimport { IBeaconProofs } from \"../../interfaces/IBeaconProofs.sol\";\n\n/**\n * @title Validator lifecycle management contract\n * @notice This contract implements all the required functionality to\n * register, deposit, withdraw, exit and remove validators.\n * @author Origin Protocol Inc\n */\nabstract contract CompoundingValidatorManager is Governable, Pausable {\n    using SafeERC20 for IERC20;\n\n    /// @dev The amount of ETH in wei that is required for a deposit to a new validator.\n    uint256 internal constant DEPOSIT_AMOUNT_WEI = 1 ether;\n    /// @dev Validator balances over this amount will eventually become active on the beacon chain.\n    /// Due to hysteresis, if the effective balance is 31 ETH, the actual balance\n    /// must rise to 32.25 ETH to trigger an effective balance update to 32 ETH.\n    /// https://eth2book.info/capella/part2/incentives/balances/#hysteresis\n    uint256 internal constant MIN_ACTIVATION_BALANCE_GWEI = 32.25 ether / 1e9;\n    /// @dev The maximum number of deposits that are waiting to be verified as processed on the beacon chain.\n    uint256 internal constant MAX_DEPOSITS = 32;\n    /// @dev The maximum number of validators that can be verified.\n    uint256 internal constant MAX_VERIFIED_VALIDATORS = 48;\n    /// @dev The default withdrawable epoch value on the Beacon chain.\n    /// A value in the far future means the validator is not exiting.\n    uint64 internal constant FAR_FUTURE_EPOCH = type(uint64).max;\n    /// @dev The number of seconds between each beacon chain slot.\n    uint64 internal constant SLOT_DURATION = 12;\n    /// @dev The number of slots in each beacon chain epoch.\n    uint64 internal constant SLOTS_PER_EPOCH = 32;\n    /// @dev Minimum time in seconds to allow snapped balances to be verified.\n    /// Set to 35 slots which is 3 slots more than 1 epoch (32 slots). Deposits get processed\n    /// once per epoch. This larger than 1 epoch delay should achieve that `snapBalances` sometimes\n    /// get called in the middle (or towards the end) of the epoch. Giving the off-chain script\n    /// sufficient time after the end of the epoch to prepare the proofs and call `verifyBalances`.\n    /// This is considering a malicious actor would keep calling `snapBalances` as frequent as possible\n    /// to disturb our operations.\n    uint64 internal constant SNAP_BALANCES_DELAY = 35 * SLOT_DURATION;\n\n    /// @notice The address of the Wrapped ETH (WETH) token contract\n    address internal immutable WETH;\n    /// @notice The address of the beacon chain deposit contract\n    address internal immutable BEACON_CHAIN_DEPOSIT_CONTRACT;\n    /// @notice The address of the SSV Network contract used to interface with\n    address internal immutable SSV_NETWORK;\n    /// @notice Address of the OETH Vault proxy contract\n    address internal immutable VAULT_ADDRESS;\n    /// @notice Address of the Beacon Proofs contract that verifies beacon chain data\n    address public immutable BEACON_PROOFS;\n    /// @notice The timestamp of the Beacon chain genesis.\n    /// @dev this is different on Testnets like Hoodi so is set at deployment time.\n    uint64 internal immutable BEACON_GENESIS_TIMESTAMP;\n\n    /// @notice Address of the registrator - allowed to register, withdraw, exit and remove validators\n    address public validatorRegistrator;\n\n    /// @notice Deposit data for new compounding validators.\n    /// @dev A `VERIFIED` deposit can mean 3 separate things:\n    ///      - a deposit has been processed by the beacon chain and shall be included in the\n    ///        balance of the next verifyBalances call\n    ///      - a deposit has been done to a slashed validator and has probably been recovered\n    ///        back to this strategy. Probably because we can not know for certain. This contract\n    ///        only detects when the validator has passed its withdrawal epoch. It is close to impossible\n    ///        to prove with Merkle Proofs that the postponed deposit this contract is responsible for\n    ///        creating is not present anymore in BeaconChain.state.pending_deposits. This in effect\n    ///        means that there might be a period where this contract thinks the deposit has been already\n    ///        returned as ETH balance before it happens. This will result in some days (or weeks)\n    ///        -> depending on the size of deposit queue of showing a deficit when calling `checkBalance`.\n    ///        As this only offsets the yield and doesn't cause a critical double-counting we are not addressing\n    ///        this issue.\n    ///      - A deposit has been done to the validator, but our deposit has been front run by a malicious\n    ///        actor. Funds in the deposit this contract makes are not recoverable.\n    enum DepositStatus {\n        UNKNOWN, // default value\n        PENDING, // deposit is pending and waiting to be  verified\n        VERIFIED // deposit has been verified\n    }\n\n    /// @param pubKeyHash Hash of validator's public key using the Beacon Chain's format\n    /// @param amountGwei Amount of ETH in gwei that has been deposited to the beacon chain deposit contract\n    /// @param slot The beacon chain slot number when the deposit has been made\n    /// @param depositIndex The index of the deposit in the list of active deposits\n    /// @param status The status of the deposit, either UNKNOWN, PENDING or VERIFIED\n    struct DepositData {\n        bytes32 pubKeyHash;\n        uint64 amountGwei;\n        uint64 slot;\n        uint32 depositIndex;\n        DepositStatus status;\n    }\n    /// @notice Restricts to only one deposit to an unverified validator at a time.\n    /// This is to limit front-running attacks of deposits to the beacon chain contract.\n    ///\n    /// @dev The value is set to true when a deposit to a new validator has been done that has\n    /// not yet be verified.\n    bool public firstDeposit;\n    /// @notice Mapping of the pending deposit roots to the deposit data\n    mapping(bytes32 => DepositData) public deposits;\n    /// @notice List of strategy deposit IDs to a validator.\n    /// The ID is the merkle root of the pending deposit data which is unique for each validator, amount and block.\n    /// Duplicate pending deposit roots are prevented so can be used as an identifier to each strategy deposit.\n    /// The list can be for deposits waiting to be verified as processed on the beacon chain,\n    /// or deposits that have been verified to an exiting validator and is now waiting for the\n    /// validator's balance to be swept.\n    /// The list may not be ordered by time of deposit.\n    /// Removed deposits will move the last deposit to the removed index.\n    bytes32[] public depositList;\n\n    enum ValidatorState {\n        NON_REGISTERED, // validator is not registered on the SSV network\n        REGISTERED, // validator is registered on the SSV network\n        STAKED, // validator has funds staked\n        VERIFIED, // validator has been verified to exist on the beacon chain\n        ACTIVE, // The validator balance is at least 32 ETH. The validator may not yet be active on the beacon chain.\n        EXITING, // The validator has been requested to exit\n        EXITED, // The validator has been verified to have a zero balance\n        REMOVED, // validator has funds withdrawn to this strategy contract and is removed from the SSV\n        INVALID // The validator has been front-run and the withdrawal address is not this strategy\n    }\n\n    // Validator data\n    struct ValidatorData {\n        ValidatorState state; // The state of the validator known to this contract\n        uint40 index; // The index of the validator on the beacon chain\n    }\n    /// @notice List of validator public key hashes that have been verified to exist on the beacon chain.\n    /// These have had a deposit processed and the validator's balance increased.\n    /// Validators will be removed from this list when its verified they have a zero balance.\n    bytes32[] public verifiedValidators;\n    /// @notice Mapping of the hash of the validator's public key to the validator state and index.\n    /// Uses the Beacon chain hashing for BLSPubkey which is sha256(abi.encodePacked(validator.pubkey, bytes16(0)))\n    mapping(bytes32 => ValidatorData) public validator;\n\n    /// @param blockRoot Beacon chain block root of the snapshot\n    /// @param timestamp Timestamp of the snapshot\n    /// @param ethBalance The balance of ETH in the strategy contract at the snapshot\n    struct Balances {\n        bytes32 blockRoot;\n        uint64 timestamp;\n        uint128 ethBalance;\n    }\n    /// @notice Mapping of the block root to the balances at that slot\n    Balances public snappedBalance;\n    /// @notice The last verified ETH balance of the strategy\n    uint256 public lastVerifiedEthBalance;\n\n    /// @dev This contract receives WETH as the deposit asset, but unlike other strategies doesn't immediately\n    /// deposit it to an underlying platform. Rather a special privilege account stakes it to the validators.\n    /// For that reason calling WETH.balanceOf(this) in a deposit function can contain WETH that has just been\n    /// deposited and also WETH that has previously been deposited. To keep a correct count we need to keep track\n    /// of WETH that has already been accounted for.\n    /// This value represents the amount of WETH balance of this contract that has already been accounted for by the\n    /// deposit events.\n    /// It is important to note that this variable is not concerned with WETH that is a result of full/partial\n    /// withdrawal of the validators. It is strictly concerned with WETH that has been deposited and is waiting to\n    /// be staked.\n    uint256 public depositedWethAccountedFor;\n\n    // For future use\n    uint256[41] private __gap;\n\n    event RegistratorChanged(address indexed newAddress);\n    event FirstDepositReset();\n    event SSVValidatorRegistered(\n        bytes32 indexed pubKeyHash,\n        uint64[] operatorIds\n    );\n    event SSVValidatorRemoved(bytes32 indexed pubKeyHash, uint64[] operatorIds);\n    event ETHStaked(\n        bytes32 indexed pubKeyHash,\n        bytes32 indexed pendingDepositRoot,\n        bytes pubKey,\n        uint256 amountWei\n    );\n    event ValidatorVerified(\n        bytes32 indexed pubKeyHash,\n        uint40 indexed validatorIndex\n    );\n    event ValidatorInvalid(bytes32 indexed pubKeyHash);\n    event DepositVerified(\n        bytes32 indexed pendingDepositRoot,\n        uint256 amountWei\n    );\n    event ValidatorWithdraw(bytes32 indexed pubKeyHash, uint256 amountWei);\n    event BalancesSnapped(bytes32 indexed blockRoot, uint256 ethBalance);\n    event BalancesVerified(\n        uint64 indexed timestamp,\n        uint256 totalDepositsWei,\n        uint256 totalValidatorBalance,\n        uint256 ethBalance\n    );\n\n    /// @dev Throws if called by any account other than the Registrator\n    modifier onlyRegistrator() {\n        require(msg.sender == validatorRegistrator, \"Not Registrator\");\n        _;\n    }\n\n    /// @dev Throws if called by any account other than the Registrator or Governor\n    modifier onlyRegistratorOrGovernor() {\n        require(\n            msg.sender == validatorRegistrator || isGovernor(),\n            \"Not Registrator or Governor\"\n        );\n        _;\n    }\n\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\n    /// @param _vaultAddress Address of the Vault\n    /// @param _beaconChainDepositContract Address of the beacon chain deposit contract\n    /// @param _ssvNetwork Address of the SSV Network contract\n    /// @param _beaconProofs Address of the Beacon Proofs contract that verifies beacon chain data\n    /// @param _beaconGenesisTimestamp The timestamp of the Beacon chain's genesis.\n    constructor(\n        address _wethAddress,\n        address _vaultAddress,\n        address _beaconChainDepositContract,\n        address _ssvNetwork,\n        address _beaconProofs,\n        uint64 _beaconGenesisTimestamp\n    ) {\n        WETH = _wethAddress;\n        BEACON_CHAIN_DEPOSIT_CONTRACT = _beaconChainDepositContract;\n        SSV_NETWORK = _ssvNetwork;\n        VAULT_ADDRESS = _vaultAddress;\n        BEACON_PROOFS = _beaconProofs;\n        BEACON_GENESIS_TIMESTAMP = _beaconGenesisTimestamp;\n\n        require(\n            block.timestamp > _beaconGenesisTimestamp,\n            \"Invalid genesis timestamp\"\n        );\n    }\n\n    /**\n     *\n     *             Admin Functions\n     *\n     */\n\n    /// @notice Set the address of the registrator which can register, exit and remove validators\n    function setRegistrator(address _address) external onlyGovernor {\n        validatorRegistrator = _address;\n        emit RegistratorChanged(_address);\n    }\n\n    /// @notice Reset the `firstDeposit` flag to false so deposits to unverified validators can be made again.\n    function resetFirstDeposit() external onlyGovernor {\n        require(firstDeposit, \"No first deposit\");\n\n        firstDeposit = false;\n\n        emit FirstDepositReset();\n    }\n\n    function pause() external onlyRegistratorOrGovernor {\n        _pause();\n    }\n\n    function unPause() external onlyGovernor {\n        _unpause();\n    }\n\n    /**\n     *\n     *             Validator Management\n     *\n     */\n\n    /// @notice Registers a single validator in a SSV Cluster.\n    /// Only the Registrator can call this function.\n    /// @param publicKey The public key of the validator\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param sharesData The shares data for the validator\n    /// @param ssvAmount The amount of SSV tokens to be deposited to the SSV cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    // slither-disable-start reentrancy-no-eth\n    function registerSsvValidator(\n        bytes calldata publicKey,\n        uint64[] calldata operatorIds,\n        bytes calldata sharesData,\n        uint256 ssvAmount,\n        Cluster calldata cluster\n    ) external onlyRegistrator whenNotPaused {\n        // Hash the public key using the Beacon Chain's format\n        bytes32 pubKeyHash = _hashPubKey(publicKey);\n        // Check each public key has not already been used\n        require(\n            validator[pubKeyHash].state == ValidatorState.NON_REGISTERED,\n            \"Validator already registered\"\n        );\n\n        // Store the validator state as registered\n        validator[pubKeyHash].state = ValidatorState.REGISTERED;\n\n        ISSVNetwork(SSV_NETWORK).registerValidator(\n            publicKey,\n            operatorIds,\n            sharesData,\n            ssvAmount,\n            cluster\n        );\n\n        emit SSVValidatorRegistered(pubKeyHash, operatorIds);\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    struct ValidatorStakeData {\n        bytes pubkey;\n        bytes signature;\n        bytes32 depositDataRoot;\n    }\n\n    /// @notice Stakes WETH in this strategy to a compounding validator.\n    /// The first deposit to a new validator, the amount must be 1 ETH.\n    /// Another deposit of at least 31 ETH is required for the validator to be activated.\n    /// This second deposit has to be done after the validator has been verified.\n    /// Does not convert any ETH sitting in this strategy to WETH.\n    /// There can not be two deposits to the same validator in the same block for the same amount.\n    /// Function is pausable so in case a run-away Registrator can be prevented from continuing\n    /// to deposit funds to slashed or undesired validators.\n    /// @param validatorStakeData validator data needed to stake.\n    /// The `ValidatorStakeData` struct contains the pubkey, signature and depositDataRoot.\n    /// Only the registrator can call this function.\n    /// @param depositAmountGwei The amount of WETH to stake to the validator in Gwei.\n    // slither-disable-start reentrancy-eth,reentrancy-no-eth\n    function stakeEth(\n        ValidatorStakeData calldata validatorStakeData,\n        uint64 depositAmountGwei\n    ) external onlyRegistrator whenNotPaused {\n        uint256 depositAmountWei = uint256(depositAmountGwei) * 1 gwei;\n        // Check there is enough WETH from the deposits sitting in this strategy contract\n        // There could be ETH from withdrawals but we'll ignore that. If it's really needed\n        // the ETH can be withdrawn and then deposited back to the strategy.\n        require(\n            depositAmountWei <= IWETH9(WETH).balanceOf(address(this)),\n            \"Insufficient WETH\"\n        );\n        require(depositList.length < MAX_DEPOSITS, \"Max deposits\");\n\n        // Convert required ETH from WETH and do the necessary accounting\n        _convertWethToEth(depositAmountWei);\n\n        // Hash the public key using the Beacon Chain's hashing for BLSPubkey\n        bytes32 pubKeyHash = _hashPubKey(validatorStakeData.pubkey);\n        ValidatorState currentState = validator[pubKeyHash].state;\n        // Can only stake to a validator that has been registered, verified or active.\n        // Can not stake to a validator that has been staked but not yet verified.\n        require(\n            (currentState == ValidatorState.REGISTERED ||\n                currentState == ValidatorState.VERIFIED ||\n                currentState == ValidatorState.ACTIVE),\n            \"Not registered or verified\"\n        );\n        require(depositAmountWei >= 1 ether, \"Deposit too small\");\n        if (currentState == ValidatorState.REGISTERED) {\n            // Can only have one pending deposit to an unverified validator at a time.\n            // This is to limit front-running deposit attacks to a single deposit.\n            // The exiting deposit needs to be verified before another deposit can be made.\n            // If there was a front-running attack, the validator needs to be verified as invalid\n            // and the Governor calls `resetFirstDeposit` to set `firstDeposit` to false.\n            require(!firstDeposit, \"Existing first deposit\");\n            // Limits the amount of ETH that can be at risk from a front-running deposit attack.\n            require(\n                depositAmountWei == DEPOSIT_AMOUNT_WEI,\n                \"Invalid first deposit amount\"\n            );\n            // Limits the number of validator balance proofs to verifyBalances\n            require(\n                verifiedValidators.length + 1 <= MAX_VERIFIED_VALIDATORS,\n                \"Max validators\"\n            );\n\n            // Flag a deposit to an unverified validator so no other deposits can be made\n            // to an unverified validator.\n            firstDeposit = true;\n            validator[pubKeyHash].state = ValidatorState.STAKED;\n        }\n\n        /* 0x02 to indicate that withdrawal credentials are for a compounding validator\n         * that was introduced with the Pectra upgrade.\n         * bytes11(0) to fill up the required zeros\n         * remaining bytes20 are for the address\n         */\n        bytes memory withdrawalCredentials = abi.encodePacked(\n            bytes1(0x02),\n            bytes11(0),\n            address(this)\n        );\n\n        /// After the Pectra upgrade the validators have a new restriction when proposing\n        /// blocks. The timestamps are at strict intervals of 12 seconds from the genesis block\n        /// forward. Each slot is created at strict 12 second intervals and those slots can\n        /// either have blocks attached to them or not. This way using the block.timestamp\n        /// the slot number can easily be calculated.\n        uint64 depositSlot = (SafeCast.toUint64(block.timestamp) -\n            BEACON_GENESIS_TIMESTAMP) / SLOT_DURATION;\n\n        // Calculate the merkle root of the beacon chain pending deposit data.\n        // This is used as the unique ID of the deposit.\n        bytes32 pendingDepositRoot = IBeaconProofs(BEACON_PROOFS)\n            .merkleizePendingDeposit(\n                pubKeyHash,\n                withdrawalCredentials,\n                depositAmountGwei,\n                validatorStakeData.signature,\n                depositSlot\n            );\n        require(\n            deposits[pendingDepositRoot].status == DepositStatus.UNKNOWN,\n            \"Duplicate deposit\"\n        );\n\n        // Store the deposit data for verifyDeposit and verifyBalances\n        deposits[pendingDepositRoot] = DepositData({\n            pubKeyHash: pubKeyHash,\n            amountGwei: depositAmountGwei,\n            slot: depositSlot,\n            depositIndex: SafeCast.toUint32(depositList.length),\n            status: DepositStatus.PENDING\n        });\n        depositList.push(pendingDepositRoot);\n\n        // Deposit to the Beacon Chain deposit contract.\n        // This will create a deposit in the beacon chain's pending deposit queue.\n        IDepositContract(BEACON_CHAIN_DEPOSIT_CONTRACT).deposit{\n            value: depositAmountWei\n        }(\n            validatorStakeData.pubkey,\n            withdrawalCredentials,\n            validatorStakeData.signature,\n            validatorStakeData.depositDataRoot\n        );\n\n        emit ETHStaked(\n            pubKeyHash,\n            pendingDepositRoot,\n            validatorStakeData.pubkey,\n            depositAmountWei\n        );\n    }\n\n    // slither-disable-end reentrancy-eth,reentrancy-no-eth\n\n    /// @notice Request a full or partial withdrawal from a validator.\n    /// A zero amount will trigger a full withdrawal.\n    /// If the remaining balance is < 32 ETH then only the amount in excess of 32 ETH will be withdrawn.\n    /// Only the Registrator can call this function.\n    /// 1 wei of value should be sent with the tx to pay for the withdrawal request fee.\n    /// If no value sent, 1 wei will be taken from the strategy's ETH balance if it has any.\n    /// If no ETH balance, the tx will revert.\n    /// @param publicKey The public key of the validator\n    /// @param amountGwei The amount of ETH to be withdrawn from the validator in Gwei.\n    /// A zero amount will trigger a full withdrawal.\n    // slither-disable-start reentrancy-no-eth\n    function validatorWithdrawal(bytes calldata publicKey, uint64 amountGwei)\n        external\n        payable\n        onlyRegistrator\n    {\n        // Hash the public key using the Beacon Chain's format\n        bytes32 pubKeyHash = _hashPubKey(publicKey);\n        ValidatorData memory validatorDataMem = validator[pubKeyHash];\n        // Validator full withdrawal could be denied due to multiple reasons:\n        //  - the validator has not been activated or active long enough\n        //    (current_epoch < activation_epoch + SHARD_COMMITTEE_PERIOD)\n        //  - the validator has pending balance to withdraw from a previous partial withdrawal request\n        //\n        // Meaning that the on-chain to beacon chain full withdrawal request could fail. Instead\n        // of adding complexity of verifying if a validator is eligible for a full exit, we allow\n        // multiple full withdrawal requests per validator.\n        require(\n            validatorDataMem.state == ValidatorState.ACTIVE ||\n                validatorDataMem.state == ValidatorState.EXITING,\n            \"Validator not active/exiting\"\n        );\n\n        // If a full withdrawal (validator exit)\n        if (amountGwei == 0) {\n            // For each staking strategy's deposits\n            uint256 depositsCount = depositList.length;\n            for (uint256 i = 0; i < depositsCount; ++i) {\n                bytes32 pendingDepositRoot = depositList[i];\n                // Check there is no pending deposits to the exiting validator\n                require(\n                    pubKeyHash != deposits[pendingDepositRoot].pubKeyHash,\n                    \"Pending deposit\"\n                );\n            }\n\n            // Store the validator state as exiting so no more deposits can be made to it.\n            // This may already be EXITING if the previous exit request failed. eg the validator\n            // was not active long enough.\n            validator[pubKeyHash].state = ValidatorState.EXITING;\n        }\n\n        // Do not remove from the list of verified validators.\n        // This is done in the verifyBalances function once the validator's balance has been verified to be zero.\n        // The validator state will be set to EXITED in the verifyBalances function.\n\n        PartialWithdrawal.request(publicKey, amountGwei);\n\n        emit ValidatorWithdraw(pubKeyHash, uint256(amountGwei) * 1 gwei);\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice Remove the validator from the SSV Cluster after:\n    /// - the validator has been exited from `validatorWithdrawal` or slashed\n    /// - the validator has incorrectly registered and can not be staked to\n    /// - the initial deposit was front-run and the withdrawal address is not this strategy's address.\n    /// Make sure `validatorWithdrawal` is called with a zero amount and the validator has exited the Beacon chain.\n    /// If removed before the validator has exited the beacon chain will result in the validator being slashed.\n    /// Only the registrator can call this function.\n    /// @param publicKey The public key of the validator\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    // slither-disable-start reentrancy-no-eth\n    function removeSsvValidator(\n        bytes calldata publicKey,\n        uint64[] calldata operatorIds,\n        Cluster calldata cluster\n    ) external onlyRegistrator {\n        // Hash the public key using the Beacon Chain's format\n        bytes32 pubKeyHash = _hashPubKey(publicKey);\n        ValidatorState currentState = validator[pubKeyHash].state;\n        // Can remove SSV validators that were incorrectly registered and can not be deposited to.\n        require(\n            currentState == ValidatorState.REGISTERED ||\n                currentState == ValidatorState.EXITED ||\n                currentState == ValidatorState.INVALID,\n            \"Validator not regd or exited\"\n        );\n\n        validator[pubKeyHash].state = ValidatorState.REMOVED;\n\n        ISSVNetwork(SSV_NETWORK).removeValidator(\n            publicKey,\n            operatorIds,\n            cluster\n        );\n\n        emit SSVValidatorRemoved(pubKeyHash, operatorIds);\n    }\n\n    /**\n     *\n     *             SSV Management\n     *\n     */\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// `depositSSV` has been removed as `deposit` on the SSVNetwork contract can be called directly\n    /// by the Strategist which is already holding SSV tokens.\n\n    /// @notice Withdraws excess SSV Tokens from the SSV Network contract which was used to pay the SSV Operators.\n    /// @dev A SSV cluster is defined by the SSVOwnerAddress and the set of operatorIds.\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param ssvAmount The amount of SSV tokens to be withdrawn from the SSV cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    function withdrawSSV(\n        uint64[] memory operatorIds,\n        uint256 ssvAmount,\n        Cluster memory cluster\n    ) external onlyGovernor {\n        ISSVNetwork(SSV_NETWORK).withdraw(operatorIds, ssvAmount, cluster);\n    }\n\n    /**\n     *\n     *             Beacon Chain Proofs\n     *\n     */\n\n    /// @notice Verifies a validator's index to its public key.\n    /// Adds to the list of verified validators if the validator's withdrawal address is this strategy's address.\n    /// Marks the validator as invalid and removes the deposit if the withdrawal address is not this strategy's address.\n    /// @param nextBlockTimestamp The timestamp of the execution layer block after the beacon chain slot\n    /// we are verifying.\n    /// The next one is needed as the Beacon Oracle returns the parent beacon block root for a block timestamp,\n    /// which is the beacon block root of the previous block.\n    /// @param validatorIndex The index of the validator on the beacon chain.\n    /// @param pubKeyHash The hash of the validator's public key using the Beacon Chain's format\n    /// @param withdrawalCredentials contain the validator type and withdrawal address. These can be incorrect and/or\n    ///        malformed. In case of incorrect withdrawalCredentials the validator deposit has been front run\n    /// @param validatorPubKeyProof The merkle proof for the validator public key to the beacon block root.\n    /// This is 53 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    /// BeaconBlock.state.validators[validatorIndex].pubkey\n    function verifyValidator(\n        uint64 nextBlockTimestamp,\n        uint40 validatorIndex,\n        bytes32 pubKeyHash,\n        bytes32 withdrawalCredentials,\n        bytes calldata validatorPubKeyProof\n    ) external {\n        require(\n            validator[pubKeyHash].state == ValidatorState.STAKED,\n            \"Validator not staked\"\n        );\n\n        // Get the beacon block root of the slot we are verifying the validator in.\n        // The parent beacon block root of the next block is the beacon block root of the slot we are verifying.\n        bytes32 blockRoot = BeaconRoots.parentBlockRoot(nextBlockTimestamp);\n\n        // Verify the validator index is for the validator with the given public key.\n        // Also verify the validator's withdrawal credentials\n        IBeaconProofs(BEACON_PROOFS).verifyValidator(\n            blockRoot,\n            pubKeyHash,\n            validatorPubKeyProof,\n            validatorIndex,\n            withdrawalCredentials\n        );\n\n        // Store the validator state as verified\n        validator[pubKeyHash] = ValidatorData({\n            state: ValidatorState.VERIFIED,\n            index: validatorIndex\n        });\n\n        bytes32 expectedWithdrawalCredentials = bytes32(\n            abi.encodePacked(bytes1(0x02), bytes11(0), address(this))\n        );\n\n        // If the initial deposit was front-run and the withdrawal address is not this strategy\n        // or the validator type is not a compounding validator (0x02)\n        if (expectedWithdrawalCredentials != withdrawalCredentials) {\n            // override the validator state\n            validator[pubKeyHash].state = ValidatorState.INVALID;\n\n            // Find and remove the deposit as the funds can not be recovered\n            uint256 depositCount = depositList.length;\n            for (uint256 i = 0; i < depositCount; i++) {\n                DepositData memory deposit = deposits[depositList[i]];\n                if (deposit.pubKeyHash == pubKeyHash) {\n                    // next verifyBalances will correctly account for the loss of a front-run\n                    // deposit. Doing it here accounts for the loss as soon as possible\n                    lastVerifiedEthBalance -= Math.min(\n                        lastVerifiedEthBalance,\n                        uint256(deposit.amountGwei) * 1 gwei\n                    );\n                    _removeDeposit(depositList[i], deposit);\n                    break;\n                }\n            }\n\n            // Leave the `firstDeposit` flag as true so no more deposits to unverified validators can be made.\n            // The Governor has to reset the `firstDeposit` to false before another deposit to\n            // an unverified validator can be made.\n            // The Governor can set a new `validatorRegistrator` if they suspect it has been compromised.\n\n            emit ValidatorInvalid(pubKeyHash);\n            return;\n        }\n\n        // Add the new validator to the list of verified validators\n        verifiedValidators.push(pubKeyHash);\n\n        // Reset the firstDeposit flag as the first deposit to an unverified validator has been verified.\n        firstDeposit = false;\n\n        emit ValidatorVerified(pubKeyHash, validatorIndex);\n    }\n\n    struct FirstPendingDepositSlotProofData {\n        uint64 slot;\n        bytes proof;\n    }\n\n    struct StrategyValidatorProofData {\n        uint64 withdrawableEpoch;\n        bytes withdrawableEpochProof;\n    }\n\n    /// @notice Verifies a deposit on the execution layer has been processed by the beacon chain.\n    /// This means the accounting of the strategy's ETH moves from a pending deposit to a validator balance.\n    ///\n    /// Important: this function has a limitation where `depositProcessedSlot` that is passed by the off-chain\n    /// verifier requires a slot immediately after it to propose a block otherwise the `BeaconRoots.parentBlockRoot`\n    /// will fail. This shouldn't be a problem, since by the current behaviour of beacon chain only 1%-3% slots\n    /// don't propose a block.\n    /// @param pendingDepositRoot The unique identifier of the deposit emitted in `ETHStaked` from\n    /// the `stakeEth` function.\n    /// @param depositProcessedSlot Any slot on or after the strategy's deposit was processed on the beacon chain.\n    /// Can not be a slot with pending deposits with the same slot as the deposit being verified.\n    /// Can not be a slot before a missed slot as the Beacon Root contract will have the parent block root\n    /// set for the next block timestamp in 12 seconds time.\n    /// @param firstPendingDeposit a `FirstPendingDepositSlotProofData` struct containing:\n    /// - slot: The beacon chain slot of the first deposit in the beacon chain's deposit queue.\n    ///   Can be any non-zero value if the deposit queue is empty.\n    /// - proof: The merkle proof of the first pending deposit's slot to the beacon block root.\n    ///   Can be either:\n    ///   * 40 witness hashes for BeaconBlock.state.PendingDeposits[0].slot when the deposit queue is not empty.\n    ///   * 37 witness hashes for BeaconBlock.state.PendingDeposits[0] when the deposit queue is empty.\n    ///   The 32 byte witness hashes are concatenated together starting from the leaf node.\n    /// @param strategyValidatorData a `StrategyValidatorProofData` struct containing:\n    /// - withdrawableEpoch: The withdrawable epoch of the validator the strategy is depositing to.\n    /// - withdrawableEpochProof: The merkle proof for the withdrawable epoch of the validator the strategy\n    ///   is depositing to, to the beacon block root.\n    ///   This is 53 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    // slither-disable-start reentrancy-no-eth\n    function verifyDeposit(\n        bytes32 pendingDepositRoot,\n        uint64 depositProcessedSlot,\n        FirstPendingDepositSlotProofData calldata firstPendingDeposit,\n        StrategyValidatorProofData calldata strategyValidatorData\n    ) external {\n        // Load into memory the previously saved deposit data\n        DepositData memory deposit = deposits[pendingDepositRoot];\n        ValidatorData memory strategyValidator = validator[deposit.pubKeyHash];\n        require(deposit.status == DepositStatus.PENDING, \"Deposit not pending\");\n        require(firstPendingDeposit.slot != 0, \"Zero 1st pending deposit slot\");\n\n        // We should allow the verification of deposits for validators that have been marked as exiting\n        // to cover this situation:\n        //  - there are 2 pending deposits\n        //  - beacon chain has slashed the validator\n        //  - when verifyDeposit is called for the first deposit it sets the Validator state to EXITING\n        //  - verifyDeposit should allow a secondary call for the other deposit to a slashed validator\n        require(\n            strategyValidator.state == ValidatorState.VERIFIED ||\n                strategyValidator.state == ValidatorState.ACTIVE ||\n                strategyValidator.state == ValidatorState.EXITING,\n            \"Not verified/active/exiting\"\n        );\n        // The verification slot must be after the deposit's slot.\n        // This is needed for when the deposit queue is empty.\n        require(deposit.slot < depositProcessedSlot, \"Slot not after deposit\");\n\n        uint64 snapTimestamp = snappedBalance.timestamp;\n\n        // This check prevents an accounting error that can happen if:\n        //  - snapBalances are snapped at the time of T\n        //  - deposit is processed on the beacon chain after time T and before verifyBalances()\n        //  - verifyDeposit is called before verifyBalances which removes a deposit from depositList\n        //    and deposit balance from totalDepositsWei\n        //  - verifyBalances is called under-reporting the strategy's balance\n        require(\n            (_calcNextBlockTimestamp(depositProcessedSlot) <= snapTimestamp) ||\n                snapTimestamp == 0,\n            \"Deposit after balance snapshot\"\n        );\n\n        // Get the parent beacon block root of the next block which is the block root of the deposit verification slot.\n        // This will revert if the slot after the verification slot was missed.\n        bytes32 depositBlockRoot = BeaconRoots.parentBlockRoot(\n            _calcNextBlockTimestamp(depositProcessedSlot)\n        );\n\n        // Verify the slot of the first pending deposit matches the beacon chain\n        bool isDepositQueueEmpty = IBeaconProofs(BEACON_PROOFS)\n            .verifyFirstPendingDeposit(\n                depositBlockRoot,\n                firstPendingDeposit.slot,\n                firstPendingDeposit.proof\n            );\n\n        // Verify the withdrawableEpoch on the validator of the strategy's deposit\n        IBeaconProofs(BEACON_PROOFS).verifyValidatorWithdrawable(\n            depositBlockRoot,\n            strategyValidator.index,\n            strategyValidatorData.withdrawableEpoch,\n            strategyValidatorData.withdrawableEpochProof\n        );\n\n        uint64 firstPendingDepositEpoch = firstPendingDeposit.slot /\n            SLOTS_PER_EPOCH;\n\n        // If deposit queue is empty all deposits have certainly been processed. If not\n        // a validator can either be not exiting and no further checks are required.\n        // Or a validator is exiting then this function needs to make sure that the\n        // pending deposit to an exited validator has certainly been processed. The\n        // slot/epoch of first pending deposit is the one that contains the transaction\n        // where the deposit to the ETH Deposit Contract has been made.\n        //\n        // Once the firstPendingDepositEpoch becomes greater than the withdrawableEpoch of\n        // the slashed validator then the deposit has certainly been processed. When the beacon\n        // chain reaches the withdrawableEpoch of the validator the deposit will no longer be\n        // postponed. And any new deposits created (and present in the deposit queue)\n        // will have an equal or larger withdrawableEpoch.\n        require(\n            strategyValidatorData.withdrawableEpoch == FAR_FUTURE_EPOCH ||\n                strategyValidatorData.withdrawableEpoch <=\n                firstPendingDepositEpoch ||\n                isDepositQueueEmpty,\n            \"Exit Deposit likely not proc.\"\n        );\n\n        // solhint-disable max-line-length\n        // Check the deposit slot is before the first pending deposit's slot on the beacon chain.\n        // If this is not true then we can't guarantee the deposit has been processed by the beacon chain.\n        // The deposit's slot can not be the same slot as the first pending deposit as there could be\n        // many deposits in the same block, hence have the same pending deposit slot.\n        // If the deposit queue is empty then our deposit must have been processed on the beacon chain.\n        // The deposit slot can be zero for validators consolidating to a compounding validator or 0x01 validator\n        // being promoted to a compounding one. Reference:\n        // - [switch_to_compounding_validator](https://ethereum.github.io/consensus-specs/specs/electra/beacon-chain/#new-switch_to_compounding_validator\n        // - [queue_excess_active_balance](https://ethereum.github.io/consensus-specs/specs/electra/beacon-chain/#new-queue_excess_active_balance)\n        // - [process_consolidation_request](https://ethereum.github.io/consensus-specs/specs/electra/beacon-chain/#new-process_consolidation_request)\n        // We can not guarantee that the deposit has been processed in that case.\n        // solhint-enable max-line-length\n        require(\n            deposit.slot < firstPendingDeposit.slot || isDepositQueueEmpty,\n            \"Deposit likely not processed\"\n        );\n\n        // Remove the deposit now it has been verified as processed on the beacon chain.\n        _removeDeposit(pendingDepositRoot, deposit);\n\n        emit DepositVerified(\n            pendingDepositRoot,\n            uint256(deposit.amountGwei) * 1 gwei\n        );\n    }\n\n    function _removeDeposit(\n        bytes32 pendingDepositRoot,\n        DepositData memory deposit\n    ) internal {\n        // After verifying the proof, update the contract storage\n        deposits[pendingDepositRoot].status = DepositStatus.VERIFIED;\n        // Move the last deposit to the index of the verified deposit\n        bytes32 lastDeposit = depositList[depositList.length - 1];\n        depositList[deposit.depositIndex] = lastDeposit;\n        deposits[lastDeposit].depositIndex = deposit.depositIndex;\n        // Delete the last deposit from the list\n        depositList.pop();\n    }\n\n    /// @dev Calculates the timestamp of the next execution block from the given slot.\n    /// @param slot The beacon chain slot number used for merkle proof verification.\n    function _calcNextBlockTimestamp(uint64 slot)\n        internal\n        view\n        returns (uint64)\n    {\n        // Calculate the next block timestamp from the slot.\n        return SLOT_DURATION * slot + BEACON_GENESIS_TIMESTAMP + SLOT_DURATION;\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice Stores the current ETH balance at the current block and beacon block root\n    ///         of the slot that is associated with the previous block.\n    ///\n    /// When snapping / verifying balance it is of a high importance that there is no\n    /// miss-match in respect to ETH that is held by the contract and balances that are\n    /// verified on the validators.\n    ///\n    /// First some context on the beacon-chain block building behaviour. Relevant parts of\n    /// constructing a block on the beacon chain consist of:\n    ///  - process_withdrawals: ETH is deducted from the validator's balance\n    ///  - process_execution_payload: immediately after the previous step executing all the\n    ///    transactions\n    ///  - apply the withdrawals: adding ETH to the recipient which is the withdrawal address\n    ///    contained in the withdrawal credentials of the exited validators\n    ///\n    /// That means that balance increases which are part of the post-block execution state are\n    /// done within the block, but the transaction that are contained within that block can not\n    /// see / interact with the balance from the exited validators. Only transactions in the\n    /// next block can do that.\n    ///\n    /// When snap balances is performed the state of the chain is snapped across 2 separate\n    /// chain states:\n    ///  - ETH balance of the contract is recorded on block X -> and corresponding slot Y\n    ///  - beacon chain block root is recorded of block X - 1 -> and corresponding slot Y - 1\n    ///    given there were no missed slots. It could also be Y - 2, Y - 3 depending on how\n    ///    many slots have not managed to propose a block. For the sake of simplicity this slot\n    ///    will be referred to as Y - 1 as it makes no difference in the argument\n    ///\n    /// Given these 2 separate chain states it is paramount that verify balances can not experience\n    /// miss-counting ETH or much more dangerous double counting of the ETH.\n    ///\n    /// When verifyBalances is called it is performed on the current block Z where Z > X. Verify\n    /// balances adds up all the ETH (omitting WETH) controlled by this contract:\n    ///  - ETH balance in the contract on block X\n    ///  - ETH balance in Deposits on block Z that haven't been yet processed in slot Y - 1\n    ///  - ETH balance in validators that are active in slot Y - 1\n    ///  - skips the ETH balance in validators that have withdrawn in slot Y - 1 (or sooner)\n    ///    and have their balance visible to transactions in slot Y and corresponding block X\n    ///    (or sooner)\n    ///\n    /// Lets verify the correctness of ETH accounting given the above described behaviour.\n    ///\n    /// *ETH balance in the contract on block X*\n    ///\n    /// This is an ETH balance of the contract on a non current X block. Any ETH leaving the\n    /// contract as a result of a withdrawal subtracts from the ETH accounted for on block X\n    /// if `verifyBalances` has already been called. It also invalidates a `snapBalances` in\n    /// case `verifyBalances` has not been called yet. Not performing this would result in not\n    /// accounting for the withdrawn ETH that has happened anywhere in the block interval [X + 1, Z].\n    ///\n    /// Similarly to withdrawals any `stakeEth` deposits to the deposit contract adds to the ETH\n    /// accounted for since the last `verifyBalances` has been called. And it invalidates the\n    /// `snapBalances` in case `verifyBalances` hasn't been yet called. Not performing this\n    /// would result in double counting the `stakedEth` since it would be present once in the\n    /// snapped contract balance and the second time in deposit storage variables.\n    ///\n    /// This behaviour is correct.\n    ///\n    /// *ETH balance in Deposits on block Z that haven't been yet processed in slot Y - 1*\n    ///\n    /// The contract sums up all the ETH that has been deposited to the Beacon chain deposit\n    /// contract at block Z. The execution layer doesn't have direct access to the state of\n    /// deposits on the beacon chain. And if it is to sum up all the ETH that is marked to be\n    /// deposited it needs to be sure to not double count ETH that is in deposits (storage vars)\n    /// and could also be part of the validator balances. It does that by verifying that at\n    /// slot Y - 1 none of the deposits visible on block Z have been processed. Meaning since\n    /// the last snap till now all are still in queue. Which ensures they can not be part of\n    /// the validator balances in later steps.\n    ///\n    /// This behaviour is correct.\n    ///\n    /// *ETH balance in validators that are active in slot Y - 1*\n    ///\n    /// The contract is verifying none of the deposits on Y - 1 slot have been processed and\n    /// for that reason it checks the validator balances in the same slot. Ensuring accounting\n    /// correctness.\n    ///\n    /// This behaviour is correct.\n    ///\n    /// *The withdrawn validators*\n    ///\n    /// The withdrawn validators could have their balances deducted in any slot before slot\n    /// Y - 1 and the execution layer sees the balance increase in the subsequent slot. Lets\n    /// look at the \"worst case scenario\" where the validator withdrawal is processed in the\n    /// slot Y - 1 (snapped slot) and see their balance increase (in execution layer) in slot\n    /// Y -> block X. The ETH balance on the contract is snapped at block X meaning that\n    /// even if the validator exits at the latest possible time it is paramount that the ETH\n    /// balance on the execution layer is recorded in the next block. Correctly accounting\n    /// for the withdrawn ETH.\n    ///\n    /// Worth mentioning if the validator exit is processed by the slot Y and balance increase\n    /// seen on the execution layer on block X + 1 the withdrawal is ignored by both the\n    /// validator balance verification as well as execution layer contract balance snap.\n    ///\n    /// This behaviour is correct.\n    ///\n    /// The validator balances on the beacon chain can then be proved with `verifyBalances`.\n    function snapBalances() external {\n        uint64 currentTimestamp = SafeCast.toUint64(block.timestamp);\n        require(\n            snappedBalance.timestamp + SNAP_BALANCES_DELAY < currentTimestamp,\n            \"Snap too soon\"\n        );\n\n        bytes32 blockRoot = BeaconRoots.parentBlockRoot(currentTimestamp);\n        // Get the current ETH balance\n        uint256 ethBalance = address(this).balance;\n\n        // Store the snapped balance\n        snappedBalance = Balances({\n            blockRoot: blockRoot,\n            timestamp: currentTimestamp,\n            ethBalance: SafeCast.toUint128(ethBalance)\n        });\n\n        emit BalancesSnapped(blockRoot, ethBalance);\n    }\n\n    // A struct is used to avoid stack too deep errors\n    struct BalanceProofs {\n        // BeaconBlock.state.balances\n        bytes32 balancesContainerRoot;\n        bytes balancesContainerProof;\n        // BeaconBlock.state.balances[validatorIndex]\n        bytes32[] validatorBalanceLeaves;\n        bytes[] validatorBalanceProofs;\n    }\n\n    struct PendingDepositProofs {\n        bytes32 pendingDepositContainerRoot;\n        bytes pendingDepositContainerProof;\n        uint32[] pendingDepositIndexes;\n        bytes[] pendingDepositProofs;\n    }\n\n    /// @notice Verifies the balances of all active validators on the beacon chain\n    /// and checks each of the strategy's deposits are still to be processed by the beacon chain.\n    /// @param balanceProofs a `BalanceProofs` struct containing the following:\n    /// - balancesContainerRoot: The merkle root of the balances container\n    /// - balancesContainerProof: The merkle proof for the balances container to the beacon block root.\n    ///    This is 9 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    /// - validatorBalanceLeaves: Array of leaf nodes containing the validator balance with three other balances.\n    /// - validatorBalanceProofs: Array of merkle proofs for the validator balance to the Balances container root.\n    ///    This is 39 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    /// @param pendingDepositProofs a `PendingDepositProofs` struct containing the following:\n    /// - pendingDepositContainerRoot: The merkle root of the pending deposits list container\n    /// - pendingDepositContainerProof: The merkle proof from the pending deposits list container\n    ///     to the beacon block root.\n    ///    This is 9 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    /// - pendingDepositIndexes: Array of indexes in the pending deposits list container for each\n    ///    of the strategy's deposits.\n    /// - pendingDepositProofs: Array of merkle proofs for each strategy deposit in the\n    ///    beacon chain's pending deposit list container to the pending deposits list container root.\n    ///    These are 28 witness hashes of 32 bytes each concatenated together starting from the leaf node.\n    // slither-disable-start reentrancy-no-eth\n    function verifyBalances(\n        BalanceProofs calldata balanceProofs,\n        PendingDepositProofs calldata pendingDepositProofs\n    ) external {\n        // Load previously snapped balances for the given block root\n        Balances memory balancesMem = snappedBalance;\n        // Check the balances are the latest\n        require(balancesMem.timestamp > 0, \"No snapped balances\");\n\n        uint256 verifiedValidatorsCount = verifiedValidators.length;\n        uint256 totalValidatorBalance = 0;\n        uint256 depositsCount = depositList.length;\n\n        // If there are no verified validators then we can skip the balance verification\n        if (verifiedValidatorsCount > 0) {\n            require(\n                balanceProofs.validatorBalanceProofs.length ==\n                    verifiedValidatorsCount,\n                \"Invalid balance proofs\"\n            );\n            require(\n                balanceProofs.validatorBalanceLeaves.length ==\n                    verifiedValidatorsCount,\n                \"Invalid balance leaves\"\n            );\n            // verify beaconBlock.state.balances root to beacon block root\n            IBeaconProofs(BEACON_PROOFS).verifyBalancesContainer(\n                balancesMem.blockRoot,\n                balanceProofs.balancesContainerRoot,\n                balanceProofs.balancesContainerProof\n            );\n\n            bytes32[]\n                memory validatorHashesMem = _getPendingDepositValidatorHashes(\n                    depositsCount\n                );\n\n            // for each validator in reverse order so we can pop off exited validators at the end\n            for (uint256 i = verifiedValidatorsCount; i > 0; ) {\n                --i;\n                ValidatorData memory validatorDataMem = validator[\n                    verifiedValidators[i]\n                ];\n                // verify validator's balance in beaconBlock.state.balances to the\n                // beaconBlock.state.balances container root\n                uint256 validatorBalanceGwei = IBeaconProofs(BEACON_PROOFS)\n                    .verifyValidatorBalance(\n                        balanceProofs.balancesContainerRoot,\n                        balanceProofs.validatorBalanceLeaves[i],\n                        balanceProofs.validatorBalanceProofs[i],\n                        validatorDataMem.index\n                    );\n\n                // If the validator has exited and the balance is now zero\n                if (validatorBalanceGwei == 0) {\n                    // Check if there are any pending deposits to this validator\n                    bool depositPending = false;\n                    for (uint256 j = 0; j < validatorHashesMem.length; j++) {\n                        if (validatorHashesMem[j] == verifiedValidators[i]) {\n                            depositPending = true;\n                            break;\n                        }\n                    }\n\n                    // If validator has a pending deposit we can not remove due to\n                    // the following situation:\n                    //  - validator has a pending deposit\n                    //  - validator has been slashed\n                    //  - sweep cycle has withdrawn all ETH from the validator. Balance is 0\n                    //  - beacon chain has processed the deposit and set the validator balance\n                    //    to deposit amount\n                    //  - if validator is no longer in the list of verifiedValidators its\n                    //    balance will not be considered and be under-counted.\n                    if (!depositPending) {\n                        // Store the validator state as exited\n                        // This could have been in VERIFIED, ACTIVE or EXITING state\n                        validator[verifiedValidators[i]].state = ValidatorState\n                            .EXITED;\n\n                        // Remove the validator with a zero balance from the list of verified validators\n\n                        // Reduce the count of verified validators which is the last index before the pop removes it.\n                        verifiedValidatorsCount -= 1;\n\n                        // Move the last validator that has already been verified to the current index.\n                        // There's an extra SSTORE if i is the last active validator but that's fine,\n                        // It's not a common case and the code is simpler this way.\n                        verifiedValidators[i] = verifiedValidators[\n                            verifiedValidatorsCount\n                        ];\n                        // Delete the last validator from the list\n                        verifiedValidators.pop();\n                    }\n\n                    // The validator balance is zero so not need to add to totalValidatorBalance\n                    continue;\n                } else if (\n                    validatorDataMem.state == ValidatorState.VERIFIED &&\n                    validatorBalanceGwei > MIN_ACTIVATION_BALANCE_GWEI\n                ) {\n                    // Store the validator state as active. This does not necessarily mean the\n                    // validator is active on the beacon chain yet. It just means the validator has\n                    // enough balance that it can become active.\n                    validator[verifiedValidators[i]].state = ValidatorState\n                        .ACTIVE;\n                }\n\n                // convert Gwei balance to Wei and add to the total validator balance\n                totalValidatorBalance += validatorBalanceGwei * 1 gwei;\n            }\n        }\n\n        uint256 totalDepositsWei = 0;\n\n        // If there are no deposits then we can skip the deposit verification.\n        // This section is after the validator balance verifications so an exited validator will be marked\n        // as EXITED before the deposits are verified. If there was a deposit to an exited validator\n        // then the deposit can only be removed once the validator is fully exited.\n        // It is possible that validator fully exits and a postponed deposit to an exited validator increases\n        // its balance again. In such case the contract will erroneously consider a deposit applied before it\n        // has been applied on the beacon chain showing a smaller than real `totalValidatorBalance`.\n        if (depositsCount > 0) {\n            require(\n                pendingDepositProofs.pendingDepositProofs.length ==\n                    depositsCount,\n                \"Invalid deposit proofs\"\n            );\n            require(\n                pendingDepositProofs.pendingDepositIndexes.length ==\n                    depositsCount,\n                \"Invalid deposit indexes\"\n            );\n\n            // Verify from the root of the pending deposit list container to the beacon block root\n            IBeaconProofs(BEACON_PROOFS).verifyPendingDepositsContainer(\n                balancesMem.blockRoot,\n                pendingDepositProofs.pendingDepositContainerRoot,\n                pendingDepositProofs.pendingDepositContainerProof\n            );\n\n            // For each staking strategy's deposit.\n            for (uint256 i = 0; i < depositsCount; ++i) {\n                bytes32 pendingDepositRoot = depositList[i];\n\n                // Verify the strategy's deposit is still pending on the beacon chain.\n                IBeaconProofs(BEACON_PROOFS).verifyPendingDeposit(\n                    pendingDepositProofs.pendingDepositContainerRoot,\n                    pendingDepositRoot,\n                    pendingDepositProofs.pendingDepositProofs[i],\n                    pendingDepositProofs.pendingDepositIndexes[i]\n                );\n\n                // Convert the deposit amount from Gwei to Wei and add to the total\n                totalDepositsWei +=\n                    uint256(deposits[pendingDepositRoot].amountGwei) *\n                    1 gwei;\n            }\n        }\n\n        // Store the verified balance in storage\n        lastVerifiedEthBalance =\n            totalDepositsWei +\n            totalValidatorBalance +\n            balancesMem.ethBalance;\n        // Reset the last snap timestamp so a new snapBalances has to be made\n        snappedBalance.timestamp = 0;\n\n        emit BalancesVerified(\n            balancesMem.timestamp,\n            totalDepositsWei,\n            totalValidatorBalance,\n            balancesMem.ethBalance\n        );\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice get a list of all validator hashes present in the pending deposits\n    ///         list can have duplicate entries\n    function _getPendingDepositValidatorHashes(uint256 depositsCount)\n        internal\n        view\n        returns (bytes32[] memory validatorHashes)\n    {\n        validatorHashes = new bytes32[](depositsCount);\n        for (uint256 i = 0; i < depositsCount; i++) {\n            validatorHashes[i] = deposits[depositList[i]].pubKeyHash;\n        }\n    }\n\n    /// @notice Hash a validator public key using the Beacon Chain's format\n    function _hashPubKey(bytes memory pubKey) internal pure returns (bytes32) {\n        require(pubKey.length == 48, \"Invalid public key\");\n        return sha256(abi.encodePacked(pubKey, bytes16(0)));\n    }\n\n    /**\n     *\n     *         WETH and ETH Accounting\n     *\n     */\n\n    /// @dev Called when WETH is transferred out of the strategy so\n    /// the strategy knows how much WETH it has on deposit.\n    /// This is so it can emit the correct amount in the Deposit event in depositAll().\n    function _transferWeth(uint256 _amount, address _recipient) internal {\n        IERC20(WETH).safeTransfer(_recipient, _amount);\n\n        // The min is required as more WETH can be withdrawn than deposited\n        // as the strategy earns consensus and execution rewards.\n        uint256 deductAmount = Math.min(_amount, depositedWethAccountedFor);\n        depositedWethAccountedFor -= deductAmount;\n\n        // No change in ETH balance so no need to snapshot the balances\n    }\n\n    /// @dev Converts ETH to WETH and updates the accounting.\n    /// @param _ethAmount The amount of ETH in wei.\n    function _convertEthToWeth(uint256 _ethAmount) internal {\n        // slither-disable-next-line arbitrary-send-eth\n        IWETH9(WETH).deposit{ value: _ethAmount }();\n\n        depositedWethAccountedFor += _ethAmount;\n\n        // Store the reduced ETH balance.\n        // The ETH balance in this strategy contract can be more than the last verified ETH balance\n        // due to partial withdrawals or full exits being processed by the beacon chain since the last snapBalances.\n        // It can also happen from execution rewards (MEV) or ETH donations.\n        lastVerifiedEthBalance -= Math.min(lastVerifiedEthBalance, _ethAmount);\n\n        // The ETH balance was decreased to WETH so we need to invalidate the last balances snap.\n        snappedBalance.timestamp = 0;\n    }\n\n    /// @dev Converts WETH to ETH and updates the accounting.\n    /// @param _wethAmount The amount of WETH in wei.\n    function _convertWethToEth(uint256 _wethAmount) internal {\n        IWETH9(WETH).withdraw(_wethAmount);\n\n        uint256 deductAmount = Math.min(_wethAmount, depositedWethAccountedFor);\n        depositedWethAccountedFor -= deductAmount;\n\n        // Store the increased ETH balance\n        lastVerifiedEthBalance += _wethAmount;\n\n        // The ETH balance was increased from WETH so we need to invalidate the last balances snap.\n        snappedBalance.timestamp = 0;\n    }\n\n    /**\n     *\n     *             View Functions\n     *\n     */\n\n    /// @notice Returns the number of deposits waiting to be verified as processed on the beacon chain,\n    /// or deposits that have been verified to an exiting validator and is now waiting for the\n    /// validator's balance to be swept.\n    function depositListLength() external view returns (uint256) {\n        return depositList.length;\n    }\n\n    /// @notice Returns the number of verified validators.\n    function verifiedValidatorsLength() external view returns (uint256) {\n        return verifiedValidators.length;\n    }\n}\n"
    },
    "contracts/strategies/NativeStaking/FeeAccumulator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title Fee Accumulator for Native Staking SSV Strategy\n * @notice Receives execution rewards which includes tx fees and\n * MEV rewards like tx priority and tx ordering.\n * It does NOT include swept ETH from beacon chain consensus rewards or full validator withdrawals.\n * @author Origin Protocol Inc\n */\ncontract FeeAccumulator {\n    /// @notice The address of the Native Staking Strategy\n    address public immutable STRATEGY;\n\n    event ExecutionRewardsCollected(address indexed strategy, uint256 amount);\n\n    /**\n     * @param _strategy Address of the Native Staking Strategy\n     */\n    constructor(address _strategy) {\n        STRATEGY = _strategy;\n    }\n\n    /**\n     * @notice sends all ETH in this FeeAccumulator contract to the Native Staking Strategy.\n     * @return eth The amount of execution rewards that were sent to the Native Staking Strategy\n     */\n    function collect() external returns (uint256 eth) {\n        require(msg.sender == STRATEGY, \"Caller is not the Strategy\");\n\n        eth = address(this).balance;\n        if (eth > 0) {\n            // Send the ETH to the Native Staking Strategy\n            Address.sendValue(payable(STRATEGY), eth);\n\n            emit ExecutionRewardsCollected(STRATEGY, eth);\n        }\n    }\n\n    /**\n     * @dev Accept ETH\n     */\n    receive() external payable {}\n}\n"
    },
    "contracts/strategies/NativeStaking/NativeStakingSSVStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { IWETH9 } from \"../../interfaces/IWETH9.sol\";\nimport { FeeAccumulator } from \"./FeeAccumulator.sol\";\nimport { ValidatorAccountant } from \"./ValidatorAccountant.sol\";\nimport { ISSVNetwork } from \"../../interfaces/ISSVNetwork.sol\";\n\nstruct ValidatorStakeData {\n    bytes pubkey;\n    bytes signature;\n    bytes32 depositDataRoot;\n}\n\n/// @title Native Staking SSV Strategy\n/// @notice Strategy to deploy funds into DVT validators powered by the SSV Network\n/// @author Origin Protocol Inc\n/// @dev This contract handles WETH and ETH and in some operations interchanges between the two. Any WETH that\n/// is on the contract across multiple blocks (and not just transitory within a transaction) is considered an\n/// asset. Meaning deposits increase the balance of the asset and withdrawal decrease it. As opposed to all\n/// our other strategies the WETH doesn't immediately get deposited into an underlying strategy and can be present\n/// across multiple blocks waiting to be unwrapped to ETH and staked to validators. This separation of WETH and ETH is\n/// required since the rewards (reward token) is also in ETH.\n///\n/// To simplify the accounting of WETH there is another difference in behavior compared to the other strategies.\n/// To withdraw WETH asset - exit message is posted to validators and the ETH hits this contract with multiple days\n/// delay. In order to simplify the WETH accounting upon detection of such an event the ValidatorAccountant\n/// immediately wraps ETH to WETH and sends it to the Vault.\n///\n/// On the other hand any ETH on the contract (across multiple blocks) is there either:\n///  - as a result of already accounted for consensus rewards\n///  - as a result of not yet accounted for consensus rewards\n///  - as a results of not yet accounted for full validator withdrawals (or validator slashes)\n///\n/// Even though the strategy assets and rewards are a very similar asset the consensus layer rewards and the\n/// execution layer rewards are considered rewards and those are dripped to the Vault over a configurable time\n/// interval and not immediately.\ncontract NativeStakingSSVStrategy is\n    ValidatorAccountant,\n    InitializableAbstractStrategy\n{\n    using SafeERC20 for IERC20;\n\n    /// @notice SSV ERC20 token that serves as a payment for operating SSV validators\n    address public immutable SSV_TOKEN;\n    /// @notice Fee collector address\n    /// @dev this address will receive maximal extractable value (MEV) rewards. These are\n    /// rewards for arranging transactions in a way that benefits the validator.\n    address payable public immutable FEE_ACCUMULATOR_ADDRESS;\n\n    /// @dev This contract receives WETH as the deposit asset, but unlike other strategies doesn't immediately\n    /// deposit it to an underlying platform. Rather a special privilege account stakes it to the validators.\n    /// For that reason calling WETH.balanceOf(this) in a deposit function can contain WETH that has just been\n    /// deposited and also WETH that has previously been deposited. To keep a correct count we need to keep track\n    /// of WETH that has already been accounted for.\n    /// This value represents the amount of WETH balance of this contract that has already been accounted for by the\n    /// deposit events.\n    /// It is important to note that this variable is not concerned with WETH that is a result of full/partial\n    /// withdrawal of the validators. It is strictly concerned with WETH that has been deposited and is waiting to\n    /// be staked.\n    uint256 public depositedWethAccountedFor;\n\n    // For future use\n    uint256[49] private __gap;\n\n    /// @param _baseConfig Base strategy config with platformAddress (ERC-4626 Vault contract), eg sfrxETH or sDAI,\n    /// and vaultAddress (OToken Vault contract), eg VaultProxy or OETHVaultProxy\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\n    /// @param _ssvToken Address of the Erc20 SSV Token contract\n    /// @param _ssvNetwork Address of the SSV Network contract\n    /// @param _maxValidators Maximum number of validators that can be registered in the strategy\n    /// @param _feeAccumulator Address of the fee accumulator receiving execution layer validator rewards\n    /// @param _beaconChainDepositContract Address of the beacon chain deposit contract\n    constructor(\n        BaseStrategyConfig memory _baseConfig,\n        address _wethAddress,\n        address _ssvToken,\n        address _ssvNetwork,\n        uint256 _maxValidators,\n        address _feeAccumulator,\n        address _beaconChainDepositContract\n    )\n        InitializableAbstractStrategy(_baseConfig)\n        ValidatorAccountant(\n            _wethAddress,\n            _baseConfig.vaultAddress,\n            _beaconChainDepositContract,\n            _ssvNetwork,\n            _maxValidators\n        )\n    {\n        SSV_TOKEN = _ssvToken;\n        FEE_ACCUMULATOR_ADDRESS = payable(_feeAccumulator);\n    }\n\n    /// @notice Set up initial internal state including\n    /// 1. approving the SSVNetwork to transfer SSV tokens from this strategy contract\n    /// 2. setting the recipient of SSV validator MEV rewards to the FeeAccumulator contract.\n    /// @param _rewardTokenAddresses Address of reward token for platform\n    /// @param _assets Addresses of initial supported assets\n    /// @param _pTokens Platform Token corresponding addresses\n    function initialize(\n        address[] memory _rewardTokenAddresses,\n        address[] memory _assets,\n        address[] memory _pTokens\n    ) external onlyGovernor initializer {\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n\n        // Approves the SSV Network contract to transfer SSV tokens for deposits\n        IERC20(SSV_TOKEN).approve(SSV_NETWORK, type(uint256).max);\n\n        // Set the FeeAccumulator as the address for SSV validators to send MEV rewards to\n        ISSVNetwork(SSV_NETWORK).setFeeRecipientAddress(\n            FEE_ACCUMULATOR_ADDRESS\n        );\n    }\n\n    /// @notice Unlike other strategies, this does not deposit assets into the underlying platform.\n    /// It just checks the asset is WETH and emits the Deposit event.\n    /// To deposit WETH into validators `registerSsvValidator` and `stakeEth` must be used.\n    /// Will NOT revert if the strategy is paused from an accounting failure.\n    /// @param _asset Address of asset to deposit. Has to be WETH.\n    /// @param _amount Amount of assets that were transferred to the strategy by the vault.\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        require(_asset == WETH, \"Unsupported asset\");\n        depositedWethAccountedFor += _amount;\n        _deposit(_asset, _amount);\n    }\n\n    /// @dev Deposit WETH to this strategy so it can later be staked into a validator.\n    /// @param _asset Address of WETH\n    /// @param _amount Amount of WETH to deposit\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_amount > 0, \"Must deposit something\");\n        /*\n         * We could do a check here that would revert when \"_amount % 32 ether != 0\". With the idea of\n         * not allowing deposits that will result in WETH sitting on the strategy after all the possible batches\n         * of 32ETH have been staked.\n         * But someone could mess with our strategy by sending some WETH to it. And we might want to deposit just\n         * enough WETH to add it up to 32 so it can be staked. For that reason the check is left out.\n         *\n         * WETH sitting on the strategy won't interfere with the accounting since accounting only operates on ETH.\n         */\n        emit Deposit(_asset, address(0), _amount);\n    }\n\n    /// @notice Unlike other strategies, this does not deposit assets into the underlying platform.\n    /// It just emits the Deposit event.\n    /// To deposit WETH into validators `registerSsvValidator` and `stakeEth` must be used.\n    /// Will NOT revert if the strategy is paused from an accounting failure.\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 wethBalance = IERC20(WETH).balanceOf(address(this));\n        uint256 newWeth = wethBalance - depositedWethAccountedFor;\n\n        if (newWeth > 0) {\n            depositedWethAccountedFor = wethBalance;\n\n            _deposit(WETH, newWeth);\n        }\n    }\n\n    /// @notice Withdraw WETH from this contract. Used only if some WETH for is lingering on the contract.\n    /// That can happen when:\n    ///   - after mints if the strategy is the default\n    ///   - time between depositToStrategy and stakeEth\n    ///   - the deposit was not a multiple of 32 WETH\n    ///   - someone sent WETH directly to this contract\n    /// Will NOT revert if the strategy is paused from an accounting failure.\n    /// @param _recipient Address to receive withdrawn assets\n    /// @param _asset WETH to withdraw\n    /// @param _amount Amount of WETH to withdraw\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_asset == WETH, \"Unsupported asset\");\n        _withdraw(_recipient, _asset, _amount);\n    }\n\n    function _withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) internal {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        _wethWithdrawn(_amount);\n\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n        emit Withdrawal(_asset, address(0), _amount);\n    }\n\n    /// @notice transfer all WETH deposits back to the vault.\n    /// This does not withdraw from the validators. That has to be done separately with the\n    /// `exitSsvValidator` and `removeSsvValidator` operations.\n    /// This does not withdraw any execution rewards from the FeeAccumulator or\n    /// consensus rewards in this strategy.\n    /// Any ETH in this strategy that was swept from a full validator withdrawal will not be withdrawn.\n    /// ETH from full validator withdrawals is sent to the Vault using `doAccounting`.\n    /// Will NOT revert if the strategy is paused from an accounting failure.\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        uint256 wethBalance = IERC20(WETH).balanceOf(address(this));\n        if (wethBalance > 0) {\n            _withdraw(vaultAddress, WETH, wethBalance);\n        }\n    }\n\n    /// @notice Returns the total value of (W)ETH that is staked to the validators\n    /// and WETH deposits that are still to be staked.\n    /// This does not include ETH from consensus rewards sitting in this strategy\n    /// or ETH from MEV rewards in the FeeAccumulator. These rewards are harvested\n    /// and sent to the Dripper so will eventually be sent to the Vault as WETH.\n    /// @param _asset      Address of weth asset\n    /// @return balance    Total value of (W)ETH\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == WETH, \"Unsupported asset\");\n\n        balance =\n            // add the ETH that has been staked in validators\n            activeDepositedValidators *\n            FULL_STAKE +\n            // add the WETH in the strategy from deposits that are still to be staked\n            IERC20(WETH).balanceOf(address(this));\n    }\n\n    function pause() external onlyStrategist {\n        _pause();\n    }\n\n    /// @notice Returns bool indicating whether asset is supported by strategy.\n    /// @param _asset The address of the asset token.\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == WETH;\n    }\n\n    /// @notice Approves the SSV Network contract to transfer SSV tokens for deposits\n    function safeApproveAllTokens() external override {\n        // Approves the SSV Network contract to transfer SSV tokens for deposits\n        IERC20(SSV_TOKEN).approve(SSV_NETWORK, type(uint256).max);\n    }\n\n    /// @notice Set the FeeAccumulator as the address for SSV validators to send MEV rewards to\n    function setFeeRecipient() external {\n        ISSVNetwork(SSV_NETWORK).setFeeRecipientAddress(\n            FEE_ACCUMULATOR_ADDRESS\n        );\n    }\n\n    /**\n     * @notice Only accept ETH from the FeeAccumulator and the WETH contract - required when\n     * unwrapping WETH just before staking it to the validator.\n     * The strategy will also receive ETH from the priority fees of transactions when producing blocks\n     * as defined in EIP-1559.\n     * The tx fees come from the Beacon chain so do not need any EVM level permissions to receive ETH.\n     * The tx fees are paid with each block produced. They are not included in the consensus rewards\n     * which are periodically swept from the validators to this strategy.\n     * For accounting purposes, the priority fees of transactions will be considered consensus rewards\n     * and will be included in the AccountingConsensusRewards event.\n     * @dev don't want to receive donations from anyone else as donations over the fuse limits will\n     * mess with the accounting of the consensus rewards and validator full withdrawals.\n     */\n    receive() external payable {\n        require(\n            msg.sender == FEE_ACCUMULATOR_ADDRESS || msg.sender == WETH,\n            \"Eth not from allowed contracts\"\n        );\n    }\n\n    /***************************************\n                Internal functions\n    ****************************************/\n\n    function _abstractSetPToken(address _asset, address) internal override {}\n\n    /// @dev Convert accumulated ETH to WETH and send to the Harvester.\n    /// Will revert if the strategy is paused for accounting.\n    function _collectRewardTokens() internal override whenNotPaused {\n        // collect ETH from execution rewards from the fee accumulator\n        uint256 executionRewards = FeeAccumulator(FEE_ACCUMULATOR_ADDRESS)\n            .collect();\n\n        // total ETH rewards to be harvested = execution rewards + consensus rewards\n        uint256 ethRewards = executionRewards + consensusRewards;\n\n        require(\n            address(this).balance >= ethRewards,\n            \"Insufficient eth balance\"\n        );\n\n        if (ethRewards > 0) {\n            // reset the counter keeping track of beacon chain consensus rewards\n            consensusRewards = 0;\n\n            // Convert ETH rewards to WETH\n            IWETH9(WETH).deposit{ value: ethRewards }();\n\n            IERC20(WETH).safeTransfer(harvesterAddress, ethRewards);\n            emit RewardTokenCollected(harvesterAddress, WETH, ethRewards);\n        }\n    }\n\n    /// @dev emits Withdrawal event from NativeStakingSSVStrategy\n    function _wethWithdrawnToVault(uint256 _amount) internal override {\n        emit Withdrawal(WETH, address(0), _amount);\n    }\n\n    /// @dev Called when WETH is withdrawn from the strategy or staked to a validator so\n    /// the strategy knows how much WETH it has on deposit.\n    /// This is so it can emit the correct amount in the Deposit event in depositAll().\n    function _wethWithdrawn(uint256 _amount) internal override {\n        /* In an ideal world we wouldn't need to reduce the deduction amount when the\n         * depositedWethAccountedFor is smaller than the _amount.\n         *\n         * The reason this is required is that a malicious actor could sent WETH directly\n         * to this contract and that would circumvent the increase of depositedWethAccountedFor\n         * property. When the ETH would be staked the depositedWethAccountedFor amount could\n         * be deducted so much that it would be negative.\n         */\n        uint256 deductAmount = Math.min(_amount, depositedWethAccountedFor);\n        depositedWethAccountedFor -= deductAmount;\n    }\n}\n"
    },
    "contracts/strategies/NativeStaking/ValidatorAccountant.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ValidatorRegistrator } from \"./ValidatorRegistrator.sol\";\nimport { IWETH9 } from \"../../interfaces/IWETH9.sol\";\n\n/// @title Validator Accountant\n/// @notice Attributes the ETH swept from beacon chain validators to this strategy contract\n/// as either full or partial withdrawals. Partial withdrawals being consensus rewards.\n/// Full withdrawals are from exited validators.\n/// @author Origin Protocol Inc\nabstract contract ValidatorAccountant is ValidatorRegistrator {\n    /// @notice The minimum amount of blocks that need to pass between two calls to manuallyFixAccounting\n    uint256 public constant MIN_FIX_ACCOUNTING_CADENCE = 7200; // 1 day\n\n    /// @notice Keeps track of the total consensus rewards swept from the beacon chain\n    uint256 public consensusRewards;\n\n    /// @notice start of fuse interval\n    uint256 public fuseIntervalStart;\n    /// @notice end of fuse interval\n    uint256 public fuseIntervalEnd;\n    /// @notice last block number manuallyFixAccounting has been called\n    uint256 public lastFixAccountingBlockNumber;\n\n    uint256[49] private __gap;\n\n    event FuseIntervalUpdated(uint256 start, uint256 end);\n    event AccountingFullyWithdrawnValidator(\n        uint256 noOfValidators,\n        uint256 remainingValidators,\n        uint256 wethSentToVault\n    );\n    event AccountingValidatorSlashed(\n        uint256 remainingValidators,\n        uint256 wethSentToVault\n    );\n    event AccountingConsensusRewards(uint256 amount);\n\n    event AccountingManuallyFixed(\n        int256 validatorsDelta,\n        int256 consensusRewardsDelta,\n        uint256 wethToVault\n    );\n\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\n    /// @param _vaultAddress Address of the Vault\n    /// @param _beaconChainDepositContract Address of the beacon chain deposit contract\n    /// @param _ssvNetwork Address of the SSV Network contract\n    /// @param _maxValidators Maximum number of validators that can be registered in the strategy\n    constructor(\n        address _wethAddress,\n        address _vaultAddress,\n        address _beaconChainDepositContract,\n        address _ssvNetwork,\n        uint256 _maxValidators\n    )\n        ValidatorRegistrator(\n            _wethAddress,\n            _vaultAddress,\n            _beaconChainDepositContract,\n            _ssvNetwork,\n            _maxValidators\n        )\n    {}\n\n    /// @notice set fuse interval values\n    function setFuseInterval(\n        uint256 _fuseIntervalStart,\n        uint256 _fuseIntervalEnd\n    ) external onlyGovernor {\n        require(\n            _fuseIntervalStart < _fuseIntervalEnd &&\n                _fuseIntervalEnd < 32 ether &&\n                _fuseIntervalEnd - _fuseIntervalStart >= 4 ether,\n            \"Incorrect fuse interval\"\n        );\n\n        fuseIntervalStart = _fuseIntervalStart;\n        fuseIntervalEnd = _fuseIntervalEnd;\n\n        emit FuseIntervalUpdated(_fuseIntervalStart, _fuseIntervalEnd);\n    }\n\n    /* solhint-disable max-line-length */\n    /// This notion page offers a good explanation of how the accounting functions\n    /// https://www.notion.so/originprotocol/Limited-simplified-native-staking-accounting-67a217c8420d40678eb943b9da0ee77d\n    /// In short, after dividing by 32, if the ETH remaining on the contract falls between 0 and fuseIntervalStart,\n    /// the accounting function will treat that ETH as Beacon chain consensus rewards.\n    /// On the contrary, if after dividing by 32, the ETH remaining on the contract falls between fuseIntervalEnd and 32,\n    /// the accounting function will treat that as a validator slashing.\n    /// @notice Perform the accounting attributing beacon chain ETH to either full or partial withdrawals. Returns true when\n    /// accounting is valid and fuse isn't \"blown\". Returns false when fuse is blown.\n    /// @dev This function could in theory be permission-less but lets allow only the Registrator (Defender Action) to call it\n    /// for now.\n    /// @return accountingValid true if accounting was successful, false if fuse is blown\n    /* solhint-enable max-line-length */\n    function doAccounting()\n        external\n        onlyRegistrator\n        whenNotPaused\n        nonReentrant\n        returns (bool accountingValid)\n    {\n        // pause the accounting on failure\n        accountingValid = _doAccounting(true);\n    }\n\n    // slither-disable-start reentrancy-eth\n    function _doAccounting(bool pauseOnFail)\n        internal\n        returns (bool accountingValid)\n    {\n        if (address(this).balance < consensusRewards) {\n            return _failAccounting(pauseOnFail);\n        }\n\n        // Calculate all the new ETH that has been swept to the contract since the last accounting\n        uint256 newSweptETH = address(this).balance - consensusRewards;\n        accountingValid = true;\n\n        // send the ETH that is from fully withdrawn validators to the Vault\n        if (newSweptETH >= FULL_STAKE) {\n            uint256 fullyWithdrawnValidators;\n            // explicitly cast to uint256 as we want to round to a whole number of validators\n            fullyWithdrawnValidators = uint256(newSweptETH / FULL_STAKE);\n            activeDepositedValidators -= fullyWithdrawnValidators;\n\n            uint256 wethToVault = FULL_STAKE * fullyWithdrawnValidators;\n            IWETH9(WETH).deposit{ value: wethToVault }();\n            // slither-disable-next-line unchecked-transfer\n            IWETH9(WETH).transfer(VAULT_ADDRESS, wethToVault);\n            _wethWithdrawnToVault(wethToVault);\n\n            emit AccountingFullyWithdrawnValidator(\n                fullyWithdrawnValidators,\n                activeDepositedValidators,\n                wethToVault\n            );\n        }\n\n        uint256 ethRemaining = address(this).balance - consensusRewards;\n        // should be less than a whole validator stake\n        require(ethRemaining < FULL_STAKE, \"Unexpected accounting\");\n\n        // If no Beacon chain consensus rewards swept\n        if (ethRemaining == 0) {\n            // do nothing\n            return accountingValid;\n        } else if (ethRemaining < fuseIntervalStart) {\n            // Beacon chain consensus rewards swept (partial validator withdrawals)\n            // solhint-disable-next-line reentrancy\n            consensusRewards += ethRemaining;\n            emit AccountingConsensusRewards(ethRemaining);\n        } else if (ethRemaining > fuseIntervalEnd) {\n            // Beacon chain consensus rewards swept but also a slashed validator fully exited\n            IWETH9(WETH).deposit{ value: ethRemaining }();\n            // slither-disable-next-line unchecked-transfer\n            IWETH9(WETH).transfer(VAULT_ADDRESS, ethRemaining);\n            activeDepositedValidators -= 1;\n\n            _wethWithdrawnToVault(ethRemaining);\n\n            emit AccountingValidatorSlashed(\n                activeDepositedValidators,\n                ethRemaining\n            );\n        }\n        // Oh no... Fuse is blown. The Strategist needs to adjust the accounting values.\n        else {\n            return _failAccounting(pauseOnFail);\n        }\n    }\n\n    // slither-disable-end reentrancy-eth\n\n    /// @dev pause any further accounting if required and return false\n    function _failAccounting(bool pauseOnFail)\n        internal\n        returns (bool accountingValid)\n    {\n        // pause if not already\n        if (pauseOnFail) {\n            _pause();\n        }\n        // fail the accounting\n        accountingValid = false;\n    }\n\n    /// @notice Allow the Strategist to fix the accounting of this strategy and unpause.\n    /// @param _validatorsDelta adjust the active validators by up to plus three or minus three\n    /// @param _consensusRewardsDelta adjust the accounted for consensus rewards up or down\n    /// @param _ethToVaultAmount the amount of ETH that gets wrapped into WETH and sent to the Vault\n    /// @dev There is a case when a validator(s) gets slashed so much that the eth swept from\n    /// the beacon chain enters the fuse area and there are no consensus rewards on the contract\n    /// to \"dip into\"/use. To increase the amount of unaccounted ETH over the fuse end interval\n    /// we need to reduce the amount of active deposited validators and immediately send WETH\n    /// to the vault, so it doesn't interfere with further accounting.\n    function manuallyFixAccounting(\n        int256 _validatorsDelta,\n        int256 _consensusRewardsDelta,\n        uint256 _ethToVaultAmount\n    ) external onlyStrategist whenPaused nonReentrant {\n        require(\n            lastFixAccountingBlockNumber + MIN_FIX_ACCOUNTING_CADENCE <\n                block.number,\n            \"Fix accounting called too soon\"\n        );\n        require(\n            _validatorsDelta >= -3 &&\n                _validatorsDelta <= 3 &&\n                // new value must be positive\n                int256(activeDepositedValidators) + _validatorsDelta >= 0,\n            \"Invalid validatorsDelta\"\n        );\n        require(\n            _consensusRewardsDelta >= -332 ether &&\n                _consensusRewardsDelta <= 332 ether &&\n                // new value must be positive\n                int256(consensusRewards) + _consensusRewardsDelta >= 0,\n            \"Invalid consensusRewardsDelta\"\n        );\n        require(_ethToVaultAmount <= 32 ether * 3, \"Invalid wethToVaultAmount\");\n\n        activeDepositedValidators = uint256(\n            int256(activeDepositedValidators) + _validatorsDelta\n        );\n        consensusRewards = uint256(\n            int256(consensusRewards) + _consensusRewardsDelta\n        );\n        lastFixAccountingBlockNumber = block.number;\n        if (_ethToVaultAmount > 0) {\n            IWETH9(WETH).deposit{ value: _ethToVaultAmount }();\n            // slither-disable-next-line unchecked-transfer\n            IWETH9(WETH).transfer(VAULT_ADDRESS, _ethToVaultAmount);\n            _wethWithdrawnToVault(_ethToVaultAmount);\n        }\n\n        emit AccountingManuallyFixed(\n            _validatorsDelta,\n            _consensusRewardsDelta,\n            _ethToVaultAmount\n        );\n\n        // rerun the accounting to see if it has now been fixed.\n        // Do not pause the accounting on failure as it is already paused\n        require(_doAccounting(false), \"Fuse still blown\");\n\n        // unpause since doAccounting was successful\n        _unpause();\n    }\n\n    /***************************************\n                 Abstract\n    ****************************************/\n\n    /// @dev allows for NativeStakingSSVStrategy contract to emit the Withdrawal event\n    function _wethWithdrawnToVault(uint256 _amount) internal virtual;\n}\n"
    },
    "contracts/strategies/NativeStaking/ValidatorRegistrator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { Governable } from \"../../governance/Governable.sol\";\nimport { IDepositContract } from \"../../interfaces/IDepositContract.sol\";\nimport { IVault } from \"../../interfaces/IVault.sol\";\nimport { IWETH9 } from \"../../interfaces/IWETH9.sol\";\nimport { ISSVNetwork, Cluster } from \"../../interfaces/ISSVNetwork.sol\";\n\nstruct ValidatorStakeData {\n    bytes pubkey;\n    bytes signature;\n    bytes32 depositDataRoot;\n}\n\n/**\n * @title Registrator of the validators\n * @notice This contract implements all the required functionality to register, exit and remove validators.\n * @author Origin Protocol Inc\n */\nabstract contract ValidatorRegistrator is Governable, Pausable {\n    /// @notice The maximum amount of ETH that can be staked by a validator\n    /// @dev this can change in the future with EIP-7251, Increase the MAX_EFFECTIVE_BALANCE\n    uint256 public constant FULL_STAKE = 32 ether;\n\n    /// @notice The address of the Wrapped ETH (WETH) token contract\n    address public immutable WETH;\n    /// @notice The address of the beacon chain deposit contract\n    address public immutable BEACON_CHAIN_DEPOSIT_CONTRACT;\n    /// @notice The address of the SSV Network contract used to interface with\n    address public immutable SSV_NETWORK;\n    /// @notice Address of the OETH Vault proxy contract\n    address public immutable VAULT_ADDRESS;\n    /// @notice Maximum number of validators that can be registered in this strategy\n    uint256 public immutable MAX_VALIDATORS;\n\n    /// @notice Address of the registrator - allowed to register, exit and remove validators\n    address public validatorRegistrator;\n    /// @notice The number of validators that have 32 (!) ETH actively deposited. When a new deposit\n    /// to a validator happens this number increases, when a validator exit is detected this number\n    /// decreases.\n    uint256 public activeDepositedValidators;\n    /// @notice State of the validators keccak256(pubKey) => state\n    mapping(bytes32 => VALIDATOR_STATE) public validatorsStates;\n    /// @notice The account that is allowed to modify stakeETHThreshold and reset stakeETHTally\n    address public stakingMonitor;\n    /// @notice Amount of ETH that can be staked before staking on the contract is suspended\n    /// and the `stakingMonitor` needs to approve further staking by calling `resetStakeETHTally`\n    uint256 public stakeETHThreshold;\n    /// @notice Amount of ETH that has been staked since the `stakingMonitor` last called `resetStakeETHTally`.\n    /// This can not go above `stakeETHThreshold`.\n    uint256 public stakeETHTally;\n    // For future use\n    uint256[47] private __gap;\n\n    enum VALIDATOR_STATE {\n        NON_REGISTERED, // validator is not registered on the SSV network\n        REGISTERED, // validator is registered on the SSV network\n        STAKED, // validator has funds staked\n        EXITING, // exit message has been posted and validator is in the process of exiting\n        EXIT_COMPLETE // validator has funds withdrawn to the EigenPod and is removed from the SSV\n    }\n\n    event RegistratorChanged(address indexed newAddress);\n    event StakingMonitorChanged(address indexed newAddress);\n    event ETHStaked(bytes32 indexed pubKeyHash, bytes pubKey, uint256 amount);\n    event SSVValidatorRegistered(\n        bytes32 indexed pubKeyHash,\n        bytes pubKey,\n        uint64[] operatorIds\n    );\n    event SSVValidatorExitInitiated(\n        bytes32 indexed pubKeyHash,\n        bytes pubKey,\n        uint64[] operatorIds\n    );\n    event SSVValidatorExitCompleted(\n        bytes32 indexed pubKeyHash,\n        bytes pubKey,\n        uint64[] operatorIds\n    );\n    event StakeETHThresholdChanged(uint256 amount);\n    event StakeETHTallyReset();\n\n    /// @dev Throws if called by any account other than the Registrator\n    modifier onlyRegistrator() {\n        require(\n            msg.sender == validatorRegistrator,\n            \"Caller is not the Registrator\"\n        );\n        _;\n    }\n\n    /// @dev Throws if called by any account other than the Staking monitor\n    modifier onlyStakingMonitor() {\n        require(msg.sender == stakingMonitor, \"Caller is not the Monitor\");\n        _;\n    }\n\n    /// @dev Throws if called by any account other than the Strategist\n    modifier onlyStrategist() {\n        require(\n            msg.sender == IVault(VAULT_ADDRESS).strategistAddr(),\n            \"Caller is not the Strategist\"\n        );\n        _;\n    }\n\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\n    /// @param _vaultAddress Address of the Vault\n    /// @param _beaconChainDepositContract Address of the beacon chain deposit contract\n    /// @param _ssvNetwork Address of the SSV Network contract\n    /// @param _maxValidators Maximum number of validators that can be registered in the strategy\n    constructor(\n        address _wethAddress,\n        address _vaultAddress,\n        address _beaconChainDepositContract,\n        address _ssvNetwork,\n        uint256 _maxValidators\n    ) {\n        WETH = _wethAddress;\n        BEACON_CHAIN_DEPOSIT_CONTRACT = _beaconChainDepositContract;\n        SSV_NETWORK = _ssvNetwork;\n        VAULT_ADDRESS = _vaultAddress;\n        MAX_VALIDATORS = _maxValidators;\n    }\n\n    /// @notice Set the address of the registrator which can register, exit and remove validators\n    function setRegistrator(address _address) external onlyGovernor {\n        validatorRegistrator = _address;\n        emit RegistratorChanged(_address);\n    }\n\n    /// @notice Set the address of the staking monitor that is allowed to reset stakeETHTally\n    function setStakingMonitor(address _address) external onlyGovernor {\n        stakingMonitor = _address;\n        emit StakingMonitorChanged(_address);\n    }\n\n    /// @notice Set the amount of ETH that can be staked before staking monitor\n    // needs to a approve further staking by resetting the stake ETH tally\n    function setStakeETHThreshold(uint256 _amount) external onlyGovernor {\n        stakeETHThreshold = _amount;\n        emit StakeETHThresholdChanged(_amount);\n    }\n\n    /// @notice Reset the stakeETHTally\n    function resetStakeETHTally() external onlyStakingMonitor {\n        stakeETHTally = 0;\n        emit StakeETHTallyReset();\n    }\n\n    /// @notice Stakes WETH to the node validators\n    /// @param validators A list of validator data needed to stake.\n    /// The `ValidatorStakeData` struct contains the pubkey, signature and depositDataRoot.\n    /// Only the registrator can call this function.\n    // slither-disable-start reentrancy-eth\n    function stakeEth(ValidatorStakeData[] calldata validators)\n        external\n        onlyRegistrator\n        whenNotPaused\n        nonReentrant\n    {\n        uint256 requiredETH = validators.length * FULL_STAKE;\n\n        // Check there is enough WETH from the deposits sitting in this strategy contract\n        require(\n            requiredETH <= IWETH9(WETH).balanceOf(address(this)),\n            \"Insufficient WETH\"\n        );\n        require(\n            activeDepositedValidators + validators.length <= MAX_VALIDATORS,\n            \"Max validators reached\"\n        );\n\n        require(\n            stakeETHTally + requiredETH <= stakeETHThreshold,\n            \"Staking ETH over threshold\"\n        );\n        stakeETHTally += requiredETH;\n\n        // Convert required ETH from WETH\n        IWETH9(WETH).withdraw(requiredETH);\n        _wethWithdrawn(requiredETH);\n\n        /* 0x01 to indicate that withdrawal credentials will contain an EOA address that the sweeping function\n         * can sweep funds to.\n         * bytes11(0) to fill up the required zeros\n         * remaining bytes20 are for the address\n         */\n        bytes memory withdrawalCredentials = abi.encodePacked(\n            bytes1(0x01),\n            bytes11(0),\n            address(this)\n        );\n\n        // For each validator\n        for (uint256 i = 0; i < validators.length; ++i) {\n            bytes32 pubKeyHash = keccak256(validators[i].pubkey);\n\n            require(\n                validatorsStates[pubKeyHash] == VALIDATOR_STATE.REGISTERED,\n                \"Validator not registered\"\n            );\n\n            IDepositContract(BEACON_CHAIN_DEPOSIT_CONTRACT).deposit{\n                value: FULL_STAKE\n            }(\n                validators[i].pubkey,\n                withdrawalCredentials,\n                validators[i].signature,\n                validators[i].depositDataRoot\n            );\n\n            validatorsStates[pubKeyHash] = VALIDATOR_STATE.STAKED;\n\n            emit ETHStaked(pubKeyHash, validators[i].pubkey, FULL_STAKE);\n        }\n        // save gas by changing this storage variable only once rather each time in the loop.\n        activeDepositedValidators += validators.length;\n    }\n\n    // slither-disable-end reentrancy-eth\n\n    /// @notice Registers a new validator in the SSV Cluster.\n    /// Only the registrator can call this function.\n    /// @param publicKeys The public keys of the validators\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param sharesData The shares data for each validator\n    /// @param ssvAmount The amount of SSV tokens to be deposited to the SSV cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    // slither-disable-start reentrancy-no-eth\n    function registerSsvValidators(\n        bytes[] calldata publicKeys,\n        uint64[] calldata operatorIds,\n        bytes[] calldata sharesData,\n        uint256 ssvAmount,\n        Cluster calldata cluster\n    ) external onlyRegistrator whenNotPaused {\n        require(\n            publicKeys.length == sharesData.length,\n            \"Pubkey sharesData mismatch\"\n        );\n        // Check each public key has not already been used\n        bytes32 pubKeyHash;\n        VALIDATOR_STATE currentState;\n        for (uint256 i = 0; i < publicKeys.length; ++i) {\n            pubKeyHash = keccak256(publicKeys[i]);\n            currentState = validatorsStates[pubKeyHash];\n            require(\n                currentState == VALIDATOR_STATE.NON_REGISTERED,\n                \"Validator already registered\"\n            );\n\n            validatorsStates[pubKeyHash] = VALIDATOR_STATE.REGISTERED;\n\n            emit SSVValidatorRegistered(pubKeyHash, publicKeys[i], operatorIds);\n        }\n\n        ISSVNetwork(SSV_NETWORK).bulkRegisterValidator(\n            publicKeys,\n            operatorIds,\n            sharesData,\n            ssvAmount,\n            cluster\n        );\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice Exit a validator from the Beacon chain.\n    /// The staked ETH will eventually swept to this native staking strategy.\n    /// Only the registrator can call this function.\n    /// @param publicKey The public key of the validator\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    // slither-disable-start reentrancy-no-eth\n    function exitSsvValidator(\n        bytes calldata publicKey,\n        uint64[] calldata operatorIds\n    ) external onlyRegistrator whenNotPaused {\n        bytes32 pubKeyHash = keccak256(publicKey);\n        VALIDATOR_STATE currentState = validatorsStates[pubKeyHash];\n        require(currentState == VALIDATOR_STATE.STAKED, \"Validator not staked\");\n\n        ISSVNetwork(SSV_NETWORK).exitValidator(publicKey, operatorIds);\n\n        validatorsStates[pubKeyHash] = VALIDATOR_STATE.EXITING;\n\n        emit SSVValidatorExitInitiated(pubKeyHash, publicKey, operatorIds);\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice Remove a validator from the SSV Cluster.\n    /// Make sure `exitSsvValidator` is called before and the validate has exited the Beacon chain.\n    /// If removed before the validator has exited the beacon chain will result in the validator being slashed.\n    /// Only the registrator can call this function.\n    /// @param publicKey The public key of the validator\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    // slither-disable-start reentrancy-no-eth\n    function removeSsvValidator(\n        bytes calldata publicKey,\n        uint64[] calldata operatorIds,\n        Cluster calldata cluster\n    ) external onlyRegistrator whenNotPaused {\n        bytes32 pubKeyHash = keccak256(publicKey);\n        VALIDATOR_STATE currentState = validatorsStates[pubKeyHash];\n        // Can remove SSV validators that were incorrectly registered and can not be deposited to.\n        require(\n            currentState == VALIDATOR_STATE.EXITING ||\n                currentState == VALIDATOR_STATE.REGISTERED,\n            \"Validator not regd or exiting\"\n        );\n\n        ISSVNetwork(SSV_NETWORK).removeValidator(\n            publicKey,\n            operatorIds,\n            cluster\n        );\n\n        validatorsStates[pubKeyHash] = VALIDATOR_STATE.EXIT_COMPLETE;\n\n        emit SSVValidatorExitCompleted(pubKeyHash, publicKey, operatorIds);\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /// @notice Deposits more SSV Tokens to the SSV Network contract which is used to pay the SSV Operators.\n    /// @dev A SSV cluster is defined by the SSVOwnerAddress and the set of operatorIds.\n    /// uses \"onlyStrategist\" modifier so continuous front-running can't DOS our maintenance service\n    /// that tries to top up SSV tokens.\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param ssvAmount The amount of SSV tokens to be deposited to the SSV cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    function depositSSV(\n        uint64[] memory operatorIds,\n        uint256 ssvAmount,\n        Cluster memory cluster\n    ) external onlyStrategist {\n        ISSVNetwork(SSV_NETWORK).deposit(\n            address(this),\n            operatorIds,\n            ssvAmount,\n            cluster\n        );\n    }\n\n    /// @notice Withdraws excess SSV Tokens from the SSV Network contract which was used to pay the SSV Operators.\n    /// @dev A SSV cluster is defined by the SSVOwnerAddress and the set of operatorIds.\n    /// @param operatorIds The operator IDs of the SSV Cluster\n    /// @param ssvAmount The amount of SSV tokens to be deposited to the SSV cluster\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\n    function withdrawSSV(\n        uint64[] memory operatorIds,\n        uint256 ssvAmount,\n        Cluster memory cluster\n    ) external onlyGovernor {\n        ISSVNetwork(SSV_NETWORK).withdraw(operatorIds, ssvAmount, cluster);\n    }\n\n    /***************************************\n                 Abstract\n    ****************************************/\n\n    /// @dev Called when WETH is withdrawn from the strategy or staked to a validator so\n    /// the strategy knows how much WETH it has on deposit.\n    /// This is so it can emit the correct amount in the Deposit event in depositAll().\n    function _wethWithdrawn(uint256 _amount) internal virtual;\n}\n"
    },
    "contracts/strategies/plume/RoosterAMOStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Rooster AMO strategy\n * @author Origin Protocol Inc\n * @custom:security-contact security@originprotocol.com\n */\nimport { Math as MathRooster } from \"../../../lib/rooster/v2-common/libraries/Math.sol\";\nimport { Math as Math_v5 } from \"../../../lib/rooster/openzeppelin-custom/contracts/utils/math/Math.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { IERC20, InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { IVault } from \"../../interfaces/IVault.sol\";\nimport { IMaverickV2Pool } from \"../../interfaces/plume/IMaverickV2Pool.sol\";\nimport { IMaverickV2Quoter } from \"../../interfaces/plume/IMaverickV2Quoter.sol\";\nimport { IMaverickV2LiquidityManager } from \"../../interfaces/plume/IMaverickV2LiquidityManager.sol\";\nimport { IMaverickV2PoolLens } from \"../../interfaces/plume/IMaverickV2PoolLens.sol\";\nimport { IMaverickV2Position } from \"../../interfaces/plume/IMaverickV2Position.sol\";\nimport { IVotingDistributor } from \"../../interfaces/plume/IVotingDistributor.sol\";\nimport { IPoolDistributor } from \"../../interfaces/plume/IPoolDistributor.sol\";\n// importing custom version of rooster TickMath because of dependency collision. Maverick uses\n// a newer OpenZepplin Math library with functionality that is not present in 4.4.2 (the one we use)\nimport { TickMath } from \"../../../lib/rooster/v2-common/libraries/TickMath.sol\";\n\ncontract RoosterAMOStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    /***************************************\n            Storage slot members\n    ****************************************/\n\n    /// @notice NFT tokenId of the liquidity position\n    ///\n    /// @dev starts with value of 1 and can not be 0\n    //  solhint-disable-next-line max-line-length\n    ///      https://github.com/rooster-protocol/rooster-contracts/blob/fbfecbc519e4495b12598024a42630b4a8ea4489/v2-common/contracts/base/Nft.sol#L14\n    uint256 public tokenId;\n    /// @dev Minimum amount of tokens the strategy would be able to withdraw from the pool.\n    ///      minimum amount of tokens are withdrawn at a 1:1 price\n    ///      Important: Underlying assets contains only assets that are deposited in the underlying Rooster pool.\n    ///      WETH or OETH held by this contract is not accounted for in underlying assets\n    uint256 public underlyingAssets;\n    /// @notice Marks the start of the interval that defines the allowed range of WETH share in\n    /// the pre-configured pool's liquidity ticker\n    uint256 public allowedWethShareStart;\n    /// @notice Marks the end of the interval that defines the allowed range of WETH share in\n    /// the pre-configured pool's liquidity ticker\n    uint256 public allowedWethShareEnd;\n    /// @dev reserved for inheritance\n    int256[46] private __reserved;\n\n    /***************************************\n          Constants, structs and events\n    ****************************************/\n\n    /// @notice The address of the Wrapped ETH (WETH) token contract\n    address public immutable WETH;\n    /// @notice The address of the OETH token contract\n    address public immutable OETH;\n    /// @notice the underlying AMO Maverick (Rooster) pool\n    IMaverickV2Pool public immutable mPool;\n    /// @notice the Liquidity manager used to add liquidity to the pool\n    IMaverickV2LiquidityManager public immutable liquidityManager;\n    /// @notice the Maverick V2 poolLens\n    ///\n    /// @dev only used to provide the pool's current sqrtPrice\n    IMaverickV2PoolLens public immutable poolLens;\n    /// @notice the Maverick V2 position\n    ///\n    /// @dev provides details of the NFT LP position and offers functions to\n    /// remove the liquidity.\n    IMaverickV2Position public immutable maverickPosition;\n    /// @notice the Maverick Quoter\n    IMaverickV2Quoter public immutable quoter;\n    /// @notice the Maverick Voting Distributor\n    IVotingDistributor public immutable votingDistributor;\n    /// @notice the Maverick Pool Distributor\n    IPoolDistributor public immutable poolDistributor;\n\n    /// @notice sqrtPriceTickLower\n    /// @dev tick lower represents the lower price of OETH priced in WETH. Meaning the pool\n    /// offers more than 1 OETH for 1 WETH. In other terms to get 1 OETH the swap needs to offer 0.9999 WETH\n    /// this is where purchasing OETH with WETH within the liquidity position is the cheapest.\n    ///\n    ///            _____________________\n    ///            |      |            |\n    ///            | WETH |    OETH   |\n    ///            |      |            |\n    ///            |      |            |\n    ///  --------- * ---- * ---------- * ---------\n    ///               currentPrice\n    ///                          sqrtPriceHigher-(1:1 parity)\n    ///      sqrtPriceLower\n    ///\n    ///\n    /// Price is defined as price of token1 in terms of token0. (token1 / token0)\n    /// @notice sqrtPriceTickLower - OETH is priced 0.9999 WETH\n    uint256 public immutable sqrtPriceTickLower;\n    /// @notice sqrtPriceTickHigher\n    /// @dev tick higher represents 1:1 price parity of WETH to OETH\n    uint256 public immutable sqrtPriceTickHigher;\n    /// @dev price at parity (in OETH this is equal to sqrtPriceTickHigher)\n    uint256 public immutable sqrtPriceAtParity;\n    /// @notice The tick where the strategy deploys the liquidity to\n    int32 public constant TICK_NUMBER = -1;\n    /// @notice Minimum liquidity that must be exceeded to continue with the action\n    /// e.g. deposit, add liquidity\n    uint256 public constant ACTION_THRESHOLD = 1e12;\n    /// @notice Maverick pool static liquidity bin type\n    uint8 public constant MAV_STATIC_BIN_KIND = 0;\n    /// @dev a threshold under which the contract no longer allows for the protocol to rebalance. Guarding\n    ///      against a strategist / guardian being taken over and with multiple transactions draining the\n    ///      protocol funds.\n    uint256 public constant SOLVENCY_THRESHOLD = 0.998 ether;\n    /// @notice Emitted when the allowed interval within which the strategy contract is allowed to deposit\n    /// liquidity to the underlying pool is updated.\n    /// @param allowedWethShareStart The start of the interval\n    /// @param allowedWethShareEnd The end of the interval\n    event PoolWethShareIntervalUpdated(\n        uint256 allowedWethShareStart,\n        uint256 allowedWethShareEnd\n    );\n    /// @notice Emitted when liquidity is removed from the underlying pool\n    /// @param withdrawLiquidityShare Share of strategy's liquidity that has been removed\n    /// @param removedWETHAmount The amount of WETH removed\n    /// @param removedOETHAmount The amount of OETH removed\n    /// @param underlyingAssets Updated amount of strategy's underlying assets\n    event LiquidityRemoved(\n        uint256 withdrawLiquidityShare,\n        uint256 removedWETHAmount,\n        uint256 removedOETHAmount,\n        uint256 underlyingAssets\n    );\n\n    /// @notice Emitted when the underlying pool is rebalanced\n    /// @param currentPoolWethShare The resulting share of strategy's liquidity\n    /// in the TICK_NUMBER\n    event PoolRebalanced(uint256 currentPoolWethShare);\n\n    /// @notice Emitted when the amount of underlying assets the strategy hold as\n    /// liquidity in the pool is updated.\n    /// @param underlyingAssets Updated amount of strategy's underlying assets\n    event UnderlyingAssetsUpdated(uint256 underlyingAssets);\n\n    /// @notice Emitted when liquidity is added to the underlying pool\n    /// @param wethAmountDesired Amount of WETH desired to be deposited\n    /// @param oethAmountDesired Amount of OETH desired to be deposited\n    /// @param wethAmountSupplied Amount of WETH deposited\n    /// @param oethAmountSupplied Amount of OETH deposited\n    /// @param tokenId NFT liquidity token id\n    /// @param underlyingAssets Updated amount of underlying assets\n    event LiquidityAdded(\n        uint256 wethAmountDesired,\n        uint256 oethAmountDesired,\n        uint256 wethAmountSupplied,\n        uint256 oethAmountSupplied,\n        uint256 tokenId,\n        uint256 underlyingAssets\n    ); // 0x1530ec74\n\n    error PoolRebalanceOutOfBounds(\n        uint256 currentPoolWethShare,\n        uint256 allowedWethShareStart,\n        uint256 allowedWethShareEnd\n    ); // 0x3681e8e0\n\n    error NotEnoughWethForSwap(uint256 wethBalance, uint256 requiredWeth); // 0x989e5ca8\n    error NotEnoughWethLiquidity(uint256 wethBalance, uint256 requiredWeth); // 0xa6737d87\n    error OutsideExpectedTickRange(); // 0xa6e1bad2\n    error SlippageCheck(uint256 tokenReceived); // 0x355cdb78\n\n    /// @notice the constructor\n    /// @dev This contract is intended to be used as a proxy. To prevent the\n    ///      potential confusion of having a functional implementation contract\n    ///      the constructor has the `initializer` modifier. This way the\n    ///      `initialize` function can not be called on the implementation contract.\n    ///      For the same reason the implementation contract also has the governor\n    ///      set to a zero address.\n    /// @param _stratConfig the basic strategy configuration\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\n    /// @param _oethAddress Address of the Erc20 OETH Token contract\n    /// @param _liquidityManager Address of liquidity manager to add\n    ///         the liquidity\n    /// @param _poolLens Address of the pool lens contract\n    /// @param _maverickPosition Address of the Maverick's position contract\n    /// @param _maverickQuoter Address of the Maverick's Quoter contract\n    /// @param _mPool Address of the Rooster concentrated liquidity pool\n    /// @param _upperTickAtParity Bool when true upperTick is the one where the\n    ///        price of OETH and WETH are at parity\n    constructor(\n        BaseStrategyConfig memory _stratConfig,\n        address _wethAddress,\n        address _oethAddress,\n        address _liquidityManager,\n        address _poolLens,\n        address _maverickPosition,\n        address _maverickQuoter,\n        address _mPool,\n        bool _upperTickAtParity,\n        address _votingDistributor,\n        address _poolDistributor\n    ) initializer InitializableAbstractStrategy(_stratConfig) {\n        require(\n            address(IMaverickV2Pool(_mPool).tokenA()) == _wethAddress,\n            \"WETH not TokenA\"\n        );\n        require(\n            address(IMaverickV2Pool(_mPool).tokenB()) == _oethAddress,\n            \"OETH not TokenB\"\n        );\n        require(\n            _liquidityManager != address(0),\n            \"LiquidityManager zero address not allowed\"\n        );\n        require(\n            _maverickQuoter != address(0),\n            \"Quoter zero address not allowed\"\n        );\n        require(_poolLens != address(0), \"PoolLens zero address not allowed\");\n        require(\n            _maverickPosition != address(0),\n            \"Position zero address not allowed\"\n        );\n        require(\n            _votingDistributor != address(0),\n            \"Voting distributor zero address not allowed\"\n        );\n        require(\n            _poolDistributor != address(0),\n            \"Pool distributor zero address not allowed\"\n        );\n\n        uint256 _tickSpacing = IMaverickV2Pool(_mPool).tickSpacing();\n        require(_tickSpacing == 1, \"Unsupported tickSpacing\");\n\n        // tickSpacing == 1\n        (sqrtPriceTickLower, sqrtPriceTickHigher) = TickMath.tickSqrtPrices(\n            _tickSpacing,\n            TICK_NUMBER\n        );\n        sqrtPriceAtParity = _upperTickAtParity\n            ? sqrtPriceTickHigher\n            : sqrtPriceTickLower;\n\n        WETH = _wethAddress;\n        OETH = _oethAddress;\n        liquidityManager = IMaverickV2LiquidityManager(_liquidityManager);\n        poolLens = IMaverickV2PoolLens(_poolLens);\n        maverickPosition = IMaverickV2Position(_maverickPosition);\n        quoter = IMaverickV2Quoter(_maverickQuoter);\n        mPool = IMaverickV2Pool(_mPool);\n        votingDistributor = IVotingDistributor(_votingDistributor);\n        poolDistributor = IPoolDistributor(_poolDistributor);\n\n        // prevent implementation contract to be governed\n        _setGovernor(address(0));\n    }\n\n    /**\n     * @notice initialize function, to set up initial internal state\n     */\n    function initialize() external onlyGovernor initializer {\n        // Read reward\n        address[] memory _rewardTokens = new address[](1);\n        _rewardTokens[0] = poolDistributor.rewardToken();\n\n        require(_rewardTokens[0] != address(0), \"No reward token configured\");\n\n        InitializableAbstractStrategy._initialize(\n            _rewardTokens,\n            new address[](0),\n            new address[](0)\n        );\n    }\n\n    /***************************************\n                  Configuration \n    ****************************************/\n\n    /**\n     * @notice Set allowed pool weth share interval. After the rebalance happens\n     * the share of WETH token in the ticker needs to be within the specifications\n     * of the interval.\n     *\n     * @param _allowedWethShareStart Start of WETH share interval expressed as 18 decimal amount\n     * @param _allowedWethShareEnd End of WETH share interval expressed as 18 decimal amount\n     */\n    function setAllowedPoolWethShareInterval(\n        uint256 _allowedWethShareStart,\n        uint256 _allowedWethShareEnd\n    ) external onlyGovernor {\n        require(\n            _allowedWethShareStart < _allowedWethShareEnd,\n            \"Invalid interval\"\n        );\n        // can not go below 1% weth share\n        require(_allowedWethShareStart > 0.01 ether, \"Invalid interval start\");\n        // can not go above 95% weth share\n        require(_allowedWethShareEnd < 0.95 ether, \"Invalid interval end\");\n\n        allowedWethShareStart = _allowedWethShareStart;\n        allowedWethShareEnd = _allowedWethShareEnd;\n        emit PoolWethShareIntervalUpdated(\n            _allowedWethShareStart,\n            _allowedWethShareEnd\n        );\n    }\n\n    /***************************************\n               Strategy overrides \n    ****************************************/\n\n    /**\n     * @notice Deposits funds to the strategy which deposits them to the\n     * underlying Rooster pool if the pool price is within the expected interval.\n     * @param _asset   Address for the asset\n     * @param _amount  Units of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @notice Deposits all the funds to the strategy which deposits them to the\n     * underlying Rooster pool if the pool price is within the expected interval.\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        _deposit(WETH, _wethBalance);\n    }\n\n    /**\n     * @dev Deposits funds to the strategy which deposits them to the\n     * underlying Rooster pool if the pool price is within the expected interval.\n     * Before this function can be called the initial pool position needs to already\n     * be minted.\n     * @param _asset Address of the asset to deposit\n     * @param _amount Amount of assets to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_asset == WETH, \"Unsupported asset\");\n        require(_amount > 0, \"Must deposit something\");\n        require(tokenId > 0, \"Initial position not minted\");\n        emit Deposit(_asset, address(0), _amount);\n\n        // if the pool price is not within the expected interval leave the WETH on the contract\n        // as to not break the mints - in case it would be configured as a default asset strategy\n        (bool _isExpectedRange, ) = _checkForExpectedPoolPrice(false);\n        if (_isExpectedRange) {\n            // deposit funds into the underlying pool. Because no swap is performed there is no\n            // need to remove any of the liquidity beforehand.\n            _rebalance(0, false, 0, 0);\n        }\n    }\n\n    /**\n     * @notice Withdraw an `amount` of WETH from the platform and\n     *         send to the `_recipient`.\n     * @param _recipient  Address to which the asset should be sent\n     * @param _asset      WETH address\n     * @param _amount     Amount of WETH to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_asset == WETH, \"Unsupported asset\");\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient == vaultAddress, \"Only withdraw to vault allowed\");\n\n        _ensureWETHBalance(_amount);\n\n        _withdraw(_recipient, _amount);\n    }\n\n    /**\n     * @notice Withdraw WETH and sends it to the Vault.\n     */\n    function withdrawAll() external override onlyVault nonReentrant {\n        if (tokenId != 0) {\n            _removeLiquidity(1e18);\n        }\n\n        uint256 _balance = IERC20(WETH).balanceOf(address(this));\n        if (_balance > 0) {\n            _withdraw(vaultAddress, _balance);\n        }\n    }\n\n    function _withdraw(address _recipient, uint256 _amount) internal {\n        IERC20(WETH).safeTransfer(_recipient, _amount);\n        emit Withdrawal(WETH, address(0), _amount);\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset   Address of the asset\n     * @return bool    True when the _asset is WETH\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == WETH;\n    }\n\n    /**\n     * @dev Approve the spending amounts for the assets\n     */\n    function _approveTokenAmounts(\n        uint256 _wethAllowance,\n        uint256 _oethAllowance\n    ) internal {\n        IERC20(WETH).approve(address(liquidityManager), _wethAllowance);\n        IERC20(OETH).approve(address(liquidityManager), _oethAllowance);\n    }\n\n    /***************************************\n              Liquidity management\n    ****************************************/\n    /**\n     * @dev Add liquidity into the pool in the pre-configured WETH to OETH share ratios\n     * defined by the allowedPoolWethShareStart|End interval.\n     *\n     * Normally a PoolLens contract is used to prepare the parameters to add liquidity to the\n     * Rooster pools. It has some errors when doing those calculation and for that reason a\n     * much more accurate Quoter contract is used. This is possible due to our requirement of\n     * adding liquidity only to one tick - PoolLens supports adding liquidity into multiple ticks\n     * using different distribution ratios.\n     */\n    function _addLiquidity() internal {\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        uint256 _oethBalance = IERC20(OETH).balanceOf(address(this));\n        // don't deposit small liquidity amounts\n        if (_wethBalance <= ACTION_THRESHOLD) {\n            return;\n        }\n\n        (\n            bytes memory packedSqrtPriceBreaks,\n            bytes[] memory packedArgs,\n            uint256 WETHRequired,\n            uint256 OETHRequired\n        ) = _getAddLiquidityParams(_wethBalance, 1e30);\n\n        if (OETHRequired > _oethBalance) {\n            IVault(vaultAddress).mintForStrategy(OETHRequired - _oethBalance);\n        }\n\n        _approveTokenAmounts(WETHRequired, OETHRequired);\n\n        (\n            uint256 _wethAmount,\n            uint256 _oethAmount,\n            uint32[] memory binIds\n        ) = liquidityManager.addPositionLiquidityToSenderByTokenIndex(\n                mPool,\n                0, // NFT token index\n                packedSqrtPriceBreaks,\n                packedArgs\n            );\n\n        require(binIds.length == 1, \"Unexpected binIds length\");\n\n        // burn remaining OETH\n        _burnOethOnTheContract();\n        _updateUnderlyingAssets();\n\n        // needs to be called after _updateUnderlyingAssets so the updated amount\n        // is reflected in the event\n        emit LiquidityAdded(\n            _wethBalance, // wethAmountDesired\n            OETHRequired, // oethAmountDesired\n            _wethAmount, // wethAmountSupplied\n            _oethAmount, // oethAmountSupplied\n            tokenId, // tokenId\n            underlyingAssets\n        );\n    }\n\n    /**\n     * @dev The function creates liquidity parameters required to be able to add liquidity to the pool.\n     * The function needs to handle the 3 different cases of the way liquidity is added:\n     *  - only WETH present in the tick\n     *  - only OETH present in the tick\n     *  - both tokens present in the tick\n     *\n     */\n    function _getAddLiquidityParams(uint256 _maxWETH, uint256 _maxOETH)\n        internal\n        returns (\n            bytes memory packedSqrtPriceBreaks,\n            bytes[] memory packedArgs,\n            uint256 WETHRequired,\n            uint256 OETHRequired\n        )\n    {\n        IMaverickV2Pool.AddLiquidityParams[]\n            memory addParams = new IMaverickV2Pool.AddLiquidityParams[](1);\n        int32[] memory ticks = new int32[](1);\n        uint128[] memory amounts = new uint128[](1);\n        ticks[0] = TICK_NUMBER;\n        // arbitrary LP amount\n        amounts[0] = 1e24;\n\n        // construct value for Quoter with arbitrary LP amount\n        IMaverickV2Pool.AddLiquidityParams memory addParam = IMaverickV2Pool\n            .AddLiquidityParams({\n                kind: MAV_STATIC_BIN_KIND,\n                ticks: ticks,\n                amounts: amounts\n            });\n\n        // get the WETH and OETH required to get the proportion of tokens required\n        // given the arbitrary liquidity\n        (WETHRequired, OETHRequired, ) = quoter.calculateAddLiquidity(\n            mPool,\n            addParam\n        );\n\n        /**\n         * If either token required is 0 then the tick consists only of the other token. In that\n         * case the liquidity calculations need to be done using the non 0 token. By setting the\n         * tokenRequired from 0 to 1 the `min` in next step will ignore that (the bigger) value.\n         */\n        WETHRequired = WETHRequired == 0 ? 1 : WETHRequired;\n        OETHRequired = OETHRequired == 0 ? 1 : OETHRequired;\n\n        addParam.amounts[0] = Math_v5\n            .min(\n                ((_maxWETH - 1) * 1e24) / WETHRequired,\n                ((_maxOETH - 1) * 1e24) / OETHRequired\n            )\n            .toUint128();\n\n        // update the quotes with the actual amounts\n        (WETHRequired, OETHRequired, ) = quoter.calculateAddLiquidity(\n            mPool,\n            addParam\n        );\n\n        require(_maxWETH >= WETHRequired, \"More WETH required than specified\");\n        require(_maxOETH >= OETHRequired, \"More OETH required than specified\");\n\n        // organize values to be used by manager\n        addParams[0] = addParam;\n        packedArgs = liquidityManager.packAddLiquidityArgsArray(addParams);\n        // price can stay 0 if array only has one element\n        packedSqrtPriceBreaks = liquidityManager.packUint88Array(\n            new uint88[](1)\n        );\n    }\n\n    /**\n     * @dev Check that the Rooster pool price is within the expected\n     *      parameters.\n     *      This function works whether the strategy contract has liquidity\n     *      position in the pool or not. The function returns _wethSharePct\n     *      as a gas optimization measure.\n     * @param _throwException  when set to true the function throws an exception\n     *                         when pool's price is not within expected range.\n     * @return _isExpectedRange  Bool expressing price is within expected range\n     * @return _wethSharePct  Share of WETH owned by this strategy contract in the\n     *                        configured ticker.\n     */\n    function _checkForExpectedPoolPrice(bool _throwException)\n        internal\n        view\n        returns (bool _isExpectedRange, uint256 _wethSharePct)\n    {\n        require(\n            allowedWethShareStart != 0 && allowedWethShareEnd != 0,\n            \"Weth share interval not set\"\n        );\n\n        uint256 _currentPrice = getPoolSqrtPrice();\n\n        /**\n         * First check pool price is in expected tick range\n         *\n         * A revert is issued even though price being equal to the lower bound as that can not\n         * be within the approved tick range.\n         */\n        if (\n            _currentPrice <= sqrtPriceTickLower ||\n            _currentPrice >= sqrtPriceTickHigher\n        ) {\n            if (_throwException) {\n                revert OutsideExpectedTickRange();\n            }\n\n            return (false, _currentPrice <= sqrtPriceTickLower ? 0 : 1e18);\n        }\n\n        // 18 decimal number expressed WETH tick share\n        _wethSharePct = _getWethShare(_currentPrice);\n\n        if (\n            _wethSharePct < allowedWethShareStart ||\n            _wethSharePct > allowedWethShareEnd\n        ) {\n            if (_throwException) {\n                revert PoolRebalanceOutOfBounds(\n                    _wethSharePct,\n                    allowedWethShareStart,\n                    allowedWethShareEnd\n                );\n            }\n            return (false, _wethSharePct);\n        }\n\n        return (true, _wethSharePct);\n    }\n\n    /**\n     * @notice Rebalance the pool to the desired token split and Deposit any WETH on the contract to the\n     * underlying rooster pool. Print the required amount of corresponding OETH. After the rebalancing is\n     * done burn any potentially remaining OETH tokens still on the strategy contract.\n     *\n     * This function has a slightly different behaviour depending on the status of the underlying Rooster\n     * pool. The function consists of the following 3 steps:\n     * 1. withdrawLiquidityOption -> this is a configurable option where either only part of the liquidity\n     *                               necessary for the swap is removed, or all of it. This way the rebalance\n     *                               is able to optimize for volume, for efficiency or anything in between\n     * 2. swapToDesiredPosition   -> move active trading price in the pool to be able to deposit WETH & OETH\n     *                               tokens with the desired pre-configured ratios\n     * 3. addLiquidity            -> add liquidity into the pool respecting ratio split configuration\n     *\n     *\n     * Exact _amountToSwap, _swapWeth & _minTokenReceived parameters shall be determined by simulating the\n     * transaction off-chain. The strategy checks that after the swap the share of the tokens is in the\n     * expected ranges.\n     *\n     * @param _amountToSwap The amount of the token to swap\n     * @param _swapWeth Swap using WETH when true, use OETH when false\n     * @param _minTokenReceived Slippage check -> minimum amount of token expected in return\n     * @param _liquidityToRemovePct Percentage of liquidity to remove -> the percentage amount of liquidity to\n     *        remove before performing the swap. 1e18 denominated\n     */\n    function rebalance(\n        uint256 _amountToSwap,\n        bool _swapWeth,\n        uint256 _minTokenReceived,\n        uint256 _liquidityToRemovePct\n    ) external nonReentrant onlyGovernorOrStrategist {\n        _rebalance(\n            _amountToSwap,\n            _swapWeth,\n            _minTokenReceived,\n            _liquidityToRemovePct\n        );\n    }\n\n    // slither-disable-start reentrancy-no-eth\n    function _rebalance(\n        uint256 _amountToSwap,\n        bool _swapWeth,\n        uint256 _minTokenReceived,\n        uint256 _liquidityToRemovePct\n    ) internal {\n        // Remove the required amount of liquidity\n        if (_liquidityToRemovePct > 0) {\n            _removeLiquidity(_liquidityToRemovePct);\n        }\n\n        // in some cases (e.g. deposits) we will just want to add liquidity and not\n        // issue a swap to move the active trading position within the pool. Before or after a\n        // deposit or as a standalone call the strategist might issue a rebalance to move the\n        // active trading price to a more desired position.\n        if (_amountToSwap > 0) {\n            // In case liquidity has been removed and there is still not enough WETH owned by the\n            // strategy contract remove additional required amount of WETH.\n            if (_swapWeth) _ensureWETHBalance(_amountToSwap);\n\n            _swapToDesiredPosition(_amountToSwap, _swapWeth, _minTokenReceived);\n        }\n\n        // calling check liquidity early so we don't get unexpected errors when adding liquidity\n        // in the later stages of this function\n        _checkForExpectedPoolPrice(true);\n\n        _addLiquidity();\n\n        // this call shouldn't be necessary, since adding liquidity shouldn't affect the active\n        // trading price. It is a defensive programming measure.\n        (, uint256 _wethSharePct) = _checkForExpectedPoolPrice(true);\n\n        // revert if protocol insolvent\n        _solvencyAssert();\n\n        emit PoolRebalanced(_wethSharePct);\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /**\n     * @dev Perform a swap so that after the swap the tick has the desired WETH to OETH token share.\n     */\n    function _swapToDesiredPosition(\n        uint256 _amountToSwap,\n        bool _swapWeth,\n        uint256 _minTokenReceived\n    ) internal {\n        IERC20 _tokenToSwap = IERC20(_swapWeth ? WETH : OETH);\n        uint256 _balance = _tokenToSwap.balanceOf(address(this));\n\n        if (_balance < _amountToSwap) {\n            // This should never trigger since _ensureWETHBalance will already\n            // throw an error if there is not enough WETH\n            if (_swapWeth) {\n                revert NotEnoughWethForSwap(_balance, _amountToSwap);\n            }\n            // if swapping OETH\n            uint256 mintForSwap = _amountToSwap - _balance;\n            IVault(vaultAddress).mintForStrategy(mintForSwap);\n        }\n\n        // SafeERC20 is used for IERC20 transfers. Not sure why slither complains\n        // slither-disable-next-line unchecked-transfer\n        _tokenToSwap.transfer(address(mPool), _amountToSwap);\n\n        // tickLimit: the furthest tick a swap will execute in. If no limit is desired,\n        // value should be set to type(int32).max for a tokenAIn (WETH) swap\n        // and type(int32).min for a swap where tokenB (OETH) is the input\n\n        IMaverickV2Pool.SwapParams memory swapParams = IMaverickV2Pool\n        // exactOutput defines whether the amount specified is the output\n        // or the input amount of the swap\n            .SwapParams({\n                amount: _amountToSwap,\n                tokenAIn: _swapWeth,\n                exactOutput: false,\n                tickLimit: TICK_NUMBER\n            });\n\n        // swaps without a callback as the assets are already sent to the pool\n        (, uint256 amountOut) = mPool.swap(\n            address(this),\n            swapParams,\n            bytes(\"\")\n        );\n\n        /**\n         * There could be additional checks here for validating minTokenReceived is within the\n         * expected range (e.g. 99% - 101% of the token sent in). Though that doesn't provide\n         * any additional security. After the swap the `_checkForExpectedPoolPrice` validates\n         * that the swap has moved the price into the expected tick (# -1).\n         *\n         * If the guardian forgets to set a `_minTokenReceived` and a sandwich attack bends\n         * the pool before the swap the `_checkForExpectedPoolPrice` will fail the transaction.\n         *\n         * A check would not prevent a compromised guardian from stealing funds as multiple\n         * transactions each loosing smaller amount of funds are still possible.\n         */\n        if (amountOut < _minTokenReceived) {\n            revert SlippageCheck(amountOut);\n        }\n\n        /**\n         * In the interest of each function in `_rebalance` to leave the contract state as\n         * clean as possible the OETH tokens here are burned. This decreases the\n         * dependence where `_swapToDesiredPosition` function relies on later functions\n         * (`addLiquidity`) to burn the OETH. Reducing the risk of error introduction.\n         */\n        _burnOethOnTheContract();\n    }\n\n    /**\n     * @dev This function removes the appropriate amount of liquidity to ensure that the required\n     * amount of WETH is available on the contract\n     *\n     * @param _amount  WETH balance required on the contract\n     */\n    function _ensureWETHBalance(uint256 _amount) internal {\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        if (_wethBalance >= _amount) {\n            return;\n        }\n\n        require(tokenId != 0, \"No liquidity available\");\n        uint256 _additionalWethRequired = _amount - _wethBalance;\n        (uint256 _wethInThePool, ) = getPositionPrincipal();\n\n        if (_wethInThePool < _additionalWethRequired) {\n            revert NotEnoughWethLiquidity(\n                _wethInThePool,\n                _additionalWethRequired\n            );\n        }\n\n        uint256 shareOfWethToRemove = _wethInThePool <= 1\n            ? 1e18\n            : Math_v5.min(\n                /**\n                 * When dealing with shares of liquidity to remove there is always some\n                 * rounding involved. After extensive fuzz testing the below approach\n                 * yielded the best results where the strategy overdraws the least and\n                 * never removes insufficient amount of WETH.\n                 */\n                (_additionalWethRequired + 2).divPrecisely(_wethInThePool - 1) +\n                    2,\n                1e18\n            );\n\n        _removeLiquidity(shareOfWethToRemove);\n    }\n\n    /**\n     * @dev Decrease partial or all liquidity from the pool.\n     * @param _liquidityToDecrease The amount of liquidity to remove denominated in 1e18\n     */\n    function _removeLiquidity(uint256 _liquidityToDecrease) internal {\n        require(_liquidityToDecrease > 0, \"Must remove some liquidity\");\n        require(\n            _liquidityToDecrease <= 1e18,\n            \"Can not remove more than 100% of liquidity\"\n        );\n\n        // 0 indicates the first (and only) bin in the NFT LP position.\n        IMaverickV2Pool.RemoveLiquidityParams memory params = maverickPosition\n            .getRemoveParams(tokenId, 0, _liquidityToDecrease);\n        (uint256 _amountWeth, uint256 _amountOeth) = maverickPosition\n            .removeLiquidityToSender(tokenId, mPool, params);\n\n        _burnOethOnTheContract();\n        _updateUnderlyingAssets();\n\n        // needs to be called after the _updateUnderlyingAssets so the updated amount is reflected\n        // in the event\n        emit LiquidityRemoved(\n            _liquidityToDecrease,\n            _amountWeth,\n            _amountOeth,\n            underlyingAssets\n        );\n    }\n\n    /**\n     * @dev Burns any OETH tokens remaining on the strategy contract if the balance is\n     * above the action threshold.\n     */\n    function _burnOethOnTheContract() internal {\n        uint256 _oethBalance = IERC20(OETH).balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(_oethBalance);\n    }\n\n    /**\n     * @notice Returns the percentage of WETH liquidity in the configured ticker\n     *         owned by this strategy contract.\n     * @return uint256 1e18 denominated percentage expressing the share\n     */\n    function getWETHShare() external view returns (uint256) {\n        uint256 _currentPrice = getPoolSqrtPrice();\n        return _getWethShare(_currentPrice);\n    }\n\n    /**\n     * @dev Returns the share of WETH in tick denominated in 1e18\n     */\n    function _getWethShare(uint256 _currentPrice)\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            uint256 wethAmount,\n            uint256 oethAmount\n        ) = _reservesInTickForGivenPriceAndLiquidity(\n                sqrtPriceTickLower,\n                sqrtPriceTickHigher,\n                _currentPrice,\n                1e24\n            );\n\n        return wethAmount.divPrecisely(wethAmount + oethAmount);\n    }\n\n    /**\n     * @notice Returns the current pool price in square root\n     * @return Square root of the pool price\n     */\n    function getPoolSqrtPrice() public view returns (uint256) {\n        return poolLens.getPoolSqrtPrice(mPool);\n    }\n\n    /**\n     * @notice Returns the current active trading tick of the underlying pool\n     * @return _currentTick Current pool trading tick\n     */\n    function getCurrentTradingTick() public view returns (int32 _currentTick) {\n        _currentTick = mPool.getState().activeTick;\n    }\n\n    /**\n     * @notice Mint the initial NFT position\n     *\n     * @dev This amount is \"gifted\" to the strategy contract and will count as a yield\n     *      surplus.\n     */\n    // slither-disable-start reentrancy-no-eth\n    function mintInitialPosition() external onlyGovernor nonReentrant {\n        require(tokenId == 0, \"Initial position already minted\");\n        (\n            bytes memory packedSqrtPriceBreaks,\n            bytes[] memory packedArgs,\n            uint256 WETHRequired,\n            uint256 OETHRequired\n        ) = _getAddLiquidityParams(1e16, 1e16);\n\n        // Mint rounded up OETH amount\n        if (OETHRequired > 0) {\n            IVault(vaultAddress).mintForStrategy(OETHRequired);\n        }\n\n        _approveTokenAmounts(WETHRequired, OETHRequired);\n\n        // Store the tokenId before calling updateUnderlyingAssets as it relies on the tokenId\n        // not being 0\n        (, , , tokenId) = liquidityManager.mintPositionNftToSender(\n            mPool,\n            packedSqrtPriceBreaks,\n            packedArgs\n        );\n\n        // burn remaining OETH\n        _burnOethOnTheContract();\n        _updateUnderlyingAssets();\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /**\n     * @notice Returns the balance of tokens the strategy holds in the LP position\n     * @return _amountWeth Amount of WETH in position\n     * @return _amountOeth Amount of OETH in position\n     */\n    function getPositionPrincipal()\n        public\n        view\n        returns (uint256 _amountWeth, uint256 _amountOeth)\n    {\n        if (tokenId == 0) {\n            return (0, 0);\n        }\n\n        (_amountWeth, _amountOeth, ) = _getPositionInformation();\n    }\n\n    /**\n     * @dev Returns the balance of tokens the strategy holds in the LP position\n     * @return _amountWeth Amount of WETH in position\n     * @return _amountOeth Amount of OETH in position\n     * @return liquidity Amount of liquidity in the position\n     */\n    function _getPositionInformation()\n        internal\n        view\n        returns (\n            uint256 _amountWeth,\n            uint256 _amountOeth,\n            uint256 liquidity\n        )\n    {\n        IMaverickV2Position.PositionFullInformation\n            memory positionInfo = maverickPosition.tokenIdPositionInformation(\n                tokenId,\n                0\n            );\n\n        require(\n            positionInfo.liquidities.length == 1,\n            \"Unexpected liquidities length\"\n        );\n        require(positionInfo.ticks.length == 1, \"Unexpected ticks length\");\n\n        _amountWeth = positionInfo.amountA;\n        _amountOeth = positionInfo.amountB;\n        liquidity = positionInfo.liquidities[0];\n    }\n\n    /**\n     * Checks that the protocol is solvent, protecting from a rogue Strategist / Guardian that can\n     * keep rebalancing the pool in both directions making the protocol lose a tiny amount of\n     * funds each time.\n     *\n     * Protocol must be at least SOLVENCY_THRESHOLD (99.8%) backed in order for the rebalances to\n     * function.\n     */\n    function _solvencyAssert() internal view {\n        uint256 _totalVaultValue = IVault(vaultAddress).totalValue();\n        uint256 _totalOethSupply = IERC20(OETH).totalSupply();\n\n        if (\n            _totalVaultValue.divPrecisely(_totalOethSupply) < SOLVENCY_THRESHOLD\n        ) {\n            revert(\"Protocol insolvent\");\n        }\n    }\n\n    /**\n     * @dev Collect Rooster reward token, and send it to the harvesterAddress\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Do nothing if there's no position minted\n        if (tokenId > 0) {\n            uint32[] memory binIds = new uint32[](1);\n            IMaverickV2Pool.TickState memory tickState = mPool.getTick(\n                TICK_NUMBER\n            );\n            // get the binId for the MAV_STATIC_BIN_KIND in tick TICK_NUMBER (-1)\n            binIds[0] = tickState.binIdsByTick[0];\n\n            uint256 lastEpoch = votingDistributor.lastEpoch();\n\n            poolDistributor.claimLp(\n                address(this),\n                tokenId,\n                mPool,\n                binIds,\n                lastEpoch\n            );\n        }\n\n        // Run the internal inherited function\n        _collectRewardTokens();\n    }\n\n    /***************************************\n            Balances and Fees\n    ****************************************/\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(_asset == WETH, \"Only WETH supported\");\n\n        // because of PoolLens inaccuracy there is usually some dust WETH left on the contract\n        uint256 _wethBalance = IERC20(WETH).balanceOf(address(this));\n        // just paranoia check, in case there is OETH in the strategy that for some reason hasn't\n        // been burned yet. This should always be 0.\n        uint256 _oethBalance = IERC20(OETH).balanceOf(address(this));\n        return underlyingAssets + _wethBalance + _oethBalance;\n    }\n\n    /// @dev This function updates the amount of underlying assets with the approach of the least possible\n    ///      total tokens extracted for the current liquidity in the pool.\n    function _updateUnderlyingAssets() internal {\n        /**\n         * Our net value represent the smallest amount of tokens we are able to extract from the position\n         * given our liquidity.\n         *\n         * The least amount of tokens ex-tractable from the position is where the active trading price is\n         * at the edge between tick -1 & tick 0. There the pool is offering 1:1 trades between WETH & OETH.\n         * At that moment the pool consists completely of WETH and no OETH.\n         *\n         * The more swaps from OETH -> WETH happen on the pool the more the price starts to move away from the tick 0\n         * towards the middle of tick -1 making OETH (priced in WETH) cheaper.\n         */\n\n        uint256 _wethAmount = tokenId == 0 ? 0 : _balanceInPosition();\n\n        underlyingAssets = _wethAmount;\n        emit UnderlyingAssetsUpdated(_wethAmount);\n    }\n\n    /**\n     * @dev Strategy reserves (which consist only of WETH in case of Rooster - Plume pool)\n     * when the tick price is closest to parity - assuring the lowest amount of tokens\n     * returned for the current position liquidity.\n     */\n    function _balanceInPosition() internal view returns (uint256 _wethBalance) {\n        (, , uint256 liquidity) = _getPositionInformation();\n\n        uint256 _oethBalance;\n\n        (_wethBalance, _oethBalance) = _reservesInTickForGivenPriceAndLiquidity(\n            sqrtPriceTickLower,\n            sqrtPriceTickHigher,\n            sqrtPriceAtParity,\n            liquidity\n        );\n\n        require(_oethBalance == 0, \"Non zero oethBalance\");\n    }\n\n    /**\n     * @notice Tick dominance   denominated in 1e18\n     * @return _tickDominance   The share of liquidity in TICK_NUMBER tick owned\n     *                          by the strategy contract denominated in 1e18\n     */\n    function tickDominance() public view returns (uint256 _tickDominance) {\n        IMaverickV2Pool.TickState memory tickState = mPool.getTick(TICK_NUMBER);\n\n        uint256 wethReserve = tickState.reserveA;\n        uint256 oethReserve = tickState.reserveB;\n\n        // prettier-ignore\n        (uint256 _amountWeth, uint256 _amountOeth, ) = _getPositionInformation();\n\n        if (wethReserve + oethReserve == 0) {\n            return 0;\n        }\n\n        _tickDominance = (_amountWeth + _amountOeth).divPrecisely(\n            wethReserve + oethReserve\n        );\n    }\n\n    /***************************************\n            Hidden functions\n    ****************************************/\n    /**\n     * @dev Unsupported\n     */\n    function setPTokenAddress(address, address) external pure override {\n        // The pool tokens can never change.\n        revert(\"Unsupported method\");\n    }\n\n    /**\n     * @dev Unsupported\n     */\n    function removePToken(uint256) external pure override {\n        // The pool tokens can never change.\n        revert(\"Unsupported method\");\n    }\n\n    /**\n     * @dev Unsupported\n     */\n    function _abstractSetPToken(address, address) internal pure override {\n        revert(\"Unsupported method\");\n    }\n\n    /**\n     * @dev Unsupported\n     */\n    function safeApproveAllTokens() external pure override {\n        // all the amounts are approved at the time required\n        revert(\"Unsupported method\");\n    }\n\n    /***************************************\n          Maverick liquidity utilities\n    ****************************************/\n\n    /// @notice Calculates deltaA = liquidity * (sqrt(upper) - sqrt(lower))\n    ///  Calculates deltaB = liquidity / sqrt(lower) - liquidity / sqrt(upper),\n    ///  i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n    ///\n    /// @dev refactored from here:\n    // solhint-disable-next-line max-line-length\n    /// https://github.com/rooster-protocol/rooster-contracts/blob/main/v2-supplemental/contracts/libraries/LiquidityUtilities.sol#L665-L695\n    function _reservesInTickForGivenPriceAndLiquidity(\n        uint256 _lowerSqrtPrice,\n        uint256 _upperSqrtPrice,\n        uint256 _newSqrtPrice,\n        uint256 _liquidity\n    ) internal pure returns (uint128 reserveA, uint128 reserveB) {\n        if (_liquidity == 0) {\n            (reserveA, reserveB) = (0, 0);\n        } else {\n            uint256 lowerEdge = MathRooster.max(_lowerSqrtPrice, _newSqrtPrice);\n\n            reserveA = MathRooster\n                .mulCeil(\n                    _liquidity,\n                    MathRooster.clip(\n                        MathRooster.min(_upperSqrtPrice, _newSqrtPrice),\n                        _lowerSqrtPrice\n                    )\n                )\n                .toUint128();\n            reserveB = MathRooster\n                .mulDivCeil(\n                    _liquidity,\n                    1e18 * MathRooster.clip(_upperSqrtPrice, lowerEdge),\n                    _upperSqrtPrice * lowerEdge\n                )\n                .toUint128();\n        }\n    }\n}\n"
    },
    "contracts/strategies/sonic/SonicStakingStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SonicValidatorDelegator } from \"./SonicValidatorDelegator.sol\";\nimport { IWrappedSonic } from \"../../interfaces/sonic/IWrappedSonic.sol\";\n\n/**\n * @title Staking Strategy for Sonic's native S currency\n * @author Origin Protocol Inc\n */\ncontract SonicStakingStrategy is SonicValidatorDelegator {\n    // For future use\n    uint256[50] private __gap;\n\n    constructor(\n        BaseStrategyConfig memory _baseConfig,\n        address _wrappedSonic,\n        address _sfc\n    ) SonicValidatorDelegator(_baseConfig, _wrappedSonic, _sfc) {}\n\n    /// @notice Deposit wrapped S asset into the underlying platform.\n    /// @param _asset Address of asset to deposit. Has to be Wrapped Sonic (wS).\n    /// @param _amount Amount of assets that were transferred to the strategy by the vault.\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        require(_asset == wrappedSonic, \"Unsupported asset\");\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @notice Deposit Wrapped Sonic (wS) to this strategy and delegate to a validator.\n     * @param _asset Address of Wrapped Sonic (wS) token\n     * @param _amount Amount of Wrapped Sonic (wS) to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal virtual {\n        require(_amount > 0, \"Must deposit something\");\n\n        _delegate(_amount);\n        emit Deposit(_asset, address(0), _amount);\n    }\n\n    /**\n     * @notice Deposit the entire balance of wrapped S in this strategy contract into\n     * the underlying platform.\n     */\n    function depositAll() external virtual override onlyVault nonReentrant {\n        uint256 wSBalance = IERC20(wrappedSonic).balanceOf(address(this));\n\n        if (wSBalance > 0) {\n            _deposit(wrappedSonic, wSBalance);\n        }\n    }\n\n    /// @notice Withdraw Wrapped Sonic (wS) from this strategy contract.\n    /// Used only if some wS is lingering on the contract.\n    /// That can happen only when someone sends wS directly to this contract\n    /// @param _recipient Address to receive withdrawn assets\n    /// @param _asset Address of the Wrapped Sonic (wS) token\n    /// @param _amount Amount of Wrapped Sonic (wS) to withdraw\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_asset == wrappedSonic, \"Unsupported asset\");\n        _withdraw(_recipient, _asset, _amount);\n    }\n\n    function _withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) internal override {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        // slither-disable-next-line unchecked-transfer unused-return\n        IERC20(_asset).transfer(_recipient, _amount);\n\n        emit Withdrawal(wrappedSonic, address(0), _amount);\n    }\n\n    /// @notice Transfer all Wrapped Sonic (wS) deposits back to the vault.\n    /// This does not withdraw from delegated validators. That has to be done separately with `undelegate`.\n    /// Any native S in this strategy will be withdrawn.\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        uint256 balance = address(this).balance;\n        if (balance > 0) {\n            IWrappedSonic(wrappedSonic).deposit{ value: balance }();\n        }\n        uint256 wSBalance = IERC20(wrappedSonic).balanceOf(address(this));\n        if (wSBalance > 0) {\n            _withdraw(vaultAddress, wrappedSonic, wSBalance);\n        }\n    }\n\n    /**\n     * @dev Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset token\n     */\n    function supportsAsset(address _asset)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _asset == wrappedSonic;\n    }\n\n    /**\n     * @notice is not supported for this strategy as the\n     * Wrapped Sonic (wS) token is set at deploy time.\n     */\n    function setPTokenAddress(address, address)\n        external\n        view\n        override\n        onlyGovernor\n    {\n        revert(\"unsupported function\");\n    }\n\n    /// @notice is not used by this strategy as all staking rewards are restaked\n    function collectRewardTokens() external override nonReentrant {\n        revert(\"unsupported function\");\n    }\n\n    /**\n     * @notice is not supported for this strategy as the\n     * Wrapped Sonic (wS) token is set at deploy time.\n     */\n    function removePToken(uint256) external view override onlyGovernor {\n        revert(\"unsupported function\");\n    }\n\n    /// @dev is not used by this strategy but must be implemented as it's abstract\n    /// in the inherited `InitializableAbstractStrategy` contract.\n    function _abstractSetPToken(address, address) internal virtual override {}\n\n    /// @notice is not used by this strategy\n    function safeApproveAllTokens() external override onlyGovernor {}\n}\n"
    },
    "contracts/strategies/sonic/SonicSwapXAMOStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title SwapX Algorithmic Market Maker (AMO) Strategy\n * @notice AMO strategy for the SwapX OS/wS stable pool\n * @author Origin Protocol Inc\n */\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IERC20, InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\nimport { sqrt } from \"../../utils/PRBMath.sol\";\nimport { IBasicToken } from \"../../interfaces/IBasicToken.sol\";\nimport { IPair } from \"../../interfaces/sonic/ISwapXPair.sol\";\nimport { IGauge } from \"../../interfaces/sonic/ISwapXGauge.sol\";\nimport { IVault } from \"../../interfaces/IVault.sol\";\n\ncontract SonicSwapXAMOStrategy is InitializableAbstractStrategy {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n    using SafeCast for uint256;\n\n    /**\n     * @notice a threshold under which the contract no longer allows for the protocol to manually rebalance.\n     *      Guarding against a strategist / guardian being taken over and with multiple transactions\n     *      draining the protocol funds.\n     */\n    uint256 public constant SOLVENCY_THRESHOLD = 0.998 ether;\n\n    /// @notice Precision for the SwapX Stable AMM (sAMM) invariant k.\n    uint256 public constant PRECISION = 1e18;\n\n    /// @notice Address of the Wrapped S (wS) token.\n    address public immutable ws;\n\n    /// @notice Address of the OS token contract.\n    address public immutable os;\n\n    /// @notice Address of the SwapX Stable pool contract.\n    address public immutable pool;\n\n    /// @notice Address of the SwapX Gauge contract.\n    address public immutable gauge;\n\n    /// @notice The max amount the OS/wS price can deviate from peg (1e18)\n    /// before deposits are reverted scaled to 18 decimals.\n    /// eg 0.01e18 or 1e16 is 1% which is 100 basis points.\n    /// This is the amount below and above peg so a 50 basis point deviation (0.005e18)\n    /// allows a price range from 0.995 to 1.005.\n    uint256 public maxDepeg;\n\n    event SwapOTokensToPool(\n        uint256 osMinted,\n        uint256 wsDepositAmount,\n        uint256 osDepositAmount,\n        uint256 lpTokens\n    );\n    event SwapAssetsToPool(\n        uint256 wsSwapped,\n        uint256 lpTokens,\n        uint256 osBurnt\n    );\n    event MaxDepegUpdated(uint256 maxDepeg);\n\n    /**\n     * @dev Verifies that the caller is the Strategist of the Vault.\n     */\n    modifier onlyStrategist() {\n        require(\n            msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Strategist\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Skim the SwapX pool in case any extra wS or OS tokens were added\n     */\n    modifier skimPool() {\n        IPair(pool).skim(address(this));\n        _;\n    }\n\n    /**\n     * @dev Checks the pool is balanced enough to allow deposits.\n     */\n    modifier nearBalancedPool() {\n        // OS/wS price = wS / OS\n        // Get the OS/wS price for selling 1 OS for wS\n        // As OS is 1, the wS amount is the OS/wS price\n        uint256 sellPrice = IPair(pool).getAmountOut(1e18, os);\n\n        // Get the amount of OS received from selling 1 wS. This is buying OS.\n        uint256 osAmount = IPair(pool).getAmountOut(1e18, ws);\n        // Convert to a OS/wS price = wS / OS\n        uint256 buyPrice = 1e36 / osAmount;\n\n        uint256 pegPrice = 1e18;\n\n        require(\n            sellPrice >= pegPrice - maxDepeg && buyPrice <= pegPrice + maxDepeg,\n            \"price out of range\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Checks the pool's balances have improved and the balances\n     * have not tipped to the other side.\n     * This modifier is only applied to functions that do swaps against the pool.\n     * Deposits and withdrawals are proportional to the pool's balances hence don't need this check.\n     */\n    modifier improvePoolBalance() {\n        // Get the asset and OToken balances in the pool\n        (uint256 wsReservesBefore, uint256 osReservesBefore, ) = IPair(pool)\n            .getReserves();\n        // diff = wS balance - OS balance\n        int256 diffBefore = wsReservesBefore.toInt256() -\n            osReservesBefore.toInt256();\n\n        _;\n\n        // Get the asset and OToken balances in the pool\n        (uint256 wsReservesAfter, uint256 osReservesAfter, ) = IPair(pool)\n            .getReserves();\n        // diff = wS balance - OS balance\n        int256 diffAfter = wsReservesAfter.toInt256() -\n            osReservesAfter.toInt256();\n\n        if (diffBefore == 0) {\n            require(diffAfter == 0, \"Position balance is worsened\");\n        } else if (diffBefore < 0) {\n            // If the pool was originally imbalanced in favor of OS, then\n            // we want to check that the pool is now more balanced\n            require(diffAfter <= 0, \"Assets overshot peg\");\n            require(diffBefore < diffAfter, \"OTokens balance worse\");\n        } else if (diffBefore > 0) {\n            // If the pool was originally imbalanced in favor of wS, then\n            // we want to check that the pool is now more balanced\n            require(diffAfter >= 0, \"OTokens overshot peg\");\n            require(diffAfter < diffBefore, \"Assets balance worse\");\n        }\n    }\n\n    /**\n     * @param _baseConfig The `platformAddress` is the address of the SwapX pool.\n     * The `vaultAddress` is the address of the Origin Sonic Vault.\n     * @param _os Address of the OS token.\n     * @param _ws Address of the Wrapped S (wS) token.\n     * @param _gauge Address of the SwapX gauge for the pool.\n     */\n    constructor(\n        BaseStrategyConfig memory _baseConfig,\n        address _os,\n        address _ws,\n        address _gauge\n    ) InitializableAbstractStrategy(_baseConfig) {\n        // Check the pool tokens are correct\n        require(\n            IPair(_baseConfig.platformAddress).token0() == _ws &&\n                IPair(_baseConfig.platformAddress).token1() == _os,\n            \"Incorrect pool tokens\"\n        );\n        // Checked both tokens are to 18 decimals\n        require(\n            IBasicToken(_ws).decimals() == 18 &&\n                IBasicToken(_os).decimals() == 18,\n            \"Incorrect token decimals\"\n        );\n        // Check the SwapX pool is a Stable AMM (sAMM)\n        require(\n            IPair(_baseConfig.platformAddress).isStable() == true,\n            \"Pool not stable\"\n        );\n        // Check the gauge is for the pool\n        require(\n            IGauge(_gauge).TOKEN() == _baseConfig.platformAddress,\n            \"Incorrect gauge\"\n        );\n\n        // Set the immutable variables\n        os = _os;\n        ws = _ws;\n        pool = _baseConfig.platformAddress;\n        gauge = _gauge;\n\n        // This is an implementation contract. The governor is set in the proxy contract.\n        _setGovernor(address(0));\n    }\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as SwapX strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Array containing SWPx token address\n     * @param _maxDepeg The max amount the OS/wS price can deviate from peg (1e18) before deposits are reverted.\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses,\n        uint256 _maxDepeg\n    ) external onlyGovernor initializer {\n        address[] memory pTokens = new address[](1);\n        pTokens[0] = pool;\n\n        address[] memory _assets = new address[](1);\n        _assets[0] = ws;\n\n        InitializableAbstractStrategy._initialize(\n            _rewardTokenAddresses,\n            _assets,\n            pTokens\n        );\n\n        maxDepeg = _maxDepeg;\n\n        _approveBase();\n    }\n\n    /***************************************\n                    Deposit\n    ****************************************/\n\n    /**\n     * @notice Deposit an amount of Wrapped S (wS) into the SwapX pool.\n     * Mint OS in proportion to the pool's wS and OS reserves,\n     * transfer Wrapped S (wS) and OS to the pool,\n     * mint the pool's LP token and deposit in the gauge.\n     * @dev This tx must be wrapped by the VaultValueChecker.\n     * To minimize loses, the pool should be rebalanced before depositing.\n     * The pool's OS/wS price must be within the maxDepeg range.\n     * @param _asset Address of Wrapped S (wS) token.\n     * @param _wsAmount Amount of Wrapped S (wS) tokens to deposit.\n     */\n    function deposit(address _asset, uint256 _wsAmount)\n        external\n        override\n        onlyVault\n        nonReentrant\n        skimPool\n        nearBalancedPool\n    {\n        require(_asset == ws, \"Unsupported asset\");\n        require(_wsAmount > 0, \"Must deposit something\");\n\n        (uint256 osDepositAmount, ) = _deposit(_wsAmount);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n\n        // Emit event for the deposited wS tokens\n        emit Deposit(ws, pool, _wsAmount);\n        // Emit event for the minted OS tokens\n        emit Deposit(os, pool, osDepositAmount);\n    }\n\n    /**\n     * @notice Deposit all the strategy's Wrapped S (wS) tokens into the SwapX pool.\n     * Mint OS in proportion to the pool's wS and OS reserves,\n     * transfer Wrapped S (wS) and OS to the pool,\n     * mint the pool's LP token and deposit in the gauge.\n     * @dev This tx must be wrapped by the VaultValueChecker.\n     * To minimize loses, the pool should be rebalanced before depositing.\n     * The pool's OS/wS price must be within the maxDepeg range.\n     */\n    function depositAll()\n        external\n        override\n        onlyVault\n        nonReentrant\n        skimPool\n        nearBalancedPool\n    {\n        uint256 wsBalance = IERC20(ws).balanceOf(address(this));\n        if (wsBalance > 0) {\n            (uint256 osDepositAmount, ) = _deposit(wsBalance);\n\n            // Ensure solvency of the vault\n            _solvencyAssert();\n\n            // Emit event for the deposited wS tokens\n            emit Deposit(ws, pool, wsBalance);\n            // Emit event for the minted OS tokens\n            emit Deposit(os, pool, osDepositAmount);\n        }\n    }\n\n    /**\n     * @dev Mint OS in proportion to the pool's wS and OS reserves,\n     * transfer Wrapped S (wS) and OS to the pool,\n     * mint the pool's LP token and deposit in the gauge.\n     * @param _wsAmount Amount of Wrapped S (wS) tokens to deposit.\n     * @return osDepositAmount Amount of OS tokens minted and deposited into the pool.\n     * @return lpTokens Amount of SwapX pool LP tokens minted and deposited into the gauge.\n     */\n    function _deposit(uint256 _wsAmount)\n        internal\n        returns (uint256 osDepositAmount, uint256 lpTokens)\n    {\n        // Calculate the required amount of OS to mint based on the wS amount.\n        osDepositAmount = _calcTokensToMint(_wsAmount);\n\n        // Mint the required OS tokens to this strategy\n        IVault(vaultAddress).mintForStrategy(osDepositAmount);\n\n        // Add wS and OS liquidity to the pool and stake in gauge\n        lpTokens = _depositToPoolAndGauge(_wsAmount, osDepositAmount);\n    }\n\n    /***************************************\n                    Withdraw\n    ****************************************/\n\n    /**\n     * @notice Withdraw wS and OS from the SwapX pool, burn the OS,\n     * and transfer the wS to the recipient.\n     * @param _recipient Address of the Vault.\n     * @param _asset Address of the Wrapped S (wS) contract.\n     * @param _wsAmount Amount of Wrapped S (wS) to withdraw.\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _wsAmount\n    ) external override onlyVault nonReentrant skimPool {\n        require(_wsAmount > 0, \"Must withdraw something\");\n        require(_asset == ws, \"Unsupported asset\");\n        // This strategy can't be set as a default strategy for wS in the Vault.\n        // This means the recipient must always be the Vault.\n        require(_recipient == vaultAddress, \"Only withdraw to vault allowed\");\n\n        // Calculate how much pool LP tokens to burn to get the required amount of wS tokens back\n        uint256 lpTokens = _calcTokensToBurn(_wsAmount);\n\n        // Withdraw pool LP tokens from the gauge and remove assets from from the pool\n        _withdrawFromGaugeAndPool(lpTokens);\n\n        // Burn all the removed OS and any that was left in the strategy\n        uint256 osToBurn = IERC20(os).balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(osToBurn);\n\n        // Transfer wS to the recipient\n        // Note there can be a dust amount of wS left in the strategy as\n        // the burn of the pool's LP tokens is rounded up\n        require(\n            IERC20(ws).balanceOf(address(this)) >= _wsAmount,\n            \"Not enough wS removed from pool\"\n        );\n        IERC20(ws).safeTransfer(_recipient, _wsAmount);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n\n        // Emit event for the withdrawn wS tokens\n        emit Withdrawal(ws, pool, _wsAmount);\n        // Emit event for the burnt OS tokens\n        emit Withdrawal(os, pool, osToBurn);\n    }\n\n    /**\n     * @notice Withdraw all pool LP tokens from the gauge,\n     * remove all wS and OS from the SwapX pool,\n     * burn all the OS tokens,\n     * and transfer all the wS to the Vault contract.\n     * @dev There is no solvency check here as withdrawAll can be called to\n     * quickly secure assets to the Vault in emergencies.\n     */\n    function withdrawAll()\n        external\n        override\n        onlyVaultOrGovernor\n        nonReentrant\n        skimPool\n    {\n        // Get all the pool LP tokens the strategy has staked in the gauge\n        uint256 lpTokens = IGauge(gauge).balanceOf(address(this));\n        // Can not withdraw zero LP tokens from the gauge\n        if (lpTokens == 0) return;\n\n        if (IGauge(gauge).emergency()) {\n            // The gauge is in emergency mode\n            _emergencyWithdrawFromGaugeAndPool();\n        } else {\n            // Withdraw pool LP tokens from the gauge and remove assets from from the pool\n            _withdrawFromGaugeAndPool(lpTokens);\n        }\n\n        // Burn all OS in this strategy contract\n        uint256 osToBurn = IERC20(os).balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(osToBurn);\n\n        // Get the strategy contract's wS balance.\n        // This includes all that was removed from the SwapX pool and\n        // any that was sitting in the strategy contract before the removal.\n        uint256 wsBalance = IERC20(ws).balanceOf(address(this));\n        IERC20(ws).safeTransfer(vaultAddress, wsBalance);\n\n        // Emit event for the withdrawn wS tokens\n        emit Withdrawal(ws, pool, wsBalance);\n        // Emit event for the burnt OS tokens\n        emit Withdrawal(os, pool, osToBurn);\n    }\n\n    /***************************************\n                Pool Rebalancing\n    ****************************************/\n\n    /** @notice Used when there is more OS than wS in the pool.\n     * wS and OS is removed from the pool, the received wS is swapped for OS\n     * and the left over OS in the strategy is burnt.\n     * The OS/wS price is < 1.0 so OS is being bought at a discount.\n     * @param _wsAmount Amount of Wrapped S (wS) to swap into the pool.\n     */\n    function swapAssetsToPool(uint256 _wsAmount)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n        skimPool\n    {\n        require(_wsAmount > 0, \"Must swap something\");\n\n        // 1. Partially remove liquidity so theres enough wS for the swap\n\n        // Calculate how much pool LP tokens to burn to get the required amount of wS tokens back\n        uint256 lpTokens = _calcTokensToBurn(_wsAmount);\n        require(lpTokens > 0, \"No LP tokens to burn\");\n\n        _withdrawFromGaugeAndPool(lpTokens);\n\n        // 2. Swap wS for OS against the pool\n        // Swap exact amount of wS for OS against the pool\n        // There can be a dust amount of wS left in the strategy as the burn of the pool's LP tokens is rounded up\n        _swapExactTokensForTokens(_wsAmount, ws, os);\n\n        // 3. Burn all the OS left in the strategy from the remove liquidity and swap\n        uint256 osToBurn = IERC20(os).balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(osToBurn);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n\n        // Emit event for the burnt OS tokens\n        emit Withdrawal(os, pool, osToBurn);\n        // Emit event for the swap\n        emit SwapAssetsToPool(_wsAmount, lpTokens, osToBurn);\n    }\n\n    /**\n     * @notice Used when there is more wS than OS in the pool.\n     * OS is minted and swapped for wS against the pool,\n     * more OS is minted and added back into the pool with the swapped out wS.\n     * The OS/wS price is > 1.0 so OS is being sold at a premium.\n     * @param _osAmount Amount of OS to swap into the pool.\n     */\n    function swapOTokensToPool(uint256 _osAmount)\n        external\n        onlyStrategist\n        nonReentrant\n        improvePoolBalance\n        skimPool\n    {\n        require(_osAmount > 0, \"Must swap something\");\n\n        // 1. Mint OS so it can be swapped into the pool\n\n        // There can be OS in the strategy from skimming the pool\n        uint256 osInStrategy = IERC20(os).balanceOf(address(this));\n        require(_osAmount >= osInStrategy, \"Too much OS in strategy\");\n        uint256 osToMint = _osAmount - osInStrategy;\n\n        // Mint the required OS tokens to this strategy\n        IVault(vaultAddress).mintForStrategy(osToMint);\n\n        // 2. Swap OS for wS against the pool\n        _swapExactTokensForTokens(_osAmount, os, ws);\n\n        // The wS is from the swap and any wS that was sitting in the strategy\n        uint256 wsDepositAmount = IERC20(ws).balanceOf(address(this));\n\n        // 3. Add wS and OS back to the pool in proportion to the pool's reserves\n        (uint256 osDepositAmount, uint256 lpTokens) = _deposit(wsDepositAmount);\n\n        // Ensure solvency of the vault\n        _solvencyAssert();\n\n        // Emit event for the minted OS tokens\n        emit Deposit(os, pool, osToMint + osDepositAmount);\n        // Emit event for the swap\n        emit SwapOTokensToPool(\n            osToMint,\n            wsDepositAmount,\n            osDepositAmount,\n            lpTokens\n        );\n    }\n\n    /***************************************\n                Assets and Rewards\n    ****************************************/\n\n    /**\n     * @notice Get the wS value of assets in the strategy and SwapX pool.\n     * The value of the assets in the pool is calculated assuming the pool is balanced.\n     * This way the value can not be manipulated by changing the pool's token balances.\n     * @param _asset      Address of the Wrapped S (wS) token\n     * @return balance    Total value in wS.\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == ws, \"Unsupported asset\");\n\n        // wS balance needed here for the balance check that happens from vault during depositing.\n        balance = IERC20(ws).balanceOf(address(this));\n\n        // This assumes 1 gauge LP token = 1 pool LP token\n        uint256 lpTokens = IGauge(gauge).balanceOf(address(this));\n        if (lpTokens == 0) return balance;\n\n        // Add the strategys share of the wS and OS tokens in the SwapX pool if the pool was balanced.\n        balance += _lpValue(lpTokens);\n    }\n\n    /**\n     * @notice Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) public view override returns (bool) {\n        return _asset == ws;\n    }\n\n    /**\n     * @notice Collect accumulated SWPx (and other) rewards and send to the Harvester.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Collect SWPx rewards from the gauge\n        IGauge(gauge).getReward();\n\n        _collectRewardTokens();\n    }\n\n    /***************************************\n        Internal SwapX Pool and Gauge Functions\n    ****************************************/\n\n    /**\n     * @dev Calculate the required amount of OS to mint based on the wS amount.\n     * This ensures the proportion of OS tokens being added to the pool matches the proportion of wS tokens.\n     * For example, if the added wS tokens is 10% of existing wS tokens in the pool,\n     * then the OS tokens being added should also be 10% of the OS tokens in the pool.\n     * @param _wsAmount Amount of Wrapped S (wS) to be added to the pool.\n     * @return osAmount Amount of OS to be minted and added to the pool.\n     */\n    function _calcTokensToMint(uint256 _wsAmount)\n        internal\n        view\n        returns (uint256 osAmount)\n    {\n        (uint256 wsReserves, uint256 osReserves, ) = IPair(pool).getReserves();\n        require(wsReserves > 0, \"Empty pool\");\n\n        // OS to add = (wS being added * OS in pool) / wS in pool\n        osAmount = (_wsAmount * osReserves) / wsReserves;\n    }\n\n    /**\n     * @dev Calculate how much pool LP tokens to burn to get the required amount of wS tokens back\n     * from the pool.\n     * @param _wsAmount Amount of Wrapped S (wS) to be removed from the pool.\n     * @return lpTokens Amount of SwapX pool LP tokens to burn.\n     */\n    function _calcTokensToBurn(uint256 _wsAmount)\n        internal\n        view\n        returns (uint256 lpTokens)\n    {\n        /* The SwapX pool proportionally returns the reserve tokens when removing liquidity.\n         * First, calculate the proportion of required wS tokens against the pools wS reserves.\n         * That same proportion is used to calculate the required amount of pool LP tokens.\n         * For example, if the required wS tokens is 10% of the pool's wS reserves,\n         * then 10% of the pool's LP supply needs to be burned.\n         *\n         * Because we are doing balanced removal we should be making profit when removing liquidity in a\n         * pool tilted to either side.\n         *\n         * Important: A downside is that the Strategist / Governor needs to be\n         * cognizant of not removing too much liquidity. And while the proposal to remove liquidity\n         * is being voted on, the pool tilt might change so much that the proposal that has been valid while\n         * created is no longer valid.\n         */\n\n        (uint256 wsReserves, , ) = IPair(pool).getReserves();\n        require(wsReserves > 0, \"Empty pool\");\n\n        lpTokens = (_wsAmount * IPair(pool).totalSupply()) / wsReserves;\n        lpTokens += 1; // Add 1 to ensure we get enough LP tokens with rounding\n    }\n\n    /**\n     * @dev Deposit Wrapped S (wS) and OS liquidity to the SwapX pool\n     * and stake the pool's LP token in the gauge.\n     * @param _wsAmount Amount of Wrapped S (wS) to deposit.\n     * @param _osAmount Amount of OS to deposit.\n     * @return lpTokens Amount of SwapX pool LP tokens minted.\n     */\n    function _depositToPoolAndGauge(uint256 _wsAmount, uint256 _osAmount)\n        internal\n        returns (uint256 lpTokens)\n    {\n        // Transfer wS to the pool\n        IERC20(ws).safeTransfer(pool, _wsAmount);\n        // Transfer OS to the pool\n        IERC20(os).safeTransfer(pool, _osAmount);\n\n        // Mint LP tokens from the pool\n        lpTokens = IPair(pool).mint(address(this));\n\n        // Deposit the pool's LP tokens into the gauge\n        IGauge(gauge).deposit(lpTokens);\n    }\n\n    /**\n     * @dev Withdraw pool LP tokens from the gauge and remove wS and OS from the pool.\n     * @param _lpTokens Amount of SwapX pool LP tokens to withdraw from the gauge\n     */\n    function _withdrawFromGaugeAndPool(uint256 _lpTokens) internal {\n        require(\n            IGauge(gauge).balanceOf(address(this)) >= _lpTokens,\n            \"Not enough LP tokens in gauge\"\n        );\n\n        // Withdraw pool LP tokens from the gauge\n        IGauge(gauge).withdraw(_lpTokens);\n\n        // Transfer the pool LP tokens to the pool\n        IERC20(pool).safeTransfer(pool, _lpTokens);\n\n        // Burn the LP tokens and transfer the wS and OS back to the strategy\n        IPair(pool).burn(address(this));\n    }\n\n    /**\n     * @dev Withdraw all pool LP tokens from the gauge when it's in emergency mode\n     * and remove wS and OS from the pool.\n     */\n    function _emergencyWithdrawFromGaugeAndPool() internal {\n        // Withdraw all pool LP tokens from the gauge\n        IGauge(gauge).emergencyWithdraw();\n\n        // Get the pool LP tokens in strategy\n        uint256 _lpTokens = IERC20(pool).balanceOf(address(this));\n\n        // Transfer the pool LP tokens to the pool\n        IERC20(pool).safeTransfer(pool, _lpTokens);\n\n        // Burn the LP tokens and transfer the wS and OS back to the strategy\n        IPair(pool).burn(address(this));\n    }\n\n    /**\n     * @dev Swap exact amount of tokens for another token against the pool.\n     * @param _amountIn Amount of tokens to swap into the pool.\n     * @param _tokenIn Address of the token going into the pool.\n     * @param _tokenOut Address of the token being swapped out of the pool.\n     */\n    function _swapExactTokensForTokens(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut\n    ) internal {\n        // Transfer in tokens to the pool\n        IERC20(_tokenIn).safeTransfer(pool, _amountIn);\n\n        // Calculate how much out tokens we get from the swap\n        uint256 amountOut = IPair(pool).getAmountOut(_amountIn, _tokenIn);\n\n        // Safety check that we are dealing with the correct pool tokens\n        require(\n            (_tokenIn == ws && _tokenOut == os) ||\n                (_tokenIn == os && _tokenOut == ws),\n            \"Unsupported swap\"\n        );\n\n        // Work out the correct order of the amounts for the pool\n        (uint256 amount0, uint256 amount1) = _tokenIn == ws\n            ? (uint256(0), amountOut)\n            : (amountOut, 0);\n\n        // Perform the swap on the pool\n        IPair(pool).swap(amount0, amount1, address(this), new bytes(0));\n\n        // The slippage protection against the amount out is indirectly done\n        // via the improvePoolBalance\n    }\n\n    /// @dev Calculate the value of a LP position in a SwapX stable pool\n    /// if the pool was balanced.\n    /// @param _lpTokens Amount of LP tokens in the SwapX pool\n    /// @return value The wS value of the LP tokens when the pool is balanced\n    function _lpValue(uint256 _lpTokens) internal view returns (uint256 value) {\n        // Get total supply of LP tokens\n        uint256 totalSupply = IPair(pool).totalSupply();\n        if (totalSupply == 0) return 0;\n\n        // Get the current reserves of the pool\n        (uint256 wsReserves, uint256 osReserves, ) = IPair(pool).getReserves();\n\n        // Calculate the invariant of the pool assuming both tokens have 18 decimals.\n        // k is scaled to 18 decimals.\n        uint256 k = _invariant(wsReserves, osReserves);\n\n        // If x = y, lets denote x = y = z (where z is the common reserve value)\n        // Substitute z into the invariant:\n        // k = z^3 * z + z * z^3\n        // k = 2 * z^4\n        // Going back the other way to calculate the common reserve value z\n        // z = (k / 2) ^ (1/4)\n        // the total value of the pool when x = y is 2 * z, which is 2 * (k / 2) ^ (1/4)\n        uint256 zSquared = sqrt((k * 1e18) / 2); // 18 + 18 = 36 decimals becomes 18 decimals after sqrt\n        uint256 z = sqrt(zSquared * 1e18); //  18 + 18 = 36 decimals becomes 18 decimals after sqrt\n        uint256 totalValueOfPool = 2 * z;\n\n        // lp value = lp tokens * value of pool  / total supply\n        value = (_lpTokens * totalValueOfPool) / totalSupply;\n    }\n\n    /**\n     * @dev Compute the invariant for a SwapX stable pool.\n     * This assumed both x and y tokens are to 18 decimals which is checked in the constructor.\n     * invariant: k = x^3 * y + x * y^3\n     * @dev This implementation is copied from SwapX's Pair contract.\n     * @param _x The amount of Wrapped S (wS) tokens in the pool\n     * @param _y The amount of the OS tokens in the pool\n     * @return k The invariant of the SwapX stable pool\n     */\n    function _invariant(uint256 _x, uint256 _y)\n        internal\n        pure\n        returns (uint256 k)\n    {\n        uint256 _a = (_x * _y) / PRECISION;\n        uint256 _b = ((_x * _x) / PRECISION + (_y * _y) / PRECISION);\n        // slither-disable-next-line divide-before-multiply\n        k = (_a * _b) / PRECISION;\n    }\n\n    /**\n     * @dev Checks that the protocol is solvent, protecting from a rogue Strategist / Guardian that can\n     * keep rebalancing the pool in both directions making the protocol lose a tiny amount of\n     * funds each time.\n     *\n     * Protocol must be at least SOLVENCY_THRESHOLD (99,8 %) backed in order for the rebalances to\n     * function.\n     */\n    function _solvencyAssert() internal view {\n        uint256 _totalVaultValue = IVault(vaultAddress).totalValue();\n        uint256 _totalSupply = IERC20(os).totalSupply();\n\n        if (\n            _totalSupply > 0 &&\n            _totalVaultValue.divPrecisely(_totalSupply) < SOLVENCY_THRESHOLD\n        ) {\n            revert(\"Protocol insolvent\");\n        }\n    }\n\n    /***************************************\n                    Setters\n    ****************************************/\n\n    /**\n     * @notice Set the maximum deviation from the OS/wS peg (1e18) before deposits are reverted.\n     * @param _maxDepeg the OS/wS price from peg (1e18) in 18 decimals.\n     * eg 0.01e18 or 1e16 is 1% which is 100 basis points.\n     */\n    function setMaxDepeg(uint256 _maxDepeg) external onlyGovernor {\n        maxDepeg = _maxDepeg;\n\n        emit MaxDepegUpdated(_maxDepeg);\n    }\n\n    /***************************************\n                    Approvals\n    ****************************************/\n\n    /**\n     * @notice Approve the spending of all assets by their corresponding pool tokens,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        _approveBase();\n    }\n\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        override\n    {}\n\n    function _approveBase() internal {\n        // Approve SwapX gauge contract to transfer SwapX pool LP tokens\n        // This is needed for deposits of SwapX pool LP tokens into the gauge.\n        // slither-disable-next-line unused-return\n        IPair(pool).approve(address(gauge), type(uint256).max);\n    }\n}\n"
    },
    "contracts/strategies/sonic/SonicValidatorDelegator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20, InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { IVault } from \"../../interfaces/IVault.sol\";\nimport { ISFC } from \"../../interfaces/sonic/ISFC.sol\";\nimport { IWrappedSonic } from \"../../interfaces/sonic/IWrappedSonic.sol\";\n\n/**\n * @title Manages delegation to Sonic validators\n * @notice This contract implements all the required functionality to delegate to,\n   undelegate from and withdraw from validators.\n * @author Origin Protocol Inc\n */\nabstract contract SonicValidatorDelegator is InitializableAbstractStrategy {\n    /// @notice Address of Sonic's wrapped S token\n    address public immutable wrappedSonic;\n    /// @notice Sonic's Special Fee Contract (SFC)\n    ISFC public immutable sfc;\n\n    /// @notice a unique ID for each withdrawal request\n    uint256 public nextWithdrawId;\n    /// @notice Sonic (S) that is pending withdrawal after undelegating\n    uint256 public pendingWithdrawals;\n\n    /// @notice List of supported validator IDs that can be delegated to\n    uint256[] public supportedValidators;\n\n    /// @notice Default validator id to deposit to\n    uint256 public defaultValidatorId;\n\n    struct WithdrawRequest {\n        uint256 validatorId;\n        uint256 undelegatedAmount;\n        uint256 timestamp;\n    }\n    /// @notice Mapping of withdrawIds to validatorIds and undelegatedAmounts\n    mapping(uint256 => WithdrawRequest) public withdrawals;\n\n    /// @notice Address of the registrator - allowed to register, exit and remove validators\n    address public validatorRegistrator;\n\n    // For future use\n    uint256[44] private __gap;\n\n    event Delegated(uint256 indexed validatorId, uint256 delegatedAmount);\n    event Undelegated(\n        uint256 indexed withdrawId,\n        uint256 indexed validatorId,\n        uint256 undelegatedAmount\n    );\n    event Withdrawn(\n        uint256 indexed withdrawId,\n        uint256 indexed validatorId,\n        uint256 undelegatedAmount,\n        uint256 withdrawnAmount\n    );\n    event RegistratorChanged(address indexed newAddress);\n    event SupportedValidator(uint256 indexed validatorId);\n    event UnsupportedValidator(uint256 indexed validatorId);\n    event DefaultValidatorIdChanged(uint256 indexed validatorId);\n\n    /// @dev Throws if called by any account other than the Registrator or Strategist\n    modifier onlyRegistratorOrStrategist() {\n        require(\n            msg.sender == validatorRegistrator ||\n                msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Registrator or Strategist\"\n        );\n        _;\n    }\n\n    constructor(\n        BaseStrategyConfig memory _baseConfig,\n        address _wrappedSonic,\n        address _sfc\n    ) InitializableAbstractStrategy(_baseConfig) {\n        wrappedSonic = _wrappedSonic;\n        sfc = ISFC(_sfc);\n    }\n\n    function initialize() external virtual onlyGovernor initializer {\n        address[] memory rewardTokens = new address[](0);\n        address[] memory assets = new address[](1);\n        address[] memory pTokens = new address[](1);\n\n        assets[0] = address(wrappedSonic);\n        pTokens[0] = address(platformAddress);\n\n        InitializableAbstractStrategy._initialize(\n            rewardTokens,\n            assets,\n            pTokens\n        );\n    }\n\n    /// @notice Returns the total value of Sonic (S) that is delegated validators.\n    /// Wrapped Sonic (wS) deposits that are still to be delegated and any undelegated amounts\n    /// still pending a withdrawal.\n    /// @param _asset      Address of Wrapped Sonic (wS) token\n    /// @return balance    Total value managed by the strategy\n    function checkBalance(address _asset)\n        external\n        view\n        virtual\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == wrappedSonic, \"Unsupported asset\");\n\n        // add the Wrapped Sonic (wS) in the strategy from deposits that are still to be delegated\n        // and any undelegated amounts still pending a withdrawal\n        balance =\n            IERC20(wrappedSonic).balanceOf(address(this)) +\n            pendingWithdrawals;\n\n        // For each supported validator, get the staked amount and pending rewards\n        uint256 validatorLen = supportedValidators.length;\n        for (uint256 i = 0; i < validatorLen; i++) {\n            uint256 validator = supportedValidators[i];\n            balance += sfc.getStake(address(this), validator);\n            balance += sfc.pendingRewards(address(this), validator);\n        }\n    }\n\n    /**\n     * @dev Delegate from this strategy to a specific Sonic validator. Called\n     * automatically on asset deposit\n     * @param _amount the amount of Sonic (S) to delegate.\n     */\n    function _delegate(uint256 _amount) internal {\n        require(\n            isSupportedValidator(defaultValidatorId),\n            \"Validator not supported\"\n        );\n\n        // unwrap Wrapped Sonic (wS) to native Sonic (S)\n        IWrappedSonic(wrappedSonic).withdraw(_amount);\n\n        //slither-disable-next-line arbitrary-send-eth\n        sfc.delegate{ value: _amount }(defaultValidatorId);\n\n        emit Delegated(defaultValidatorId, _amount);\n    }\n\n    /**\n     * @notice Undelegate from a specific Sonic validator.\n     * This needs to be followed by a `withdrawFromSFC` two weeks later.\n     * @param _validatorId The Sonic validator ID to undelegate from.\n     * @param _undelegateAmount the amount of Sonic (S) to undelegate.\n     * @return withdrawId The unique ID of the withdrawal request.\n     */\n    function undelegate(uint256 _validatorId, uint256 _undelegateAmount)\n        external\n        onlyRegistratorOrStrategist\n        nonReentrant\n        returns (uint256 withdrawId)\n    {\n        withdrawId = _undelegate(_validatorId, _undelegateAmount);\n    }\n\n    function _undelegate(uint256 _validatorId, uint256 _undelegateAmount)\n        internal\n        returns (uint256 withdrawId)\n    {\n        // Can still undelegate even if the validator is no longer supported\n        require(_undelegateAmount > 0, \"Must undelegate something\");\n\n        uint256 amountDelegated = sfc.getStake(address(this), _validatorId);\n        require(\n            _undelegateAmount <= amountDelegated,\n            \"Insufficient delegation\"\n        );\n\n        withdrawId = nextWithdrawId++;\n\n        withdrawals[withdrawId] = WithdrawRequest(\n            _validatorId,\n            _undelegateAmount,\n            block.timestamp\n        );\n        pendingWithdrawals += _undelegateAmount;\n\n        sfc.undelegate(_validatorId, withdrawId, _undelegateAmount);\n\n        emit Undelegated(withdrawId, _validatorId, _undelegateAmount);\n    }\n\n    /**\n     * @notice Withdraw native S from a previously undelegated validator.\n     * The native S is wrapped wS and transferred to the Vault.\n     * @param _withdrawId The unique withdraw ID used to `undelegate`\n     * @return withdrawnAmount The amount of Sonic (S) withdrawn.\n     * This can be less than the undelegated amount in the event of slashing.\n     */\n    function withdrawFromSFC(uint256 _withdrawId)\n        external\n        onlyRegistratorOrStrategist\n        nonReentrant\n        returns (uint256 withdrawnAmount)\n    {\n        require(_withdrawId < nextWithdrawId, \"Invalid withdrawId\");\n\n        // Can still withdraw even if the validator is no longer supported\n        // Load the withdrawal from storage into memory\n        WithdrawRequest memory withdrawal = withdrawals[_withdrawId];\n        require(!isWithdrawnFromSFC(_withdrawId), \"Already withdrawn\");\n\n        withdrawals[_withdrawId].undelegatedAmount = 0;\n        pendingWithdrawals -= withdrawal.undelegatedAmount;\n\n        uint256 sBalanceBefore = address(this).balance;\n\n        // Try to withdraw from SFC\n        try sfc.withdraw(withdrawal.validatorId, _withdrawId) {\n            // continue below\n        } catch (bytes memory err) {\n            bytes4 errorSelector = bytes4(err);\n\n            // If the validator has been fully slashed, SFC's withdraw function will\n            // revert with a StakeIsFullySlashed custom error.\n            if (errorSelector == ISFC.StakeIsFullySlashed.selector) {\n                // The validator was fully slashed, so all the delegated amounts were lost.\n                // Will swallow the error as we still want to update the\n                // withdrawals and pendingWithdrawals storage variables.\n\n                // The return param defaults to zero but lets set it explicitly so it's clear\n                withdrawnAmount = 0;\n\n                emit Withdrawn(\n                    _withdrawId,\n                    withdrawal.validatorId,\n                    withdrawal.undelegatedAmount,\n                    withdrawnAmount\n                );\n\n                // Exit here as there is nothing to transfer to the Vault\n                return withdrawnAmount;\n            } else {\n                // Bubble up any other SFC custom errors.\n                // Inline assembly is currently the only way to generically rethrow the exact same custom error\n                // from the raw bytes err in a catch block while preserving its original selector and parameters.\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    revert(add(32, err), mload(err))\n                }\n            }\n        }\n\n        // Set return parameter\n        withdrawnAmount = address(this).balance - sBalanceBefore;\n\n        // Wrap Sonic (S) to Wrapped Sonic (wS)\n        IWrappedSonic(wrappedSonic).deposit{ value: withdrawnAmount }();\n\n        // Transfer the Wrapped Sonic (wS) to the Vault\n        _withdraw(vaultAddress, wrappedSonic, withdrawnAmount);\n\n        // withdrawal.undelegatedAmount & withdrawnAmount can differ in case of slashing\n        emit Withdrawn(\n            _withdrawId,\n            withdrawal.validatorId,\n            withdrawal.undelegatedAmount,\n            withdrawnAmount\n        );\n    }\n\n    /// @notice returns a bool whether a withdrawalId has already been withdrawn or not\n    /// @param _withdrawId The unique withdraw ID used to `undelegate`\n    function isWithdrawnFromSFC(uint256 _withdrawId)\n        public\n        view\n        returns (bool)\n    {\n        WithdrawRequest memory withdrawal = withdrawals[_withdrawId];\n        require(withdrawal.validatorId > 0, \"Invalid withdrawId\");\n        return withdrawal.undelegatedAmount == 0;\n    }\n\n    /**\n     * @notice Restake any pending validator rewards for all supported validators\n     * @param _validatorIds List of Sonic validator IDs to restake rewards\n     */\n    function restakeRewards(uint256[] calldata _validatorIds)\n        external\n        nonReentrant\n    {\n        for (uint256 i = 0; i < _validatorIds.length; ++i) {\n            require(\n                isSupportedValidator(_validatorIds[i]),\n                \"Validator not supported\"\n            );\n\n            uint256 rewards = sfc.pendingRewards(\n                address(this),\n                _validatorIds[i]\n            );\n\n            if (rewards > 0) {\n                sfc.restakeRewards(_validatorIds[i]);\n            }\n        }\n\n        // The SFC contract will emit Delegated and RestakedRewards events.\n        // The checkBalance function should not change as the pending rewards will moved to the staked amount.\n    }\n\n    /**\n     * @notice Claim any pending rewards from validators\n     * @param _validatorIds List of Sonic validator IDs to claim rewards\n     */\n    function collectRewards(uint256[] calldata _validatorIds)\n        external\n        onlyRegistratorOrStrategist\n        nonReentrant\n    {\n        uint256 sBalanceBefore = address(this).balance;\n\n        for (uint256 i = 0; i < _validatorIds.length; ++i) {\n            uint256 rewards = sfc.pendingRewards(\n                address(this),\n                _validatorIds[i]\n            );\n\n            if (rewards > 0) {\n                // The SFC contract will emit ClaimedRewards(delegator (this), validatorId, rewards)\n                sfc.claimRewards(_validatorIds[i]);\n            }\n        }\n\n        uint256 rewardsAmount = address(this).balance - sBalanceBefore;\n\n        // Wrap Sonic (S) to Wrapped Sonic (wS)\n        IWrappedSonic(wrappedSonic).deposit{ value: rewardsAmount }();\n\n        // Transfer the Wrapped Sonic (wS) to the Vault\n        _withdraw(vaultAddress, wrappedSonic, rewardsAmount);\n    }\n\n    /**\n     * @notice To receive native S from SFC and Wrapped Sonic (wS)\n     *\n     * @dev This does not prevent donating S tokens to the contract\n     * as wrappedSonic has a `withdrawTo` function where a third party\n     * owner of wrappedSonic can withdraw to this contract.\n     */\n    receive() external payable {\n        require(\n            msg.sender == address(sfc) || msg.sender == wrappedSonic,\n            \"S not from allowed contracts\"\n        );\n    }\n\n    /***************************************\n                Admin functions\n    ****************************************/\n\n    /// @notice Set the address of the Registrator which can undelegate, withdraw and collect rewards\n    /// @param _validatorRegistrator The address of the Registrator\n    function setRegistrator(address _validatorRegistrator)\n        external\n        onlyGovernor\n    {\n        validatorRegistrator = _validatorRegistrator;\n        emit RegistratorChanged(_validatorRegistrator);\n    }\n\n    /// @notice Set the default validatorId to delegate to on deposit\n    /// @param _validatorId The validator identifier. eg 18\n    function setDefaultValidatorId(uint256 _validatorId)\n        external\n        onlyRegistratorOrStrategist\n    {\n        require(isSupportedValidator(_validatorId), \"Validator not supported\");\n        defaultValidatorId = _validatorId;\n        emit DefaultValidatorIdChanged(_validatorId);\n    }\n\n    /// @notice Allows a validator to be delegated to by the Registrator\n    /// @param _validatorId The validator identifier. eg 18\n    function supportValidator(uint256 _validatorId) external onlyGovernor {\n        require(\n            !isSupportedValidator(_validatorId),\n            \"Validator already supported\"\n        );\n\n        supportedValidators.push(_validatorId);\n\n        emit SupportedValidator(_validatorId);\n    }\n\n    /// @notice Removes a validator from the supported list.\n    /// Unsupported validators can still be undelegated from, withdrawn from and rewards collected.\n    /// @param _validatorId The validator identifier. eg 18\n    function unsupportValidator(uint256 _validatorId) external onlyGovernor {\n        require(isSupportedValidator(_validatorId), \"Validator not supported\");\n\n        uint256 validatorLen = supportedValidators.length;\n        for (uint256 i = 0; i < validatorLen; ++i) {\n            if (supportedValidators[i] == _validatorId) {\n                supportedValidators[i] = supportedValidators[validatorLen - 1];\n                supportedValidators.pop();\n                break;\n            }\n        }\n\n        uint256 stake = sfc.getStake(address(this), _validatorId);\n\n        // undelegate if validator still has funds staked\n        if (stake > 0) {\n            _undelegate(_validatorId, stake);\n        }\n        emit UnsupportedValidator(_validatorId);\n    }\n\n    /// @notice Returns the length of the supportedValidators array\n    function supportedValidatorsLength() external view returns (uint256) {\n        return supportedValidators.length;\n    }\n\n    /// @notice Returns whether a validator is supported by this strategy\n    /// @param _validatorId The validator identifier\n    function isSupportedValidator(uint256 _validatorId)\n        public\n        view\n        returns (bool)\n    {\n        uint256 validatorLen = supportedValidators.length;\n        for (uint256 i = 0; i < validatorLen; ++i) {\n            if (supportedValidators[i] == _validatorId) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) internal virtual;\n}\n"
    },
    "contracts/strategies/VaultValueChecker.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IOUSD } from \"../interfaces/IOUSD.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract VaultValueChecker {\n    IVault public immutable vault;\n    IOUSD public immutable ousd;\n    // Snapshot expiration time in seconds.\n    // Used to prevent accidental use of an old snapshot, but\n    // is not zero to allow easy testing of strategist actions in fork testing\n    uint256 constant SNAPSHOT_EXPIRES = 5 * 60;\n\n    struct Snapshot {\n        uint256 vaultValue;\n        uint256 totalSupply;\n        uint256 time;\n    }\n    // By doing per user snapshots, we prevent a reentrancy attack\n    // from a third party that updates the snapshot in the middle\n    // of an allocation process\n\n    mapping(address => Snapshot) public snapshots;\n\n    constructor(address _vault, address _ousd) {\n        vault = IVault(_vault);\n        ousd = IOUSD(_ousd);\n    }\n\n    function takeSnapshot() external {\n        snapshots[msg.sender] = Snapshot({\n            vaultValue: vault.totalValue(),\n            totalSupply: ousd.totalSupply(),\n            time: block.timestamp\n        });\n    }\n\n    function checkDelta(\n        int256 expectedProfit,\n        int256 profitVariance,\n        int256 expectedVaultChange,\n        int256 vaultChangeVariance\n    ) external {\n        // Intentionaly not view so that this method shows up in TX builders\n        Snapshot memory snapshot = snapshots[msg.sender];\n        int256 vaultChange = toInt256(vault.totalValue()) -\n            toInt256(snapshot.vaultValue);\n        int256 supplyChange = toInt256(ousd.totalSupply()) -\n            toInt256(snapshot.totalSupply);\n        int256 profit = vaultChange - supplyChange;\n\n        require(\n            snapshot.time >= block.timestamp - SNAPSHOT_EXPIRES,\n            \"Snapshot too old\"\n        );\n        require(snapshot.time <= block.timestamp, \"Snapshot too new\");\n        require(profit >= expectedProfit - profitVariance, \"Profit too low\");\n        require(profit <= expectedProfit + profitVariance, \"Profit too high\");\n        require(\n            vaultChange >= expectedVaultChange - vaultChangeVariance,\n            \"Vault value change too low\"\n        );\n        require(\n            vaultChange <= expectedVaultChange + vaultChangeVariance,\n            \"Vault value change too high\"\n        );\n    }\n\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // From openzeppelin math/SafeCast.sol\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(\n            value <= uint256(type(int256).max),\n            \"SafeCast: value doesn't fit in an int256\"\n        );\n        return int256(value);\n    }\n}\n\ncontract OETHVaultValueChecker is VaultValueChecker {\n    constructor(address _vault, address _ousd)\n        VaultValueChecker(_vault, _ousd)\n    {}\n}\n"
    },
    "contracts/token/OETH.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { OUSD } from \"./OUSD.sol\";\n\n/**\n * @title OETH Token Contract\n * @author Origin Protocol Inc\n */\ncontract OETH is OUSD {\n    function symbol() external pure override returns (string memory) {\n        return \"OETH\";\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Origin Ether\";\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return 18;\n    }\n}\n"
    },
    "contracts/token/OETHBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { OUSD } from \"./OUSD.sol\";\n\n/**\n * @title OETH Token Contract\n * @author Origin Protocol Inc\n */\ncontract OETHBase is OUSD {\n    constructor() {\n        // Nobody owns the implementation contract\n        _setGovernor(address(0));\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"superOETHb\";\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Super OETH\";\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return 18;\n    }\n}\n"
    },
    "contracts/token/OETHPlume.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { OUSD } from \"./OUSD.sol\";\n\n/**\n * @title Super OETH (Plume) Token Contract\n * @author Origin Protocol Inc\n */\ncontract OETHPlume is OUSD {\n    constructor() {\n        // Nobody owns the implementation contract\n        _setGovernor(address(0));\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"superOETHp\";\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Super OETH\";\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return 18;\n    }\n}\n"
    },
    "contracts/token/OSonic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { OUSD } from \"./OUSD.sol\";\n\n/**\n * @title Origin Sonic (OS) token on Sonic\n * @author Origin Protocol Inc\n */\ncontract OSonic is OUSD {\n    function symbol() external pure override returns (string memory) {\n        return \"OS\";\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Origin Sonic\";\n    }\n}\n"
    },
    "contracts/token/OUSD.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OUSD Token Contract\n * @dev ERC20 compatible contract for OUSD\n * @dev Implements an elastic supply\n * @author Origin Protocol Inc\n */\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\ncontract OUSD is Governable {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n\n    /// @dev Event triggered when the supply changes\n    /// @param totalSupply Updated token total supply\n    /// @param rebasingCredits Updated token rebasing credits\n    /// @param rebasingCreditsPerToken Updated token rebasing credits per token\n    event TotalSupplyUpdatedHighres(\n        uint256 totalSupply,\n        uint256 rebasingCredits,\n        uint256 rebasingCreditsPerToken\n    );\n    /// @dev Event triggered when an account opts in for rebasing\n    /// @param account Address of the account\n    event AccountRebasingEnabled(address account);\n    /// @dev Event triggered when an account opts out of rebasing\n    /// @param account Address of the account\n    event AccountRebasingDisabled(address account);\n    /// @dev Emitted when `value` tokens are moved from one account `from` to\n    ///      another `to`.\n    /// @param from Address of the account tokens are moved from\n    /// @param to Address of the account tokens are moved to\n    /// @param value Amount of tokens transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set by\n    ///      a call to {approve}. `value` is the new allowance.\n    /// @param owner Address of the owner approving allowance\n    /// @param spender Address of the spender allowance is granted to\n    /// @param value Amount of tokens spender can transfer\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    /// @dev Yield resulting from {changeSupply} that a `source` account would\n    ///      receive is directed to `target` account.\n    /// @param source Address of the source forwarding the yield\n    /// @param target Address of the target receiving the yield\n    event YieldDelegated(address source, address target);\n    /// @dev Yield delegation from `source` account to the `target` account is\n    ///      suspended.\n    /// @param source Address of the source suspending yield forwarding\n    /// @param target Address of the target no longer receiving yield from `source`\n    ///        account\n    event YieldUndelegated(address source, address target);\n\n    enum RebaseOptions {\n        NotSet,\n        StdNonRebasing,\n        StdRebasing,\n        YieldDelegationSource,\n        YieldDelegationTarget\n    }\n\n    uint256[154] private _gap; // Slots to align with deployed contract\n    uint256 private constant MAX_SUPPLY = type(uint128).max;\n    /// @dev The amount of tokens in existence\n    uint256 public totalSupply;\n    mapping(address => mapping(address => uint256)) private allowances;\n    /// @dev The vault with privileges to execute {mint}, {burn}\n    ///     and {changeSupply}\n    address public vaultAddress;\n    mapping(address => uint256) internal creditBalances;\n    // the 2 storage variables below need trailing underscores to not name collide with public functions\n    uint256 private rebasingCredits_; // Sum of all rebasing credits (creditBalances for rebasing accounts)\n    uint256 private rebasingCreditsPerToken_;\n    /// @dev The amount of tokens that are not rebasing - receiving yield\n    uint256 public nonRebasingSupply;\n    mapping(address => uint256) internal alternativeCreditsPerToken;\n    /// @dev A map of all addresses and their respective RebaseOptions\n    mapping(address => RebaseOptions) public rebaseState;\n    mapping(address => uint256) private __deprecated_isUpgraded;\n    /// @dev A map of addresses that have yields forwarded to. This is an\n    ///      inverse mapping of {yieldFrom}\n    /// Key Account forwarding yield\n    /// Value Account receiving yield\n    mapping(address => address) public yieldTo;\n    /// @dev A map of addresses that are receiving the yield. This is an\n    ///      inverse mapping of {yieldTo}\n    /// Key Account receiving yield\n    /// Value Account forwarding yield\n    mapping(address => address) public yieldFrom;\n\n    uint256 private constant RESOLUTION_INCREASE = 1e9;\n    uint256[34] private __gap; // including below gap totals up to 200\n\n    /// @dev Verifies that the caller is the Governor or Strategist.\n    modifier onlyGovernorOrStrategist() {\n        require(\n            isGovernor() || msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    /// @dev Initializes the contract and sets necessary variables.\n    /// @param _vaultAddress Address of the vault contract\n    /// @param _initialCreditsPerToken The starting rebasing credits per token.\n    function initialize(address _vaultAddress, uint256 _initialCreditsPerToken)\n        external\n        onlyGovernor\n    {\n        require(_vaultAddress != address(0), \"Zero vault address\");\n        require(vaultAddress == address(0), \"Already initialized\");\n\n        rebasingCreditsPerToken_ = _initialCreditsPerToken;\n        vaultAddress = _vaultAddress;\n    }\n\n    /// @dev Returns the symbol of the token, a shorter version\n    ///      of the name.\n    function symbol() external pure virtual returns (string memory) {\n        return \"OUSD\";\n    }\n\n    /// @dev Returns the name of the token.\n    function name() external pure virtual returns (string memory) {\n        return \"Origin Dollar\";\n    }\n\n    /// @dev Returns the number of decimals used to get its user representation.\n    function decimals() external pure virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault contract\n     */\n    modifier onlyVault() {\n        require(vaultAddress == msg.sender, \"Caller is not the Vault\");\n        _;\n    }\n\n    /**\n     * @return High resolution rebasingCreditsPerToken\n     */\n    function rebasingCreditsPerTokenHighres() external view returns (uint256) {\n        return rebasingCreditsPerToken_;\n    }\n\n    /**\n     * @return Low resolution rebasingCreditsPerToken\n     */\n    function rebasingCreditsPerToken() external view returns (uint256) {\n        return rebasingCreditsPerToken_ / RESOLUTION_INCREASE;\n    }\n\n    /**\n     * @return High resolution total number of rebasing credits\n     */\n    function rebasingCreditsHighres() external view returns (uint256) {\n        return rebasingCredits_;\n    }\n\n    /**\n     * @return Low resolution total number of rebasing credits\n     */\n    function rebasingCredits() external view returns (uint256) {\n        return rebasingCredits_ / RESOLUTION_INCREASE;\n    }\n\n    /**\n     * @notice Gets the balance of the specified address.\n     * @param _account Address to query the balance of.\n     * @return A uint256 representing the amount of base units owned by the\n     *         specified address.\n     */\n    function balanceOf(address _account) public view returns (uint256) {\n        RebaseOptions state = rebaseState[_account];\n        if (state == RebaseOptions.YieldDelegationSource) {\n            // Saves a slot read when transferring to or from a yield delegating source\n            // since we know creditBalances equals the balance.\n            return creditBalances[_account];\n        }\n        uint256 baseBalance = (creditBalances[_account] * 1e18) /\n            _creditsPerToken(_account);\n        if (state == RebaseOptions.YieldDelegationTarget) {\n            // creditBalances of yieldFrom accounts equals token balances\n            return baseBalance - creditBalances[yieldFrom[_account]];\n        }\n        return baseBalance;\n    }\n\n    /**\n     * @notice Gets the credits balance of the specified address.\n     * @dev Backwards compatible with old low res credits per token.\n     * @param _account The address to query the balance of.\n     * @return (uint256, uint256) Credit balance and credits per token of the\n     *         address\n     */\n    function creditsBalanceOf(address _account)\n        external\n        view\n        returns (uint256, uint256)\n    {\n        uint256 cpt = _creditsPerToken(_account);\n        if (cpt == 1e27) {\n            // For a period before the resolution upgrade, we created all new\n            // contract accounts at high resolution. Since they are not changing\n            // as a result of this upgrade, we will return their true values\n            return (creditBalances[_account], cpt);\n        } else {\n            return (\n                creditBalances[_account] / RESOLUTION_INCREASE,\n                cpt / RESOLUTION_INCREASE\n            );\n        }\n    }\n\n    /**\n     * @notice Gets the credits balance of the specified address.\n     * @param _account The address to query the balance of.\n     * @return (uint256, uint256, bool) Credit balance, credits per token of the\n     *         address, and isUpgraded\n     */\n    function creditsBalanceOfHighres(address _account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        return (\n            creditBalances[_account],\n            _creditsPerToken(_account),\n            true // all accounts have their resolution \"upgraded\"\n        );\n    }\n\n    // Backwards compatible view\n    function nonRebasingCreditsPerToken(address _account)\n        external\n        view\n        returns (uint256)\n    {\n        return alternativeCreditsPerToken[_account];\n    }\n\n    /**\n     * @notice Transfer tokens to a specified address.\n     * @param _to the address to transfer to.\n     * @param _value the amount to be transferred.\n     * @return true on success.\n     */\n    function transfer(address _to, uint256 _value) external returns (bool) {\n        require(_to != address(0), \"Transfer to zero address\");\n\n        _executeTransfer(msg.sender, _to, _value);\n\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n     * @notice Transfer tokens from one address to another.\n     * @param _from The address you want to send tokens from.\n     * @param _to The address you want to transfer to.\n     * @param _value The amount of tokens to be transferred.\n     * @return true on success.\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool) {\n        require(_to != address(0), \"Transfer to zero address\");\n        uint256 userAllowance = allowances[_from][msg.sender];\n        require(_value <= userAllowance, \"Allowance exceeded\");\n\n        unchecked {\n            allowances[_from][msg.sender] = userAllowance - _value;\n        }\n\n        _executeTransfer(_from, _to, _value);\n\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function _executeTransfer(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal {\n        (\n            int256 fromRebasingCreditsDiff,\n            int256 fromNonRebasingSupplyDiff\n        ) = _adjustAccount(_from, -_value.toInt256());\n        (\n            int256 toRebasingCreditsDiff,\n            int256 toNonRebasingSupplyDiff\n        ) = _adjustAccount(_to, _value.toInt256());\n\n        _adjustGlobals(\n            fromRebasingCreditsDiff + toRebasingCreditsDiff,\n            fromNonRebasingSupplyDiff + toNonRebasingSupplyDiff\n        );\n    }\n\n    function _adjustAccount(address _account, int256 _balanceChange)\n        internal\n        returns (int256 rebasingCreditsDiff, int256 nonRebasingSupplyDiff)\n    {\n        RebaseOptions state = rebaseState[_account];\n        int256 currentBalance = balanceOf(_account).toInt256();\n        if (currentBalance + _balanceChange < 0) {\n            revert(\"Transfer amount exceeds balance\");\n        }\n        uint256 newBalance = (currentBalance + _balanceChange).toUint256();\n\n        if (state == RebaseOptions.YieldDelegationSource) {\n            address target = yieldTo[_account];\n            uint256 targetOldBalance = balanceOf(target);\n            uint256 targetNewCredits = _balanceToRebasingCredits(\n                targetOldBalance + newBalance\n            );\n            rebasingCreditsDiff =\n                targetNewCredits.toInt256() -\n                creditBalances[target].toInt256();\n\n            creditBalances[_account] = newBalance;\n            creditBalances[target] = targetNewCredits;\n        } else if (state == RebaseOptions.YieldDelegationTarget) {\n            uint256 newCredits = _balanceToRebasingCredits(\n                newBalance + creditBalances[yieldFrom[_account]]\n            );\n            rebasingCreditsDiff =\n                newCredits.toInt256() -\n                creditBalances[_account].toInt256();\n            creditBalances[_account] = newCredits;\n        } else {\n            _autoMigrate(_account);\n            uint256 alternativeCreditsPerTokenMem = alternativeCreditsPerToken[\n                _account\n            ];\n            if (alternativeCreditsPerTokenMem > 0) {\n                nonRebasingSupplyDiff = _balanceChange;\n                if (alternativeCreditsPerTokenMem != 1e18) {\n                    alternativeCreditsPerToken[_account] = 1e18;\n                }\n                creditBalances[_account] = newBalance;\n            } else {\n                uint256 newCredits = _balanceToRebasingCredits(newBalance);\n                rebasingCreditsDiff =\n                    newCredits.toInt256() -\n                    creditBalances[_account].toInt256();\n                creditBalances[_account] = newCredits;\n            }\n        }\n    }\n\n    function _adjustGlobals(\n        int256 _rebasingCreditsDiff,\n        int256 _nonRebasingSupplyDiff\n    ) internal {\n        if (_rebasingCreditsDiff != 0) {\n            rebasingCredits_ = (rebasingCredits_.toInt256() +\n                _rebasingCreditsDiff).toUint256();\n        }\n        if (_nonRebasingSupplyDiff != 0) {\n            nonRebasingSupply = (nonRebasingSupply.toInt256() +\n                _nonRebasingSupplyDiff).toUint256();\n        }\n    }\n\n    /**\n     * @notice Function to check the amount of tokens that _owner has allowed\n     *      to `_spender`.\n     * @param _owner The address which owns the funds.\n     * @param _spender The address which will spend the funds.\n     * @return The number of tokens still available for the _spender.\n     */\n    function allowance(address _owner, address _spender)\n        external\n        view\n        returns (uint256)\n    {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Approve the passed address to spend the specified amount of\n     *      tokens on behalf of msg.sender.\n     * @param _spender The address which will spend the funds.\n     * @param _value The amount of tokens to be spent.\n     * @return true on success.\n     */\n    function approve(address _spender, uint256 _value) external returns (bool) {\n        allowances[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * @notice Creates `_amount` tokens and assigns them to `_account`,\n     *     increasing the total supply.\n     */\n    function mint(address _account, uint256 _amount) external onlyVault {\n        require(_account != address(0), \"Mint to the zero address\");\n\n        // Account\n        (\n            int256 toRebasingCreditsDiff,\n            int256 toNonRebasingSupplyDiff\n        ) = _adjustAccount(_account, _amount.toInt256());\n        // Globals\n        _adjustGlobals(toRebasingCreditsDiff, toNonRebasingSupplyDiff);\n        totalSupply = totalSupply + _amount;\n\n        require(totalSupply < MAX_SUPPLY, \"Max supply\");\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    /**\n     * @notice Destroys `_amount` tokens from `_account`,\n     *     reducing the total supply.\n     */\n    function burn(address _account, uint256 _amount) external onlyVault {\n        require(_account != address(0), \"Burn from the zero address\");\n        if (_amount == 0) {\n            return;\n        }\n\n        // Account\n        (\n            int256 toRebasingCreditsDiff,\n            int256 toNonRebasingSupplyDiff\n        ) = _adjustAccount(_account, -_amount.toInt256());\n        // Globals\n        _adjustGlobals(toRebasingCreditsDiff, toNonRebasingSupplyDiff);\n        totalSupply = totalSupply - _amount;\n\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    /**\n     * @dev Get the credits per token for an account. Returns a fixed amount\n     *      if the account is non-rebasing.\n     * @param _account Address of the account.\n     */\n    function _creditsPerToken(address _account)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 alternativeCreditsPerTokenMem = alternativeCreditsPerToken[\n            _account\n        ];\n        if (alternativeCreditsPerTokenMem != 0) {\n            return alternativeCreditsPerTokenMem;\n        } else {\n            return rebasingCreditsPerToken_;\n        }\n    }\n\n    /**\n     * @dev Auto migrate contracts to be non rebasing,\n     *     unless they have opted into yield.\n     * @param _account Address of the account.\n     */\n    function _autoMigrate(address _account) internal {\n        uint256 codeLen = _account.code.length;\n        bool isEOA = (codeLen == 0) ||\n            (codeLen == 23 && bytes3(_account.code) == 0xef0100);\n        // In previous code versions, contracts would not have had their\n        // rebaseState[_account] set to RebaseOptions.NonRebasing when migrated\n        // therefore we check the actual accounting used on the account as well.\n        if (\n            (!isEOA) &&\n            rebaseState[_account] == RebaseOptions.NotSet &&\n            alternativeCreditsPerToken[_account] == 0\n        ) {\n            _rebaseOptOut(_account);\n        }\n    }\n\n    /**\n     * @dev Calculates credits from contract's global rebasingCreditsPerToken_, and\n     *      also balance that corresponds to those credits. The latter is important\n     *      when adjusting the contract's global nonRebasingSupply to circumvent any\n     *      possible rounding errors.\n     *\n     * @param _balance Balance of the account.\n     */\n    function _balanceToRebasingCredits(uint256 _balance)\n        internal\n        view\n        returns (uint256 rebasingCredits)\n    {\n        // Rounds up, because we need to ensure that accounts always have\n        // at least the balance that they should have.\n        // Note this should always be used on an absolute account value,\n        // not on a possibly negative diff, because then the rounding would be wrong.\n        return ((_balance) * rebasingCreditsPerToken_ + 1e18 - 1) / 1e18;\n    }\n\n    /**\n     * @notice The calling account will start receiving yield after a successful call.\n     * @param _account Address of the account.\n     */\n    function governanceRebaseOptIn(address _account) external onlyGovernor {\n        require(_account != address(0), \"Zero address not allowed\");\n        _rebaseOptIn(_account);\n    }\n\n    /**\n     * @notice The calling account will start receiving yield after a successful call.\n     */\n    function rebaseOptIn() external {\n        _rebaseOptIn(msg.sender);\n    }\n\n    function _rebaseOptIn(address _account) internal {\n        uint256 balance = balanceOf(_account);\n\n        // prettier-ignore\n        require(\n            alternativeCreditsPerToken[_account] > 0 ||\n                // Accounts may explicitly `rebaseOptIn` regardless of\n                // accounting if they have a 0 balance.\n                creditBalances[_account] == 0\n            ,\n            \"Account must be non-rebasing\"\n        );\n        RebaseOptions state = rebaseState[_account];\n        // prettier-ignore\n        require(\n            state == RebaseOptions.StdNonRebasing ||\n                state == RebaseOptions.NotSet,\n            \"Only standard non-rebasing accounts can opt in\"\n        );\n\n        uint256 newCredits = _balanceToRebasingCredits(balance);\n\n        // Account\n        rebaseState[_account] = RebaseOptions.StdRebasing;\n        alternativeCreditsPerToken[_account] = 0;\n        creditBalances[_account] = newCredits;\n        // Globals\n        _adjustGlobals(newCredits.toInt256(), -balance.toInt256());\n\n        emit AccountRebasingEnabled(_account);\n    }\n\n    /**\n     * @notice The calling account will no longer receive yield\n     */\n    function rebaseOptOut() external {\n        _rebaseOptOut(msg.sender);\n    }\n\n    function _rebaseOptOut(address _account) internal {\n        require(\n            alternativeCreditsPerToken[_account] == 0,\n            \"Account must be rebasing\"\n        );\n        RebaseOptions state = rebaseState[_account];\n        require(\n            state == RebaseOptions.StdRebasing || state == RebaseOptions.NotSet,\n            \"Only standard rebasing accounts can opt out\"\n        );\n\n        uint256 oldCredits = creditBalances[_account];\n        uint256 balance = balanceOf(_account);\n\n        // Account\n        rebaseState[_account] = RebaseOptions.StdNonRebasing;\n        alternativeCreditsPerToken[_account] = 1e18;\n        creditBalances[_account] = balance;\n        // Globals\n        _adjustGlobals(-oldCredits.toInt256(), balance.toInt256());\n\n        emit AccountRebasingDisabled(_account);\n    }\n\n    /**\n     * @notice Distribute yield to users. This changes the exchange rate\n     *  between \"credits\" and OUSD tokens to change rebasing user's balances.\n     * @param _newTotalSupply New total supply of OUSD.\n     */\n    function changeSupply(uint256 _newTotalSupply) external onlyVault {\n        require(totalSupply > 0, \"Cannot increase 0 supply\");\n\n        if (totalSupply == _newTotalSupply) {\n            emit TotalSupplyUpdatedHighres(\n                totalSupply,\n                rebasingCredits_,\n                rebasingCreditsPerToken_\n            );\n            return;\n        }\n\n        totalSupply = _newTotalSupply > MAX_SUPPLY\n            ? MAX_SUPPLY\n            : _newTotalSupply;\n\n        uint256 rebasingSupply = totalSupply - nonRebasingSupply;\n        // round up in the favour of the protocol\n        rebasingCreditsPerToken_ =\n            (rebasingCredits_ * 1e18 + rebasingSupply - 1) /\n            rebasingSupply;\n\n        require(rebasingCreditsPerToken_ > 0, \"Invalid change in supply\");\n\n        emit TotalSupplyUpdatedHighres(\n            totalSupply,\n            rebasingCredits_,\n            rebasingCreditsPerToken_\n        );\n    }\n\n    /*\n     * @notice Send the yield from one account to another account.\n     *         Each account keeps its own balances.\n     */\n    function delegateYield(address _from, address _to)\n        external\n        onlyGovernorOrStrategist\n    {\n        require(_from != address(0), \"Zero from address not allowed\");\n        require(_to != address(0), \"Zero to address not allowed\");\n\n        require(_from != _to, \"Cannot delegate to self\");\n        require(\n            yieldFrom[_to] == address(0) &&\n                yieldTo[_to] == address(0) &&\n                yieldFrom[_from] == address(0) &&\n                yieldTo[_from] == address(0),\n            \"Blocked by existing yield delegation\"\n        );\n        RebaseOptions stateFrom = rebaseState[_from];\n        RebaseOptions stateTo = rebaseState[_to];\n\n        require(\n            stateFrom == RebaseOptions.NotSet ||\n                stateFrom == RebaseOptions.StdNonRebasing ||\n                stateFrom == RebaseOptions.StdRebasing,\n            \"Invalid rebaseState from\"\n        );\n\n        require(\n            stateTo == RebaseOptions.NotSet ||\n                stateTo == RebaseOptions.StdNonRebasing ||\n                stateTo == RebaseOptions.StdRebasing,\n            \"Invalid rebaseState to\"\n        );\n\n        if (alternativeCreditsPerToken[_from] == 0) {\n            _rebaseOptOut(_from);\n        }\n        if (alternativeCreditsPerToken[_to] > 0) {\n            _rebaseOptIn(_to);\n        }\n\n        uint256 fromBalance = balanceOf(_from);\n        uint256 toBalance = balanceOf(_to);\n        uint256 oldToCredits = creditBalances[_to];\n        uint256 newToCredits = _balanceToRebasingCredits(\n            fromBalance + toBalance\n        );\n\n        // Set up the bidirectional links\n        yieldTo[_from] = _to;\n        yieldFrom[_to] = _from;\n\n        // Local\n        rebaseState[_from] = RebaseOptions.YieldDelegationSource;\n        alternativeCreditsPerToken[_from] = 1e18;\n        creditBalances[_from] = fromBalance;\n        rebaseState[_to] = RebaseOptions.YieldDelegationTarget;\n        creditBalances[_to] = newToCredits;\n\n        // Global\n        int256 creditsChange = newToCredits.toInt256() -\n            oldToCredits.toInt256();\n        _adjustGlobals(creditsChange, -(fromBalance).toInt256());\n        emit YieldDelegated(_from, _to);\n    }\n\n    /*\n     * @notice Stop sending the yield from one account to another account.\n     */\n    function undelegateYield(address _from) external onlyGovernorOrStrategist {\n        // Require a delegation, which will also ensure a valid delegation\n        require(yieldTo[_from] != address(0), \"Zero address not allowed\");\n\n        address to = yieldTo[_from];\n        uint256 fromBalance = balanceOf(_from);\n        uint256 toBalance = balanceOf(to);\n        uint256 oldToCredits = creditBalances[to];\n        uint256 newToCredits = _balanceToRebasingCredits(toBalance);\n\n        // Remove the bidirectional links\n        yieldFrom[to] = address(0);\n        yieldTo[_from] = address(0);\n\n        // Local\n        rebaseState[_from] = RebaseOptions.StdNonRebasing;\n        // alternativeCreditsPerToken[from] already 1e18 from `delegateYield()`\n        creditBalances[_from] = fromBalance;\n        rebaseState[to] = RebaseOptions.StdRebasing;\n        // alternativeCreditsPerToken[to] already 0 from `delegateYield()`\n        creditBalances[to] = newToCredits;\n\n        // Global\n        int256 creditsChange = newToCredits.toInt256() -\n            oldToCredits.toInt256();\n        _adjustGlobals(creditsChange, fromBalance.toInt256());\n        emit YieldUndelegated(_from, to);\n    }\n}\n"
    },
    "contracts/token/WOETH.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ERC4626 } from \"../../lib/openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { Governable } from \"../governance/Governable.sol\";\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { OETH } from \"./OETH.sol\";\n\n/**\n * @title Wrapped OETH Token Contract\n * @author Origin Protocol Inc\n *\n * @dev An important capability of this contract is that it isn't susceptible to changes of the\n * exchange rate of WOETH/OETH if/when someone sends the underlying asset (OETH) to the contract.\n * If OETH weren't rebasing this could be achieved by solely tracking the ERC20 transfers of the OETH\n * token on mint, deposit, redeem, withdraw. The issue is that OETH is rebasing and OETH balances\n * will change when the token rebases.\n * For that reason the contract logic checks the actual underlying OETH token balance only once\n * (either on a fresh contract creation or upgrade) and considering the WOETH supply and\n * rebasingCreditsPerToken calculates the _adjuster. Once the adjuster is calculated any donations\n * to the contract are ignored. The totalSupply (instead of querying OETH balance) works off of\n * adjuster the current WOETH supply and rebasingCreditsPerToken. This makes WOETH value accrual\n * completely follow OETH's value accrual.\n * WOETH is safe to use in lending markets as the VualtCore's _rebase contains safeguards preventing\n * any sudden large rebases.\n */\n\ncontract WOETH is ERC4626, Governable, Initializable {\n    using SafeERC20 for IERC20;\n    /* This is a 1e27 adjustment constant that expresses the difference in exchange rate between\n     * OETH's rebase since inception (expressed with rebasingCreditsPerToken) and WOETH to OETH\n     * conversion.\n     *\n     * If WOETH and OETH are deployed at the same time, the value of adjuster is a neutral 1e27\n     */\n    uint256 public adjuster;\n    uint256[49] private __gap;\n\n    // no need to set ERC20 name and symbol since they are overridden in WOETH & WOETHBase\n    constructor(ERC20 underlying_) ERC20(\"\", \"\") ERC4626(underlying_) {}\n\n    /**\n     * @notice Enable OETH rebasing for this contract\n     */\n    function initialize() external onlyGovernor initializer {\n        OETH(address(asset())).rebaseOptIn();\n\n        initialize2();\n    }\n\n    /**\n     * @notice secondary initializer that newly deployed contracts will execute as part\n     *         of primary initialize function and the existing contracts will have it called\n     *         as a governance operation.\n     */\n    function initialize2() public onlyGovernor {\n        require(adjuster == 0, \"Initialize2 already called\");\n\n        if (totalSupply() == 0) {\n            adjuster = 1e27;\n        } else {\n            adjuster =\n                (rebasingCreditsPerTokenHighres() *\n                    ERC20(asset()).balanceOf(address(this))) /\n                totalSupply();\n        }\n    }\n\n    function name()\n        public\n        view\n        virtual\n        override(ERC20, IERC20Metadata)\n        returns (string memory)\n    {\n        return \"Wrapped OETH\";\n    }\n\n    function symbol()\n        public\n        view\n        virtual\n        override(ERC20, IERC20Metadata)\n        returns (string memory)\n    {\n        return \"wOETH\";\n    }\n\n    /**\n     * @notice Transfer token to governor. Intended for recovering tokens stuck in\n     *      contract, i.e. mistaken sends. Cannot transfer OETH\n     * @param asset_ Address for the asset\n     * @param amount_ Amount of the asset to transfer\n     */\n    function transferToken(address asset_, uint256 amount_)\n        external\n        onlyGovernor\n    {\n        require(asset_ != address(asset()), \"Cannot collect core asset\");\n        IERC20(asset_).safeTransfer(governor(), amount_);\n    }\n\n    /// @inheritdoc ERC4626\n    function convertToShares(uint256 assets)\n        public\n        view\n        virtual\n        override\n        returns (uint256 shares)\n    {\n        return (assets * rebasingCreditsPerTokenHighres()) / adjuster;\n    }\n\n    /// @inheritdoc ERC4626\n    function convertToAssets(uint256 shares)\n        public\n        view\n        virtual\n        override\n        returns (uint256 assets)\n    {\n        return (shares * adjuster) / rebasingCreditsPerTokenHighres();\n    }\n\n    /// @inheritdoc ERC4626\n    function totalAssets() public view override returns (uint256) {\n        return (totalSupply() * adjuster) / rebasingCreditsPerTokenHighres();\n    }\n\n    function rebasingCreditsPerTokenHighres() internal view returns (uint256) {\n        return OETH(asset()).rebasingCreditsPerTokenHighres();\n    }\n}\n"
    },
    "contracts/token/WOETHBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { WOETH } from \"./WOETH.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title OETH Token Contract\n * @author Origin Protocol Inc\n */\n\ncontract WOETHBase is WOETH {\n    constructor(ERC20 underlying_) WOETH(underlying_) {}\n\n    function name() public view virtual override returns (string memory) {\n        return \"Wrapped Super OETH\";\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return \"wsuperOETHb\";\n    }\n}\n"
    },
    "contracts/token/WOETHPlume.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { WOETH } from \"./WOETH.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title wOETH (Plume) Token Contract\n * @author Origin Protocol Inc\n */\n\ncontract WOETHPlume is WOETH {\n    constructor(ERC20 underlying_) WOETH(underlying_) {}\n\n    function name() public view virtual override returns (string memory) {\n        return \"Wrapped Super OETH\";\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return \"wsuperOETHp\";\n    }\n}\n"
    },
    "contracts/token/WOSonic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { WOETH } from \"./WOETH.sol\";\n\n/**\n * @title Wrapped Origin Sonic (wOS) token on Sonic\n * @author Origin Protocol Inc\n */\ncontract WOSonic is WOETH {\n    constructor(ERC20 underlying_) WOETH(underlying_) {}\n\n    function name()\n        public\n        view\n        virtual\n        override(WOETH)\n        returns (string memory)\n    {\n        return \"Wrapped OS\";\n    }\n\n    function symbol()\n        public\n        view\n        virtual\n        override(WOETH)\n        returns (string memory)\n    {\n        return \"wOS\";\n    }\n}\n"
    },
    "contracts/token/WrappedOusd.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { WOETH } from \"./WOETH.sol\";\n\n/**\n * @title Wrapped OUSD Token Contract\n * @author Origin Protocol Inc\n */\ncontract WrappedOusd is WOETH {\n    constructor(ERC20 underlying_) WOETH(underlying_) {}\n\n    function name()\n        public\n        view\n        virtual\n        override(WOETH)\n        returns (string memory)\n    {\n        return \"Wrapped OUSD\";\n    }\n\n    function symbol()\n        public\n        view\n        virtual\n        override(WOETH)\n        returns (string memory)\n    {\n        return \"WOUSD\";\n    }\n}\n"
    },
    "contracts/utils/BalancerErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.7.4 <0.9.0;\n\n// solhint-disable\n\n/**\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n * supported.\n * Uses the default 'BAL' prefix for the error code\n */\nfunction _require(bool condition, uint256 errorCode) pure {\n    if (!condition) _revert(errorCode);\n}\n\n/**\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n * supported.\n */\nfunction _require(\n    bool condition,\n    uint256 errorCode,\n    bytes3 prefix\n) pure {\n    if (!condition) _revert(errorCode, prefix);\n}\n\n/**\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n * Uses the default 'BAL' prefix for the error code\n */\nfunction _revert(uint256 errorCode) pure {\n    _revert(errorCode, 0x42414c); // This is the raw byte representation of \"BAL\"\n}\n\n/**\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n */\nfunction _revert(uint256 errorCode, bytes3 prefix) pure {\n    uint256 prefixUint = uint256(uint24(prefix));\n    // We're going to dynamically create a revert string based on the error code, with the following format:\n    // 'BAL#{errorCode}'\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\n    //\n    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\n    // number (8 to 16 bits) than the individual string characters.\n    //\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\n    assembly {\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\n        // the '0' character.\n\n        let units := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let tenths := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let hundreds := add(mod(errorCode, 10), 0x30)\n\n        // With the individual characters, we can now construct the full string.\n        // We first append the '#' character (0x23) to the prefix. In the case of 'BAL', it results in 0x42414c23 ('BAL#')\n        // Then, we shift this by 24 (to provide space for the 3 bytes of the error code), and add the\n        // characters to it, each shifted by a multiple of 8.\n        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\n        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\n        // array).\n        let formattedPrefix := shl(24, add(0x23, shl(8, prefixUint)))\n\n        let revertReason := shl(\n            200,\n            add(\n                formattedPrefix,\n                add(add(units, shl(8, tenths)), shl(16, hundreds))\n            )\n        )\n\n        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\n        // message will have the following layout:\n        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\n\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\n        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\n        mstore(\n            0x0,\n            0x08c379a000000000000000000000000000000000000000000000000000000000\n        )\n        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\n        mstore(\n            0x04,\n            0x0000000000000000000000000000000000000000000000000000000000000020\n        )\n        // The string length is fixed: 7 characters.\n        mstore(0x24, 7)\n        // Finally, the string itself is stored.\n        mstore(0x44, revertReason)\n\n        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\n        revert(0, 100)\n    }\n}\n\nlibrary Errors {\n    // Math\n    uint256 internal constant ADD_OVERFLOW = 0;\n    uint256 internal constant SUB_OVERFLOW = 1;\n    uint256 internal constant SUB_UNDERFLOW = 2;\n    uint256 internal constant MUL_OVERFLOW = 3;\n    uint256 internal constant ZERO_DIVISION = 4;\n    uint256 internal constant DIV_INTERNAL = 5;\n    uint256 internal constant X_OUT_OF_BOUNDS = 6;\n    uint256 internal constant Y_OUT_OF_BOUNDS = 7;\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\n    uint256 internal constant INVALID_EXPONENT = 9;\n\n    // Input\n    uint256 internal constant OUT_OF_BOUNDS = 100;\n    uint256 internal constant UNSORTED_ARRAY = 101;\n    uint256 internal constant UNSORTED_TOKENS = 102;\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\n    uint256 internal constant ZERO_TOKEN = 104;\n    uint256 internal constant INSUFFICIENT_DATA = 105;\n\n    // Shared pools\n    uint256 internal constant MIN_TOKENS = 200;\n    uint256 internal constant MAX_TOKENS = 201;\n    uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\n    uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\n    uint256 internal constant MINIMUM_BPT = 204;\n    uint256 internal constant CALLER_NOT_VAULT = 205;\n    uint256 internal constant UNINITIALIZED = 206;\n    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\n    uint256 internal constant EXPIRED_PERMIT = 209;\n    uint256 internal constant NOT_TWO_TOKENS = 210;\n    uint256 internal constant DISABLED = 211;\n\n    // Pools\n    uint256 internal constant MIN_AMP = 300;\n    uint256 internal constant MAX_AMP = 301;\n    uint256 internal constant MIN_WEIGHT = 302;\n    uint256 internal constant MAX_STABLE_TOKENS = 303;\n    uint256 internal constant MAX_IN_RATIO = 304;\n    uint256 internal constant MAX_OUT_RATIO = 305;\n    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\n    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\n    uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\n    uint256 internal constant INVALID_TOKEN = 309;\n    uint256 internal constant UNHANDLED_JOIN_KIND = 310;\n    uint256 internal constant ZERO_INVARIANT = 311;\n    uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;\n    uint256 internal constant ORACLE_NOT_INITIALIZED = 313;\n    uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;\n    uint256 internal constant ORACLE_INVALID_INDEX = 315;\n    uint256 internal constant ORACLE_BAD_SECS = 316;\n    uint256 internal constant AMP_END_TIME_TOO_CLOSE = 317;\n    uint256 internal constant AMP_ONGOING_UPDATE = 318;\n    uint256 internal constant AMP_RATE_TOO_HIGH = 319;\n    uint256 internal constant AMP_NO_ONGOING_UPDATE = 320;\n    uint256 internal constant STABLE_INVARIANT_DIDNT_CONVERGE = 321;\n    uint256 internal constant STABLE_GET_BALANCE_DIDNT_CONVERGE = 322;\n    uint256 internal constant RELAYER_NOT_CONTRACT = 323;\n    uint256 internal constant BASE_POOL_RELAYER_NOT_CALLED = 324;\n    uint256 internal constant REBALANCING_RELAYER_REENTERED = 325;\n    uint256 internal constant GRADUAL_UPDATE_TIME_TRAVEL = 326;\n    uint256 internal constant SWAPS_DISABLED = 327;\n    uint256 internal constant CALLER_IS_NOT_LBP_OWNER = 328;\n    uint256 internal constant PRICE_RATE_OVERFLOW = 329;\n    uint256 internal constant INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED = 330;\n    uint256 internal constant WEIGHT_CHANGE_TOO_FAST = 331;\n    uint256 internal constant LOWER_GREATER_THAN_UPPER_TARGET = 332;\n    uint256 internal constant UPPER_TARGET_TOO_HIGH = 333;\n    uint256 internal constant UNHANDLED_BY_LINEAR_POOL = 334;\n    uint256 internal constant OUT_OF_TARGET_RANGE = 335;\n    uint256 internal constant UNHANDLED_EXIT_KIND = 336;\n    uint256 internal constant UNAUTHORIZED_EXIT = 337;\n    uint256 internal constant MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE = 338;\n    uint256 internal constant UNHANDLED_BY_MANAGED_POOL = 339;\n    uint256 internal constant UNHANDLED_BY_PHANTOM_POOL = 340;\n    uint256 internal constant TOKEN_DOES_NOT_HAVE_RATE_PROVIDER = 341;\n    uint256 internal constant INVALID_INITIALIZATION = 342;\n    uint256 internal constant OUT_OF_NEW_TARGET_RANGE = 343;\n    uint256 internal constant FEATURE_DISABLED = 344;\n    uint256 internal constant UNINITIALIZED_POOL_CONTROLLER = 345;\n    uint256 internal constant SET_SWAP_FEE_DURING_FEE_CHANGE = 346;\n    uint256 internal constant SET_SWAP_FEE_PENDING_FEE_CHANGE = 347;\n    uint256 internal constant CHANGE_TOKENS_DURING_WEIGHT_CHANGE = 348;\n    uint256 internal constant CHANGE_TOKENS_PENDING_WEIGHT_CHANGE = 349;\n    uint256 internal constant MAX_WEIGHT = 350;\n    uint256 internal constant UNAUTHORIZED_JOIN = 351;\n    uint256 internal constant MAX_MANAGEMENT_AUM_FEE_PERCENTAGE = 352;\n    uint256 internal constant FRACTIONAL_TARGET = 353;\n    uint256 internal constant ADD_OR_REMOVE_BPT = 354;\n    uint256 internal constant INVALID_CIRCUIT_BREAKER_BOUNDS = 355;\n    uint256 internal constant CIRCUIT_BREAKER_TRIPPED = 356;\n    uint256 internal constant MALICIOUS_QUERY_REVERT = 357;\n    uint256 internal constant JOINS_EXITS_DISABLED = 358;\n\n    // Lib\n    uint256 internal constant REENTRANCY = 400;\n    uint256 internal constant SENDER_NOT_ALLOWED = 401;\n    uint256 internal constant PAUSED = 402;\n    uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\n    uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\n    uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\n    uint256 internal constant INSUFFICIENT_BALANCE = 406;\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\n    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\n    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\n    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\n    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\n    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\n    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\n    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\n    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\n    uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\n    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\n    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\n    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\n    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\n    uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\n    uint256 internal constant CALLER_IS_NOT_OWNER = 426;\n    uint256 internal constant NEW_OWNER_IS_ZERO = 427;\n    uint256 internal constant CODE_DEPLOYMENT_FAILED = 428;\n    uint256 internal constant CALL_TO_NON_CONTRACT = 429;\n    uint256 internal constant LOW_LEVEL_CALL_FAILED = 430;\n    uint256 internal constant NOT_PAUSED = 431;\n    uint256 internal constant ADDRESS_ALREADY_ALLOWLISTED = 432;\n    uint256 internal constant ADDRESS_NOT_ALLOWLISTED = 433;\n    uint256 internal constant ERC20_BURN_EXCEEDS_BALANCE = 434;\n    uint256 internal constant INVALID_OPERATION = 435;\n    uint256 internal constant CODEC_OVERFLOW = 436;\n    uint256 internal constant IN_RECOVERY_MODE = 437;\n    uint256 internal constant NOT_IN_RECOVERY_MODE = 438;\n    uint256 internal constant INDUCED_FAILURE = 439;\n    uint256 internal constant EXPIRED_SIGNATURE = 440;\n    uint256 internal constant MALFORMED_SIGNATURE = 441;\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_UINT64 = 442;\n    uint256 internal constant UNHANDLED_FEE_TYPE = 443;\n    uint256 internal constant BURN_FROM_ZERO = 444;\n\n    // Vault\n    uint256 internal constant INVALID_POOL_ID = 500;\n    uint256 internal constant CALLER_NOT_POOL = 501;\n    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\n    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\n    uint256 internal constant INVALID_SIGNATURE = 504;\n    uint256 internal constant EXIT_BELOW_MIN = 505;\n    uint256 internal constant JOIN_ABOVE_MAX = 506;\n    uint256 internal constant SWAP_LIMIT = 507;\n    uint256 internal constant SWAP_DEADLINE = 508;\n    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\n    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\n    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\n    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\n    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\n    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\n    uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\n    uint256 internal constant INSUFFICIENT_ETH = 516;\n    uint256 internal constant UNALLOCATED_ETH = 517;\n    uint256 internal constant ETH_TRANSFER = 518;\n    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\n    uint256 internal constant TOKENS_MISMATCH = 520;\n    uint256 internal constant TOKEN_NOT_REGISTERED = 521;\n    uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\n    uint256 internal constant TOKENS_ALREADY_SET = 523;\n    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\n    uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\n    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\n    uint256 internal constant POOL_NO_TOKENS = 527;\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\n\n    // Fees\n    uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\n    uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\n    uint256 internal constant AUM_FEE_PERCENTAGE_TOO_HIGH = 603;\n\n    // FeeSplitter\n    uint256 internal constant SPLITTER_FEE_PERCENTAGE_TOO_HIGH = 700;\n\n    // Misc\n    uint256 internal constant UNIMPLEMENTED = 998;\n    uint256 internal constant SHOULD_NOT_HAPPEN = 999;\n}\n"
    },
    "contracts/utils/BytesHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nuint256 constant UINT32_LENGTH = 4;\nuint256 constant UINT64_LENGTH = 8;\nuint256 constant UINT256_LENGTH = 32;\n// Address is 20 bytes, but we expect the data to be padded with 0s to 32 bytes\nuint256 constant ADDRESS_LENGTH = 32;\n\nlibrary BytesHelper {\n    /**\n     * @dev Extract a slice from bytes memory\n     * @param data The bytes memory to slice\n     * @param start The start index (inclusive)\n     * @param end The end index (exclusive)\n     * @return result A new bytes memory containing the slice\n     */\n    function extractSlice(\n        bytes memory data,\n        uint256 start,\n        uint256 end\n    ) internal pure returns (bytes memory) {\n        require(end >= start, \"Invalid slice range\");\n        require(end <= data.length, \"Slice end exceeds data length\");\n\n        uint256 length = end - start;\n        bytes memory result = new bytes(length);\n\n        // Simple byte-by-byte copy\n        for (uint256 i = 0; i < length; i++) {\n            result[i] = data[start + i];\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Decode a uint32 from a bytes memory\n     * @param data The bytes memory to decode\n     * @return uint32 The decoded uint32\n     */\n    function decodeUint32(bytes memory data) internal pure returns (uint32) {\n        require(data.length == 4, \"Invalid data length\");\n        return uint32(uint256(bytes32(data)) >> 224);\n    }\n\n    /**\n     * @dev Extract a uint32 from a bytes memory\n     * @param data The bytes memory to extract from\n     * @param start The start index (inclusive)\n     * @return uint32 The extracted uint32\n     */\n    function extractUint32(bytes memory data, uint256 start)\n        internal\n        pure\n        returns (uint32)\n    {\n        return decodeUint32(extractSlice(data, start, start + UINT32_LENGTH));\n    }\n\n    /**\n     * @dev Decode an address from a bytes memory.\n     *      Expects the data to be padded with 0s to 32 bytes.\n     * @param data The bytes memory to decode\n     * @return address The decoded address\n     */\n    function decodeAddress(bytes memory data) internal pure returns (address) {\n        // We expect the data to be padded with 0s, so length is 32 not 20\n        require(data.length == 32, \"Invalid data length\");\n        return abi.decode(data, (address));\n    }\n\n    /**\n     * @dev Extract an address from a bytes memory\n     * @param data The bytes memory to extract from\n     * @param start The start index (inclusive)\n     * @return address The extracted address\n     */\n    function extractAddress(bytes memory data, uint256 start)\n        internal\n        pure\n        returns (address)\n    {\n        return decodeAddress(extractSlice(data, start, start + ADDRESS_LENGTH));\n    }\n\n    /**\n     * @dev Decode a uint256 from a bytes memory\n     * @param data The bytes memory to decode\n     * @return uint256 The decoded uint256\n     */\n    function decodeUint256(bytes memory data) internal pure returns (uint256) {\n        require(data.length == 32, \"Invalid data length\");\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @dev Extract a uint256 from a bytes memory\n     * @param data The bytes memory to extract from\n     * @param start The start index (inclusive)\n     * @return uint256 The extracted uint256\n     */\n    function extractUint256(bytes memory data, uint256 start)\n        internal\n        pure\n        returns (uint256)\n    {\n        return decodeUint256(extractSlice(data, start, start + UINT256_LENGTH));\n    }\n}\n"
    },
    "contracts/utils/Helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IBasicToken } from \"../interfaces/IBasicToken.sol\";\n\nlibrary Helpers {\n    /**\n     * @notice Fetch the `symbol()` from an ERC20 token\n     * @dev Grabs the `symbol()` from a contract\n     * @param _token Address of the ERC20 token\n     * @return string Symbol of the ERC20 token\n     */\n    function getSymbol(address _token) internal view returns (string memory) {\n        string memory symbol = IBasicToken(_token).symbol();\n        return symbol;\n    }\n\n    /**\n     * @notice Fetch the `decimals()` from an ERC20 token\n     * @dev Grabs the `decimals()` from a contract and fails if\n     *      the decimal value does not live within a certain range\n     * @param _token Address of the ERC20 token\n     * @return uint256 Decimals of the ERC20 token\n     */\n    function getDecimals(address _token) internal view returns (uint256) {\n        uint256 decimals = IBasicToken(_token).decimals();\n        require(\n            decimals >= 4 && decimals <= 18,\n            \"Token must have sufficient decimal places\"\n        );\n\n        return decimals;\n    }\n}\n"
    },
    "contracts/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Base contract any contracts that need to initialize state after deployment.\n * @author Origin Protocol Inc\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(\n            initializing || !initialized,\n            \"Initializable: contract is already initialized\"\n        );\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/utils/InitializableAbstractStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Base contract for vault strategies.\n * @author Origin Protocol Inc\n */\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\nabstract contract InitializableAbstractStrategy is Initializable, Governable {\n    using SafeERC20 for IERC20;\n\n    event PTokenAdded(address indexed _asset, address _pToken);\n    event PTokenRemoved(address indexed _asset, address _pToken);\n    event Deposit(address indexed _asset, address _pToken, uint256 _amount);\n    event Withdrawal(address indexed _asset, address _pToken, uint256 _amount);\n    event RewardTokenCollected(\n        address recipient,\n        address rewardToken,\n        uint256 amount\n    );\n    event RewardTokenAddressesUpdated(\n        address[] _oldAddresses,\n        address[] _newAddresses\n    );\n    event HarvesterAddressesUpdated(\n        address _oldHarvesterAddress,\n        address _newHarvesterAddress\n    );\n\n    /// @notice Address of the underlying platform\n    address public immutable platformAddress;\n    /// @notice Address of the OToken vault\n    address public immutable vaultAddress;\n\n    /// @dev Replaced with an immutable variable\n    // slither-disable-next-line constable-states\n    address private _deprecated_platformAddress;\n\n    /// @dev Replaced with an immutable\n    // slither-disable-next-line constable-states\n    address private _deprecated_vaultAddress;\n\n    /// @notice asset => pToken (Platform Specific Token Address)\n    mapping(address => address) public assetToPToken;\n\n    /// @notice Full list of all assets supported by the strategy\n    address[] internal assetsMapped;\n\n    // Deprecated: Reward token address\n    // slither-disable-next-line constable-states\n    address private _deprecated_rewardTokenAddress;\n\n    // Deprecated: now resides in Harvester's rewardTokenConfigs\n    // slither-disable-next-line constable-states\n    uint256 private _deprecated_rewardLiquidationThreshold;\n\n    /// @notice Address of the Harvester contract allowed to collect reward tokens\n    address public harvesterAddress;\n\n    /// @notice Address of the reward tokens. eg CRV, BAL, CVX, AURA\n    address[] public rewardTokenAddresses;\n\n    /* Reserved for future expansion. Used to be 100 storage slots\n     * and has decreased to accommodate:\n     * - harvesterAddress\n     * - rewardTokenAddresses\n     */\n    int256[98] private _reserved;\n\n    struct BaseStrategyConfig {\n        address platformAddress; // Address of the underlying platform\n        address vaultAddress; // Address of the OToken's Vault\n    }\n\n    /**\n     * @dev Verifies that the caller is the Governor or Strategist.\n     */\n    modifier onlyGovernorOrStrategist() virtual {\n        require(\n            isGovernor() || msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    /**\n     * @param _config The platform and OToken vault addresses\n     */\n    constructor(BaseStrategyConfig memory _config) {\n        platformAddress = _config.platformAddress;\n        vaultAddress = _config.vaultAddress;\n    }\n\n    /**\n     * @dev Internal initialize function, to set up initial internal state\n     * @param _rewardTokenAddresses Address of reward token for platform\n     * @param _assets Addresses of initial supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function _initialize(\n        address[] memory _rewardTokenAddresses,\n        address[] memory _assets,\n        address[] memory _pTokens\n    ) internal {\n        rewardTokenAddresses = _rewardTokenAddresses;\n\n        uint256 assetCount = _assets.length;\n        require(assetCount == _pTokens.length, \"Invalid input arrays\");\n        for (uint256 i = 0; i < assetCount; ++i) {\n            _setPTokenAddress(_assets[i], _pTokens[i]);\n        }\n    }\n\n    /**\n     * @notice Collect accumulated reward token and send to Vault.\n     */\n    function collectRewardTokens() external virtual onlyHarvester nonReentrant {\n        _collectRewardTokens();\n    }\n\n    /**\n     * @dev Default implementation that transfers reward tokens to the Harvester\n     * Implementing strategies need to add custom logic to collect the rewards.\n     */\n    function _collectRewardTokens() internal virtual {\n        uint256 rewardTokenCount = rewardTokenAddresses.length;\n        for (uint256 i = 0; i < rewardTokenCount; ++i) {\n            IERC20 rewardToken = IERC20(rewardTokenAddresses[i]);\n            uint256 balance = rewardToken.balanceOf(address(this));\n            if (balance > 0) {\n                emit RewardTokenCollected(\n                    harvesterAddress,\n                    address(rewardToken),\n                    balance\n                );\n                rewardToken.safeTransfer(harvesterAddress, balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault.\n     */\n    modifier onlyVault() {\n        require(msg.sender == vaultAddress, \"Caller is not the Vault\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Harvester.\n     */\n    modifier onlyHarvester() {\n        require(msg.sender == harvesterAddress, \"Caller is not the Harvester\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault or Governor.\n     */\n    modifier onlyVaultOrGovernor() {\n        require(\n            msg.sender == vaultAddress || msg.sender == governor(),\n            \"Caller is not the Vault or Governor\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault, Governor, or Strategist.\n     */\n    modifier onlyVaultOrGovernorOrStrategist() {\n        require(\n            msg.sender == vaultAddress ||\n                msg.sender == governor() ||\n                msg.sender == IVault(vaultAddress).strategistAddr(),\n            \"Caller is not the Vault, Governor, or Strategist\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Set the reward token addresses. Any old addresses will be overwritten.\n     * @param _rewardTokenAddresses Array of reward token addresses\n     */\n    function setRewardTokenAddresses(address[] calldata _rewardTokenAddresses)\n        external\n        onlyGovernor\n    {\n        uint256 rewardTokenCount = _rewardTokenAddresses.length;\n        for (uint256 i = 0; i < rewardTokenCount; ++i) {\n            require(\n                _rewardTokenAddresses[i] != address(0),\n                \"Can not set an empty address as a reward token\"\n            );\n        }\n\n        emit RewardTokenAddressesUpdated(\n            rewardTokenAddresses,\n            _rewardTokenAddresses\n        );\n        rewardTokenAddresses = _rewardTokenAddresses;\n    }\n\n    /**\n     * @notice Get the reward token addresses.\n     * @return address[] the reward token addresses.\n     */\n    function getRewardTokenAddresses()\n        external\n        view\n        returns (address[] memory)\n    {\n        return rewardTokenAddresses;\n    }\n\n    /**\n     * @notice Provide support for asset by passing its pToken address.\n     *      This method can only be called by the system Governor\n     * @param _asset    Address for the asset\n     * @param _pToken   Address for the corresponding platform token\n     */\n    function setPTokenAddress(address _asset, address _pToken)\n        external\n        virtual\n        onlyGovernor\n    {\n        _setPTokenAddress(_asset, _pToken);\n    }\n\n    /**\n     * @notice Remove a supported asset by passing its index.\n     *      This method can only be called by the system Governor\n     * @param _assetIndex Index of the asset to be removed\n     */\n    function removePToken(uint256 _assetIndex) external virtual onlyGovernor {\n        require(_assetIndex < assetsMapped.length, \"Invalid index\");\n        address asset = assetsMapped[_assetIndex];\n        address pToken = assetToPToken[asset];\n\n        if (_assetIndex < assetsMapped.length - 1) {\n            assetsMapped[_assetIndex] = assetsMapped[assetsMapped.length - 1];\n        }\n        assetsMapped.pop();\n        assetToPToken[asset] = address(0);\n\n        emit PTokenRemoved(asset, pToken);\n    }\n\n    /**\n     * @notice Provide support for asset by passing its pToken address.\n     *      Add to internal mappings and execute the platform specific,\n     * abstract method `_abstractSetPToken`\n     * @param _asset    Address for the asset\n     * @param _pToken   Address for the corresponding platform token\n     */\n    function _setPTokenAddress(address _asset, address _pToken) internal {\n        require(assetToPToken[_asset] == address(0), \"pToken already set\");\n        require(\n            _asset != address(0) && _pToken != address(0),\n            \"Invalid addresses\"\n        );\n\n        assetToPToken[_asset] = _pToken;\n        assetsMapped.push(_asset);\n\n        emit PTokenAdded(_asset, _pToken);\n\n        _abstractSetPToken(_asset, _pToken);\n    }\n\n    /**\n     * @notice Transfer token to governor. Intended for recovering tokens stuck in\n     *      strategy contracts, i.e. mistaken sends.\n     * @param _asset Address for the asset\n     * @param _amount Amount of the asset to transfer\n     */\n    function transferToken(address _asset, uint256 _amount)\n        public\n        virtual\n        onlyGovernor\n    {\n        require(!supportsAsset(_asset), \"Cannot transfer supported asset\");\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /**\n     * @notice Set the Harvester contract that can collect rewards.\n     * @param _harvesterAddress Address of the harvester contract.\n     */\n    function setHarvesterAddress(address _harvesterAddress)\n        external\n        onlyGovernor\n    {\n        emit HarvesterAddressesUpdated(harvesterAddress, _harvesterAddress);\n        harvesterAddress = _harvesterAddress;\n    }\n\n    /***************************************\n                 Abstract\n    ****************************************/\n\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        virtual;\n\n    function safeApproveAllTokens() external virtual;\n\n    /**\n     * @notice Deposit an amount of assets into the platform\n     * @param _asset               Address for the asset\n     * @param _amount              Units of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount) external virtual;\n\n    /**\n     * @notice Deposit all supported assets in this strategy contract to the platform\n     */\n    function depositAll() external virtual;\n\n    /**\n     * @notice Withdraw an `amount` of assets from the platform and\n     * send to the `_recipient`.\n     * @param _recipient         Address to which the asset should be sent\n     * @param _asset             Address of the asset\n     * @param _amount            Units of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external virtual;\n\n    /**\n     * @notice Withdraw all supported assets from platform and\n     * sends to the OToken's Vault.\n     */\n    function withdrawAll() external virtual;\n\n    /**\n     * @notice Get the total asset value held in the platform.\n     *      This includes any interest that was generated since depositing.\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        virtual\n        returns (uint256 balance);\n\n    /**\n     * @notice Check if an asset is supported.\n     * @param _asset    Address of the asset\n     * @return bool     Whether asset is supported\n     */\n    function supportsAsset(address _asset) public view virtual returns (bool);\n}\n"
    },
    "contracts/utils/PRBMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n// Copied from the PRBMath library\n// https://github.com/PaulRBerg/prb-math/blob/main/src/Common.sol\n\n/// @notice Calculates the square root of x using the Babylonian method.\n///\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n///\n/// Notes:\n/// - If x is not a perfect square, the result is rounded down.\n/// - Credits to OpenZeppelin for the explanations in comments below.\n///\n/// @param x The uint256 number for which to calculate the square root.\n/// @return result The result as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction sqrt(uint256 x) pure returns (uint256 result) {\n    if (x == 0) {\n        return 0;\n    }\n\n    // For our first guess, we calculate the biggest power of 2 which is smaller than the square root of x.\n    //\n    // We know that the \"msb\" (most significant bit) of x is a power of 2 such that we have:\n    //\n    // $$\n    // msb(x) <= x <= 2*msb(x)$\n    // $$\n    //\n    // We write $msb(x)$ as $2^k$, and we get:\n    //\n    // $$\n    // k = log_2(x)\n    // $$\n    //\n    // Thus, we can write the initial inequality as:\n    //\n    // $$\n    // 2^{log_2(x)} <= x <= 2*2^{log_2(x)+1} \\\\\n    // sqrt(2^k) <= sqrt(x) < sqrt(2^{k+1}) \\\\\n    // 2^{k/2} <= sqrt(x) < 2^{(k+1)/2} <= 2^{(k/2)+1}\n    // $$\n    //\n    // Consequently, $2^{log_2(x) /2} is a good first approximation of sqrt(x) with at least one correct bit.\n    uint256 xAux = uint256(x);\n    result = 1;\n    if (xAux >= 2**128) {\n        xAux >>= 128;\n        result <<= 64;\n    }\n    if (xAux >= 2**64) {\n        xAux >>= 64;\n        result <<= 32;\n    }\n    if (xAux >= 2**32) {\n        xAux >>= 32;\n        result <<= 16;\n    }\n    if (xAux >= 2**16) {\n        xAux >>= 16;\n        result <<= 8;\n    }\n    if (xAux >= 2**8) {\n        xAux >>= 8;\n        result <<= 4;\n    }\n    if (xAux >= 2**4) {\n        xAux >>= 4;\n        result <<= 2;\n    }\n    if (xAux >= 2**2) {\n        result <<= 1;\n    }\n\n    // At this point, `result` is an estimation with at least one bit of precision. We know the true value has at\n    // most 128 bits, since it is the square root of a uint256. Newton's method converges quadratically (precision\n    // doubles at every iteration). We thus need at most 7 iteration to turn our partial result with one bit of\n    // precision into the expected uint128 result.\n    unchecked {\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n\n        // If x is not a perfect square, round the result toward zero.\n        uint256 roundedResult = x / result;\n        if (result >= roundedResult) {\n            result = roundedResult;\n        }\n    }\n}\n"
    },
    "contracts/utils/StableMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n// Based on StableMath from Stability Labs Pty. Ltd.\n// https://github.com/mstable/mStable-contracts/blob/master/contracts/shared/StableMath.sol\n\nlibrary StableMath {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Scaling unit for use in specific calculations,\n     * where 1 * 10**18, or 1e18 represents a unit '1'\n     */\n    uint256 private constant FULL_SCALE = 1e18;\n\n    /***************************************\n                    Helpers\n    ****************************************/\n\n    /**\n     * @dev Adjust the scale of an integer\n     * @param to Decimals to scale to\n     * @param from Decimals to scale from\n     */\n    function scaleBy(\n        uint256 x,\n        uint256 to,\n        uint256 from\n    ) internal pure returns (uint256) {\n        if (to > from) {\n            x = x.mul(10**(to - from));\n        } else if (to < from) {\n            // slither-disable-next-line divide-before-multiply\n            x = x.div(10**(from - to));\n        }\n        return x;\n    }\n\n    /***************************************\n               Precise Arithmetic\n    ****************************************/\n\n    /**\n     * @dev Multiplies two precise units, and then truncates by the full scale\n     * @param x Left hand input to multiplication\n     * @param y Right hand input to multiplication\n     * @return Result after multiplying the two inputs and then dividing by the shared\n     *         scale unit\n     */\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulTruncateScale(x, y, FULL_SCALE);\n    }\n\n    /**\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\n     * @param x Left hand input to multiplication\n     * @param y Right hand input to multiplication\n     * @param scale Scale unit\n     * @return Result after multiplying the two inputs and then dividing by the shared\n     *         scale unit\n     */\n    function mulTruncateScale(\n        uint256 x,\n        uint256 y,\n        uint256 scale\n    ) internal pure returns (uint256) {\n        // e.g. assume scale = fullScale\n        // z = 10e18 * 9e17 = 9e36\n        uint256 z = x.mul(y);\n        // return 9e36 / 1e18 = 9e18\n        return z.div(scale);\n    }\n\n    /**\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\n     * @param x Left hand input to multiplication\n     * @param y Right hand input to multiplication\n     * @return Result after multiplying the two inputs and then dividing by the shared\n     *          scale unit, rounded up to the closest base unit.\n     */\n    function mulTruncateCeil(uint256 x, uint256 y)\n        internal\n        pure\n        returns (uint256)\n    {\n        // e.g. 8e17 * 17268172638 = 138145381104e17\n        uint256 scaled = x.mul(y);\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\n        uint256 ceil = scaled.add(FULL_SCALE.sub(1));\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\n        return ceil.div(FULL_SCALE);\n    }\n\n    /**\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\n     * @param x Left hand input to division\n     * @param y Right hand input to division\n     * @return Result after multiplying the left operand by the scale, and\n     *         executing the division on the right hand input.\n     */\n    function divPrecisely(uint256 x, uint256 y)\n        internal\n        pure\n        returns (uint256)\n    {\n        // e.g. 8e18 * 1e18 = 8e36\n        uint256 z = x.mul(FULL_SCALE);\n        // e.g. 8e36 / 10e18 = 8e17\n        return z.div(y);\n    }\n}\n"
    },
    "contracts/vault/OETHBaseVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { VaultAdmin } from \"./VaultAdmin.sol\";\n\n/**\n * @title OETH Base VaultAdmin Contract\n * @author Origin Protocol Inc\n */\ncontract OETHBaseVault is VaultAdmin {\n    constructor(address _weth) VaultAdmin(_weth) {}\n}\n"
    },
    "contracts/vault/OETHPlumeVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { VaultAdmin } from \"./VaultAdmin.sol\";\n\n/**\n * @title OETH Plume VaultAdmin Contract\n * @author Origin Protocol Inc\n */\ncontract OETHPlumeVault is VaultAdmin {\n    constructor(address _weth) VaultAdmin(_weth) {}\n\n    // @inheritdoc VaultAdmin\n    function _mint(\n        address,\n        uint256 _amount,\n        uint256\n    ) internal virtual {\n        // Only Strategist or Governor can mint using the Vault for now.\n        // This allows the strateigst to fund the Vault with WETH when\n        // removing liquidi from wOETH strategy.\n        require(\n            msg.sender == strategistAddr || isGovernor(),\n            \"Caller is not the Strategist or Governor\"\n        );\n\n        super._mint(_amount);\n    }\n}\n"
    },
    "contracts/vault/OETHVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { VaultAdmin } from \"./VaultAdmin.sol\";\n\n/**\n * @title OETH VaultAdmin Contract\n * @author Origin Protocol Inc\n */\ncontract OETHVault is VaultAdmin {\n    constructor(address _weth) VaultAdmin(_weth) {}\n}\n"
    },
    "contracts/vault/OSVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { VaultAdmin } from \"./VaultAdmin.sol\";\n\n/**\n * @title Origin Sonic VaultAdmin contract on Sonic\n * @author Origin Protocol Inc\n */\ncontract OSVault is VaultAdmin {\n    constructor(address _wS) VaultAdmin(_wS) {}\n}\n"
    },
    "contracts/vault/OUSDVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { VaultAdmin } from \"./VaultAdmin.sol\";\n\n/**\n * @title OUSD VaultAdmin Contract\n * @author Origin Protocol Inc\n */\ncontract OUSDVault is VaultAdmin {\n    constructor(address _usdc) VaultAdmin(_usdc) {}\n}\n"
    },
    "contracts/vault/VaultAdmin.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OToken VaultAdmin contract\n * @notice The VaultAdmin contract makes configuration and admin calls on the vault.\n * @author Origin Protocol Inc\n */\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./VaultCore.sol\";\n\nabstract contract VaultAdmin is VaultCore {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n    using SafeCast for uint256;\n\n    /**\n     * @dev Verifies that the caller is the Governor or Strategist.\n     */\n    modifier onlyGovernorOrStrategist() {\n        require(\n            msg.sender == strategistAddr || isGovernor(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    constructor(address _asset) VaultCore(_asset) {}\n\n    /***************************************\n                 Configuration\n    ****************************************/\n    /**\n     * @notice Set a buffer of asset to keep in the Vault to handle most\n     * redemptions without needing to spend gas unwinding asset from a Strategy.\n     * @param _vaultBuffer Percentage using 18 decimals. 100% = 1e18.\n     */\n    function setVaultBuffer(uint256 _vaultBuffer)\n        external\n        onlyGovernorOrStrategist\n    {\n        require(_vaultBuffer <= 1e18, \"Invalid value\");\n        vaultBuffer = _vaultBuffer;\n        emit VaultBufferUpdated(_vaultBuffer);\n    }\n\n    /**\n     * @notice Sets the minimum amount of OTokens in a mint to trigger an\n     * automatic allocation of funds afterwords.\n     * @param _threshold OToken amount with 18 fixed decimals.\n     */\n    function setAutoAllocateThreshold(uint256 _threshold)\n        external\n        onlyGovernor\n    {\n        autoAllocateThreshold = _threshold;\n        emit AllocateThresholdUpdated(_threshold);\n    }\n\n    /**\n     * @notice Set a minimum amount of OTokens in a mint or redeem that triggers a\n     * rebase\n     * @param _threshold OToken amount with 18 fixed decimals.\n     */\n    function setRebaseThreshold(uint256 _threshold) external onlyGovernor {\n        rebaseThreshold = _threshold;\n        emit RebaseThresholdUpdated(_threshold);\n    }\n\n    /**\n     * @notice Set address of Strategist\n     * @param _address Address of Strategist\n     */\n    function setStrategistAddr(address _address) external onlyGovernor {\n        strategistAddr = _address;\n        emit StrategistUpdated(_address);\n    }\n\n    /**\n     * @notice Set the default Strategy for asset, i.e. the one which\n     * the asset will be automatically allocated to and withdrawn from\n     * @param _strategy Address of the Strategy\n     */\n    function setDefaultStrategy(address _strategy)\n        external\n        onlyGovernorOrStrategist\n    {\n        emit DefaultStrategyUpdated(_strategy);\n        // If its a zero address being passed for the strategy we are removing\n        // the default strategy\n        if (_strategy != address(0)) {\n            // Make sure the strategy meets some criteria\n            require(strategies[_strategy].isSupported, \"Strategy not approved\");\n            require(\n                IStrategy(_strategy).supportsAsset(asset),\n                \"Asset not supported by Strategy\"\n            );\n        }\n        defaultStrategy = _strategy;\n    }\n\n    /**\n     * @notice Changes the async withdrawal claim period for OETH & superOETHb\n     * @param _delay Delay period (should be between 10 mins to 7 days).\n     *          Set to 0 to disable async withdrawals\n     */\n    function setWithdrawalClaimDelay(uint256 _delay) external onlyGovernor {\n        require(\n            _delay == 0 || (_delay >= 10 minutes && _delay <= 15 days),\n            \"Invalid claim delay period\"\n        );\n        withdrawalClaimDelay = _delay;\n        emit WithdrawalClaimDelayUpdated(_delay);\n    }\n\n    // slither-disable-start reentrancy-no-eth\n    /**\n     * @notice Set a yield streaming max rate. This spreads yield over\n     * time if it is above the max rate. This is a per rebase APR which\n     * due to compounding differs from the yearly APR. Governance should\n     * consider this fact when picking a desired APR\n     * @param apr in 1e18 notation. 3 * 1e18 = 3% APR\n     */\n    function setRebaseRateMax(uint256 apr) external onlyGovernorOrStrategist {\n        // The old yield will be at the old rate\n        _rebase();\n        // Change the rate\n        uint256 newPerSecond = apr / 100 / 365 days;\n        require(newPerSecond <= MAX_REBASE_PER_SECOND, \"Rate too high\");\n        rebasePerSecondMax = newPerSecond.toUint64();\n        emit RebasePerSecondMaxChanged(newPerSecond);\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    // slither-disable-start reentrancy-no-eth\n    /**\n     * @notice Set the drip duration period\n     * @param _dripDuration Time in seconds to target a constant yield rate\n     */\n    function setDripDuration(uint256 _dripDuration)\n        external\n        onlyGovernorOrStrategist\n    {\n        // The old yield will be at the old rate\n        _rebase();\n        dripDuration = _dripDuration.toUint64();\n        emit DripDurationChanged(_dripDuration);\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /***************************************\n                Strategy Config\n    ****************************************/\n\n    /**\n     * @notice Add a strategy to the Vault.\n     * @param _addr Address of the strategy to add\n     */\n    function approveStrategy(address _addr) external onlyGovernor {\n        require(!strategies[_addr].isSupported, \"Strategy already approved\");\n        require(\n            IStrategy(_addr).supportsAsset(asset),\n            \"Asset not supported by Strategy\"\n        );\n        strategies[_addr] = Strategy({ isSupported: true, _deprecated: 0 });\n        allStrategies.push(_addr);\n        emit StrategyApproved(_addr);\n    }\n\n    /**\n     * @notice Remove a strategy from the Vault.\n     * @param _addr Address of the strategy to remove\n     */\n\n    function removeStrategy(address _addr) external onlyGovernor {\n        require(strategies[_addr].isSupported, \"Strategy not approved\");\n        require(defaultStrategy != _addr, \"Strategy is default for asset\");\n\n        // Initialize strategyIndex with out of bounds result so function will\n        // revert if no valid index found\n        uint256 stratCount = allStrategies.length;\n        uint256 strategyIndex = stratCount;\n        for (uint256 i = 0; i < stratCount; ++i) {\n            if (allStrategies[i] == _addr) {\n                strategyIndex = i;\n                break;\n            }\n        }\n\n        if (strategyIndex < stratCount) {\n            allStrategies[strategyIndex] = allStrategies[stratCount - 1];\n            allStrategies.pop();\n\n            // Mark the strategy as not supported\n            strategies[_addr].isSupported = false;\n            isMintWhitelistedStrategy[_addr] = false;\n\n            // Withdraw all asset\n            IStrategy strategy = IStrategy(_addr);\n            strategy.withdrawAll();\n\n            // 1e13 for 18 decimals. And 1e1(10) for 6 decimals\n            uint256 maxDustBalance = uint256(1e13).scaleBy(assetDecimals, 18);\n\n            /*\n             * Some strategies are not able to withdraw all of their funds in a synchronous call.\n             * Prevent the possible accidental removal of such strategies before their funds are withdrawn.\n             */\n            require(\n                strategy.checkBalance(asset) < maxDustBalance,\n                \"Strategy has funds\"\n            );\n            emit StrategyRemoved(_addr);\n        }\n    }\n\n    /**\n     * @notice Adds a strategy to the mint whitelist.\n     *          Reverts if strategy isn't approved on Vault.\n     * @param strategyAddr Strategy address\n     */\n    function addStrategyToMintWhitelist(address strategyAddr)\n        external\n        onlyGovernor\n    {\n        require(strategies[strategyAddr].isSupported, \"Strategy not approved\");\n\n        require(\n            !isMintWhitelistedStrategy[strategyAddr],\n            \"Already whitelisted\"\n        );\n\n        isMintWhitelistedStrategy[strategyAddr] = true;\n\n        emit StrategyAddedToMintWhitelist(strategyAddr);\n    }\n\n    /**\n     * @notice Removes a strategy from the mint whitelist.\n     * @param strategyAddr Strategy address\n     */\n    function removeStrategyFromMintWhitelist(address strategyAddr)\n        external\n        onlyGovernor\n    {\n        // Intentionally skipping `strategies.isSupported` check since\n        // we may wanna remove an address even after removing the strategy\n\n        require(isMintWhitelistedStrategy[strategyAddr], \"Not whitelisted\");\n\n        isMintWhitelistedStrategy[strategyAddr] = false;\n\n        emit StrategyRemovedFromMintWhitelist(strategyAddr);\n    }\n\n    /***************************************\n                Strategies\n    ****************************************/\n\n    /**\n     * @notice Deposit multiple asset from the vault into the strategy.\n     * @param _strategyToAddress Address of the Strategy to deposit asset into.\n     * @param _assets Array of asset address that will be deposited into the strategy.\n     * @param _amounts Array of amounts of each corresponding asset to deposit.\n     */\n    function depositToStrategy(\n        address _strategyToAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external onlyGovernorOrStrategist nonReentrant {\n        _depositToStrategy(_strategyToAddress, _assets, _amounts);\n    }\n\n    function _depositToStrategy(\n        address _strategyToAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) internal virtual {\n        require(\n            strategies[_strategyToAddress].isSupported,\n            \"Invalid to Strategy\"\n        );\n        require(\n            _assets.length == 1 && _amounts.length == 1 && _assets[0] == asset,\n            \"Only asset is supported\"\n        );\n\n        // Check the there is enough asset to transfer once the backing\n        // asset reserved for the withdrawal queue is accounted for\n        require(\n            _amounts[0] <= _assetAvailable(),\n            \"Not enough assets available\"\n        );\n\n        // Send required amount of funds to the strategy\n        IERC20(asset).safeTransfer(_strategyToAddress, _amounts[0]);\n\n        // Deposit all the funds that have been sent to the strategy\n        IStrategy(_strategyToAddress).depositAll();\n    }\n\n    /**\n     * @notice Withdraw multiple asset from the strategy to the vault.\n     * @param _strategyFromAddress Address of the Strategy to withdraw asset from.\n     * @param _assets Array of asset address that will be withdrawn from the strategy.\n     * @param _amounts Array of amounts of each corresponding asset to withdraw.\n     */\n    function withdrawFromStrategy(\n        address _strategyFromAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external onlyGovernorOrStrategist nonReentrant {\n        _withdrawFromStrategy(\n            address(this),\n            _strategyFromAddress,\n            _assets,\n            _amounts\n        );\n    }\n\n    /**\n     * @param _recipient can either be a strategy or the Vault\n     */\n    function _withdrawFromStrategy(\n        address _recipient,\n        address _strategyFromAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) internal virtual {\n        require(\n            strategies[_strategyFromAddress].isSupported,\n            \"Invalid from Strategy\"\n        );\n        require(_assets.length == _amounts.length, \"Parameter length mismatch\");\n\n        uint256 assetCount = _assets.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            // Withdraw from Strategy to the recipient\n            IStrategy(_strategyFromAddress).withdraw(\n                _recipient,\n                _assets[i],\n                _amounts[i]\n            );\n        }\n\n        _addWithdrawalQueueLiquidity();\n    }\n\n    /**\n     * @notice Sets the maximum allowable difference between\n     * total supply and asset' value.\n     */\n    function setMaxSupplyDiff(uint256 _maxSupplyDiff) external onlyGovernor {\n        maxSupplyDiff = _maxSupplyDiff;\n        emit MaxSupplyDiffChanged(_maxSupplyDiff);\n    }\n\n    /**\n     * @notice Sets the trusteeAddress that can receive a portion of yield.\n     *      Setting to the zero address disables this feature.\n     */\n    function setTrusteeAddress(address _address) external onlyGovernor {\n        trusteeAddress = _address;\n        emit TrusteeAddressChanged(_address);\n    }\n\n    /**\n     * @notice Sets the TrusteeFeeBps to the percentage of yield that should be\n     *      received in basis points.\n     */\n    function setTrusteeFeeBps(uint256 _basis) external onlyGovernor {\n        require(_basis <= 5000, \"basis cannot exceed 50%\");\n        trusteeFeeBps = _basis;\n        emit TrusteeFeeBpsChanged(_basis);\n    }\n\n    /***************************************\n                    Pause\n    ****************************************/\n\n    /**\n     * @notice Set the deposit paused flag to true to prevent rebasing.\n     */\n    function pauseRebase() external onlyGovernorOrStrategist {\n        rebasePaused = true;\n        emit RebasePaused();\n    }\n\n    /**\n     * @notice Set the deposit paused flag to true to allow rebasing.\n     */\n    function unpauseRebase() external onlyGovernorOrStrategist {\n        rebasePaused = false;\n        emit RebaseUnpaused();\n    }\n\n    /**\n     * @notice Set the deposit paused flag to true to prevent capital movement.\n     */\n    function pauseCapital() external onlyGovernorOrStrategist {\n        capitalPaused = true;\n        emit CapitalPaused();\n    }\n\n    /**\n     * @notice Set the deposit paused flag to false to enable capital movement.\n     */\n    function unpauseCapital() external onlyGovernorOrStrategist {\n        capitalPaused = false;\n        emit CapitalUnpaused();\n    }\n\n    /***************************************\n                    Utils\n    ****************************************/\n\n    /**\n     * @notice Transfer token to governor. Intended for recovering tokens stuck in\n     *      contract, i.e. mistaken sends.\n     * @param _asset Address for the asset\n     * @param _amount Amount of the asset to transfer\n     */\n    function transferToken(address _asset, uint256 _amount)\n        external\n        onlyGovernor\n    {\n        require(asset != _asset, \"Only unsupported asset\");\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /***************************************\n             Strategies Admin\n    ****************************************/\n\n    /**\n     * @notice Withdraws all asset from the strategy and sends asset to the Vault.\n     * @param _strategyAddr Strategy address.\n     */\n    function withdrawAllFromStrategy(address _strategyAddr)\n        external\n        onlyGovernorOrStrategist\n    {\n        _withdrawAllFromStrategy(_strategyAddr);\n    }\n\n    function _withdrawAllFromStrategy(address _strategyAddr) internal virtual {\n        require(\n            strategies[_strategyAddr].isSupported,\n            \"Strategy is not supported\"\n        );\n        IStrategy strategy = IStrategy(_strategyAddr);\n        strategy.withdrawAll();\n        _addWithdrawalQueueLiquidity();\n    }\n\n    /**\n     * @notice Withdraws all asset from all the strategies and sends asset to the Vault.\n     */\n    function withdrawAllFromStrategies() external onlyGovernorOrStrategist {\n        _withdrawAllFromStrategies();\n    }\n\n    function _withdrawAllFromStrategies() internal virtual {\n        uint256 stratCount = allStrategies.length;\n        for (uint256 i = 0; i < stratCount; ++i) {\n            IStrategy(allStrategies[i]).withdrawAll();\n        }\n        _addWithdrawalQueueLiquidity();\n    }\n}\n"
    },
    "contracts/vault/VaultCore.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OToken VaultCore contract\n * @notice The Vault contract stores asset. On a deposit, OTokens will be minted\n           and sent to the depositor. On a withdrawal, OTokens will be burned and\n           asset will be sent to the withdrawer. The Vault accepts deposits of\n           interest from yield bearing strategies which will modify the supply\n           of OTokens.\n * @author Origin Protocol Inc\n */\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { StableMath } from \"../utils/StableMath.sol\";\n\nimport \"./VaultInitializer.sol\";\n\nabstract contract VaultCore is VaultInitializer {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    /**\n     * @dev Verifies that the rebasing is not paused.\n     */\n    modifier whenNotRebasePaused() {\n        require(!rebasePaused, \"Rebasing paused\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the deposits are not paused.\n     */\n    modifier whenNotCapitalPaused() {\n        require(!capitalPaused, \"Capital paused\");\n        _;\n    }\n\n    constructor(address _asset) VaultInitializer(_asset) {}\n\n    ////////////////////////////////////////////////////\n    ///                 MINT / BURN                  ///\n    ////////////////////////////////////////////////////\n    /**\n     * @notice Deposit a supported asset and mint OTokens.\n     * @dev Deprecated: use `mint(uint256 _amount)` instead.\n     * @dev Deprecated: param _asset Address of the asset being deposited\n     * @param _amount Amount of the asset being deposited\n     * @dev Deprecated: param _minimumOusdAmount Minimum OTokens to mint\n     */\n    function mint(\n        address,\n        uint256 _amount,\n        uint256\n    ) external whenNotCapitalPaused nonReentrant {\n        _mint(_amount);\n    }\n\n    /**\n     * @notice Deposit a supported asset and mint OTokens.\n     * @param _amount Amount of the asset being deposited\n     */\n    function mint(uint256 _amount) external whenNotCapitalPaused nonReentrant {\n        _mint(_amount);\n    }\n\n    // slither-disable-start reentrancy-no-eth\n    /**\n     * @dev Deposit a supported asset and mint OTokens.\n     * @param _amount Amount of the asset being deposited\n     */\n    function _mint(uint256 _amount) internal virtual {\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        // Scale amount to 18 decimals\n        uint256 scaledAmount = _amount.scaleBy(18, assetDecimals);\n\n        emit Mint(msg.sender, scaledAmount);\n\n        // Rebase must happen before any transfers occur.\n        if (!rebasePaused && scaledAmount >= rebaseThreshold) {\n            _rebase();\n        }\n\n        // Mint oTokens\n        oToken.mint(msg.sender, scaledAmount);\n\n        IERC20(asset).safeTransferFrom(msg.sender, address(this), _amount);\n\n        // Give priority to the withdrawal queue for the new asset liquidity\n        _addWithdrawalQueueLiquidity();\n\n        // Auto-allocate if necessary\n        if (scaledAmount >= autoAllocateThreshold) {\n            _allocate();\n        }\n    }\n\n    // slither-disable-end reentrancy-no-eth\n\n    /**\n     * @notice Mint OTokens for an allowed Strategy\n     * @param _amount Amount of OToken to mint\n     *\n     * Notice: can't use `nonReentrant` modifier since the `mint` function can\n     * call `allocate`, and that can trigger an AMO strategy to call this function\n     * while the execution of the `mint` has not yet completed -> causing a `nonReentrant` collision.\n     *\n     * Also important to understand is that this is a limitation imposed by the test suite.\n     * Production / mainnet contracts should never be configured in a way where mint/redeem functions\n     * that are moving funds between the Vault and end user wallets can influence strategies\n     * utilizing this function.\n     */\n    function mintForStrategy(uint256 _amount)\n        external\n        virtual\n        whenNotCapitalPaused\n    {\n        require(\n            strategies[msg.sender].isSupported == true,\n            \"Unsupported strategy\"\n        );\n        require(\n            isMintWhitelistedStrategy[msg.sender] == true,\n            \"Not whitelisted strategy\"\n        );\n\n        emit Mint(msg.sender, _amount);\n        // Mint matching amount of OTokens\n        oToken.mint(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Burn OTokens for an allowed Strategy\n     * @param _amount Amount of OToken to burn\n     *\n     * @dev Notice: can't use `nonReentrant` modifier since the `redeem` function could\n     * require withdrawal on an AMO strategy and that one can call `burnForStrategy`\n     * while the execution of the `redeem` has not yet completed -> causing a `nonReentrant` collision.\n     *\n     * Also important to understand is that this is a limitation imposed by the test suite.\n     * Production / mainnet contracts should never be configured in a way where mint/redeem functions\n     * that are moving funds between the Vault and end user wallets can influence strategies\n     * utilizing this function.\n     */\n    function burnForStrategy(uint256 _amount)\n        external\n        virtual\n        whenNotCapitalPaused\n    {\n        require(\n            strategies[msg.sender].isSupported == true,\n            \"Unsupported strategy\"\n        );\n        require(\n            isMintWhitelistedStrategy[msg.sender] == true,\n            \"Not whitelisted strategy\"\n        );\n\n        emit Redeem(msg.sender, _amount);\n\n        // Burn OTokens\n        oToken.burn(msg.sender, _amount);\n    }\n\n    ////////////////////////////////////////////////////\n    ///               ASYNC WITHDRAWALS              ///\n    ////////////////////////////////////////////////////\n    /**\n     * @notice Request an asynchronous withdrawal of asset in exchange for OToken.\n     * The OToken is burned on request and the asset is transferred to the withdrawer on claim.\n     * This request can be claimed once the withdrawal queue's `claimable` amount\n     * is greater than or equal this request's `queued` amount.\n     * There is a minimum of 10 minutes before a request can be claimed. After that, the request just needs\n     * enough asset liquidity in the Vault to satisfy all the outstanding requests to that point in the queue.\n     * OToken is converted to asset at 1:1.\n     * @param _amount Amount of OToken to burn.\n     * @return requestId Unique ID for the withdrawal request\n     * @return queued Cumulative total of all asset queued including already claimed requests.\n     */\n    function requestWithdrawal(uint256 _amount)\n        external\n        virtual\n        whenNotCapitalPaused\n        nonReentrant\n        returns (uint256 requestId, uint256 queued)\n    {\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(withdrawalClaimDelay > 0, \"Async withdrawals not enabled\");\n\n        // The check that the requester has enough OToken is done in to later burn call\n\n        requestId = withdrawalQueueMetadata.nextWithdrawalIndex;\n        queued =\n            withdrawalQueueMetadata.queued +\n            _amount.scaleBy(assetDecimals, 18);\n\n        // Store the next withdrawal request\n        withdrawalQueueMetadata.nextWithdrawalIndex = SafeCast.toUint128(\n            requestId + 1\n        );\n        // Store the updated queued amount which reserves asset in the withdrawal queue\n        // and reduces the vault's total asset\n        withdrawalQueueMetadata.queued = SafeCast.toUint128(queued);\n        // Store the user's withdrawal request\n        // `queued` is in asset decimals, while `amount` is in OToken decimals (18)\n        withdrawalRequests[requestId] = WithdrawalRequest({\n            withdrawer: msg.sender,\n            claimed: false,\n            timestamp: uint40(block.timestamp),\n            amount: SafeCast.toUint128(_amount),\n            queued: SafeCast.toUint128(queued)\n        });\n\n        // Burn the user's OToken\n        oToken.burn(msg.sender, _amount);\n\n        // Prevent withdrawal if the vault is solvent by more than the allowed percentage\n        _postRedeem(_amount);\n\n        emit WithdrawalRequested(msg.sender, requestId, _amount, queued);\n    }\n\n    // slither-disable-start reentrancy-no-eth\n    /**\n     * @notice Claim a previously requested withdrawal once it is claimable.\n     * This request can be claimed once the withdrawal queue's `claimable` amount\n     * is greater than or equal this request's `queued` amount and 10 minutes has passed.\n     * If the requests is not claimable, the transaction will revert with `Queue pending liquidity`.\n     * If the request is not older than 10 minutes, the transaction will revert with `Claim delay not met`.\n     * OToken is converted to asset at 1:1.\n     * @param _requestId Unique ID for the withdrawal request\n     * @return amount Amount of asset transferred to the withdrawer\n     */\n    function claimWithdrawal(uint256 _requestId)\n        external\n        virtual\n        whenNotCapitalPaused\n        nonReentrant\n        returns (uint256 amount)\n    {\n        // Try and get more liquidity if there is not enough available\n        if (\n            withdrawalRequests[_requestId].queued >\n            withdrawalQueueMetadata.claimable\n        ) {\n            // Add any asset to the withdrawal queue\n            // this needs to remain here as:\n            //  - Vault can be funded and `addWithdrawalQueueLiquidity` is not externally called\n            //  - funds can be withdrawn from a strategy\n            //\n            // Those funds need to be added to withdrawal queue liquidity\n            _addWithdrawalQueueLiquidity();\n        }\n\n        // Scale amount to asset decimals\n        amount = _claimWithdrawal(_requestId);\n\n        // transfer asset from the vault to the withdrawer\n        IERC20(asset).safeTransfer(msg.sender, amount);\n\n        // Prevent insolvency\n        _postRedeem(amount.scaleBy(18, assetDecimals));\n    }\n\n    // slither-disable-end reentrancy-no-eth\n    /**\n     * @notice Claim a previously requested withdrawals once they are claimable.\n     * This requests can be claimed once the withdrawal queue's `claimable` amount\n     * is greater than or equal each request's `queued` amount and 10 minutes has passed.\n     * If one of the requests is not claimable, the whole transaction will revert with `Queue pending liquidity`.\n     * If one of the requests is not older than 10 minutes,\n     * the whole transaction will revert with `Claim delay not met`.\n     * @param _requestIds Unique ID of each withdrawal request\n     * @return amounts Amount of asset received for each request\n     * @return totalAmount Total amount of asset transferred to the withdrawer\n     */\n    function claimWithdrawals(uint256[] calldata _requestIds)\n        external\n        virtual\n        whenNotCapitalPaused\n        nonReentrant\n        returns (uint256[] memory amounts, uint256 totalAmount)\n    {\n        // Add any asset to the withdrawal queue\n        // this needs to remain here as:\n        //  - Vault can be funded and `addWithdrawalQueueLiquidity` is not externally called\n        //  - funds can be withdrawn from a strategy\n        //\n        // Those funds need to be added to withdrawal queue liquidity\n        _addWithdrawalQueueLiquidity();\n\n        amounts = new uint256[](_requestIds.length);\n        for (uint256 i; i < _requestIds.length; ++i) {\n            // Scale all amounts to asset decimals, thus totalAmount is also in asset decimals\n            amounts[i] = _claimWithdrawal(_requestIds[i]);\n            totalAmount += amounts[i];\n        }\n\n        // transfer all the claimed asset from the vault to the withdrawer\n        IERC20(asset).safeTransfer(msg.sender, totalAmount);\n\n        // Prevent insolvency\n        _postRedeem(totalAmount.scaleBy(18, assetDecimals));\n\n        return (amounts, totalAmount);\n    }\n\n    function _claimWithdrawal(uint256 requestId)\n        internal\n        returns (uint256 amount)\n    {\n        require(withdrawalClaimDelay > 0, \"Async withdrawals not enabled\");\n\n        // Load the structs from storage into memory\n        WithdrawalRequest memory request = withdrawalRequests[requestId];\n        WithdrawalQueueMetadata memory queue = withdrawalQueueMetadata;\n\n        require(\n            request.timestamp + withdrawalClaimDelay <= block.timestamp,\n            \"Claim delay not met\"\n        );\n        // If there isn't enough reserved liquidity in the queue to claim\n        require(request.queued <= queue.claimable, \"Queue pending liquidity\");\n        require(request.withdrawer == msg.sender, \"Not requester\");\n        require(request.claimed == false, \"Already claimed\");\n\n        // Store the request as claimed\n        withdrawalRequests[requestId].claimed = true;\n        // Store the updated claimed amount\n        withdrawalQueueMetadata.claimed =\n            queue.claimed +\n            SafeCast.toUint128(\n                StableMath.scaleBy(request.amount, assetDecimals, 18)\n            );\n\n        emit WithdrawalClaimed(msg.sender, requestId, request.amount);\n\n        return StableMath.scaleBy(request.amount, assetDecimals, 18);\n    }\n\n    function _postRedeem(uint256 _amount) internal {\n        // Until we can prove that we won't affect the prices of our asset\n        // by withdrawing them, this should be here.\n        // It's possible that a strategy was off on its asset total, perhaps\n        // a reward token sold for more or for less than anticipated.\n        uint256 totalUnits = 0;\n        if (_amount >= rebaseThreshold && !rebasePaused) {\n            totalUnits = _rebase();\n        } else {\n            totalUnits = _totalValue();\n        }\n\n        // Check that the OTokens are backed by enough asset\n        if (maxSupplyDiff > 0) {\n            // If there are more outstanding withdrawal requests than asset in the vault and strategies\n            // then the available asset will be negative and totalUnits will be rounded up to zero.\n            // As we don't know the exact shortfall amount, we will reject all redeem and withdrawals\n            require(totalUnits > 0, \"Too many outstanding requests\");\n\n            // Allow a max difference of maxSupplyDiff% between\n            // asset value and OUSD total supply\n            uint256 diff = oToken.totalSupply().divPrecisely(totalUnits);\n            require(\n                (diff > 1e18 ? diff - 1e18 : 1e18 - diff) <= maxSupplyDiff,\n                \"Backing supply liquidity error\"\n            );\n        }\n    }\n\n    /**\n     * @notice Allocate unallocated funds on Vault to strategies.\n     */\n    function allocate() external virtual whenNotCapitalPaused nonReentrant {\n        // Add any unallocated asset to the withdrawal queue first\n        _addWithdrawalQueueLiquidity();\n\n        _allocate();\n    }\n\n    /**\n     * @dev Allocate asset (eg. WETH or USDC) to the default asset strategy\n     *          if there is excess to the Vault buffer.\n     * This is called from either `mint` or `allocate` and assumes `_addWithdrawalQueueLiquidity`\n     * has been called before this function.\n     */\n    function _allocate() internal virtual {\n        // No need to do anything if no default strategy for asset\n        address depositStrategyAddr = defaultStrategy;\n        if (depositStrategyAddr == address(0)) return;\n\n        uint256 assetAvailableInVault = _assetAvailable();\n        // No need to do anything if there isn't any asset in the vault to allocate\n        if (assetAvailableInVault == 0) return;\n\n        // Calculate the target buffer for the vault using the total supply\n        uint256 totalSupply = oToken.totalSupply();\n        // Scaled to asset decimals\n        uint256 targetBuffer = totalSupply.mulTruncate(vaultBuffer).scaleBy(\n            assetDecimals,\n            18\n        );\n\n        // If available asset in the Vault is below or equal the target buffer then there's nothing to allocate\n        if (assetAvailableInVault <= targetBuffer) return;\n\n        // The amount of asset to allocate to the default strategy\n        uint256 allocateAmount = assetAvailableInVault - targetBuffer;\n\n        IStrategy strategy = IStrategy(depositStrategyAddr);\n        // Transfer asset to the strategy and call the strategy's deposit function\n        IERC20(asset).safeTransfer(address(strategy), allocateAmount);\n        strategy.deposit(asset, allocateAmount);\n\n        emit AssetAllocated(asset, depositStrategyAddr, allocateAmount);\n    }\n\n    /**\n     * @notice Calculate the total value of asset held by the Vault and all\n     *      strategies and update the supply of OTokens.\n     */\n    function rebase() external virtual nonReentrant {\n        _rebase();\n    }\n\n    /**\n     * @dev Calculate the total value of asset held by the Vault and all\n     *      strategies and update the supply of OTokens, optionally sending a\n     *      portion of the yield to the trustee.\n     * @return totalUnits Total balance of Vault in units\n     */\n    function _rebase() internal whenNotRebasePaused returns (uint256) {\n        uint256 supply = oToken.totalSupply();\n        uint256 vaultValue = _totalValue();\n        // If no supply yet, do not rebase\n        if (supply == 0) {\n            return vaultValue;\n        }\n\n        // Calculate yield and new supply\n        (uint256 yield, uint256 targetRate) = _nextYield(supply, vaultValue);\n        uint256 newSupply = supply + yield;\n        // Only rebase upwards and if we have enough backing funds\n        if (newSupply <= supply || newSupply > vaultValue) {\n            return vaultValue;\n        }\n\n        rebasePerSecondTarget = uint64(_min(targetRate, type(uint64).max));\n        lastRebase = uint64(block.timestamp); // Intentional cast\n\n        // Fee collection on yield\n        address _trusteeAddress = trusteeAddress; // gas savings\n        uint256 fee = 0;\n        if (_trusteeAddress != address(0)) {\n            fee = (yield * trusteeFeeBps) / 1e4;\n            if (fee > 0) {\n                require(fee < yield, \"Fee must not be greater than yield\");\n                oToken.mint(_trusteeAddress, fee);\n            }\n        }\n        emit YieldDistribution(_trusteeAddress, yield, fee);\n\n        // Only ratchet OToken supply upwards\n        // Final check uses latest totalSupply\n        if (newSupply > oToken.totalSupply()) {\n            oToken.changeSupply(newSupply);\n        }\n        return vaultValue;\n    }\n\n    /**\n     * @notice Calculates the amount that would rebase at next rebase.\n     * This is before any fees.\n     * @return yield amount of expected yield\n     */\n    function previewYield() external view returns (uint256 yield) {\n        (yield, ) = _nextYield(oToken.totalSupply(), _totalValue());\n        return yield;\n    }\n\n    /**\n     * @dev Calculates the amount that would rebase at next rebase.\n     *      See this Readme for detailed explanation:\n     *      contracts/contracts/vault/README - Yield Limits.md\n     */\n    function _nextYield(uint256 supply, uint256 vaultValue)\n        internal\n        view\n        virtual\n        returns (uint256 yield, uint256 targetRate)\n    {\n        uint256 nonRebasing = oToken.nonRebasingSupply();\n        uint256 rebasing = supply - nonRebasing;\n        uint256 elapsed = block.timestamp - lastRebase;\n        targetRate = rebasePerSecondTarget;\n\n        if (\n            elapsed == 0 || // Yield only once per block.\n            rebasing == 0 || // No yield if there are no rebasing tokens to give it to.\n            supply > vaultValue || // No yield if we do not have yield to give.\n            block.timestamp >= type(uint64).max // No yield if we are too far in the future to calculate it correctly.\n        ) {\n            return (0, targetRate);\n        }\n\n        // Start with the full difference available\n        yield = vaultValue - supply;\n\n        // Cap via optional automatic duration smoothing\n        uint256 _dripDuration = dripDuration;\n        if (_dripDuration > 1) {\n            // If we are able to sustain an increased drip rate for\n            // double the duration, then increase the target drip rate\n            targetRate = _max(targetRate, yield / (_dripDuration * 2));\n            // If we cannot sustain the target rate any more,\n            // then rebase what we can, and reduce the target\n            targetRate = _min(targetRate, yield / _dripDuration);\n            // drip at the new target rate\n            yield = _min(yield, targetRate * elapsed);\n        }\n\n        // Cap per second. elapsed is not 1e18 denominated\n        yield = _min(yield, (rebasing * elapsed * rebasePerSecondMax) / 1e18);\n\n        // Cap at a hard max per rebase, to avoid long durations resulting in huge rebases\n        yield = _min(yield, (rebasing * MAX_REBASE) / 1e18);\n\n        return (yield, targetRate);\n    }\n\n    /**\n     * @notice Determine the total value of asset held by the vault and its\n     *         strategies.\n     * @return value Total value in USD/ETH (1e18)\n     */\n    function totalValue() external view virtual returns (uint256 value) {\n        value = _totalValue();\n    }\n\n    /**\n     * @dev Internal Calculate the total value of the asset held by the\n     *          vault and its strategies.\n     * @dev The total value of all WETH held by the vault and all its strategies\n     *          less any WETH that is reserved for the withdrawal queue.\n     *          If there is not enough WETH in the vault and all strategies to cover\n     *          all outstanding withdrawal requests then return a total value of 0.\n     * @return value Total value in USD/ETH (1e18)\n     */\n    function _totalValue() internal view virtual returns (uint256 value) {\n        // As asset is the only asset, just return the asset balance\n        value = _checkBalance(asset).scaleBy(18, assetDecimals);\n    }\n\n    /**\n     * @notice Get the balance of an asset held in Vault and all strategies.\n     * @param _asset Address of asset\n     * @return uint256 Balance of asset in decimals of asset\n     */\n    function checkBalance(address _asset) external view returns (uint256) {\n        return _checkBalance(_asset);\n    }\n\n    /**\n     * @notice Get the balance of an asset held in Vault and all strategies.\n     * @dev Get the balance of an asset held in Vault and all strategies\n     * less any asset that is reserved for the withdrawal queue.\n     * BaseAsset is the only asset that can return a non-zero balance.\n     * All other asset will return 0 even if there is some dust amounts left in the Vault.\n     * For example, there is 1 wei left of stETH (or USDC) in the OETH (or OUSD) Vault but\n     * will return 0 in this function.\n     *\n     * If there is not enough asset in the vault and all strategies to cover all outstanding\n     * withdrawal requests then return a asset balance of 0\n     * @param _asset Address of asset\n     * @return balance Balance of asset in decimals of asset\n     */\n    function _checkBalance(address _asset)\n        internal\n        view\n        virtual\n        returns (uint256 balance)\n    {\n        if (_asset != asset) return 0;\n\n        // Get the asset in the vault and the strategies\n        IERC20 asset = IERC20(_asset);\n        balance = asset.balanceOf(address(this));\n        uint256 stratCount = allStrategies.length;\n        for (uint256 i = 0; i < stratCount; ++i) {\n            IStrategy strategy = IStrategy(allStrategies[i]);\n            if (strategy.supportsAsset(_asset)) {\n                balance = balance + strategy.checkBalance(_asset);\n            }\n        }\n\n        WithdrawalQueueMetadata memory queue = withdrawalQueueMetadata;\n\n        // If the vault becomes insolvent enough that the total value in the vault and all strategies\n        // is less than the outstanding withdrawals.\n        // For example, there was a mass slashing event and most users request a withdrawal.\n        if (balance + queue.claimed < queue.queued) {\n            return 0;\n        }\n\n        // Need to remove asset that is reserved for the withdrawal queue\n        return balance + queue.claimed - queue.queued;\n    }\n\n    /**\n     * @notice Adds WETH to the withdrawal queue if there is a funding shortfall.\n     * @dev is called from the Native Staking strategy when validator withdrawals are processed.\n     * It also called before any WETH is allocated to a strategy.\n     */\n    function addWithdrawalQueueLiquidity() external {\n        _addWithdrawalQueueLiquidity();\n    }\n\n    /**\n     * @dev Adds asset (eg. WETH or USDC) to the withdrawal queue if there is a funding shortfall.\n     * This assumes 1 asset equal 1 corresponding OToken.\n     */\n    function _addWithdrawalQueueLiquidity()\n        internal\n        returns (uint256 addedClaimable)\n    {\n        WithdrawalQueueMetadata memory queue = withdrawalQueueMetadata;\n\n        // Check if the claimable asset is less than the queued amount\n        uint256 queueShortfall = queue.queued - queue.claimable;\n\n        // No need to do anything is the withdrawal queue is full funded\n        if (queueShortfall == 0) {\n            return 0;\n        }\n\n        uint256 assetBalance = IERC20(asset).balanceOf(address(this));\n\n        // Of the claimable withdrawal requests, how much is unclaimed?\n        // That is, the amount of asset that is currently allocated for the withdrawal queue\n        uint256 allocatedBaseAsset = queue.claimable - queue.claimed;\n\n        // If there is no unallocated asset then there is nothing to add to the queue\n        if (assetBalance <= allocatedBaseAsset) {\n            return 0;\n        }\n\n        uint256 unallocatedBaseAsset = assetBalance - allocatedBaseAsset;\n        // the new claimable amount is the smaller of the queue shortfall or unallocated asset\n        addedClaimable = queueShortfall < unallocatedBaseAsset\n            ? queueShortfall\n            : unallocatedBaseAsset;\n        uint256 newClaimable = queue.claimable + addedClaimable;\n\n        // Store the new claimable amount back to storage\n        withdrawalQueueMetadata.claimable = SafeCast.toUint128(newClaimable);\n\n        // emit a WithdrawalClaimable event\n        emit WithdrawalClaimable(newClaimable, addedClaimable);\n    }\n\n    /**\n     * @dev Calculate how much asset (eg. WETH or USDC) in the vault is not reserved for the withdrawal queue.\n     * That is, it is available to be redeemed or deposited into a strategy.\n     */\n    function _assetAvailable() internal view returns (uint256 assetAvailable) {\n        WithdrawalQueueMetadata memory queue = withdrawalQueueMetadata;\n\n        // The amount of asset that is still to be claimed in the withdrawal queue\n        uint256 outstandingWithdrawals = queue.queued - queue.claimed;\n\n        // The amount of sitting in asset in the vault\n        uint256 assetBalance = IERC20(asset).balanceOf(address(this));\n        // If there is not enough asset in the vault to cover the outstanding withdrawals\n        if (assetBalance <= outstandingWithdrawals) return 0;\n\n        return assetBalance - outstandingWithdrawals;\n    }\n\n    /***************************************\n                    Utils\n    ****************************************/\n\n    /**\n     * @notice Return the number of asset supported by the Vault.\n     */\n    function getAssetCount() public view returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @notice Return all vault asset addresses in order\n     */\n    function getAllAssets() external view returns (address[] memory) {\n        address[] memory a = new address[](1);\n        a[0] = asset;\n        return a;\n    }\n\n    /**\n     * @notice Return the number of strategies active on the Vault.\n     */\n    function getStrategyCount() external view returns (uint256) {\n        return allStrategies.length;\n    }\n\n    /**\n     * @notice Return the array of all strategies\n     */\n    function getAllStrategies() external view returns (address[] memory) {\n        return allStrategies;\n    }\n\n    /**\n     * @notice Returns whether the vault supports the asset\n     * @param _asset address of the asset\n     * @return true if supported\n     */\n    function isSupportedAsset(address _asset) external view returns (bool) {\n        return asset == _asset;\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function _max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n}\n"
    },
    "contracts/vault/VaultInitializer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OToken VaultInitializer contract\n * @notice The Vault contract initializes the vault.\n * @author Origin Protocol Inc\n */\n\nimport \"./VaultStorage.sol\";\n\nabstract contract VaultInitializer is VaultStorage {\n    constructor(address _asset) VaultStorage(_asset) {}\n\n    function initialize(address _oToken) external onlyGovernor initializer {\n        require(_oToken != address(0), \"oToken address is zero\");\n\n        oToken = OUSD(_oToken);\n\n        rebasePaused = false;\n        capitalPaused = true;\n\n        // Initial Vault buffer of 0%\n        vaultBuffer = 0;\n        // Initial allocate threshold of 25,000 OUSD\n        autoAllocateThreshold = 25000e18;\n        // Threshold for rebasing\n        rebaseThreshold = 1000e18;\n        // Initialize all strategies\n        allStrategies = new address[](0);\n        // Start with drip duration: 7 days\n        dripDuration = 604800;\n    }\n}\n"
    },
    "contracts/vault/VaultStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title OToken VaultStorage contract\n * @notice The VaultStorage contract defines the storage for the Vault contracts\n * @author Origin Protocol Inc\n */\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { OUSD } from \"../token/OUSD.sol\";\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport \"../utils/Helpers.sol\";\n\nabstract contract VaultStorage is Initializable, Governable {\n    using SafeERC20 for IERC20;\n\n    event AssetAllocated(address _asset, address _strategy, uint256 _amount);\n    event StrategyApproved(address _addr);\n    event StrategyRemoved(address _addr);\n    event Mint(address _addr, uint256 _value);\n    event Redeem(address _addr, uint256 _value);\n    event CapitalPaused();\n    event CapitalUnpaused();\n    event DefaultStrategyUpdated(address _strategy);\n    event RebasePaused();\n    event RebaseUnpaused();\n    event VaultBufferUpdated(uint256 _vaultBuffer);\n    event AllocateThresholdUpdated(uint256 _threshold);\n    event RebaseThresholdUpdated(uint256 _threshold);\n    event StrategistUpdated(address _address);\n    event MaxSupplyDiffChanged(uint256 maxSupplyDiff);\n    event YieldDistribution(address _to, uint256 _yield, uint256 _fee);\n    event TrusteeFeeBpsChanged(uint256 _basis);\n    event TrusteeAddressChanged(address _address);\n    event StrategyAddedToMintWhitelist(address indexed strategy);\n    event StrategyRemovedFromMintWhitelist(address indexed strategy);\n    event RebasePerSecondMaxChanged(uint256 rebaseRatePerSecond);\n    event DripDurationChanged(uint256 dripDuration);\n    event WithdrawalRequested(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount,\n        uint256 _queued\n    );\n    event WithdrawalClaimed(\n        address indexed _withdrawer,\n        uint256 indexed _requestId,\n        uint256 _amount\n    );\n    event WithdrawalClaimable(uint256 _claimable, uint256 _newClaimable);\n    event WithdrawalClaimDelayUpdated(uint256 _newDelay);\n\n    // Since we are proxy, all state should be uninitalized.\n    // Since this storage contract does not have logic directly on it\n    // we should not be checking for to see if these variables can be constant.\n    // slither-disable-start uninitialized-state\n    // slither-disable-start constable-states\n\n    /// @dev mapping of supported vault assets to their configuration\n    uint256 private _deprecated_assets;\n    /// @dev list of all assets supported by the vault.\n    address[] private _deprecated_allAssets;\n\n    // Strategies approved for use by the Vault\n    struct Strategy {\n        bool isSupported;\n        uint256 _deprecated; // Deprecated storage slot\n    }\n    /// @dev mapping of strategy contracts to their configuration\n    mapping(address => Strategy) public strategies;\n    /// @dev list of all vault strategies\n    address[] internal allStrategies;\n\n    /// @notice Address of the Oracle price provider contract\n    address private _deprecated_priceProvider;\n    /// @notice pause rebasing if true\n    bool public rebasePaused;\n    /// @notice pause operations that change the OToken supply.\n    /// eg mint, redeem, allocate, mint/burn for strategy\n    bool public capitalPaused;\n    /// @notice Redemption fee in basis points. eg 50 = 0.5%\n    uint256 private _deprecated_redeemFeeBps;\n    /// @notice Percentage of assets to keep in Vault to handle (most) withdrawals. 100% = 1e18.\n    uint256 public vaultBuffer;\n    /// @notice OToken mints over this amount automatically allocate funds. 18 decimals.\n    uint256 public autoAllocateThreshold;\n    /// @notice OToken mints over this amount automatically rebase. 18 decimals.\n    uint256 public rebaseThreshold;\n\n    /// @dev Address of the OToken token. eg OUSD or OETH.\n    OUSD public oToken;\n\n    /// @dev Address of the contract responsible for post rebase syncs with AMMs\n    address private _deprecated_rebaseHooksAddr = address(0);\n\n    /// @dev Deprecated: Address of Uniswap\n    address private _deprecated_uniswapAddr = address(0);\n\n    /// @notice Address of the Strategist\n    address public strategistAddr = address(0);\n\n    /// @notice Mapping of asset address to the Strategy that they should automatically\n    // be allocated to\n    uint256 private _deprecated_assetDefaultStrategies;\n\n    /// @notice Max difference between total supply and total value of assets. 18 decimals.\n    uint256 public maxSupplyDiff;\n\n    /// @notice Trustee contract that can collect a percentage of yield\n    address public trusteeAddress;\n\n    /// @notice Amount of yield collected in basis points. eg 2000 = 20%\n    uint256 public trusteeFeeBps;\n\n    /// @dev Deprecated: Tokens that should be swapped for stablecoins\n    address[] private _deprecated_swapTokens;\n\n    /// @notice Metapool strategy that is allowed to mint/burn OTokens without changing collateral\n\n    address private _deprecated_ousdMetaStrategy;\n\n    /// @notice How much OTokens are currently minted by the strategy\n    int256 private _deprecated_netOusdMintedForStrategy;\n\n    /// @notice How much net total OTokens are allowed to be minted by all strategies\n    uint256 private _deprecated_netOusdMintForStrategyThreshold;\n\n    uint256 private _deprecated_swapConfig;\n\n    // List of strategies that can mint oTokens directly\n    // Used in OETHBaseVaultCore\n    mapping(address => bool) public isMintWhitelistedStrategy;\n\n    /// @notice Address of the Dripper contract that streams harvested rewards to the Vault\n    /// @dev The vault is proxied so needs to be set with setDripper against the proxy contract.\n    address private _deprecated_dripper;\n\n    /// Withdrawal Queue Storage /////\n\n    struct WithdrawalQueueMetadata {\n        // cumulative total of all withdrawal requests included the ones that have already been claimed\n        uint128 queued;\n        // cumulative total of all the requests that can be claimed including the ones that have already been claimed\n        uint128 claimable;\n        // total of all the requests that have been claimed\n        uint128 claimed;\n        // index of the next withdrawal request starting at 0\n        uint128 nextWithdrawalIndex;\n    }\n\n    /// @notice Global metadata for the withdrawal queue including:\n    /// queued - cumulative total of all withdrawal requests included the ones that have already been claimed\n    /// claimable - cumulative total of all the requests that can be claimed including the ones already claimed\n    /// claimed - total of all the requests that have been claimed\n    /// nextWithdrawalIndex - index of the next withdrawal request starting at 0\n    WithdrawalQueueMetadata public withdrawalQueueMetadata;\n\n    struct WithdrawalRequest {\n        address withdrawer;\n        bool claimed;\n        uint40 timestamp; // timestamp of the withdrawal request\n        // Amount of oTokens to redeem. eg OETH\n        uint128 amount;\n        // cumulative total of all withdrawal requests including this one.\n        // this request can be claimed when this queued amount is less than or equal to the queue's claimable amount.\n        uint128 queued;\n    }\n\n    /// @notice Mapping of withdrawal request indices to the user withdrawal request data\n    mapping(uint256 => WithdrawalRequest) public withdrawalRequests;\n\n    /// @notice Sets a minimum delay that is required to elapse between\n    ///     requesting async withdrawals and claiming the request.\n    ///     When set to 0 async withdrawals are disabled.\n    uint256 public withdrawalClaimDelay;\n\n    /// @notice Time in seconds that the vault last rebased yield.\n    uint64 public lastRebase;\n\n    /// @notice Automatic rebase yield calculations. In seconds. Set to 0 or 1 to disable.\n    uint64 public dripDuration;\n\n    /// @notice max rebase percentage per second\n    ///   Can be used to set maximum yield of the protocol,\n    ///   spreading out yield over time\n    uint64 public rebasePerSecondMax;\n\n    /// @notice target rebase rate limit, based on past rates and funds available.\n    uint64 public rebasePerSecondTarget;\n\n    uint256 internal constant MAX_REBASE = 0.02 ether;\n    uint256 internal constant MAX_REBASE_PER_SECOND =\n        uint256(0.05 ether) / 1 days;\n\n    /// @notice Default strategy for asset\n    address public defaultStrategy;\n\n    // For future use\n    uint256[42] private __gap;\n\n    /// @notice Index of WETH asset in allAssets array\n    /// Legacy OETHVaultCore code, relocated here for vault consistency.\n    uint256 private _deprecated_wethAssetIndex;\n\n    /// @dev Address of the asset (eg. WETH or USDC)\n    address public immutable asset;\n    uint8 internal immutable assetDecimals;\n\n    // slither-disable-end constable-states\n    // slither-disable-end uninitialized-state\n\n    constructor(address _asset) {\n        uint8 _decimals = IERC20Metadata(_asset).decimals();\n        require(_decimals <= 18, \"invalid asset decimals\");\n        asset = _asset;\n        assetDecimals = _decimals;\n    }\n\n    /// @notice Deprecated: use `oToken()` instead.\n    function oUSD() external view returns (OUSD) {\n        return oToken;\n    }\n}\n"
    },
    "contracts/zapper/AbstractOTokenZapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { IERC4626 } from \"../../lib/openzeppelin/interfaces/IERC4626.sol\";\n\nabstract contract AbstractOTokenZapper {\n    IERC20 public immutable oToken;\n    IERC4626 public immutable wOToken;\n    IVault public immutable vault;\n\n    IWETH9 public immutable weth;\n\n    address private constant ETH_MARKER =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    event Zap(address indexed minter, address indexed asset, uint256 amount);\n\n    constructor(\n        address _oToken,\n        address _wOToken,\n        address _vault,\n        address _weth\n    ) {\n        oToken = IERC20(_oToken);\n        wOToken = IERC4626(_wOToken);\n        vault = IVault(_vault);\n        weth = IWETH9(_weth);\n\n        IWETH9(_weth).approve(address(_vault), type(uint256).max);\n        IERC20(_oToken).approve(_wOToken, type(uint256).max);\n    }\n\n    /**\n     * @dev Deposit ETH and receive OToken in return.\n     * Will verify that the user is sent 1:1 for ETH.\n     */\n    receive() external payable {\n        deposit();\n    }\n\n    /**\n     * @dev Deposit ETH and receive OToken in return\n     * Will verify that the user is sent 1:1 for ETH.\n     * @return Amount of OETH sent to user\n     */\n    function deposit() public payable returns (uint256) {\n        uint256 balance = address(this).balance;\n\n        emit Zap(msg.sender, ETH_MARKER, balance);\n\n        // Wrap ETH\n        weth.deposit{ value: balance }();\n\n        // Mint with WETH\n        return _mint(balance, msg.sender);\n    }\n\n    /**\n     * @dev Deposit ETH and receive superOETHb in return\n     * @param minReceived min amount of wsuperOETHb to receive\n     * @return Amount of wsuperOETHb sent to user\n     */\n    function depositETHForWrappedTokens(uint256 minReceived)\n        external\n        payable\n        returns (uint256)\n    {\n        uint256 balance = address(this).balance;\n\n        emit Zap(msg.sender, ETH_MARKER, balance);\n\n        // Wrap ETH\n        weth.deposit{ value: balance }();\n\n        // Mint with WETH\n        uint256 mintedOToken = _mint(balance, address(this));\n\n        // Wrap OToken into wOToken\n        uint256 mintedWOToken = wOToken.deposit(mintedOToken, msg.sender);\n\n        require(mintedWOToken >= minReceived, \"Zapper: not enough minted\");\n\n        return mintedWOToken;\n    }\n\n    /**\n     * @dev Deposit WETH and receive OToken in return\n     * @param wethAmount Amount of WETH to deposit\n     * @param minReceived min amount of wsuperOETHb to receive\n     * @return Amount of wsuperOETHb sent to user\n     */\n    function depositWETHForWrappedTokens(\n        uint256 wethAmount,\n        uint256 minReceived\n    ) external returns (uint256) {\n        // slither-disable-next-line unchecked-transfer unused-return\n        weth.transferFrom(msg.sender, address(this), wethAmount);\n\n        emit Zap(msg.sender, address(weth), wethAmount);\n\n        // Mint with WETH\n        uint256 mintedOToken = _mint(wethAmount, address(this));\n\n        // Wrap OToken into wOToken\n        uint256 mintedWOToken = wOToken.deposit(mintedOToken, msg.sender);\n\n        require(mintedWOToken >= minReceived, \"Zapper: not enough minted\");\n\n        return mintedWOToken;\n    }\n\n    /**\n     * @dev Internal function to mint superOETHb with WETH\n     * @param minOToken Minimum amount of OToken to for user to receive\n     * @param recipient Address that receives the tokens\n     * @return Amount of OToken sent to user\n     */\n    function _mint(uint256 minOToken, address recipient)\n        internal\n        returns (uint256)\n    {\n        uint256 toMint = weth.balanceOf(address(this));\n        vault.mint(address(weth), toMint, minOToken);\n        uint256 mintedAmount = oToken.balanceOf(address(this));\n        require(mintedAmount >= minOToken, \"Zapper: not enough minted\");\n\n        if (recipient != address(this)) {\n            require(oToken.transfer(recipient, mintedAmount));\n        }\n\n        return mintedAmount;\n    }\n}\n"
    },
    "contracts/zapper/OETHBaseZapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractOTokenZapper } from \"./AbstractOTokenZapper.sol\";\n\ncontract OETHBaseZapper is AbstractOTokenZapper {\n    constructor(\n        address _oethb,\n        address _woethb,\n        address _vault\n    )\n        AbstractOTokenZapper(\n            _oethb,\n            _woethb,\n            _vault,\n            0x4200000000000000000000000000000000000006\n        )\n    {}\n}\n"
    },
    "contracts/zapper/OETHZapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AbstractOTokenZapper } from \"./AbstractOTokenZapper.sol\";\n\ncontract OETHZapper is AbstractOTokenZapper {\n    constructor(\n        address _oeth,\n        address _woeth,\n        address _vault,\n        address _weth\n    ) AbstractOTokenZapper(_oeth, _woeth, _vault, _weth) {}\n}\n"
    },
    "contracts/zapper/OSonicZapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IWrappedSonic } from \"../interfaces/sonic/IWrappedSonic.sol\";\nimport { IERC4626 } from \"../../lib/openzeppelin/interfaces/IERC4626.sol\";\n\n/**\n * @title Zapper for Origin Sonic (OS) tokens\n * @author Origin Protocol Inc\n */\ncontract OSonicZapper {\n    IERC20 public immutable OS;\n    IERC4626 public immutable wOS;\n    IVault public immutable vault;\n\n    IWrappedSonic public constant wS =\n        IWrappedSonic(0x039e2fB66102314Ce7b64Ce5Ce3E5183bc94aD38);\n    address private constant ETH_MARKER =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    event Zap(address indexed minter, address indexed asset, uint256 amount);\n\n    constructor(\n        address _OS,\n        address _wOS,\n        address _vault\n    ) {\n        OS = IERC20(_OS);\n        wOS = IERC4626(_wOS);\n        vault = IVault(_vault);\n\n        wS.approve(address(_vault), type(uint256).max);\n        IERC20(_OS).approve(_wOS, type(uint256).max);\n    }\n\n    /**\n     * @dev Deposit native S currency and receive Origin Sonic (OS) tokens in return.\n     * Will verify that the user is sent 1:1 for S.\n     */\n    receive() external payable {\n        deposit();\n    }\n\n    /**\n     * @dev Deposit native S currency and receive Origin Sonic (OS) tokens in return.\n     * Will verify that the user is sent 1:1 for S.\n     * @return Amount of Origin Sonic (OS) tokens sent to user\n     */\n    function deposit() public payable returns (uint256) {\n        uint256 balance = address(this).balance;\n\n        emit Zap(msg.sender, ETH_MARKER, balance);\n\n        // Wrap native S\n        wS.deposit{ value: balance }();\n\n        // Mint Origin Sonic (OS) with Wrapped Sonic (wS)\n        return _mint(balance, msg.sender);\n    }\n\n    /**\n     * @dev Deposit S and receive Wrapped Origin Sonic (wOS) in return\n     * @param minReceived min amount of Wrapped Origin Sonic (wOS) to receive\n     * @return Amount of Wrapped Origin Sonic (wOS) tokens sent to user\n     */\n    function depositSForWrappedTokens(uint256 minReceived)\n        external\n        payable\n        returns (uint256)\n    {\n        uint256 balance = address(this).balance;\n\n        emit Zap(msg.sender, ETH_MARKER, balance);\n\n        // Wrap S\n        wS.deposit{ value: balance }();\n\n        // Mint with Wrapped Sonic\n        uint256 mintOS = _mint(balance, address(this));\n\n        // Wrap Origin Sonic (OS) into Wrapped Origin Sonic (wOS)\n        uint256 mintedWOS = wOS.deposit(mintOS, msg.sender);\n\n        require(mintedWOS >= minReceived, \"Zapper: not enough minted\");\n\n        return mintedWOS;\n    }\n\n    /**\n     * @dev Deposit Wrapped Sonic (wS) tokens and receive Wrapped Origin Sonic (wOS) tokens in return\n     * @param wSAmount Amount of Wrapped Sonic (wS) to deposit\n     * @param minReceived min amount of Wrapped Origin Sonic (wOS) token to receive\n     * @return Amount of Wrapped Origin Sonic (wOS) tokens sent to user\n     */\n    function depositWSForWrappedTokens(uint256 wSAmount, uint256 minReceived)\n        external\n        returns (uint256)\n    {\n        // slither-disable-next-line unchecked-transfer unused-return\n        wS.transferFrom(msg.sender, address(this), wSAmount);\n\n        emit Zap(msg.sender, address(wS), wSAmount);\n\n        // Mint with Wrapped Sonic (wS)\n        uint256 mintedOS = _mint(wSAmount, address(this));\n\n        // Wrap Origin Sonic (OS) tokens into Wrapped Origin Sonic (wOS) tokens\n        uint256 mintedWOS = wOS.deposit(mintedOS, msg.sender);\n\n        require(mintedWOS >= minReceived, \"Zapper: not enough minted\");\n\n        return mintedWOS;\n    }\n\n    /**\n     * @dev Internal function to mint Origin Sonic (OS) with Wrapped S (wS)\n     * @param minOS Minimum amount of Origin Sonic (OS) tokens the user can receive\n     * @param recipient Address that receives the tokens\n     * @return Amount of Origin Sonic (OS) tokens sent to the recipient\n     */\n    function _mint(uint256 minOS, address recipient)\n        internal\n        returns (uint256)\n    {\n        uint256 toMint = wS.balanceOf(address(this));\n        vault.mint(address(wS), toMint, minOS);\n        uint256 mintedAmount = OS.balanceOf(address(this));\n        require(mintedAmount >= minOS, \"Zapper: not enough minted\");\n\n        if (recipient != address(this)) {\n            require(OS.transfer(recipient, mintedAmount));\n        }\n\n        return mintedAmount;\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n"
    },
    "lib/openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC4626 } from \"../../../../interfaces/IERC4626.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n// From Open Zeppelin draft PR commit:\n// fac43034dca85ff539db3fc8aa2a7084b843d454\n// https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3171\n\nabstract contract ERC4626 is ERC20, IERC4626 {\n    IERC20Metadata private immutable _asset;\n\n    constructor(IERC20Metadata __asset) {\n        _asset = __asset;\n    }\n\n    /** @dev See {IERC4262-asset} */\n    function asset() public view virtual override returns (address) {\n        return address(_asset);\n    }\n\n    /** @dev See {IERC4262-totalAssets} */\n    function totalAssets() public view virtual override returns (uint256) {\n        return _asset.balanceOf(address(this));\n    }\n\n    /**\n     * @dev See {IERC4262-convertToShares}\n     *\n     * Will revert if asserts > 0, totalSupply > 0 and totalAssets = 0. That corresponds to a case where any asset\n     * would represent an infinite amout of shares.\n     */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n\n        return\n            (assets == 0 || supply == 0)\n                ? (assets * 10**decimals()) / 10**_asset.decimals()\n                : (assets * supply) / totalAssets();\n    }\n\n    /** @dev See {IERC4262-convertToAssets} */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n\n        return (supply == 0) ? (shares * 10**_asset.decimals()) / 10**decimals() : (shares * totalAssets()) / supply;\n    }\n\n    /** @dev See {IERC4262-maxDeposit} */\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4262-maxMint} */\n    function maxMint(address) public view virtual override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4262-maxWithdraw} */\n    function maxWithdraw(address owner) public view virtual override returns (uint256) {\n        return convertToAssets(balanceOf(owner));\n    }\n\n    /** @dev See {IERC4262-maxRedeem} */\n    function maxRedeem(address owner) public view virtual override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4262-previewDeposit} */\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /** @dev See {IERC4262-previewMint} */\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        uint256 assets = convertToAssets(shares);\n        return assets + (convertToShares(assets) < shares ? 1 : 0);\n    }\n\n    /** @dev See {IERC4262-previewWithdraw} */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        uint256 shares = convertToShares(assets);\n        return shares + (convertToAssets(shares) < assets ? 1 : 0);\n    }\n\n    /** @dev See {IERC4262-previewRedeem} */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /** @dev See {IERC4262-deposit} */\n    function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {\n        require(assets <= maxDeposit(receiver), \"ERC4626: deposit more then max\");\n\n        address caller = _msgSender();\n        uint256 shares = previewDeposit(assets);\n\n        // if _asset is ERC777, transferFrom can call reenter BEFORE the transfer happens through\n        // the tokensToSend hook, so we need to transfer before we mint to keep the invariants.\n        SafeERC20.safeTransferFrom(_asset, caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4262-mint} */\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256) {\n        require(shares <= maxMint(receiver), \"ERC4626: mint more then max\");\n\n        address caller = _msgSender();\n        uint256 assets = previewMint(shares);\n\n        // if _asset is ERC777, transferFrom can call reenter BEFORE the transfer happens through\n        // the tokensToSend hook, so we need to transfer before we mint to keep the invariants.\n        SafeERC20.safeTransferFrom(_asset, caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n\n        return assets;\n    }\n\n    /** @dev See {IERC4262-withdraw} */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(assets <= maxWithdraw(owner), \"ERC4626: withdraw more then max\");\n\n        address caller = _msgSender();\n        uint256 shares = previewWithdraw(assets);\n\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // if _asset is ERC777, transfer can call reenter AFTER the transfer happens through\n        // the tokensReceived hook, so we need to transfer after we burn to keep the invariants.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(_asset, receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4262-redeem} */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(shares <= maxRedeem(owner), \"ERC4626: redeem more then max\");\n\n        address caller = _msgSender();\n        uint256 assets = previewRedeem(shares);\n\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // if _asset is ERC777, transfer can call reenter AFTER the transfer happens through\n        // the tokensReceived hook, so we need to transfer after we burn to keep the invariants.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(_asset, receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    // Included here, since this method was not yet present in\n    // the version of Open Zeppelin ERC20 code we use.\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n}"
    },
    "lib/openzeppelin/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is managed by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n}"
    },
    "lib/rooster/openzeppelin-custom/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2 + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2 + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2 and mod 2 - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2 + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2 - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2 - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2. Now that denominator is an odd number, it has an inverse modulo 2 such\n            // that denominator * inv  1 mod 2. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv  1 mod 2.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2. Since the preconditions guarantee that the outcome is\n            // less than 2, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax  1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1)  1 mod p`. As a consequence, we have `a * a**(p-2)  1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1)  sqrt(a) < 2**e`). We know that `e  128` because `(2) = 2` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1)  sqrt(a) < 2**e  (2**(e-1))  a < (2**e)  2**(2*e-2)  a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1)  sqrt(a) < 2**e = 2 * x_n`. This implies _n  2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to _n  2**(e-2).\n            // This is going to be our x_0 (and _0)\n            xn = (3 * xn) >> 1; // _0 := | x_0 - sqrt(a) |  2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1} - a = ((x_n + a / x_n) / 2) - a\n            //              = ((x_n + a) / (2 * x_n)) - a\n            //              = (x_n + 2 * a * x_n + a) / (4 * x_n) - a\n            //              = (x_n + 2 * a * x_n + a - 4 * a * x_n) / (4 * x_n)\n            //              = (x_n - 2 * a * x_n + a) / (4 * x_n)\n            //              = (x_n - a) / (2 * x_n)\n            //              = ((x_n - a) / (2 * x_n))\n            //               0\n            // Which proves that for all n  1, sqrt(a)  x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // _{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a)) / (2 * x_n) |\n            //         = | _n / (2 * x_n) |\n            //         = _n / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // _1 = _0 / | (2 * x_0) |\n            //      (2**(e-2)) / (2 * (2**(e-1) + 2**(e-2)))\n            //      2**(2*e-4) / (3 * 2**(e-1))\n            //      2**(e-3) / 3\n            //      2**(e-3-log2(3))\n            //      2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1)  sqrt(a)  x_n:\n            // _{n+1} = _n / | (2 * x_n) |\n            //          (2**(e-k)) / (2 * 2**(e-1))\n            //          2**(2*e-2*k) / 2**e\n            //          2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // _1 := | x_1 - sqrt(a) |  2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // _2 := | x_2 - sqrt(a) |  2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // _3 := | x_3 - sqrt(a) |  2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // _4 := | x_4 - sqrt(a) |  2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // _5 := | x_5 - sqrt(a) |  2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // _6 := | x_6 - sqrt(a) |  2**(e-144)  -- general case with k = 72\n\n            // Because e  128 (as discussed during the first estimation phase), we know have reached a precision\n            // _6  2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}"
    },
    "lib/rooster/openzeppelin-custom/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}"
    },
    "lib/rooster/openzeppelin-custom/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}"
    },
    "lib/rooster/v2-common/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// As the copyright holder of this work, Ubiquity Labs retains\n// the right to distribute, use, and modify this code under any license of\n// their choosing, in addition to the terms of the GPL-v2 or later.\npragma solidity ^0.8.25;\n\n// factory contraints on pools\nuint8 constant MAX_PROTOCOL_FEE_RATIO_D3 = 0.25e3; // 25%\nuint256 constant MAX_PROTOCOL_LENDING_FEE_RATE_D18 = 0.02e18; // 2%\nuint64 constant MAX_POOL_FEE_D18 = 0.9e18; // 90%\nuint64 constant MIN_LOOKBACK = 1 seconds;\n\n// pool constraints\nuint8 constant NUMBER_OF_KINDS = 4;\nint32 constant NUMBER_OF_KINDS_32 = int32(int8(NUMBER_OF_KINDS));\nuint256 constant MAX_TICK = 322_378; // max price 1e14 in D18 scale\nint32 constant MAX_TICK_32 = int32(int256(MAX_TICK));\nint32 constant MIN_TICK_32 = int32(-int256(MAX_TICK));\nuint256 constant MAX_BINS_TO_MERGE = 3;\nuint128 constant MINIMUM_LIQUIDITY = 1e8;\n\n// accessor named constants\nuint8 constant ALL_KINDS_MASK = 0xF; // 0b1111\nuint8 constant PERMISSIONED_LIQUIDITY_MASK = 0x10; // 0b010000\nuint8 constant PERMISSIONED_SWAP_MASK = 0x20; // 0b100000\nuint8 constant OPTIONS_MASK = ALL_KINDS_MASK | PERMISSIONED_LIQUIDITY_MASK | PERMISSIONED_SWAP_MASK; // 0b111111\n\n// named values\naddress constant MERGED_LP_BALANCE_ADDRESS = address(0);\nuint256 constant MERGED_LP_BALANCE_SUBACCOUNT = 0;\nuint128 constant ONE = 1e18;\nuint128 constant ONE_SQUARED = 1e36;\nint256 constant INT256_ONE = 1e18;\nuint256 constant ONE_D8 = 1e8;\nuint256 constant ONE_D3 = 1e3;\nint40 constant INT_ONE_D8 = 1e8;\nint40 constant HALF_TICK_D8 = 0.5e8;\nuint8 constant DEFAULT_DECIMALS = 18;\nuint256 constant DEFAULT_SCALE = 1;\nbytes constant EMPTY_PRICE_BREAKS = hex\"010000000000000000000000\";"
    },
    "lib/rooster/v2-common/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// As the copyright holder of this work, Ubiquity Labs retains\n// the right to distribute, use, and modify this code under any license of\n// their choosing, in addition to the terms of the GPL-v2 or later.\npragma solidity ^0.8.25;\n\nimport {Math as OzMath} from \"../../openzeppelin-custom/contracts/utils/math/Math.sol\";\n\nimport {ONE, DEFAULT_SCALE, DEFAULT_DECIMALS, INT_ONE_D8, ONE_SQUARED} from \"./Constants.sol\";\n\n/**\n * @notice Math functions.\n */\nlibrary Math {\n    /**\n     * @notice Returns the lesser of two values.\n     * @param x First uint256 value.\n     * @param y Second uint256 value.\n     */\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly (\"memory-safe\") {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /**\n     * @notice Returns the lesser of two uint128 values.\n     * @param x First uint128 value.\n     * @param y Second uint128 value.\n     */\n    function min128(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        assembly (\"memory-safe\") {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /**\n     * @notice Returns the lesser of two int256 values.\n     * @param x First int256 value.\n     * @param y Second int256 value.\n     */\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\n        assembly (\"memory-safe\") {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }\n\n    /**\n     * @notice Returns the greater of two uint256 values.\n     * @param x First uint256 value.\n     * @param y Second uint256 value.\n     */\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly (\"memory-safe\") {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /**\n     * @notice Returns the greater of two int256 values.\n     * @param x First int256 value.\n     * @param y Second int256 value.\n     */\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\n        assembly (\"memory-safe\") {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }\n\n    /**\n     * @notice Returns the greater of two uint128 values.\n     * @param x First uint128 value.\n     * @param y Second uint128 value.\n     */\n    function max128(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        assembly (\"memory-safe\") {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /**\n     * @notice Thresholds a value to be within the specified bounds.\n     * @param value The value to bound.\n     * @param lowerLimit The minimum allowable value.\n     * @param upperLimit The maximum allowable value.\n     */\n    function boundValue(\n        uint256 value,\n        uint256 lowerLimit,\n        uint256 upperLimit\n    ) internal pure returns (uint256 outputValue) {\n        outputValue = min(max(value, lowerLimit), upperLimit);\n    }\n\n    /**\n     * @notice Returns the difference between two uint128 values or zero if the result would be negative.\n     * @param x The minuend.\n     * @param y The subtrahend.\n     */\n    function clip128(uint128 x, uint128 y) internal pure returns (uint128) {\n        unchecked {\n            return x < y ? 0 : x - y;\n        }\n    }\n\n    /**\n     * @notice Returns the difference between two uint256 values or zero if the result would be negative.\n     * @param x The minuend.\n     * @param y The subtrahend.\n     */\n    function clip(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            return x < y ? 0 : x - y;\n        }\n    }\n\n    /**\n     * @notice Divides one uint256 by another, rounding down to the nearest\n     * integer.\n     * @param x The dividend.\n     * @param y The divisor.\n     */\n    function divFloor(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivFloor(x, ONE, y);\n    }\n\n    /**\n     * @notice Divides one uint256 by another, rounding up to the nearest integer.\n     * @param x The dividend.\n     * @param y The divisor.\n     */\n    function divCeil(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivCeil(x, ONE, y);\n    }\n\n    /**\n     * @notice Multiplies two uint256 values and then divides by ONE, rounding down.\n     * @param x The multiplicand.\n     * @param y The multiplier.\n     */\n    function mulFloor(uint256 x, uint256 y) internal pure returns (uint256) {\n        return OzMath.mulDiv(x, y, ONE);\n    }\n\n    /**\n     * @notice Multiplies two uint256 values and then divides by ONE, rounding up.\n     * @param x The multiplicand.\n     * @param y The multiplier.\n     */\n    function mulCeil(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivCeil(x, y, ONE);\n    }\n\n    /**\n     * @notice Calculates the multiplicative inverse of a uint256, rounding down.\n     * @param x The value to invert.\n     */\n    function invFloor(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return ONE_SQUARED / x;\n        }\n    }\n\n    /**\n     * @notice Calculates the multiplicative inverse of a uint256, rounding up.\n     * @param denominator The value to invert.\n     */\n    function invCeil(uint256 denominator) internal pure returns (uint256 z) {\n        assembly (\"memory-safe\") {\n            // divide z - 1 by the denominator and add 1.\n            z := add(div(sub(ONE_SQUARED, 1), denominator), 1)\n        }\n    }\n\n    /**\n     * @notice Multiplies two uint256 values and divides by a third, rounding down.\n     * @param x The multiplicand.\n     * @param y The multiplier.\n     * @param k The divisor.\n     */\n    function mulDivFloor(uint256 x, uint256 y, uint256 k) internal pure returns (uint256 result) {\n        result = OzMath.mulDiv(x, y, max(1, k));\n    }\n\n    /**\n     * @notice Multiplies two uint256 values and divides by a third, rounding up if there's a remainder.\n     * @param x The multiplicand.\n     * @param y The multiplier.\n     * @param k The divisor.\n     */\n    function mulDivCeil(uint256 x, uint256 y, uint256 k) internal pure returns (uint256 result) {\n        result = mulDivFloor(x, y, k);\n        if (mulmod(x, y, max(1, k)) != 0) result = result + 1;\n    }\n\n    /**\n     * @notice Multiplies two uint256 values and divides by a third, rounding\n     * down. Will revert if `x * y` is larger than `type(uint256).max`.\n     * @param x The first operand for multiplication.\n     * @param y The second operand for multiplication.\n     * @param denominator The divisor after multiplication.\n     */\n    function mulDivDown(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 z) {\n        assembly (\"memory-safe\") {\n            // Store x * y in z for now.\n            z := mul(x, y)\n            if iszero(denominator) {\n                denominator := 1\n            }\n\n            if iszero(or(iszero(x), eq(div(z, x), y))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    /**\n     * @notice Multiplies two uint256 values and divides by a third, rounding\n     * up. Will revert if `x * y` is larger than `type(uint256).max`.\n     * @param x The first operand for multiplication.\n     * @param y The second operand for multiplication.\n     * @param denominator The divisor after multiplication.\n     */\n    function mulDivUp(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 z) {\n        assembly (\"memory-safe\") {\n            // Store x * y in z for now.\n            z := mul(x, y)\n            if iszero(denominator) {\n                denominator := 1\n            }\n\n            if iszero(or(iszero(x), eq(div(z, x), y))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    /**\n     * @notice Multiplies a uint256 by another and divides by a constant,\n     * rounding down. Will revert if `x * y` is larger than\n     * `type(uint256).max`.\n     * @param x The multiplicand.\n     * @param y The multiplier.\n     */\n    function mulDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, ONE);\n    }\n\n    /**\n     * @notice Divides a uint256 by another, rounding down the result. Will\n     * revert if `x * 1e18` is larger than `type(uint256).max`.\n     * @param x The dividend.\n     * @param y The divisor.\n     */\n    function divDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, ONE, y);\n    }\n\n    /**\n     * @notice Divides a uint256 by another, rounding up the result. Will\n     * revert if `x * 1e18` is larger than `type(uint256).max`.\n     * @param x The dividend.\n     * @param y The divisor.\n     */\n    function divUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, ONE, y);\n    }\n\n    /**\n     * @notice Scales a number based on a difference in decimals from a default.\n     * @param decimals The new decimal precision.\n     */\n    function scale(uint8 decimals) internal pure returns (uint256) {\n        unchecked {\n            if (decimals == DEFAULT_DECIMALS) {\n                return DEFAULT_SCALE;\n            } else {\n                return 10 ** (DEFAULT_DECIMALS - decimals);\n            }\n        }\n    }\n\n    /**\n     * @notice Adjusts a scaled amount to the token decimal scale.\n     * @param amount The scaled amount.\n     * @param scaleFactor The scaling factor to adjust by.\n     * @param ceil Whether to round up (true) or down (false).\n     */\n    function ammScaleToTokenScale(uint256 amount, uint256 scaleFactor, bool ceil) internal pure returns (uint256 z) {\n        unchecked {\n            if (scaleFactor == DEFAULT_SCALE || amount == 0) {\n                return amount;\n            } else {\n                if (!ceil) return amount / scaleFactor;\n                assembly (\"memory-safe\") {\n                    z := add(div(sub(amount, 1), scaleFactor), 1)\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Adjusts a token amount to the D18 AMM scale.\n     * @param amount The amount in token scale.\n     * @param scaleFactor The scale factor for adjustment.\n     */\n    function tokenScaleToAmmScale(uint256 amount, uint256 scaleFactor) internal pure returns (uint256) {\n        if (scaleFactor == DEFAULT_SCALE) {\n            return amount;\n        } else {\n            return amount * scaleFactor;\n        }\n    }\n\n    /**\n     * @notice Returns the absolute value of a signed 32-bit integer.\n     * @param x The integer to take the absolute value of.\n     */\n    function abs32(int32 x) internal pure returns (uint32) {\n        unchecked {\n            return uint32(x < 0 ? -x : x);\n        }\n    }\n\n    /**\n     * @notice Returns the absolute value of a signed 256-bit integer.\n     * @param x The integer to take the absolute value of.\n     */\n    function abs(int256 x) internal pure returns (uint256) {\n        unchecked {\n            return uint256(x < 0 ? -x : x);\n        }\n    }\n\n    /**\n     * @notice Calculates the integer square root of a uint256 rounded down.\n     * @param x The number to take the square root of.\n     */\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        // from https://github.com/transmissions11/solmate/blob/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/FixedPointMathLib.sol\n        assembly (\"memory-safe\") {\n            let y := x\n            z := 181\n\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            z := shr(18, mul(z, add(y, 65536)))\n\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /**\n     * @notice Computes the floor of a D8-scaled number as an int32, ignoring\n     * potential overflow in the cast.\n     * @param val The D8-scaled number.\n     */\n    function floorD8Unchecked(int256 val) internal pure returns (int32) {\n        int32 val32;\n        bool check;\n        unchecked {\n            val32 = int32(val / INT_ONE_D8);\n            check = (val < 0 && val % INT_ONE_D8 != 0);\n        }\n        return check ? val32 - 1 : val32;\n    }\n}"
    },
    "lib/rooster/v2-common/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// As the copyright holder of this work, Ubiquity Labs retains\n// the right to distribute, use, and modify this code under any license of\n// their choosing, in addition to the terms of the GPL-v2 or later.\npragma solidity ^0.8.25;\n\nimport {Math as OzMath} from \"../../openzeppelin-custom/contracts/utils/math/Math.sol\";\nimport {Math} from \"./Math.sol\";\nimport {MAX_TICK, ONE} from \"./Constants.sol\";\n\n/**\n * @notice Math functions related to tick operations.\n */\n// slither-disable-start divide-before-multiply\nlibrary TickMath {\n    using Math for uint256;\n\n    error TickMaxExceeded(int256 tick);\n\n    /**\n     * @notice Compute the lower and upper sqrtPrice of a tick.\n     * @param tickSpacing The tick spacing used for calculations.\n     * @param _tick The input tick value.\n     */\n    function tickSqrtPrices(\n        uint256 tickSpacing,\n        int32 _tick\n    ) internal pure returns (uint256 sqrtLowerPrice, uint256 sqrtUpperPrice) {\n        unchecked {\n            sqrtLowerPrice = tickSqrtPrice(tickSpacing, _tick);\n            sqrtUpperPrice = tickSqrtPrice(tickSpacing, _tick + 1);\n        }\n    }\n\n    /**\n     * @notice Compute the base tick value from the pool tick and the\n     * tickSpacing.  Revert if base tick is beyond the max tick boundary.\n     * @param tickSpacing The tick spacing used for calculations.\n     * @param _tick The input tick value.\n     */\n    function subTickIndex(uint256 tickSpacing, int32 _tick) internal pure returns (uint32 subTick) {\n        subTick = Math.abs32(_tick);\n        subTick *= uint32(tickSpacing);\n        if (subTick > MAX_TICK) {\n            revert TickMaxExceeded(_tick);\n        }\n    }\n\n    /**\n     * @notice Calculate the square root price for a given tick and tick spacing.\n     * @param tickSpacing The tick spacing used for calculations.\n     * @param _tick The input tick value.\n     * @return _result The square root price.\n     */\n    function tickSqrtPrice(uint256 tickSpacing, int32 _tick) internal pure returns (uint256 _result) {\n        unchecked {\n            uint256 tick = subTickIndex(tickSpacing, _tick);\n\n            uint256 ratio = tick & 0x1 != 0 ? 0xfffcb933bd6fad9d3af5f0b9f25db4d6 : 0x100000000000000000000000000000000;\n            if (tick & 0x2 != 0) ratio = (ratio * 0xfff97272373d41fd789c8cb37ffcaa1c) >> 128;\n            if (tick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656ac9229c67059486f389) >> 128;\n            if (tick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e81259b3cddc7a064941) >> 128;\n            if (tick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f67b19e8887e0bd251eb7) >> 128;\n            if (tick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98cd2e57b660be99eb2c4a) >> 128;\n            if (tick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c9838804e327cb417cafcb) >> 128;\n            if (tick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99d51e2cc356c2f617dbe0) >> 128;\n            if (tick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900aecf64236ab31f1f9dcb5) >> 128;\n            if (tick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac4d9194200696907cf2e37) >> 128;\n            if (tick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b88206f8abe8a3b44dd9be) >> 128;\n            if (tick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c578ef4f1d17b2b235d480) >> 128;\n            if (tick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd254ee83bdd3f248e7e785e) >> 128;\n            if (tick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d8f7dd10e744d913d033333) >> 128;\n            if (tick & 0x4000 != 0) ratio = (ratio * 0x70d869a156ddd32a39e257bc3f50aa9b) >> 128;\n            if (tick & 0x8000 != 0) ratio = (ratio * 0x31be135f97da6e09a19dc367e3b6da40) >> 128;\n            if (tick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7e5a9780b0cc4e25d61a56) >> 128;\n            if (tick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedbcb3a6ccb7ce618d14225) >> 128;\n            if (tick & 0x40000 != 0) ratio = (ratio * 0x2216e584f630389b2052b8db590e) >> 128;\n            if (_tick > 0) ratio = type(uint256).max / ratio;\n            _result = (ratio * ONE) >> 128;\n        }\n    }\n\n    /**\n     * @notice Calculate liquidity of a tick.\n     * @param reserveA Tick reserve of token A.\n     * @param reserveB Tick reserve of token B.\n     * @param sqrtLowerTickPrice The square root price of the lower tick edge.\n     * @param sqrtUpperTickPrice The square root price of the upper tick edge.\n     */\n    function getTickL(\n        uint256 reserveA,\n        uint256 reserveB,\n        uint256 sqrtLowerTickPrice,\n        uint256 sqrtUpperTickPrice\n    ) internal pure returns (uint256 liquidity) {\n        // known:\n        // - sqrt price values are different\n        // - reserveA and reserveB fit in 128 bit\n        // - sqrt price is in (1e-7, 1e7)\n        // - D18 max for uint256 is 1.15e59\n        // - D18 min is 1e-18\n\n        unchecked {\n            // diff is in (5e-12, 4e6); max tick spacing is 10_000\n            uint256 diff = sqrtUpperTickPrice - sqrtLowerTickPrice;\n\n            // Need to maximize precision by shifting small values A and B up so\n            // that they use more of the available bit range. Two constraints to\n            // consider: we need A * B * diff / sqrtPrice to be bigger than 1e-18\n            // when the bump is not in play.  This constrains the threshold for\n            // bumping to be at least 77 bit; ie, either a or b needs 2^77 which\n            // means that term A * B * diff / sqrtPrice > 1e-18.\n            //\n            // At the other end, the second constraint is that b^2 needs to fit in\n            // a 256-bit number, so, post bump, the max reserve value needs to be\n            // less than 6e22. With a 78-bit threshold and a 57-bit bump, we have A\n            // and B are in (1.4e-1, 4.4e22 (2^(78+57))) with bump, and one of A or\n            // B is at least 2^78 without the bump, but the other reserve value may\n            // be as small as 1 wei.\n            uint256 precisionBump = 0;\n            if ((reserveA >> 78) == 0 && (reserveB >> 78) == 0) {\n                precisionBump = 57;\n                reserveA <<= precisionBump;\n                reserveB <<= precisionBump;\n            }\n\n            if (reserveB == 0) return Math.divDown(reserveA, diff) >> precisionBump;\n            if (reserveA == 0)\n                return Math.mulDivDown(reserveB.mulDown(sqrtLowerTickPrice), sqrtUpperTickPrice, diff) >> precisionBump;\n\n            // b is in (7.2e-9 (2^57 / 1e7 / 2), 2.8e29  (2^(78+57) * 1e7 / 2)) with bump\n            // b is in a subset of the same range without bump\n            uint256 b = (reserveA.divDown(sqrtUpperTickPrice) + reserveB.mulDown(sqrtLowerTickPrice)) >> 1;\n\n            // b^2 is in (5.1e-17, 4.8e58); and will not overflow on either end;\n            // A*B is in (3e-13 (2^78 / 1e18 * 1e-18), 1.9e45) without bump and is in a subset range with bump\n            // A*B*diff/sqrtUpper is in (1.5e-17 (3e-13 * 5e-12 * 1e7), 7.6e58);\n\n            // Since b^2 is at the upper edge of the precision range, we are not\n            // able to multiply the argument of the sqrt by 1e18, instead, we move\n            // this factor outside of the sqrt. The resulting loss of precision\n            // means that this liquidity value is a lower bound on the tick\n            // liquidity\n            return\n                OzMath.mulDiv(\n                    b +\n                        Math.sqrt(\n                            (OzMath.mulDiv(b, b, ONE) +\n                                OzMath.mulDiv(reserveB.mulFloor(reserveA), diff, sqrtUpperTickPrice))\n                        ) *\n                        1e9,\n                    sqrtUpperTickPrice,\n                    diff\n                ) >> precisionBump;\n        }\n    }\n\n    /**\n     * @notice Calculate square root price of a tick. Returns left edge of the\n     * tick if the tick has no reserves.\n     * @param reserveA Tick reserve of token A.\n     * @param reserveB Tick reserve of token B.\n     * @param sqrtLowerTickPrice The square root price of the lower tick edge.\n     * @param sqrtUpperTickPrice The square root price of the upper tick edge.\n     * @return sqrtPrice The calculated square root price.\n     */\n    function getSqrtPrice(\n        uint256 reserveA,\n        uint256 reserveB,\n        uint256 sqrtLowerTickPrice,\n        uint256 sqrtUpperTickPrice,\n        uint256 liquidity\n    ) internal pure returns (uint256 sqrtPrice) {\n        unchecked {\n            if (reserveA == 0) {\n                return sqrtLowerTickPrice;\n            }\n            if (reserveB == 0) {\n                return sqrtUpperTickPrice;\n            }\n            sqrtPrice = Math.sqrt(\n                ONE *\n                    (reserveA + liquidity.mulDown(sqrtLowerTickPrice)).divDown(\n                        reserveB + liquidity.divDown(sqrtUpperTickPrice)\n                    )\n            );\n            sqrtPrice = Math.boundValue(sqrtPrice, sqrtLowerTickPrice, sqrtUpperTickPrice);\n        }\n    }\n\n    /**\n     * @notice Calculate square root price of a tick. Returns left edge of the\n     * tick if the tick has no reserves.\n     * @param reserveA Tick reserve of token A.\n     * @param reserveB Tick reserve of token B.\n     * @param sqrtLowerTickPrice The square root price of the lower tick edge.\n     * @param sqrtUpperTickPrice The square root price of the upper tick edge.\n     * @return sqrtPrice The calculated square root price.\n     * @return liquidity The calculated liquidity.\n     */\n    function getTickSqrtPriceAndL(\n        uint256 reserveA,\n        uint256 reserveB,\n        uint256 sqrtLowerTickPrice,\n        uint256 sqrtUpperTickPrice\n    ) internal pure returns (uint256 sqrtPrice, uint256 liquidity) {\n        liquidity = getTickL(reserveA, reserveB, sqrtLowerTickPrice, sqrtUpperTickPrice);\n        sqrtPrice = getSqrtPrice(reserveA, reserveB, sqrtLowerTickPrice, sqrtUpperTickPrice, liquidity);\n    }\n}\n// slither-disable-end divide-before-multiply"
    },
    "solidity-bytes-utils/contracts/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonalo S <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        // We're using the unchecked block below because otherwise execution ends \n        // with the native overflow error code.\n        unchecked {\n            require(_length + 31 >= _length, \"slice_overflow\");\n        }\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}