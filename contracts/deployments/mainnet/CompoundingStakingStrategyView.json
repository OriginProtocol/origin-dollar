{
  "address": "0xEDf495F92c2eBdEE8B797E9C503aA7A3302A9c88",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_stakingStrategy",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "getPendingDeposits",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "pendingDepositRoot",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "pubKeyHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "amountGwei",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "slot",
              "type": "uint64"
            }
          ],
          "internalType": "struct CompoundingStakingStrategyView.DepositView[]",
          "name": "pendingDeposits",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getVerifiedValidators",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "pubKeyHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "index",
              "type": "uint64"
            },
            {
              "internalType": "enum CompoundingValidatorManager.ValidatorState",
              "name": "state",
              "type": "uint8"
            }
          ],
          "internalType": "struct CompoundingStakingStrategyView.ValidatorView[]",
          "name": "validators",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "stakingStrategy",
      "outputs": [
        {
          "internalType": "contract CompoundingValidatorManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xa0e60a801bbb92b22c2a8816b01f5b03806d5f4c36e772cd0fa47b061a706df7",
  "receipt": {
    "to": null,
    "from": "0x3Ba227D87c2A7aB89EAaCEFbeD9bfa0D15Ad249A",
    "contractAddress": "0xEDf495F92c2eBdEE8B797E9C503aA7A3302A9c88",
    "transactionIndex": 75,
    "gasUsed": "534977",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x8a13bd10bddd573cc8fdfa99fe1938b888b00f1d0417f216f31850392d175901",
    "transactionHash": "0xa0e60a801bbb92b22c2a8816b01f5b03806d5f4c36e772cd0fa47b061a706df7",
    "logs": [],
    "blockNumber": 23667479,
    "cumulativeGasUsed": "9819327",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xaF04828Ed923216c77dC22a2fc8E077FDaDAA87d"
  ],
  "numDeployments": 1,
  "solcInputHash": "812616693b19e4c7ea528016595dc2c6",
  "metadata": "{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingStrategy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"getPendingDeposits\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"pendingDepositRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"pubKeyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"amountGwei\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"}],\"internalType\":\"struct CompoundingStakingStrategyView.DepositView[]\",\"name\":\"pendingDeposits\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVerifiedValidators\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"pubKeyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"index\",\"type\":\"uint64\"},{\"internalType\":\"enum CompoundingValidatorManager.ValidatorState\",\"name\":\"state\",\"type\":\"uint8\"}],\"internalType\":\"struct CompoundingStakingStrategyView.ValidatorView[]\",\"name\":\"validators\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingStrategy\",\"outputs\":[{\"internalType\":\"contract CompoundingValidatorManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Origin Protocol Inc\",\"kind\":\"dev\",\"methods\":{\"getPendingDeposits()\":{\"returns\":{\"pendingDeposits\":\"An array of `DepositView` containing the deposit ID, public key hash, amount in Gwei and the slot of the deposit.\"}},\"getVerifiedValidators()\":{\"returns\":{\"validators\":\"An array of `ValidatorView` containing the public key hash, validator index and state.\"}}},\"title\":\"Viewing contract for the Compounding Staking Strategy.\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getPendingDeposits()\":{\"notice\":\"Returns the deposits that are still to be verified. These may or may not have been processed by the beacon chain.\"},\"getVerifiedValidators()\":{\"notice\":\"Returns the strategy's active validators. These are the ones that have been verified and have a non-zero balance.\"},\"stakingStrategy()\":{\"notice\":\"The address of the Compounding Staking Strategy contract\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/strategies/NativeStaking/CompoundingStakingView.sol\":\"CompoundingStakingStrategyView\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/security/Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\",\"keccak256\":\"0xe68ed7fb8766ed1e888291f881e36b616037f852b37d96877045319ad298ba87\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x61437cb513a887a1bbad006e7b1c8b414478427d33de47c5600af3c748f108da\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc3d946432c0ddbb1f846a0d3985be71299df331b91d06732152117f62f0be2b5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x51b758a8815ecc9596c66c37d56b1d33883a444631a3f916b9fe65cb863ef7c4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\",\"keccak256\":\"0xfaad496c1c944b6259b7dc70b4865eb1775d6402bc0c81b38a0b24d9f525ae37\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x5c6caab697d302ad7eb59c234a4d2dbc965c1bae87709bd2850060b7695b28c7\",\"license\":\"MIT\"},\"contracts/beacon/BeaconRoots.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Library to retrieve beacon block roots.\\n * @author Origin Protocol Inc\\n */\\nlibrary BeaconRoots {\\n    /// @notice The address of beacon block roots oracle\\n    /// See https://eips.ethereum.org/EIPS/eip-4788\\n    address internal constant BEACON_ROOTS_ADDRESS =\\n        0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02;\\n\\n    /// @notice Returns the beacon block root for the previous block.\\n    /// This comes from the Beacon Roots contract defined in EIP-4788.\\n    /// This will revert if the block is more than 8,191 blocks old as\\n    /// that is the size of the beacon root's ring buffer.\\n    /// @param timestamp The timestamp of the block for which to get the parent root.\\n    /// @return parentRoot The parent block root for the given timestamp.\\n    function parentBlockRoot(uint64 timestamp)\\n        internal\\n        view\\n        returns (bytes32 parentRoot)\\n    {\\n        // Call the Beacon Roots contract to get the parent block root.\\n        // This does not have a function signature, so we use a staticcall.\\n        (bool success, bytes memory result) = BEACON_ROOTS_ADDRESS.staticcall(\\n            abi.encode(timestamp)\\n        );\\n\\n        require(success && result.length > 0, \\\"Invalid beacon timestamp\\\");\\n        parentRoot = abi.decode(result, (bytes32));\\n    }\\n}\\n\",\"keccak256\":\"0x4005989f852a68bbcdc1cdc3472ebd3911395e75b4e6366ffcaae4d1c128691e\",\"license\":\"BUSL-1.1\"},\"contracts/beacon/PartialWithdrawal.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Library to request full or partial withdrawals from validators on the beacon chain.\\n * @author Origin Protocol Inc\\n */\\nlibrary PartialWithdrawal {\\n    /// @notice The address where the withdrawal request is sent to\\n    /// See https://eips.ethereum.org/EIPS/eip-7002\\n    address internal constant WITHDRAWAL_REQUEST_ADDRESS =\\n        0x00000961Ef480Eb55e80D19ad83579A64c007002;\\n\\n    /// @notice Requests a partial withdrawal for a given validator public key and amount.\\n    /// @param validatorPubKey The public key of the validator to withdraw from\\n    /// @param amount The amount of ETH to withdraw\\n    function request(bytes calldata validatorPubKey, uint64 amount)\\n        internal\\n        returns (uint256 fee_)\\n    {\\n        require(validatorPubKey.length == 48, \\\"Invalid validator byte length\\\");\\n        fee_ = fee();\\n\\n        // Call the Withdrawal Request contract with the validator public key\\n        // and amount to be withdrawn packed together\\n\\n        // This is a general purpose EL to CL request:\\n        // https://eips.ethereum.org/EIPS/eip-7685\\n        (bool success, ) = WITHDRAWAL_REQUEST_ADDRESS.call{ value: fee_ }(\\n            abi.encodePacked(validatorPubKey, amount)\\n        );\\n\\n        require(success, \\\"Withdrawal request failed\\\");\\n    }\\n\\n    /// @notice Gets fee for withdrawal requests contract on Beacon chain\\n    function fee() internal view returns (uint256) {\\n        // Get fee from the withdrawal request contract\\n        (bool success, bytes memory result) = WITHDRAWAL_REQUEST_ADDRESS\\n            .staticcall(\\\"\\\");\\n\\n        require(success && result.length > 0, \\\"Failed to get fee\\\");\\n        return abi.decode(result, (uint256));\\n    }\\n}\\n\",\"keccak256\":\"0x80d29153ff7eb5c6841692aca98eb0cc14ac43ad2d8e402890b6c6b6e4a9719d\",\"license\":\"BUSL-1.1\"},\"contracts/governance/Governable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Base for contracts that are managed by the Origin Protocol's Governor.\\n * @dev Copy of the openzeppelin Ownable.sol contract with nomenclature change\\n *      from owner to governor and renounce methods removed. Does not use\\n *      Context.sol like Ownable.sol does for simplification.\\n * @author Origin Protocol Inc\\n */\\nabstract contract Governable {\\n    // Storage position of the owner and pendingOwner of the contract\\n    // keccak256(\\\"OUSD.governor\\\");\\n    bytes32 private constant governorPosition =\\n        0x7bea13895fa79d2831e0a9e28edede30099005a50d652d8957cf8a607ee6ca4a;\\n\\n    // keccak256(\\\"OUSD.pending.governor\\\");\\n    bytes32 private constant pendingGovernorPosition =\\n        0x44c4d30b2eaad5130ad70c3ba6972730566f3e6359ab83e800d905c61b1c51db;\\n\\n    // keccak256(\\\"OUSD.reentry.status\\\");\\n    bytes32 private constant reentryStatusPosition =\\n        0x53bf423e48ed90e97d02ab0ebab13b2a235a6bfbe9c321847d5c175333ac4535;\\n\\n    // See OpenZeppelin ReentrancyGuard implementation\\n    uint256 constant _NOT_ENTERED = 1;\\n    uint256 constant _ENTERED = 2;\\n\\n    event PendingGovernorshipTransfer(\\n        address indexed previousGovernor,\\n        address indexed newGovernor\\n    );\\n\\n    event GovernorshipTransferred(\\n        address indexed previousGovernor,\\n        address indexed newGovernor\\n    );\\n\\n    /**\\n     * @notice Returns the address of the current Governor.\\n     */\\n    function governor() public view returns (address) {\\n        return _governor();\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current Governor.\\n     */\\n    function _governor() internal view returns (address governorOut) {\\n        bytes32 position = governorPosition;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            governorOut := sload(position)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address of the pending Governor.\\n     */\\n    function _pendingGovernor()\\n        internal\\n        view\\n        returns (address pendingGovernor)\\n    {\\n        bytes32 position = pendingGovernorPosition;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            pendingGovernor := sload(position)\\n        }\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the Governor.\\n     */\\n    modifier onlyGovernor() {\\n        require(isGovernor(), \\\"Caller is not the Governor\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Returns true if the caller is the current Governor.\\n     */\\n    function isGovernor() public view returns (bool) {\\n        return msg.sender == _governor();\\n    }\\n\\n    function _setGovernor(address newGovernor) internal {\\n        emit GovernorshipTransferred(_governor(), newGovernor);\\n\\n        bytes32 position = governorPosition;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(position, newGovernor)\\n        }\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        bytes32 position = reentryStatusPosition;\\n        uint256 _reentry_status;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            _reentry_status := sload(position)\\n        }\\n\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_reentry_status != _ENTERED, \\\"Reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(position, _ENTERED)\\n        }\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(position, _NOT_ENTERED)\\n        }\\n    }\\n\\n    function _setPendingGovernor(address newGovernor) internal {\\n        bytes32 position = pendingGovernorPosition;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(position, newGovernor)\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfers Governance of the contract to a new account (`newGovernor`).\\n     * Can only be called by the current Governor. Must be claimed for this to complete\\n     * @param _newGovernor Address of the new Governor\\n     */\\n    function transferGovernance(address _newGovernor) external onlyGovernor {\\n        _setPendingGovernor(_newGovernor);\\n        emit PendingGovernorshipTransfer(_governor(), _newGovernor);\\n    }\\n\\n    /**\\n     * @notice Claim Governance of the contract to a new account (`newGovernor`).\\n     * Can only be called by the new Governor.\\n     */\\n    function claimGovernance() external {\\n        require(\\n            msg.sender == _pendingGovernor(),\\n            \\\"Only the pending Governor can complete the claim\\\"\\n        );\\n        _changeGovernor(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Change Governance of the contract to a new account (`newGovernor`).\\n     * @param _newGovernor Address of the new Governor\\n     */\\n    function _changeGovernor(address _newGovernor) internal {\\n        require(_newGovernor != address(0), \\\"New Governor is address(0)\\\");\\n        _setGovernor(_newGovernor);\\n    }\\n}\\n\",\"keccak256\":\"0xf32f873c8bfbacf2e5f01d0cf37bc7f54fbd5aa656e95c8a599114229946f107\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IBeaconProofs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\ninterface IBeaconProofs {\\n    function verifyValidator(\\n        bytes32 beaconBlockRoot,\\n        bytes32 pubKeyHash,\\n        bytes calldata validatorPubKeyProof,\\n        uint40 validatorIndex,\\n        bytes32 withdrawalCredentials\\n    ) external view;\\n\\n    function verifyValidatorWithdrawable(\\n        bytes32 beaconBlockRoot,\\n        uint40 validatorIndex,\\n        uint64 withdrawableEpoch,\\n        bytes calldata withdrawableEpochProof\\n    ) external view;\\n\\n    function verifyBalancesContainer(\\n        bytes32 beaconBlockRoot,\\n        bytes32 balancesContainerLeaf,\\n        bytes calldata balancesContainerProof\\n    ) external view;\\n\\n    function verifyValidatorBalance(\\n        bytes32 balancesContainerRoot,\\n        bytes32 validatorBalanceLeaf,\\n        bytes calldata balanceProof,\\n        uint40 validatorIndex\\n    ) external view returns (uint256 validatorBalance);\\n\\n    function verifyPendingDepositsContainer(\\n        bytes32 beaconBlockRoot,\\n        bytes32 pendingDepositsContainerRoot,\\n        bytes calldata proof\\n    ) external view;\\n\\n    function verifyPendingDeposit(\\n        bytes32 pendingDepositsContainerRoot,\\n        bytes32 pendingDepositRoot,\\n        bytes calldata proof,\\n        uint32 pendingDepositIndex\\n    ) external view;\\n\\n    function verifyFirstPendingDeposit(\\n        bytes32 beaconBlockRoot,\\n        uint64 slot,\\n        bytes calldata firstPendingDepositSlotProof\\n    ) external view returns (bool isEmptyDepositQueue);\\n\\n    function merkleizePendingDeposit(\\n        bytes32 pubKeyHash,\\n        bytes calldata withdrawalCredentials,\\n        uint64 amountGwei,\\n        bytes calldata signature,\\n        uint64 slot\\n    ) external pure returns (bytes32 root);\\n\\n    function merkleizeSignature(bytes calldata signature)\\n        external\\n        pure\\n        returns (bytes32 root);\\n}\\n\",\"keccak256\":\"0xbc611f259b296451c358638a6e164227179bcee079656f5078800cc2f06c22fd\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IDepositContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IDepositContract {\\n    /// @notice A processed deposit event.\\n    event DepositEvent(\\n        bytes pubkey,\\n        bytes withdrawal_credentials,\\n        bytes amount,\\n        bytes signature,\\n        bytes index\\n    );\\n\\n    /// @notice Submit a Phase 0 DepositData object.\\n    /// @param pubkey A BLS12-381 public key.\\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\\n    /// @param signature A BLS12-381 signature.\\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\\n    /// Used as a protection against malformed input.\\n    function deposit(\\n        bytes calldata pubkey,\\n        bytes calldata withdrawal_credentials,\\n        bytes calldata signature,\\n        bytes32 deposit_data_root\\n    ) external payable;\\n\\n    /// @notice Query the current deposit root hash.\\n    /// @return The deposit root hash.\\n    function get_deposit_root() external view returns (bytes32);\\n\\n    /// @notice Query the current deposit count.\\n    /// @return The deposit count encoded as a little endian 64-bit number.\\n    function get_deposit_count() external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x598f90bdbc854250bbd5991426bfb43367207e64e33109c41aa8b54323fd8d8e\",\"license\":\"MIT\"},\"contracts/interfaces/ISSVNetwork.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nstruct Cluster {\\n    uint32 validatorCount;\\n    uint64 networkFeeIndex;\\n    uint64 index;\\n    bool active;\\n    uint256 balance;\\n}\\n\\ninterface ISSVNetwork {\\n    /**********/\\n    /* Errors */\\n    /**********/\\n\\n    error CallerNotOwner(); // 0x5cd83192\\n    error CallerNotWhitelisted(); // 0x8c6e5d71\\n    error FeeTooLow(); // 0x732f9413\\n    error FeeExceedsIncreaseLimit(); // 0x958065d9\\n    error NoFeeDeclared(); // 0x1d226c30\\n    error ApprovalNotWithinTimeframe(); // 0x97e4b518\\n    error OperatorDoesNotExist(); // 0x961e3e8c\\n    error InsufficientBalance(); // 0xf4d678b8\\n    error ValidatorDoesNotExist(); // 0xe51315d2\\n    error ClusterNotLiquidatable(); // 0x60300a8d\\n    error InvalidPublicKeyLength(); // 0x637297a4\\n    error InvalidOperatorIdsLength(); // 0x38186224\\n    error ClusterAlreadyEnabled(); // 0x3babafd2\\n    error ClusterIsLiquidated(); // 0x95a0cf33\\n    error ClusterDoesNotExists(); // 0x185e2b16\\n    error IncorrectClusterState(); // 0x12e04c87\\n    error UnsortedOperatorsList(); // 0xdd020e25\\n    error NewBlockPeriodIsBelowMinimum(); // 0x6e6c9cac\\n    error ExceedValidatorLimit(); // 0x6df5ab76\\n    error TokenTransferFailed(); // 0x045c4b02\\n    error SameFeeChangeNotAllowed(); // 0xc81272f8\\n    error FeeIncreaseNotAllowed(); // 0x410a2b6c\\n    error NotAuthorized(); // 0xea8e4eb5\\n    error OperatorsListNotUnique(); // 0xa5a1ff5d\\n    error OperatorAlreadyExists(); // 0x289c9494\\n    error TargetModuleDoesNotExist(); // 0x8f9195fb\\n    error MaxValueExceeded(); // 0x91aa3017\\n    error FeeTooHigh(); // 0xcd4e6167\\n    error PublicKeysSharesLengthMismatch(); // 0x9ad467b8\\n    error IncorrectValidatorStateWithData(bytes publicKey); // 0x89307938\\n    error ValidatorAlreadyExistsWithData(bytes publicKey); // 0x388e7999\\n    error EmptyPublicKeysList(); // df83e679\\n\\n    // legacy errors\\n    error ValidatorAlreadyExists(); // 0x8d09a73e\\n    error IncorrectValidatorState(); // 0x2feda3c1\\n\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n    event BeaconUpgraded(address indexed beacon);\\n    event ClusterDeposited(\\n        address indexed owner,\\n        uint64[] operatorIds,\\n        uint256 value,\\n        Cluster cluster\\n    );\\n    event ClusterLiquidated(\\n        address indexed owner,\\n        uint64[] operatorIds,\\n        Cluster cluster\\n    );\\n    event ClusterReactivated(\\n        address indexed owner,\\n        uint64[] operatorIds,\\n        Cluster cluster\\n    );\\n    event ClusterWithdrawn(\\n        address indexed owner,\\n        uint64[] operatorIds,\\n        uint256 value,\\n        Cluster cluster\\n    );\\n    event DeclareOperatorFeePeriodUpdated(uint64 value);\\n    event ExecuteOperatorFeePeriodUpdated(uint64 value);\\n    event FeeRecipientAddressUpdated(\\n        address indexed owner,\\n        address recipientAddress\\n    );\\n    event Initialized(uint8 version);\\n    event LiquidationThresholdPeriodUpdated(uint64 value);\\n    event MinimumLiquidationCollateralUpdated(uint256 value);\\n    event NetworkEarningsWithdrawn(uint256 value, address recipient);\\n    event NetworkFeeUpdated(uint256 oldFee, uint256 newFee);\\n    event OperatorAdded(\\n        uint64 indexed operatorId,\\n        address indexed owner,\\n        bytes publicKey,\\n        uint256 fee\\n    );\\n    event OperatorFeeDeclarationCancelled(\\n        address indexed owner,\\n        uint64 indexed operatorId\\n    );\\n    event OperatorFeeDeclared(\\n        address indexed owner,\\n        uint64 indexed operatorId,\\n        uint256 blockNumber,\\n        uint256 fee\\n    );\\n    event OperatorFeeExecuted(\\n        address indexed owner,\\n        uint64 indexed operatorId,\\n        uint256 blockNumber,\\n        uint256 fee\\n    );\\n    event OperatorFeeIncreaseLimitUpdated(uint64 value);\\n    event OperatorMaximumFeeUpdated(uint64 maxFee);\\n    event OperatorRemoved(uint64 indexed operatorId);\\n    event OperatorWhitelistUpdated(\\n        uint64 indexed operatorId,\\n        address whitelisted\\n    );\\n    event OperatorWithdrawn(\\n        address indexed owner,\\n        uint64 indexed operatorId,\\n        uint256 value\\n    );\\n    event OwnershipTransferStarted(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n    event Upgraded(address indexed implementation);\\n    event ValidatorAdded(\\n        address indexed owner,\\n        uint64[] operatorIds,\\n        bytes publicKey,\\n        bytes shares,\\n        Cluster cluster\\n    );\\n    event ValidatorExited(\\n        address indexed owner,\\n        uint64[] operatorIds,\\n        bytes publicKey\\n    );\\n    event ValidatorRemoved(\\n        address indexed owner,\\n        uint64[] operatorIds,\\n        bytes publicKey,\\n        Cluster cluster\\n    );\\n\\n    fallback() external;\\n\\n    function acceptOwnership() external;\\n\\n    function cancelDeclaredOperatorFee(uint64 operatorId) external;\\n\\n    function declareOperatorFee(uint64 operatorId, uint256 fee) external;\\n\\n    function deposit(\\n        address clusterOwner,\\n        uint64[] memory operatorIds,\\n        uint256 amount,\\n        Cluster memory cluster\\n    ) external;\\n\\n    function executeOperatorFee(uint64 operatorId) external;\\n\\n    function exitValidator(bytes memory publicKey, uint64[] memory operatorIds)\\n        external;\\n\\n    function bulkExitValidator(\\n        bytes[] calldata publicKeys,\\n        uint64[] calldata operatorIds\\n    ) external;\\n\\n    function getVersion() external pure returns (string memory version);\\n\\n    function initialize(\\n        address token_,\\n        address ssvOperators_,\\n        address ssvClusters_,\\n        address ssvDAO_,\\n        address ssvViews_,\\n        uint64 minimumBlocksBeforeLiquidation_,\\n        uint256 minimumLiquidationCollateral_,\\n        uint32 validatorsPerOperatorLimit_,\\n        uint64 declareOperatorFeePeriod_,\\n        uint64 executeOperatorFeePeriod_,\\n        uint64 operatorMaxFeeIncrease_\\n    ) external;\\n\\n    function liquidate(\\n        address clusterOwner,\\n        uint64[] memory operatorIds,\\n        Cluster memory cluster\\n    ) external;\\n\\n    function owner() external view returns (address);\\n\\n    function pendingOwner() external view returns (address);\\n\\n    function proxiableUUID() external view returns (bytes32);\\n\\n    function reactivate(\\n        uint64[] memory operatorIds,\\n        uint256 amount,\\n        Cluster memory cluster\\n    ) external;\\n\\n    function reduceOperatorFee(uint64 operatorId, uint256 fee) external;\\n\\n    function registerOperator(bytes memory publicKey, uint256 fee)\\n        external\\n        returns (uint64 id);\\n\\n    function registerValidator(\\n        bytes memory publicKey,\\n        uint64[] memory operatorIds,\\n        bytes memory sharesData,\\n        uint256 amount,\\n        Cluster memory cluster\\n    ) external;\\n\\n    function bulkRegisterValidator(\\n        bytes[] calldata publicKeys,\\n        uint64[] calldata operatorIds,\\n        bytes[] calldata sharesData,\\n        uint256 amount,\\n        Cluster memory cluster\\n    ) external;\\n\\n    function removeOperator(uint64 operatorId) external;\\n\\n    function removeValidator(\\n        bytes memory publicKey,\\n        uint64[] memory operatorIds,\\n        Cluster memory cluster\\n    ) external;\\n\\n    function bulkRemoveValidator(\\n        bytes[] calldata publicKeys,\\n        uint64[] calldata operatorIds,\\n        Cluster memory cluster\\n    ) external;\\n\\n    function renounceOwnership() external;\\n\\n    function setFeeRecipientAddress(address recipientAddress) external;\\n\\n    function setOperatorWhitelist(uint64 operatorId, address whitelisted)\\n        external;\\n\\n    function transferOwnership(address newOwner) external;\\n\\n    function updateDeclareOperatorFeePeriod(uint64 timeInSeconds) external;\\n\\n    function updateExecuteOperatorFeePeriod(uint64 timeInSeconds) external;\\n\\n    function updateLiquidationThresholdPeriod(uint64 blocks) external;\\n\\n    function updateMaximumOperatorFee(uint64 maxFee) external;\\n\\n    function updateMinimumLiquidationCollateral(uint256 amount) external;\\n\\n    function updateModule(uint8 moduleId, address moduleAddress) external;\\n\\n    function updateNetworkFee(uint256 fee) external;\\n\\n    function updateOperatorFeeIncreaseLimit(uint64 percentage) external;\\n\\n    function upgradeTo(address newImplementation) external;\\n\\n    function upgradeToAndCall(address newImplementation, bytes memory data)\\n        external\\n        payable;\\n\\n    function withdraw(\\n        uint64[] memory operatorIds,\\n        uint256 amount,\\n        Cluster memory cluster\\n    ) external;\\n\\n    function withdrawAllOperatorEarnings(uint64 operatorId) external;\\n\\n    function withdrawNetworkEarnings(uint256 amount) external;\\n\\n    function withdrawOperatorEarnings(uint64 operatorId, uint256 amount)\\n        external;\\n}\\n\",\"keccak256\":\"0xbd86cb74702aebc5b53c8fc738a2e3ad1b410583460617be84b22ce922af12a7\",\"license\":\"MIT\"},\"contracts/interfaces/IWETH9.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IWETH9 {\\n    event Approval(address indexed src, address indexed guy, uint256 wad);\\n    event Deposit(address indexed dst, uint256 wad);\\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\\n    event Withdrawal(address indexed src, uint256 wad);\\n\\n    function allowance(address, address) external view returns (uint256);\\n\\n    function approve(address guy, uint256 wad) external returns (bool);\\n\\n    function balanceOf(address) external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function deposit() external payable;\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function transfer(address dst, uint256 wad) external returns (bool);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 wad\\n    ) external returns (bool);\\n\\n    function withdraw(uint256 wad) external;\\n}\\n\",\"keccak256\":\"0x05b7dce6c24d3cd4e48b5c6346d86e5e40ecc3291bcdf3f3ef091c98fc826519\",\"license\":\"MIT\"},\"contracts/strategies/NativeStaking/CompoundingStakingView.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport { CompoundingValidatorManager } from \\\"./CompoundingValidatorManager.sol\\\";\\n\\n/**\\n * @title Viewing contract for the Compounding Staking Strategy.\\n * @author Origin Protocol Inc\\n */\\ncontract CompoundingStakingStrategyView {\\n    /// @notice The address of the Compounding Staking Strategy contract\\n    CompoundingValidatorManager public immutable stakingStrategy;\\n\\n    constructor(address _stakingStrategy) {\\n        stakingStrategy = CompoundingValidatorManager(_stakingStrategy);\\n    }\\n\\n    struct ValidatorView {\\n        bytes32 pubKeyHash;\\n        uint64 index;\\n        CompoundingValidatorManager.ValidatorState state;\\n    }\\n\\n    struct DepositView {\\n        bytes32 pendingDepositRoot;\\n        bytes32 pubKeyHash;\\n        uint64 amountGwei;\\n        uint64 slot;\\n    }\\n\\n    /// @notice Returns the strategy's active validators.\\n    /// These are the ones that have been verified and have a non-zero balance.\\n    /// @return validators An array of `ValidatorView` containing the public key hash, validator index and state.\\n    function getVerifiedValidators()\\n        external\\n        view\\n        returns (ValidatorView[] memory validators)\\n    {\\n        uint256 validatorCount = stakingStrategy.verifiedValidatorsLength();\\n        validators = new ValidatorView[](validatorCount);\\n        for (uint256 i = 0; i < validatorCount; ++i) {\\n            bytes32 pubKeyHash = stakingStrategy.verifiedValidators(i);\\n            (\\n                CompoundingValidatorManager.ValidatorState state,\\n                uint64 index\\n            ) = stakingStrategy.validator(pubKeyHash);\\n            validators[i] = ValidatorView({\\n                pubKeyHash: pubKeyHash,\\n                index: index,\\n                state: state\\n            });\\n        }\\n    }\\n\\n    /// @notice Returns the deposits that are still to be verified.\\n    /// These may or may not have been processed by the beacon chain.\\n    /// @return pendingDeposits An array of `DepositView` containing the deposit ID, public key hash,\\n    /// amount in Gwei and the slot of the deposit.\\n    function getPendingDeposits()\\n        external\\n        view\\n        returns (DepositView[] memory pendingDeposits)\\n    {\\n        uint256 depositsCount = stakingStrategy.depositListLength();\\n        pendingDeposits = new DepositView[](depositsCount);\\n        for (uint256 i = 0; i < depositsCount; ++i) {\\n            (\\n                bytes32 pubKeyHash,\\n                uint64 amountGwei,\\n                uint64 slot,\\n                ,\\n\\n            ) = stakingStrategy.deposits(stakingStrategy.depositList(i));\\n            pendingDeposits[i] = DepositView({\\n                pendingDepositRoot: stakingStrategy.depositList(i),\\n                pubKeyHash: pubKeyHash,\\n                amountGwei: amountGwei,\\n                slot: slot\\n            });\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x34d802a22f83c82e40a166d6589e8a471137971d2c5a5b302e579d245beac2c2\",\"license\":\"BUSL-1.1\"},\"contracts/strategies/NativeStaking/CompoundingValidatorManager.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { SafeCast } from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport { Math } from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { Pausable } from \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport { Governable } from \\\"../../governance/Governable.sol\\\";\\nimport { IDepositContract } from \\\"../../interfaces/IDepositContract.sol\\\";\\nimport { IWETH9 } from \\\"../../interfaces/IWETH9.sol\\\";\\nimport { ISSVNetwork, Cluster } from \\\"../../interfaces/ISSVNetwork.sol\\\";\\nimport { BeaconRoots } from \\\"../../beacon/BeaconRoots.sol\\\";\\nimport { PartialWithdrawal } from \\\"../../beacon/PartialWithdrawal.sol\\\";\\nimport { IBeaconProofs } from \\\"../../interfaces/IBeaconProofs.sol\\\";\\n\\n/**\\n * @title Validator lifecycle management contract\\n * @notice This contract implements all the required functionality to\\n * register, deposit, withdraw, exit and remove validators.\\n * @author Origin Protocol Inc\\n */\\nabstract contract CompoundingValidatorManager is Governable, Pausable {\\n    using SafeERC20 for IERC20;\\n\\n    /// @dev The amount of ETH in wei that is required for a deposit to a new validator.\\n    uint256 internal constant DEPOSIT_AMOUNT_WEI = 1 ether;\\n    /// @dev Validator balances over this amount will eventually become active on the beacon chain.\\n    /// Due to hysteresis, if the effective balance is 31 ETH, the actual balance\\n    /// must rise to 32.25 ETH to trigger an effective balance update to 32 ETH.\\n    /// https://eth2book.info/capella/part2/incentives/balances/#hysteresis\\n    uint256 internal constant MIN_ACTIVATION_BALANCE_GWEI = 32.25 ether / 1e9;\\n    /// @dev The maximum number of deposits that are waiting to be verified as processed on the beacon chain.\\n    uint256 internal constant MAX_DEPOSITS = 32;\\n    /// @dev The maximum number of validators that can be verified.\\n    uint256 internal constant MAX_VERIFIED_VALIDATORS = 48;\\n    /// @dev The default withdrawable epoch value on the Beacon chain.\\n    /// A value in the far future means the validator is not exiting.\\n    uint64 internal constant FAR_FUTURE_EPOCH = type(uint64).max;\\n    /// @dev The number of seconds between each beacon chain slot.\\n    uint64 internal constant SLOT_DURATION = 12;\\n    /// @dev The number of slots in each beacon chain epoch.\\n    uint64 internal constant SLOTS_PER_EPOCH = 32;\\n    /// @dev Minimum time in seconds to allow snapped balances to be verified.\\n    /// Set to 35 slots which is 3 slots more than 1 epoch (32 slots). Deposits get processed\\n    /// once per epoch. This larger than 1 epoch delay should achieve that `snapBalances` sometimes\\n    /// get called in the middle (or towards the end) of the epoch. Giving the off-chain script\\n    /// sufficient time after the end of the epoch to prepare the proofs and call `verifyBalances`.\\n    /// This is considering a malicious actor would keep calling `snapBalances` as frequent as possible\\n    /// to disturb our operations.\\n    uint64 internal constant SNAP_BALANCES_DELAY = 35 * SLOT_DURATION;\\n\\n    /// @notice The address of the Wrapped ETH (WETH) token contract\\n    address internal immutable WETH;\\n    /// @notice The address of the beacon chain deposit contract\\n    address internal immutable BEACON_CHAIN_DEPOSIT_CONTRACT;\\n    /// @notice The address of the SSV Network contract used to interface with\\n    address internal immutable SSV_NETWORK;\\n    /// @notice Address of the OETH Vault proxy contract\\n    address internal immutable VAULT_ADDRESS;\\n    /// @notice Address of the Beacon Proofs contract that verifies beacon chain data\\n    address public immutable BEACON_PROOFS;\\n    /// @notice The timestamp of the Beacon chain genesis.\\n    /// @dev this is different on Testnets like Hoodi so is set at deployment time.\\n    uint64 internal immutable BEACON_GENESIS_TIMESTAMP;\\n\\n    /// @notice Address of the registrator - allowed to register, withdraw, exit and remove validators\\n    address public validatorRegistrator;\\n\\n    /// @notice Deposit data for new compounding validators.\\n    /// @dev A `VERIFIED` deposit can mean 3 separate things:\\n    ///      - a deposit has been processed by the beacon chain and shall be included in the\\n    ///        balance of the next verifyBalances call\\n    ///      - a deposit has been done to a slashed validator and has probably been recovered\\n    ///        back to this strategy. Probably because we can not know for certain. This contract\\n    ///        only detects when the validator has passed its withdrawal epoch. It is close to impossible\\n    ///        to prove with Merkle Proofs that the postponed deposit this contract is responsible for\\n    ///        creating is not present anymore in BeaconChain.state.pending_deposits. This in effect\\n    ///        means that there might be a period where this contract thinks the deposit has been already\\n    ///        returned as ETH balance before it happens. This will result in some days (or weeks)\\n    ///        -> depending on the size of deposit queue of showing a deficit when calling `checkBalance`.\\n    ///        As this only offsets the yield and doesn't cause a critical double-counting we are not addressing\\n    ///        this issue.\\n    ///      - A deposit has been done to the validator, but our deposit has been front run by a malicious\\n    ///        actor. Funds in the deposit this contract makes are not recoverable.\\n    enum DepositStatus {\\n        UNKNOWN, // default value\\n        PENDING, // deposit is pending and waiting to be  verified\\n        VERIFIED // deposit has been verified\\n    }\\n\\n    /// @param pubKeyHash Hash of validator's public key using the Beacon Chain's format\\n    /// @param amountGwei Amount of ETH in gwei that has been deposited to the beacon chain deposit contract\\n    /// @param slot The beacon chain slot number when the deposit has been made\\n    /// @param depositIndex The index of the deposit in the list of active deposits\\n    /// @param status The status of the deposit, either UNKNOWN, PENDING or VERIFIED\\n    struct DepositData {\\n        bytes32 pubKeyHash;\\n        uint64 amountGwei;\\n        uint64 slot;\\n        uint32 depositIndex;\\n        DepositStatus status;\\n    }\\n    /// @notice Restricts to only one deposit to an unverified validator at a time.\\n    /// This is to limit front-running attacks of deposits to the beacon chain contract.\\n    ///\\n    /// @dev The value is set to true when a deposit to a new validator has been done that has\\n    /// not yet be verified.\\n    bool public firstDeposit;\\n    /// @notice Mapping of the pending deposit roots to the deposit data\\n    mapping(bytes32 => DepositData) public deposits;\\n    /// @notice List of strategy deposit IDs to a validator.\\n    /// The ID is the merkle root of the pending deposit data which is unique for each validator, amount and block.\\n    /// Duplicate pending deposit roots are prevented so can be used as an identifier to each strategy deposit.\\n    /// The list can be for deposits waiting to be verified as processed on the beacon chain,\\n    /// or deposits that have been verified to an exiting validator and is now waiting for the\\n    /// validator's balance to be swept.\\n    /// The list may not be ordered by time of deposit.\\n    /// Removed deposits will move the last deposit to the removed index.\\n    bytes32[] public depositList;\\n\\n    enum ValidatorState {\\n        NON_REGISTERED, // validator is not registered on the SSV network\\n        REGISTERED, // validator is registered on the SSV network\\n        STAKED, // validator has funds staked\\n        VERIFIED, // validator has been verified to exist on the beacon chain\\n        ACTIVE, // The validator balance is at least 32 ETH. The validator may not yet be active on the beacon chain.\\n        EXITING, // The validator has been requested to exit\\n        EXITED, // The validator has been verified to have a zero balance\\n        REMOVED, // validator has funds withdrawn to this strategy contract and is removed from the SSV\\n        INVALID // The validator has been front-run and the withdrawal address is not this strategy\\n    }\\n\\n    // Validator data\\n    struct ValidatorData {\\n        ValidatorState state; // The state of the validator known to this contract\\n        uint40 index; // The index of the validator on the beacon chain\\n    }\\n    /// @notice List of validator public key hashes that have been verified to exist on the beacon chain.\\n    /// These have had a deposit processed and the validator's balance increased.\\n    /// Validators will be removed from this list when its verified they have a zero balance.\\n    bytes32[] public verifiedValidators;\\n    /// @notice Mapping of the hash of the validator's public key to the validator state and index.\\n    /// Uses the Beacon chain hashing for BLSPubkey which is sha256(abi.encodePacked(validator.pubkey, bytes16(0)))\\n    mapping(bytes32 => ValidatorData) public validator;\\n\\n    /// @param blockRoot Beacon chain block root of the snapshot\\n    /// @param timestamp Timestamp of the snapshot\\n    /// @param ethBalance The balance of ETH in the strategy contract at the snapshot\\n    struct Balances {\\n        bytes32 blockRoot;\\n        uint64 timestamp;\\n        uint128 ethBalance;\\n    }\\n    /// @notice Mapping of the block root to the balances at that slot\\n    Balances public snappedBalance;\\n    /// @notice The last verified ETH balance of the strategy\\n    uint256 public lastVerifiedEthBalance;\\n\\n    /// @dev This contract receives WETH as the deposit asset, but unlike other strategies doesn't immediately\\n    /// deposit it to an underlying platform. Rather a special privilege account stakes it to the validators.\\n    /// For that reason calling WETH.balanceOf(this) in a deposit function can contain WETH that has just been\\n    /// deposited and also WETH that has previously been deposited. To keep a correct count we need to keep track\\n    /// of WETH that has already been accounted for.\\n    /// This value represents the amount of WETH balance of this contract that has already been accounted for by the\\n    /// deposit events.\\n    /// It is important to note that this variable is not concerned with WETH that is a result of full/partial\\n    /// withdrawal of the validators. It is strictly concerned with WETH that has been deposited and is waiting to\\n    /// be staked.\\n    uint256 public depositedWethAccountedFor;\\n\\n    // For future use\\n    uint256[41] private __gap;\\n\\n    event RegistratorChanged(address indexed newAddress);\\n    event FirstDepositReset();\\n    event SSVValidatorRegistered(\\n        bytes32 indexed pubKeyHash,\\n        uint64[] operatorIds\\n    );\\n    event SSVValidatorRemoved(bytes32 indexed pubKeyHash, uint64[] operatorIds);\\n    event ETHStaked(\\n        bytes32 indexed pubKeyHash,\\n        bytes32 indexed pendingDepositRoot,\\n        bytes pubKey,\\n        uint256 amountWei\\n    );\\n    event ValidatorVerified(\\n        bytes32 indexed pubKeyHash,\\n        uint40 indexed validatorIndex\\n    );\\n    event ValidatorInvalid(bytes32 indexed pubKeyHash);\\n    event DepositVerified(\\n        bytes32 indexed pendingDepositRoot,\\n        uint256 amountWei\\n    );\\n    event ValidatorWithdraw(bytes32 indexed pubKeyHash, uint256 amountWei);\\n    event BalancesSnapped(bytes32 indexed blockRoot, uint256 ethBalance);\\n    event BalancesVerified(\\n        uint64 indexed timestamp,\\n        uint256 totalDepositsWei,\\n        uint256 totalValidatorBalance,\\n        uint256 ethBalance\\n    );\\n\\n    /// @dev Throws if called by any account other than the Registrator\\n    modifier onlyRegistrator() {\\n        require(msg.sender == validatorRegistrator, \\\"Not Registrator\\\");\\n        _;\\n    }\\n\\n    /// @dev Throws if called by any account other than the Registrator or Governor\\n    modifier onlyRegistratorOrGovernor() {\\n        require(\\n            msg.sender == validatorRegistrator || isGovernor(),\\n            \\\"Not Registrator or Governor\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @param _wethAddress Address of the Erc20 WETH Token contract\\n    /// @param _vaultAddress Address of the Vault\\n    /// @param _beaconChainDepositContract Address of the beacon chain deposit contract\\n    /// @param _ssvNetwork Address of the SSV Network contract\\n    /// @param _beaconProofs Address of the Beacon Proofs contract that verifies beacon chain data\\n    /// @param _beaconGenesisTimestamp The timestamp of the Beacon chain's genesis.\\n    constructor(\\n        address _wethAddress,\\n        address _vaultAddress,\\n        address _beaconChainDepositContract,\\n        address _ssvNetwork,\\n        address _beaconProofs,\\n        uint64 _beaconGenesisTimestamp\\n    ) {\\n        WETH = _wethAddress;\\n        BEACON_CHAIN_DEPOSIT_CONTRACT = _beaconChainDepositContract;\\n        SSV_NETWORK = _ssvNetwork;\\n        VAULT_ADDRESS = _vaultAddress;\\n        BEACON_PROOFS = _beaconProofs;\\n        BEACON_GENESIS_TIMESTAMP = _beaconGenesisTimestamp;\\n\\n        require(\\n            block.timestamp > _beaconGenesisTimestamp,\\n            \\\"Invalid genesis timestamp\\\"\\n        );\\n    }\\n\\n    /**\\n     *\\n     *             Admin Functions\\n     *\\n     */\\n\\n    /// @notice Set the address of the registrator which can register, exit and remove validators\\n    function setRegistrator(address _address) external onlyGovernor {\\n        validatorRegistrator = _address;\\n        emit RegistratorChanged(_address);\\n    }\\n\\n    /// @notice Reset the `firstDeposit` flag to false so deposits to unverified validators can be made again.\\n    function resetFirstDeposit() external onlyGovernor {\\n        require(firstDeposit, \\\"No first deposit\\\");\\n\\n        firstDeposit = false;\\n\\n        emit FirstDepositReset();\\n    }\\n\\n    function pause() external onlyRegistratorOrGovernor {\\n        _pause();\\n    }\\n\\n    function unPause() external onlyGovernor {\\n        _unpause();\\n    }\\n\\n    /**\\n     *\\n     *             Validator Management\\n     *\\n     */\\n\\n    /// @notice Registers a single validator in a SSV Cluster.\\n    /// Only the Registrator can call this function.\\n    /// @param publicKey The public key of the validator\\n    /// @param operatorIds The operator IDs of the SSV Cluster\\n    /// @param sharesData The shares data for the validator\\n    /// @param ssvAmount The amount of SSV tokens to be deposited to the SSV cluster\\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\\n    // slither-disable-start reentrancy-no-eth\\n    function registerSsvValidator(\\n        bytes calldata publicKey,\\n        uint64[] calldata operatorIds,\\n        bytes calldata sharesData,\\n        uint256 ssvAmount,\\n        Cluster calldata cluster\\n    ) external onlyRegistrator whenNotPaused {\\n        // Hash the public key using the Beacon Chain's format\\n        bytes32 pubKeyHash = _hashPubKey(publicKey);\\n        // Check each public key has not already been used\\n        require(\\n            validator[pubKeyHash].state == ValidatorState.NON_REGISTERED,\\n            \\\"Validator already registered\\\"\\n        );\\n\\n        // Store the validator state as registered\\n        validator[pubKeyHash].state = ValidatorState.REGISTERED;\\n\\n        ISSVNetwork(SSV_NETWORK).registerValidator(\\n            publicKey,\\n            operatorIds,\\n            sharesData,\\n            ssvAmount,\\n            cluster\\n        );\\n\\n        emit SSVValidatorRegistered(pubKeyHash, operatorIds);\\n    }\\n\\n    // slither-disable-end reentrancy-no-eth\\n\\n    struct ValidatorStakeData {\\n        bytes pubkey;\\n        bytes signature;\\n        bytes32 depositDataRoot;\\n    }\\n\\n    /// @notice Stakes WETH in this strategy to a compounding validator.\\n    /// The first deposit to a new validator, the amount must be 1 ETH.\\n    /// Another deposit of at least 31 ETH is required for the validator to be activated.\\n    /// This second deposit has to be done after the validator has been verified.\\n    /// Does not convert any ETH sitting in this strategy to WETH.\\n    /// There can not be two deposits to the same validator in the same block for the same amount.\\n    /// Function is pausable so in case a run-away Registrator can be prevented from continuing\\n    /// to deposit funds to slashed or undesired validators.\\n    /// @param validatorStakeData validator data needed to stake.\\n    /// The `ValidatorStakeData` struct contains the pubkey, signature and depositDataRoot.\\n    /// Only the registrator can call this function.\\n    /// @param depositAmountGwei The amount of WETH to stake to the validator in Gwei.\\n    // slither-disable-start reentrancy-eth,reentrancy-no-eth\\n    function stakeEth(\\n        ValidatorStakeData calldata validatorStakeData,\\n        uint64 depositAmountGwei\\n    ) external onlyRegistrator whenNotPaused {\\n        uint256 depositAmountWei = uint256(depositAmountGwei) * 1 gwei;\\n        // Check there is enough WETH from the deposits sitting in this strategy contract\\n        // There could be ETH from withdrawals but we'll ignore that. If it's really needed\\n        // the ETH can be withdrawn and then deposited back to the strategy.\\n        require(\\n            depositAmountWei <= IWETH9(WETH).balanceOf(address(this)),\\n            \\\"Insufficient WETH\\\"\\n        );\\n        require(depositList.length < MAX_DEPOSITS, \\\"Max deposits\\\");\\n\\n        // Convert required ETH from WETH and do the necessary accounting\\n        _convertWethToEth(depositAmountWei);\\n\\n        // Hash the public key using the Beacon Chain's hashing for BLSPubkey\\n        bytes32 pubKeyHash = _hashPubKey(validatorStakeData.pubkey);\\n        ValidatorState currentState = validator[pubKeyHash].state;\\n        // Can only stake to a validator that has been registered, verified or active.\\n        // Can not stake to a validator that has been staked but not yet verified.\\n        require(\\n            (currentState == ValidatorState.REGISTERED ||\\n                currentState == ValidatorState.VERIFIED ||\\n                currentState == ValidatorState.ACTIVE),\\n            \\\"Not registered or verified\\\"\\n        );\\n        require(depositAmountWei >= 1 ether, \\\"Deposit too small\\\");\\n        if (currentState == ValidatorState.REGISTERED) {\\n            // Can only have one pending deposit to an unverified validator at a time.\\n            // This is to limit front-running deposit attacks to a single deposit.\\n            // The exiting deposit needs to be verified before another deposit can be made.\\n            // If there was a front-running attack, the validator needs to be verified as invalid\\n            // and the Governor calls `resetFirstDeposit` to set `firstDeposit` to false.\\n            require(!firstDeposit, \\\"Existing first deposit\\\");\\n            // Limits the amount of ETH that can be at risk from a front-running deposit attack.\\n            require(\\n                depositAmountWei == DEPOSIT_AMOUNT_WEI,\\n                \\\"Invalid first deposit amount\\\"\\n            );\\n            // Limits the number of validator balance proofs to verifyBalances\\n            require(\\n                verifiedValidators.length + 1 <= MAX_VERIFIED_VALIDATORS,\\n                \\\"Max validators\\\"\\n            );\\n\\n            // Flag a deposit to an unverified validator so no other deposits can be made\\n            // to an unverified validator.\\n            firstDeposit = true;\\n            validator[pubKeyHash].state = ValidatorState.STAKED;\\n        }\\n\\n        /* 0x02 to indicate that withdrawal credentials are for a compounding validator\\n         * that was introduced with the Pectra upgrade.\\n         * bytes11(0) to fill up the required zeros\\n         * remaining bytes20 are for the address\\n         */\\n        bytes memory withdrawalCredentials = abi.encodePacked(\\n            bytes1(0x02),\\n            bytes11(0),\\n            address(this)\\n        );\\n\\n        /// After the Pectra upgrade the validators have a new restriction when proposing\\n        /// blocks. The timestamps are at strict intervals of 12 seconds from the genesis block\\n        /// forward. Each slot is created at strict 12 second intervals and those slots can\\n        /// either have blocks attached to them or not. This way using the block.timestamp\\n        /// the slot number can easily be calculated.\\n        uint64 depositSlot = (SafeCast.toUint64(block.timestamp) -\\n            BEACON_GENESIS_TIMESTAMP) / SLOT_DURATION;\\n\\n        // Calculate the merkle root of the beacon chain pending deposit data.\\n        // This is used as the unique ID of the deposit.\\n        bytes32 pendingDepositRoot = IBeaconProofs(BEACON_PROOFS)\\n            .merkleizePendingDeposit(\\n                pubKeyHash,\\n                withdrawalCredentials,\\n                depositAmountGwei,\\n                validatorStakeData.signature,\\n                depositSlot\\n            );\\n        require(\\n            deposits[pendingDepositRoot].status == DepositStatus.UNKNOWN,\\n            \\\"Duplicate deposit\\\"\\n        );\\n\\n        // Store the deposit data for verifyDeposit and verifyBalances\\n        deposits[pendingDepositRoot] = DepositData({\\n            pubKeyHash: pubKeyHash,\\n            amountGwei: depositAmountGwei,\\n            slot: depositSlot,\\n            depositIndex: SafeCast.toUint32(depositList.length),\\n            status: DepositStatus.PENDING\\n        });\\n        depositList.push(pendingDepositRoot);\\n\\n        // Deposit to the Beacon Chain deposit contract.\\n        // This will create a deposit in the beacon chain's pending deposit queue.\\n        IDepositContract(BEACON_CHAIN_DEPOSIT_CONTRACT).deposit{\\n            value: depositAmountWei\\n        }(\\n            validatorStakeData.pubkey,\\n            withdrawalCredentials,\\n            validatorStakeData.signature,\\n            validatorStakeData.depositDataRoot\\n        );\\n\\n        emit ETHStaked(\\n            pubKeyHash,\\n            pendingDepositRoot,\\n            validatorStakeData.pubkey,\\n            depositAmountWei\\n        );\\n    }\\n\\n    // slither-disable-end reentrancy-eth,reentrancy-no-eth\\n\\n    /// @notice Request a full or partial withdrawal from a validator.\\n    /// A zero amount will trigger a full withdrawal.\\n    /// If the remaining balance is < 32 ETH then only the amount in excess of 32 ETH will be withdrawn.\\n    /// Only the Registrator can call this function.\\n    /// 1 wei of value should be sent with the tx to pay for the withdrawal request fee.\\n    /// If no value sent, 1 wei will be taken from the strategy's ETH balance if it has any.\\n    /// If no ETH balance, the tx will revert.\\n    /// @param publicKey The public key of the validator\\n    /// @param amountGwei The amount of ETH to be withdrawn from the validator in Gwei.\\n    /// A zero amount will trigger a full withdrawal.\\n    // slither-disable-start reentrancy-no-eth\\n    function validatorWithdrawal(bytes calldata publicKey, uint64 amountGwei)\\n        external\\n        payable\\n        onlyRegistrator\\n    {\\n        // Hash the public key using the Beacon Chain's format\\n        bytes32 pubKeyHash = _hashPubKey(publicKey);\\n        ValidatorData memory validatorDataMem = validator[pubKeyHash];\\n        // Validator full withdrawal could be denied due to multiple reasons:\\n        //  - the validator has not been activated or active long enough\\n        //    (current_epoch < activation_epoch + SHARD_COMMITTEE_PERIOD)\\n        //  - the validator has pending balance to withdraw from a previous partial withdrawal request\\n        //\\n        // Meaning that the on-chain to beacon chain full withdrawal request could fail. Instead\\n        // of adding complexity of verifying if a validator is eligible for a full exit, we allow\\n        // multiple full withdrawal requests per validator.\\n        require(\\n            validatorDataMem.state == ValidatorState.ACTIVE ||\\n                validatorDataMem.state == ValidatorState.EXITING,\\n            \\\"Validator not active/exiting\\\"\\n        );\\n\\n        // If a full withdrawal (validator exit)\\n        if (amountGwei == 0) {\\n            // For each staking strategy's deposits\\n            uint256 depositsCount = depositList.length;\\n            for (uint256 i = 0; i < depositsCount; ++i) {\\n                bytes32 pendingDepositRoot = depositList[i];\\n                // Check there is no pending deposits to the exiting validator\\n                require(\\n                    pubKeyHash != deposits[pendingDepositRoot].pubKeyHash,\\n                    \\\"Pending deposit\\\"\\n                );\\n            }\\n\\n            // Store the validator state as exiting so no more deposits can be made to it.\\n            // This may already be EXITING if the previous exit request failed. eg the validator\\n            // was not active long enough.\\n            validator[pubKeyHash].state = ValidatorState.EXITING;\\n        }\\n\\n        // Do not remove from the list of verified validators.\\n        // This is done in the verifyBalances function once the validator's balance has been verified to be zero.\\n        // The validator state will be set to EXITED in the verifyBalances function.\\n\\n        PartialWithdrawal.request(publicKey, amountGwei);\\n\\n        emit ValidatorWithdraw(pubKeyHash, uint256(amountGwei) * 1 gwei);\\n    }\\n\\n    // slither-disable-end reentrancy-no-eth\\n\\n    /// @notice Remove the validator from the SSV Cluster after:\\n    /// - the validator has been exited from `validatorWithdrawal` or slashed\\n    /// - the validator has incorrectly registered and can not be staked to\\n    /// - the initial deposit was front-run and the withdrawal address is not this strategy's address.\\n    /// Make sure `validatorWithdrawal` is called with a zero amount and the validator has exited the Beacon chain.\\n    /// If removed before the validator has exited the beacon chain will result in the validator being slashed.\\n    /// Only the registrator can call this function.\\n    /// @param publicKey The public key of the validator\\n    /// @param operatorIds The operator IDs of the SSV Cluster\\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\\n    // slither-disable-start reentrancy-no-eth\\n    function removeSsvValidator(\\n        bytes calldata publicKey,\\n        uint64[] calldata operatorIds,\\n        Cluster calldata cluster\\n    ) external onlyRegistrator {\\n        // Hash the public key using the Beacon Chain's format\\n        bytes32 pubKeyHash = _hashPubKey(publicKey);\\n        ValidatorState currentState = validator[pubKeyHash].state;\\n        // Can remove SSV validators that were incorrectly registered and can not be deposited to.\\n        require(\\n            currentState == ValidatorState.REGISTERED ||\\n                currentState == ValidatorState.EXITED ||\\n                currentState == ValidatorState.INVALID,\\n            \\\"Validator not regd or exited\\\"\\n        );\\n\\n        validator[pubKeyHash].state = ValidatorState.REMOVED;\\n\\n        ISSVNetwork(SSV_NETWORK).removeValidator(\\n            publicKey,\\n            operatorIds,\\n            cluster\\n        );\\n\\n        emit SSVValidatorRemoved(pubKeyHash, operatorIds);\\n    }\\n\\n    /**\\n     *\\n     *             SSV Management\\n     *\\n     */\\n\\n    // slither-disable-end reentrancy-no-eth\\n\\n    /// `depositSSV` has been removed as `deposit` on the SSVNetwork contract can be called directly\\n    /// by the Strategist which is already holding SSV tokens.\\n\\n    /// @notice Withdraws excess SSV Tokens from the SSV Network contract which was used to pay the SSV Operators.\\n    /// @dev A SSV cluster is defined by the SSVOwnerAddress and the set of operatorIds.\\n    /// @param operatorIds The operator IDs of the SSV Cluster\\n    /// @param ssvAmount The amount of SSV tokens to be withdrawn from the SSV cluster\\n    /// @param cluster The SSV cluster details including the validator count and SSV balance\\n    function withdrawSSV(\\n        uint64[] memory operatorIds,\\n        uint256 ssvAmount,\\n        Cluster memory cluster\\n    ) external onlyGovernor {\\n        ISSVNetwork(SSV_NETWORK).withdraw(operatorIds, ssvAmount, cluster);\\n    }\\n\\n    /**\\n     *\\n     *             Beacon Chain Proofs\\n     *\\n     */\\n\\n    /// @notice Verifies a validator's index to its public key.\\n    /// Adds to the list of verified validators if the validator's withdrawal address is this strategy's address.\\n    /// Marks the validator as invalid and removes the deposit if the withdrawal address is not this strategy's address.\\n    /// @param nextBlockTimestamp The timestamp of the execution layer block after the beacon chain slot\\n    /// we are verifying.\\n    /// The next one is needed as the Beacon Oracle returns the parent beacon block root for a block timestamp,\\n    /// which is the beacon block root of the previous block.\\n    /// @param validatorIndex The index of the validator on the beacon chain.\\n    /// @param pubKeyHash The hash of the validator's public key using the Beacon Chain's format\\n    /// @param withdrawalCredentials contain the validator type and withdrawal address. These can be incorrect and/or\\n    ///        malformed. In case of incorrect withdrawalCredentials the validator deposit has been front run\\n    /// @param validatorPubKeyProof The merkle proof for the validator public key to the beacon block root.\\n    /// This is 53 witness hashes of 32 bytes each concatenated together starting from the leaf node.\\n    /// BeaconBlock.state.validators[validatorIndex].pubkey\\n    function verifyValidator(\\n        uint64 nextBlockTimestamp,\\n        uint40 validatorIndex,\\n        bytes32 pubKeyHash,\\n        bytes32 withdrawalCredentials,\\n        bytes calldata validatorPubKeyProof\\n    ) external {\\n        require(\\n            validator[pubKeyHash].state == ValidatorState.STAKED,\\n            \\\"Validator not staked\\\"\\n        );\\n\\n        // Get the beacon block root of the slot we are verifying the validator in.\\n        // The parent beacon block root of the next block is the beacon block root of the slot we are verifying.\\n        bytes32 blockRoot = BeaconRoots.parentBlockRoot(nextBlockTimestamp);\\n\\n        // Verify the validator index is for the validator with the given public key.\\n        // Also verify the validator's withdrawal credentials\\n        IBeaconProofs(BEACON_PROOFS).verifyValidator(\\n            blockRoot,\\n            pubKeyHash,\\n            validatorPubKeyProof,\\n            validatorIndex,\\n            withdrawalCredentials\\n        );\\n\\n        // Store the validator state as verified\\n        validator[pubKeyHash] = ValidatorData({\\n            state: ValidatorState.VERIFIED,\\n            index: validatorIndex\\n        });\\n\\n        bytes32 expectedWithdrawalCredentials = bytes32(\\n            abi.encodePacked(bytes1(0x02), bytes11(0), address(this))\\n        );\\n\\n        // If the initial deposit was front-run and the withdrawal address is not this strategy\\n        // or the validator type is not a compounding validator (0x02)\\n        if (expectedWithdrawalCredentials != withdrawalCredentials) {\\n            // override the validator state\\n            validator[pubKeyHash].state = ValidatorState.INVALID;\\n\\n            // Find and remove the deposit as the funds can not be recovered\\n            uint256 depositCount = depositList.length;\\n            for (uint256 i = 0; i < depositCount; i++) {\\n                DepositData memory deposit = deposits[depositList[i]];\\n                if (deposit.pubKeyHash == pubKeyHash) {\\n                    // next verifyBalances will correctly account for the loss of a front-run\\n                    // deposit. Doing it here accounts for the loss as soon as possible\\n                    lastVerifiedEthBalance -= Math.min(\\n                        lastVerifiedEthBalance,\\n                        uint256(deposit.amountGwei) * 1 gwei\\n                    );\\n                    _removeDeposit(depositList[i], deposit);\\n                    break;\\n                }\\n            }\\n\\n            // Leave the `firstDeposit` flag as true so no more deposits to unverified validators can be made.\\n            // The Governor has to reset the `firstDeposit` to false before another deposit to\\n            // an unverified validator can be made.\\n            // The Governor can set a new `validatorRegistrator` if they suspect it has been compromised.\\n\\n            emit ValidatorInvalid(pubKeyHash);\\n            return;\\n        }\\n\\n        // Add the new validator to the list of verified validators\\n        verifiedValidators.push(pubKeyHash);\\n\\n        // Reset the firstDeposit flag as the first deposit to an unverified validator has been verified.\\n        firstDeposit = false;\\n\\n        emit ValidatorVerified(pubKeyHash, validatorIndex);\\n    }\\n\\n    struct FirstPendingDepositSlotProofData {\\n        uint64 slot;\\n        bytes proof;\\n    }\\n\\n    struct StrategyValidatorProofData {\\n        uint64 withdrawableEpoch;\\n        bytes withdrawableEpochProof;\\n    }\\n\\n    /// @notice Verifies a deposit on the execution layer has been processed by the beacon chain.\\n    /// This means the accounting of the strategy's ETH moves from a pending deposit to a validator balance.\\n    ///\\n    /// Important: this function has a limitation where `depositProcessedSlot` that is passed by the off-chain\\n    /// verifier requires a slot immediately after it to propose a block otherwise the `BeaconRoots.parentBlockRoot`\\n    /// will fail. This shouldn't be a problem, since by the current behaviour of beacon chain only 1%-3% slots\\n    /// don't propose a block.\\n    /// @param pendingDepositRoot The unique identifier of the deposit emitted in `ETHStaked` from\\n    /// the `stakeEth` function.\\n    /// @param depositProcessedSlot Any slot on or after the strategy's deposit was processed on the beacon chain.\\n    /// Can not be a slot with pending deposits with the same slot as the deposit being verified.\\n    /// Can not be a slot before a missed slot as the Beacon Root contract will have the parent block root\\n    /// set for the next block timestamp in 12 seconds time.\\n    /// @param firstPendingDeposit a `FirstPendingDepositSlotProofData` struct containing:\\n    /// - slot: The beacon chain slot of the first deposit in the beacon chain's deposit queue.\\n    ///   Can be any non-zero value if the deposit queue is empty.\\n    /// - proof: The merkle proof of the first pending deposit's slot to the beacon block root.\\n    ///   Can be either:\\n    ///   * 40 witness hashes for BeaconBlock.state.PendingDeposits[0].slot when the deposit queue is not empty.\\n    ///   * 37 witness hashes for BeaconBlock.state.PendingDeposits[0] when the deposit queue is empty.\\n    ///   The 32 byte witness hashes are concatenated together starting from the leaf node.\\n    /// @param strategyValidatorData a `StrategyValidatorProofData` struct containing:\\n    /// - withdrawableEpoch: The withdrawable epoch of the validator the strategy is depositing to.\\n    /// - withdrawableEpochProof: The merkle proof for the withdrawable epoch of the validator the strategy\\n    ///   is depositing to, to the beacon block root.\\n    ///   This is 53 witness hashes of 32 bytes each concatenated together starting from the leaf node.\\n    // slither-disable-start reentrancy-no-eth\\n    function verifyDeposit(\\n        bytes32 pendingDepositRoot,\\n        uint64 depositProcessedSlot,\\n        FirstPendingDepositSlotProofData calldata firstPendingDeposit,\\n        StrategyValidatorProofData calldata strategyValidatorData\\n    ) external {\\n        // Load into memory the previously saved deposit data\\n        DepositData memory deposit = deposits[pendingDepositRoot];\\n        ValidatorData memory strategyValidator = validator[deposit.pubKeyHash];\\n        require(deposit.status == DepositStatus.PENDING, \\\"Deposit not pending\\\");\\n        require(firstPendingDeposit.slot != 0, \\\"Zero 1st pending deposit slot\\\");\\n\\n        // We should allow the verification of deposits for validators that have been marked as exiting\\n        // to cover this situation:\\n        //  - there are 2 pending deposits\\n        //  - beacon chain has slashed the validator\\n        //  - when verifyDeposit is called for the first deposit it sets the Validator state to EXITING\\n        //  - verifyDeposit should allow a secondary call for the other deposit to a slashed validator\\n        require(\\n            strategyValidator.state == ValidatorState.VERIFIED ||\\n                strategyValidator.state == ValidatorState.ACTIVE ||\\n                strategyValidator.state == ValidatorState.EXITING,\\n            \\\"Not verified/active/exiting\\\"\\n        );\\n        // The verification slot must be after the deposit's slot.\\n        // This is needed for when the deposit queue is empty.\\n        require(deposit.slot < depositProcessedSlot, \\\"Slot not after deposit\\\");\\n\\n        uint64 snapTimestamp = snappedBalance.timestamp;\\n\\n        // This check prevents an accounting error that can happen if:\\n        //  - snapBalances are snapped at the time of T\\n        //  - deposit is processed on the beacon chain after time T and before verifyBalances()\\n        //  - verifyDeposit is called before verifyBalances which removes a deposit from depositList\\n        //    and deposit balance from totalDepositsWei\\n        //  - verifyBalances is called under-reporting the strategy's balance\\n        require(\\n            (_calcNextBlockTimestamp(depositProcessedSlot) <= snapTimestamp) ||\\n                snapTimestamp == 0,\\n            \\\"Deposit after balance snapshot\\\"\\n        );\\n\\n        // Get the parent beacon block root of the next block which is the block root of the deposit verification slot.\\n        // This will revert if the slot after the verification slot was missed.\\n        bytes32 depositBlockRoot = BeaconRoots.parentBlockRoot(\\n            _calcNextBlockTimestamp(depositProcessedSlot)\\n        );\\n\\n        // Verify the slot of the first pending deposit matches the beacon chain\\n        bool isDepositQueueEmpty = IBeaconProofs(BEACON_PROOFS)\\n            .verifyFirstPendingDeposit(\\n                depositBlockRoot,\\n                firstPendingDeposit.slot,\\n                firstPendingDeposit.proof\\n            );\\n\\n        // Verify the withdrawableEpoch on the validator of the strategy's deposit\\n        IBeaconProofs(BEACON_PROOFS).verifyValidatorWithdrawable(\\n            depositBlockRoot,\\n            strategyValidator.index,\\n            strategyValidatorData.withdrawableEpoch,\\n            strategyValidatorData.withdrawableEpochProof\\n        );\\n\\n        uint64 firstPendingDepositEpoch = firstPendingDeposit.slot /\\n            SLOTS_PER_EPOCH;\\n\\n        // If deposit queue is empty all deposits have certainly been processed. If not\\n        // a validator can either be not exiting and no further checks are required.\\n        // Or a validator is exiting then this function needs to make sure that the\\n        // pending deposit to an exited validator has certainly been processed. The\\n        // slot/epoch of first pending deposit is the one that contains the transaction\\n        // where the deposit to the ETH Deposit Contract has been made.\\n        //\\n        // Once the firstPendingDepositEpoch becomes greater than the withdrawableEpoch of\\n        // the slashed validator then the deposit has certainly been processed. When the beacon\\n        // chain reaches the withdrawableEpoch of the validator the deposit will no longer be\\n        // postponed. And any new deposits created (and present in the deposit queue)\\n        // will have an equal or larger withdrawableEpoch.\\n        require(\\n            strategyValidatorData.withdrawableEpoch == FAR_FUTURE_EPOCH ||\\n                strategyValidatorData.withdrawableEpoch <=\\n                firstPendingDepositEpoch ||\\n                isDepositQueueEmpty,\\n            \\\"Exit Deposit likely not proc.\\\"\\n        );\\n\\n        // solhint-disable max-line-length\\n        // Check the deposit slot is before the first pending deposit's slot on the beacon chain.\\n        // If this is not true then we can't guarantee the deposit has been processed by the beacon chain.\\n        // The deposit's slot can not be the same slot as the first pending deposit as there could be\\n        // many deposits in the same block, hence have the same pending deposit slot.\\n        // If the deposit queue is empty then our deposit must have been processed on the beacon chain.\\n        // The deposit slot can be zero for validators consolidating to a compounding validator or 0x01 validator\\n        // being promoted to a compounding one. Reference:\\n        // - [switch_to_compounding_validator](https://ethereum.github.io/consensus-specs/specs/electra/beacon-chain/#new-switch_to_compounding_validator\\n        // - [queue_excess_active_balance](https://ethereum.github.io/consensus-specs/specs/electra/beacon-chain/#new-queue_excess_active_balance)\\n        // - [process_consolidation_request](https://ethereum.github.io/consensus-specs/specs/electra/beacon-chain/#new-process_consolidation_request)\\n        // We can not guarantee that the deposit has been processed in that case.\\n        // solhint-enable max-line-length\\n        require(\\n            deposit.slot < firstPendingDeposit.slot || isDepositQueueEmpty,\\n            \\\"Deposit likely not processed\\\"\\n        );\\n\\n        // Remove the deposit now it has been verified as processed on the beacon chain.\\n        _removeDeposit(pendingDepositRoot, deposit);\\n\\n        emit DepositVerified(\\n            pendingDepositRoot,\\n            uint256(deposit.amountGwei) * 1 gwei\\n        );\\n    }\\n\\n    function _removeDeposit(\\n        bytes32 pendingDepositRoot,\\n        DepositData memory deposit\\n    ) internal {\\n        // After verifying the proof, update the contract storage\\n        deposits[pendingDepositRoot].status = DepositStatus.VERIFIED;\\n        // Move the last deposit to the index of the verified deposit\\n        bytes32 lastDeposit = depositList[depositList.length - 1];\\n        depositList[deposit.depositIndex] = lastDeposit;\\n        deposits[lastDeposit].depositIndex = deposit.depositIndex;\\n        // Delete the last deposit from the list\\n        depositList.pop();\\n    }\\n\\n    /// @dev Calculates the timestamp of the next execution block from the given slot.\\n    /// @param slot The beacon chain slot number used for merkle proof verification.\\n    function _calcNextBlockTimestamp(uint64 slot)\\n        internal\\n        view\\n        returns (uint64)\\n    {\\n        // Calculate the next block timestamp from the slot.\\n        return SLOT_DURATION * slot + BEACON_GENESIS_TIMESTAMP + SLOT_DURATION;\\n    }\\n\\n    // slither-disable-end reentrancy-no-eth\\n\\n    /// @notice Stores the current ETH balance at the current block and beacon block root\\n    ///         of the slot that is associated with the previous block.\\n    ///\\n    /// When snapping / verifying balance it is of a high importance that there is no\\n    /// miss-match in respect to ETH that is held by the contract and balances that are\\n    /// verified on the validators.\\n    ///\\n    /// First some context on the beacon-chain block building behaviour. Relevant parts of\\n    /// constructing a block on the beacon chain consist of:\\n    ///  - process_withdrawals: ETH is deducted from the validator's balance\\n    ///  - process_execution_payload: immediately after the previous step executing all the\\n    ///    transactions\\n    ///  - apply the withdrawals: adding ETH to the recipient which is the withdrawal address\\n    ///    contained in the withdrawal credentials of the exited validators\\n    ///\\n    /// That means that balance increases which are part of the post-block execution state are\\n    /// done within the block, but the transaction that are contained within that block can not\\n    /// see / interact with the balance from the exited validators. Only transactions in the\\n    /// next block can do that.\\n    ///\\n    /// When snap balances is performed the state of the chain is snapped across 2 separate\\n    /// chain states:\\n    ///  - ETH balance of the contract is recorded on block X -> and corresponding slot Y\\n    ///  - beacon chain block root is recorded of block X - 1 -> and corresponding slot Y - 1\\n    ///    given there were no missed slots. It could also be Y - 2, Y - 3 depending on how\\n    ///    many slots have not managed to propose a block. For the sake of simplicity this slot\\n    ///    will be referred to as Y - 1 as it makes no difference in the argument\\n    ///\\n    /// Given these 2 separate chain states it is paramount that verify balances can not experience\\n    /// miss-counting ETH or much more dangerous double counting of the ETH.\\n    ///\\n    /// When verifyBalances is called it is performed on the current block Z where Z > X. Verify\\n    /// balances adds up all the ETH (omitting WETH) controlled by this contract:\\n    ///  - ETH balance in the contract on block X\\n    ///  - ETH balance in Deposits on block Z that haven't been yet processed in slot Y - 1\\n    ///  - ETH balance in validators that are active in slot Y - 1\\n    ///  - skips the ETH balance in validators that have withdrawn in slot Y - 1 (or sooner)\\n    ///    and have their balance visible to transactions in slot Y and corresponding block X\\n    ///    (or sooner)\\n    ///\\n    /// Lets verify the correctness of ETH accounting given the above described behaviour.\\n    ///\\n    /// *ETH balance in the contract on block X*\\n    ///\\n    /// This is an ETH balance of the contract on a non current X block. Any ETH leaving the\\n    /// contract as a result of a withdrawal subtracts from the ETH accounted for on block X\\n    /// if `verifyBalances` has already been called. It also invalidates a `snapBalances` in\\n    /// case `verifyBalances` has not been called yet. Not performing this would result in not\\n    /// accounting for the withdrawn ETH that has happened anywhere in the block interval [X + 1, Z].\\n    ///\\n    /// Similarly to withdrawals any `stakeEth` deposits to the deposit contract adds to the ETH\\n    /// accounted for since the last `verifyBalances` has been called. And it invalidates the\\n    /// `snapBalances` in case `verifyBalances` hasn't been yet called. Not performing this\\n    /// would result in double counting the `stakedEth` since it would be present once in the\\n    /// snapped contract balance and the second time in deposit storage variables.\\n    ///\\n    /// This behaviour is correct.\\n    ///\\n    /// *ETH balance in Deposits on block Z that haven't been yet processed in slot Y - 1*\\n    ///\\n    /// The contract sums up all the ETH that has been deposited to the Beacon chain deposit\\n    /// contract at block Z. The execution layer doesn't have direct access to the state of\\n    /// deposits on the beacon chain. And if it is to sum up all the ETH that is marked to be\\n    /// deposited it needs to be sure to not double count ETH that is in deposits (storage vars)\\n    /// and could also be part of the validator balances. It does that by verifying that at\\n    /// slot Y - 1 none of the deposits visible on block Z have been processed. Meaning since\\n    /// the last snap till now all are still in queue. Which ensures they can not be part of\\n    /// the validator balances in later steps.\\n    ///\\n    /// This behaviour is correct.\\n    ///\\n    /// *ETH balance in validators that are active in slot Y - 1*\\n    ///\\n    /// The contract is verifying none of the deposits on Y - 1 slot have been processed and\\n    /// for that reason it checks the validator balances in the same slot. Ensuring accounting\\n    /// correctness.\\n    ///\\n    /// This behaviour is correct.\\n    ///\\n    /// *The withdrawn validators*\\n    ///\\n    /// The withdrawn validators could have their balances deducted in any slot before slot\\n    /// Y - 1 and the execution layer sees the balance increase in the subsequent slot. Lets\\n    /// look at the \\\"worst case scenario\\\" where the validator withdrawal is processed in the\\n    /// slot Y - 1 (snapped slot) and see their balance increase (in execution layer) in slot\\n    /// Y -> block X. The ETH balance on the contract is snapped at block X meaning that\\n    /// even if the validator exits at the latest possible time it is paramount that the ETH\\n    /// balance on the execution layer is recorded in the next block. Correctly accounting\\n    /// for the withdrawn ETH.\\n    ///\\n    /// Worth mentioning if the validator exit is processed by the slot Y and balance increase\\n    /// seen on the execution layer on block X + 1 the withdrawal is ignored by both the\\n    /// validator balance verification as well as execution layer contract balance snap.\\n    ///\\n    /// This behaviour is correct.\\n    ///\\n    /// The validator balances on the beacon chain can then be proved with `verifyBalances`.\\n    function snapBalances() external {\\n        uint64 currentTimestamp = SafeCast.toUint64(block.timestamp);\\n        require(\\n            snappedBalance.timestamp + SNAP_BALANCES_DELAY < currentTimestamp,\\n            \\\"Snap too soon\\\"\\n        );\\n\\n        bytes32 blockRoot = BeaconRoots.parentBlockRoot(currentTimestamp);\\n        // Get the current ETH balance\\n        uint256 ethBalance = address(this).balance;\\n\\n        // Store the snapped balance\\n        snappedBalance = Balances({\\n            blockRoot: blockRoot,\\n            timestamp: currentTimestamp,\\n            ethBalance: SafeCast.toUint128(ethBalance)\\n        });\\n\\n        emit BalancesSnapped(blockRoot, ethBalance);\\n    }\\n\\n    // A struct is used to avoid stack too deep errors\\n    struct BalanceProofs {\\n        // BeaconBlock.state.balances\\n        bytes32 balancesContainerRoot;\\n        bytes balancesContainerProof;\\n        // BeaconBlock.state.balances[validatorIndex]\\n        bytes32[] validatorBalanceLeaves;\\n        bytes[] validatorBalanceProofs;\\n    }\\n\\n    struct PendingDepositProofs {\\n        bytes32 pendingDepositContainerRoot;\\n        bytes pendingDepositContainerProof;\\n        uint32[] pendingDepositIndexes;\\n        bytes[] pendingDepositProofs;\\n    }\\n\\n    /// @notice Verifies the balances of all active validators on the beacon chain\\n    /// and checks each of the strategy's deposits are still to be processed by the beacon chain.\\n    /// @param balanceProofs a `BalanceProofs` struct containing the following:\\n    /// - balancesContainerRoot: The merkle root of the balances container\\n    /// - balancesContainerProof: The merkle proof for the balances container to the beacon block root.\\n    ///    This is 9 witness hashes of 32 bytes each concatenated together starting from the leaf node.\\n    /// - validatorBalanceLeaves: Array of leaf nodes containing the validator balance with three other balances.\\n    /// - validatorBalanceProofs: Array of merkle proofs for the validator balance to the Balances container root.\\n    ///    This is 39 witness hashes of 32 bytes each concatenated together starting from the leaf node.\\n    /// @param pendingDepositProofs a `PendingDepositProofs` struct containing the following:\\n    /// - pendingDepositContainerRoot: The merkle root of the pending deposits list container\\n    /// - pendingDepositContainerProof: The merkle proof from the pending deposits list container\\n    ///     to the beacon block root.\\n    ///    This is 9 witness hashes of 32 bytes each concatenated together starting from the leaf node.\\n    /// - pendingDepositIndexes: Array of indexes in the pending deposits list container for each\\n    ///    of the strategy's deposits.\\n    /// - pendingDepositProofs: Array of merkle proofs for each strategy deposit in the\\n    ///    beacon chain's pending deposit list container to the pending deposits list container root.\\n    ///    These are 28 witness hashes of 32 bytes each concatenated together starting from the leaf node.\\n    // slither-disable-start reentrancy-no-eth\\n    function verifyBalances(\\n        BalanceProofs calldata balanceProofs,\\n        PendingDepositProofs calldata pendingDepositProofs\\n    ) external {\\n        // Load previously snapped balances for the given block root\\n        Balances memory balancesMem = snappedBalance;\\n        // Check the balances are the latest\\n        require(balancesMem.timestamp > 0, \\\"No snapped balances\\\");\\n\\n        uint256 verifiedValidatorsCount = verifiedValidators.length;\\n        uint256 totalValidatorBalance = 0;\\n        uint256 depositsCount = depositList.length;\\n\\n        // If there are no verified validators then we can skip the balance verification\\n        if (verifiedValidatorsCount > 0) {\\n            require(\\n                balanceProofs.validatorBalanceProofs.length ==\\n                    verifiedValidatorsCount,\\n                \\\"Invalid balance proofs\\\"\\n            );\\n            require(\\n                balanceProofs.validatorBalanceLeaves.length ==\\n                    verifiedValidatorsCount,\\n                \\\"Invalid balance leaves\\\"\\n            );\\n            // verify beaconBlock.state.balances root to beacon block root\\n            IBeaconProofs(BEACON_PROOFS).verifyBalancesContainer(\\n                balancesMem.blockRoot,\\n                balanceProofs.balancesContainerRoot,\\n                balanceProofs.balancesContainerProof\\n            );\\n\\n            bytes32[]\\n                memory validatorHashesMem = _getPendingDepositValidatorHashes(\\n                    depositsCount\\n                );\\n\\n            // for each validator in reverse order so we can pop off exited validators at the end\\n            for (uint256 i = verifiedValidatorsCount; i > 0; ) {\\n                --i;\\n                ValidatorData memory validatorDataMem = validator[\\n                    verifiedValidators[i]\\n                ];\\n                // verify validator's balance in beaconBlock.state.balances to the\\n                // beaconBlock.state.balances container root\\n                uint256 validatorBalanceGwei = IBeaconProofs(BEACON_PROOFS)\\n                    .verifyValidatorBalance(\\n                        balanceProofs.balancesContainerRoot,\\n                        balanceProofs.validatorBalanceLeaves[i],\\n                        balanceProofs.validatorBalanceProofs[i],\\n                        validatorDataMem.index\\n                    );\\n\\n                // If the validator has exited and the balance is now zero\\n                if (validatorBalanceGwei == 0) {\\n                    // Check if there are any pending deposits to this validator\\n                    bool depositPending = false;\\n                    for (uint256 j = 0; j < validatorHashesMem.length; j++) {\\n                        if (validatorHashesMem[j] == verifiedValidators[i]) {\\n                            depositPending = true;\\n                            break;\\n                        }\\n                    }\\n\\n                    // If validator has a pending deposit we can not remove due to\\n                    // the following situation:\\n                    //  - validator has a pending deposit\\n                    //  - validator has been slashed\\n                    //  - sweep cycle has withdrawn all ETH from the validator. Balance is 0\\n                    //  - beacon chain has processed the deposit and set the validator balance\\n                    //    to deposit amount\\n                    //  - if validator is no longer in the list of verifiedValidators its\\n                    //    balance will not be considered and be under-counted.\\n                    if (!depositPending) {\\n                        // Store the validator state as exited\\n                        // This could have been in VERIFIED, ACTIVE or EXITING state\\n                        validator[verifiedValidators[i]].state = ValidatorState\\n                            .EXITED;\\n\\n                        // Remove the validator with a zero balance from the list of verified validators\\n\\n                        // Reduce the count of verified validators which is the last index before the pop removes it.\\n                        verifiedValidatorsCount -= 1;\\n\\n                        // Move the last validator that has already been verified to the current index.\\n                        // There's an extra SSTORE if i is the last active validator but that's fine,\\n                        // It's not a common case and the code is simpler this way.\\n                        verifiedValidators[i] = verifiedValidators[\\n                            verifiedValidatorsCount\\n                        ];\\n                        // Delete the last validator from the list\\n                        verifiedValidators.pop();\\n                    }\\n\\n                    // The validator balance is zero so not need to add to totalValidatorBalance\\n                    continue;\\n                } else if (\\n                    validatorDataMem.state == ValidatorState.VERIFIED &&\\n                    validatorBalanceGwei > MIN_ACTIVATION_BALANCE_GWEI\\n                ) {\\n                    // Store the validator state as active. This does not necessarily mean the\\n                    // validator is active on the beacon chain yet. It just means the validator has\\n                    // enough balance that it can become active.\\n                    validator[verifiedValidators[i]].state = ValidatorState\\n                        .ACTIVE;\\n                }\\n\\n                // convert Gwei balance to Wei and add to the total validator balance\\n                totalValidatorBalance += validatorBalanceGwei * 1 gwei;\\n            }\\n        }\\n\\n        uint256 totalDepositsWei = 0;\\n\\n        // If there are no deposits then we can skip the deposit verification.\\n        // This section is after the validator balance verifications so an exited validator will be marked\\n        // as EXITED before the deposits are verified. If there was a deposit to an exited validator\\n        // then the deposit can only be removed once the validator is fully exited.\\n        // It is possible that validator fully exits and a postponed deposit to an exited validator increases\\n        // its balance again. In such case the contract will erroneously consider a deposit applied before it\\n        // has been applied on the beacon chain showing a smaller than real `totalValidatorBalance`.\\n        if (depositsCount > 0) {\\n            require(\\n                pendingDepositProofs.pendingDepositProofs.length ==\\n                    depositsCount,\\n                \\\"Invalid deposit proofs\\\"\\n            );\\n            require(\\n                pendingDepositProofs.pendingDepositIndexes.length ==\\n                    depositsCount,\\n                \\\"Invalid deposit indexes\\\"\\n            );\\n\\n            // Verify from the root of the pending deposit list container to the beacon block root\\n            IBeaconProofs(BEACON_PROOFS).verifyPendingDepositsContainer(\\n                balancesMem.blockRoot,\\n                pendingDepositProofs.pendingDepositContainerRoot,\\n                pendingDepositProofs.pendingDepositContainerProof\\n            );\\n\\n            // For each staking strategy's deposit.\\n            for (uint256 i = 0; i < depositsCount; ++i) {\\n                bytes32 pendingDepositRoot = depositList[i];\\n\\n                // Verify the strategy's deposit is still pending on the beacon chain.\\n                IBeaconProofs(BEACON_PROOFS).verifyPendingDeposit(\\n                    pendingDepositProofs.pendingDepositContainerRoot,\\n                    pendingDepositRoot,\\n                    pendingDepositProofs.pendingDepositProofs[i],\\n                    pendingDepositProofs.pendingDepositIndexes[i]\\n                );\\n\\n                // Convert the deposit amount from Gwei to Wei and add to the total\\n                totalDepositsWei +=\\n                    uint256(deposits[pendingDepositRoot].amountGwei) *\\n                    1 gwei;\\n            }\\n        }\\n\\n        // Store the verified balance in storage\\n        lastVerifiedEthBalance =\\n            totalDepositsWei +\\n            totalValidatorBalance +\\n            balancesMem.ethBalance;\\n        // Reset the last snap timestamp so a new snapBalances has to be made\\n        snappedBalance.timestamp = 0;\\n\\n        emit BalancesVerified(\\n            balancesMem.timestamp,\\n            totalDepositsWei,\\n            totalValidatorBalance,\\n            balancesMem.ethBalance\\n        );\\n    }\\n\\n    // slither-disable-end reentrancy-no-eth\\n\\n    /// @notice get a list of all validator hashes present in the pending deposits\\n    ///         list can have duplicate entries\\n    function _getPendingDepositValidatorHashes(uint256 depositsCount)\\n        internal\\n        view\\n        returns (bytes32[] memory validatorHashes)\\n    {\\n        validatorHashes = new bytes32[](depositsCount);\\n        for (uint256 i = 0; i < depositsCount; i++) {\\n            validatorHashes[i] = deposits[depositList[i]].pubKeyHash;\\n        }\\n    }\\n\\n    /// @notice Hash a validator public key using the Beacon Chain's format\\n    function _hashPubKey(bytes memory pubKey) internal pure returns (bytes32) {\\n        require(pubKey.length == 48, \\\"Invalid public key\\\");\\n        return sha256(abi.encodePacked(pubKey, bytes16(0)));\\n    }\\n\\n    /**\\n     *\\n     *         WETH and ETH Accounting\\n     *\\n     */\\n\\n    /// @dev Called when WETH is transferred out of the strategy so\\n    /// the strategy knows how much WETH it has on deposit.\\n    /// This is so it can emit the correct amount in the Deposit event in depositAll().\\n    function _transferWeth(uint256 _amount, address _recipient) internal {\\n        IERC20(WETH).safeTransfer(_recipient, _amount);\\n\\n        // The min is required as more WETH can be withdrawn than deposited\\n        // as the strategy earns consensus and execution rewards.\\n        uint256 deductAmount = Math.min(_amount, depositedWethAccountedFor);\\n        depositedWethAccountedFor -= deductAmount;\\n\\n        // No change in ETH balance so no need to snapshot the balances\\n    }\\n\\n    /// @dev Converts ETH to WETH and updates the accounting.\\n    /// @param _ethAmount The amount of ETH in wei.\\n    function _convertEthToWeth(uint256 _ethAmount) internal {\\n        // slither-disable-next-line arbitrary-send-eth\\n        IWETH9(WETH).deposit{ value: _ethAmount }();\\n\\n        depositedWethAccountedFor += _ethAmount;\\n\\n        // Store the reduced ETH balance.\\n        // The ETH balance in this strategy contract can be more than the last verified ETH balance\\n        // due to partial withdrawals or full exits being processed by the beacon chain since the last snapBalances.\\n        // It can also happen from execution rewards (MEV) or ETH donations.\\n        lastVerifiedEthBalance -= Math.min(lastVerifiedEthBalance, _ethAmount);\\n\\n        // The ETH balance was decreased to WETH so we need to invalidate the last balances snap.\\n        snappedBalance.timestamp = 0;\\n    }\\n\\n    /// @dev Converts WETH to ETH and updates the accounting.\\n    /// @param _wethAmount The amount of WETH in wei.\\n    function _convertWethToEth(uint256 _wethAmount) internal {\\n        IWETH9(WETH).withdraw(_wethAmount);\\n\\n        uint256 deductAmount = Math.min(_wethAmount, depositedWethAccountedFor);\\n        depositedWethAccountedFor -= deductAmount;\\n\\n        // Store the increased ETH balance\\n        lastVerifiedEthBalance += _wethAmount;\\n\\n        // The ETH balance was increased from WETH so we need to invalidate the last balances snap.\\n        snappedBalance.timestamp = 0;\\n    }\\n\\n    /**\\n     *\\n     *             View Functions\\n     *\\n     */\\n\\n    /// @notice Returns the number of deposits waiting to be verified as processed on the beacon chain,\\n    /// or deposits that have been verified to an exiting validator and is now waiting for the\\n    /// validator's balance to be swept.\\n    function depositListLength() external view returns (uint256) {\\n        return depositList.length;\\n    }\\n\\n    /// @notice Returns the number of verified validators.\\n    function verifiedValidatorsLength() external view returns (uint256) {\\n        return verifiedValidators.length;\\n    }\\n}\\n\",\"keccak256\":\"0x509d34414ec1c8f709a81174042c0f9ee1866644d8bcf96d5ff9dae0a80fe05e\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b5060405161097038038061097083398101604081905261002f91610040565b6001600160a01b0316608052610070565b60006020828403121561005257600080fd5b81516001600160a01b038116811461006957600080fd5b9392505050565b6080516108b66100ba60003960008181604b0152818160ba015281816101ce015281816102480152818161034b0152818161044d0152818161047c015261059301526108b66000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c80632e4aee1f146100465780635e1c519b1461008a578063d1699c261461009f575b600080fd5b61006d7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020015b60405180910390f35b6100926100b4565b604051610081919061066f565b6100a7610345565b60405161008191906106f2565b606060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663d79e40326040518163ffffffff1660e01b8152600401602060405180830381865afa158015610116573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061013a9190610764565b90508067ffffffffffffffff8111156101555761015561077d565b6040519080825280602002602001820160405280156101a757816020015b61019460408051606081018252600080825260208201819052909182015290565b8152602001906001900390816101735790505b50915060005b8181101561034057604051630ef9985560e01b8152600481018290526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690630ef9985590602401602060405180830381865afa15801561021d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102419190610764565b90506000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166398245f1b846040518263ffffffff1660e01b815260040161029491815260200190565b6040805180830381865afa1580156102b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102d49190610793565b64ffffffffff169150915060405180606001604052808481526020018267ffffffffffffffff16815260200183600881111561031257610312610659565b815250868581518110610327576103276107db565b60200260200101819052505050508060010190506101ad565b505090565b606060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316634896b31a6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156103a7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103cb9190610764565b90508067ffffffffffffffff8111156103e6576103e661077d565b60405190808252806020026020018201604052801561043857816020015b6040805160808101825260008082526020808301829052928201819052606082015282526000199092019101816104045790505b50915060005b818110156103405760008060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316633d4dff7b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b8ec6678876040518263ffffffff1660e01b81526004016104c891815260200190565b602060405180830381865afa1580156104e5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105099190610764565b6040518263ffffffff1660e01b815260040161052791815260200190565b60a060405180830381865afa158015610544573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610568919061080e565b505060408051608081019182905263171d8ccf60e31b909152608481018890529295509093509150807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b8ec667860a48301602060405180830381865afa1580156105e1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106059190610764565b81526020018481526020018367ffffffffffffffff1681526020018267ffffffffffffffff16815250868581518110610640576106406107db565b602002602001018190525050505080600101905061043e565b634e487b7160e01b600052602160045260246000fd5b602080825282518282018190526000918401906040840190835b818110156106e75783518051845260208082015167ffffffffffffffff169085015260400151600981106106cd57634e487b7160e01b600052602160045260246000fd5b604084015260209390930192606090920191600101610689565b509095945050505050565b602080825282518282018190526000918401906040840190835b818110156106e7578351805184526020810151602085015267ffffffffffffffff604082015116604085015267ffffffffffffffff60608201511660608501525060808301925060208401935060018101905061070c565b60006020828403121561077657600080fd5b5051919050565b634e487b7160e01b600052604160045260246000fd5b600080604083850312156107a657600080fd5b8251600981106107b557600080fd5b602084015190925064ffffffffff811681146107d057600080fd5b809150509250929050565b634e487b7160e01b600052603260045260246000fd5b805167ffffffffffffffff8116811461080957600080fd5b919050565b600080600080600060a0868803121561082657600080fd5b85519450610836602087016107f1565b9350610844604087016107f1565b9250606086015163ffffffff8116811461085d57600080fd5b60808701519092506003811061087257600080fd5b80915050929550929590935056fea2646970667358221220f9132258bb79a37f33b57519241ed5d829b6c6b002d8c48858b3ffaebe893bac64736f6c634300081c0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c80632e4aee1f146100465780635e1c519b1461008a578063d1699c261461009f575b600080fd5b61006d7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020015b60405180910390f35b6100926100b4565b604051610081919061066f565b6100a7610345565b60405161008191906106f2565b606060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663d79e40326040518163ffffffff1660e01b8152600401602060405180830381865afa158015610116573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061013a9190610764565b90508067ffffffffffffffff8111156101555761015561077d565b6040519080825280602002602001820160405280156101a757816020015b61019460408051606081018252600080825260208201819052909182015290565b8152602001906001900390816101735790505b50915060005b8181101561034057604051630ef9985560e01b8152600481018290526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690630ef9985590602401602060405180830381865afa15801561021d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102419190610764565b90506000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166398245f1b846040518263ffffffff1660e01b815260040161029491815260200190565b6040805180830381865afa1580156102b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102d49190610793565b64ffffffffff169150915060405180606001604052808481526020018267ffffffffffffffff16815260200183600881111561031257610312610659565b815250868581518110610327576103276107db565b60200260200101819052505050508060010190506101ad565b505090565b606060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316634896b31a6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156103a7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103cb9190610764565b90508067ffffffffffffffff8111156103e6576103e661077d565b60405190808252806020026020018201604052801561043857816020015b6040805160808101825260008082526020808301829052928201819052606082015282526000199092019101816104045790505b50915060005b818110156103405760008060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316633d4dff7b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b8ec6678876040518263ffffffff1660e01b81526004016104c891815260200190565b602060405180830381865afa1580156104e5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105099190610764565b6040518263ffffffff1660e01b815260040161052791815260200190565b60a060405180830381865afa158015610544573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610568919061080e565b505060408051608081019182905263171d8ccf60e31b909152608481018890529295509093509150807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b8ec667860a48301602060405180830381865afa1580156105e1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106059190610764565b81526020018481526020018367ffffffffffffffff1681526020018267ffffffffffffffff16815250868581518110610640576106406107db565b602002602001018190525050505080600101905061043e565b634e487b7160e01b600052602160045260246000fd5b602080825282518282018190526000918401906040840190835b818110156106e75783518051845260208082015167ffffffffffffffff169085015260400151600981106106cd57634e487b7160e01b600052602160045260246000fd5b604084015260209390930192606090920191600101610689565b509095945050505050565b602080825282518282018190526000918401906040840190835b818110156106e7578351805184526020810151602085015267ffffffffffffffff604082015116604085015267ffffffffffffffff60608201511660608501525060808301925060208401935060018101905061070c565b60006020828403121561077657600080fd5b5051919050565b634e487b7160e01b600052604160045260246000fd5b600080604083850312156107a657600080fd5b8251600981106107b557600080fd5b602084015190925064ffffffffff811681146107d057600080fd5b809150509250929050565b634e487b7160e01b600052603260045260246000fd5b805167ffffffffffffffff8116811461080957600080fd5b919050565b600080600080600060a0868803121561082657600080fd5b85519450610836602087016107f1565b9350610844604087016107f1565b9250606086015163ffffffff8116811461085d57600080fd5b60808701519092506003811061087257600080fd5b80915050929550929590935056fea2646970667358221220f9132258bb79a37f33b57519241ed5d829b6c6b002d8c48858b3ffaebe893bac64736f6c634300081c0033",
  "libraries": {},
  "devdoc": {
    "author": "Origin Protocol Inc",
    "kind": "dev",
    "methods": {
      "getPendingDeposits()": {
        "returns": {
          "pendingDeposits": "An array of `DepositView` containing the deposit ID, public key hash, amount in Gwei and the slot of the deposit."
        }
      },
      "getVerifiedValidators()": {
        "returns": {
          "validators": "An array of `ValidatorView` containing the public key hash, validator index and state."
        }
      }
    },
    "title": "Viewing contract for the Compounding Staking Strategy.",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getPendingDeposits()": {
        "notice": "Returns the deposits that are still to be verified. These may or may not have been processed by the beacon chain."
      },
      "getVerifiedValidators()": {
        "notice": "Returns the strategy's active validators. These are the ones that have been verified and have a non-zero balance."
      },
      "stakingStrategy()": {
        "notice": "The address of the Compounding Staking Strategy contract"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}